\chapter{Proof Tools: Propositional Logic}
\label{chap:proof-tools}

Users of \HOL{} can create their own theorem proving tools by
combining predefined rules and tactics. The \ML{} type-discipline
ensures that only logically sound methods can be used to create values
of type \ml{thm}.  In this chapter, a real example is described.

Two implementations of the tool are given to illustrate various styles
of proof programming. The first implementation is the obvious one, but
is inefficient because of the `brute force' method used. The second
implementation attempts to be a great deal more intelligent.
Extensions to the tools to allow more general applicability are also
discussed.

The problem to be solved is that of deciding the truth of a closed
formula of propositional logic.  Such a formula has the general form
\[
\begin{array}{ccl}
\varphi & ::= & v \;|\;\top\;|\;\bot \;|\; \neg\varphi\;|\;\varphi \land \varphi \;|\; \varphi \lor \varphi\\[1ex]
\mathit{formula} &::= & \forall \vec{v}. \;\varphi
\end{array}
\]
where the variables $v$ are all of boolean type, and where the
universal quantification at the outermost level captures all of the
free variables.

\section{Method 1: Truth Tables}

\setcounter{sessioncount}{0}

The first method to be implemented is the brute force method of trying
all possible boolean combinations.  This approach's only real virtue
is that it is exceptionally easy to implement.  First we will prove
the motivating theorem:
\begin{hol}
\begin{verbatim}
   val FORALL_BOOL = prove(
     ``(!v. P v) = P T /\ P F``,
     SRW_TAC [][EQ_IMP_THM] THEN Cases_on `v` THEN SRW_TAC [][]);
\end{verbatim}
\end{hol}
The proof proceeds by splitting the goal into two halves, showing
\[
(\forall v. \;P(v))\Rightarrow P(\top) \land P(\bot)
\]
(which goal is automatically shown by the simplifier), and
\[
P(\top) \land P(\bot) \Rightarrow P(v)
\]
for an arbitrary boolean variable $v$.  After case-splitting on $v$,
the assumptions are then enough to show the goal.  (This theorem is
actually already proved in the theory \theoryimp{bool}.)

The next, and final, step is to rewrite with this theorem:
\begin{hol}
\begin{verbatim}
   val tautDP = SIMP_CONV bool_ss [FORALL_BOOL]
\end{verbatim}
\end{hol}

This enables the following

\begin{session}
\begin{verbatim}
- tautDP ``!p q. p /\ q /\ ~p``;
> val it = |- (!p q. p /\ q /\ ~p) = F : thm

- tautDP ``!p. p \/ ~p``
> val it = |- (!p. p \/ ~p) = T : thm
\end{verbatim}
\end{session}
and even the marginally more intimidating
\begin{session}
\begin{verbatim}
- time tautDP
     ``!p q c a. ~(((~a \/ p /\ ~q \/ ~p /\ q) /\
                    (~(p /\ ~q \/ ~p /\ q) \/ a)) /\
                   (~c \/ p /\ q) /\ (~(p /\ q) \/ c)) \/
                 ~(p /\ q) \/ c /\ ~a``;
runtime: 0.147s,    gctime: 0.012s,     systime: 0.000s.
> val it =
    |- (!p q c a.
          ~(((~a \/ p /\ ~q \/ ~p /\ q) /\ (~(p /\ ~q \/ ~p /\ q) \/ a)) /\
            (~c \/ p /\ q) /\ (~(p /\ q) \/ c)) \/ ~(p /\ q) \/ c /\ ~a) =
       T : thm
\end{verbatim}
\end{session}

This is a dreadful algorithm for solving this problem.  The system's
built-in function, \ml{tautLib.TAUT\_CONV} solves the same problem ten
times faster, even though it is also using a truth-table
technique.\footnote{The main difference is that \ml{TAUT\_CONV}
  simplifies the body of the universally quantified formula after each
  case-split.  Our function does all of the case-splits and then
  simplifies.  The simplifier, which works over a term top-down, can't
  implement \ml{TAUT\_CONV}'s algorithm directly.}  The only real
merit in this solution is that it took one line to write.  This is a
general illustration of the truth that \HOL{}'s high-level tools,
particularly the simplifier, can provide fast prototypes for a variety
of proof tasks.

\section{Method 2: the DPLL Algorithm}

The Davis-Putnam-Loveland-Logemann method~\cite{DPLL-paper} for
deciding the satisfiability of propositional formulas in CNF
(Conjunctive Normal Form) is a powerful technique, still used in
state-of-the-art solvers today.  If we strip the universal quantifiers
from our input formulas, our task can be seen as determining the
validity of a propositional formula.  Testing the negation of such a
formula for satisfiability is a test for validity: if the formula's
negation is satisfiable, then it is not valid (the satisfying
assignment will make the original false); if the formula's negation is
unsatisfiable, then the formula is valid (no assignment can make it
false).

\subsection*{Preliminaries}

To begin, assume that we have code already to convert arbitrary
formulas into CNF, and to then decide the satisfiability of these
formulas.  Assume further that if the input to the latter procedure is
unsatisfiable, then it will return with a theorem of the form
\[ \vdash \varphi = \holtxt{F}
\]
or if it is satisfiable, then it will return a satisfying assignment,
a map from variables to booleans.   This map will be a function from
\HOL{} variables to one of the \HOL{} terms \holtxt{T} or \holtxt{F}.
Thus, we will assume
\begin{hol}
\begin{verbatim}
   datatype result = Unsat of thm | Sat of term -> term
   val toCNF : term -> thm
   val DPLL : term -> result
\end{verbatim}
\end{hol}
(The theorem returned by \ml{toCNF} will equate the input term to
another in CNF.)

\smallskip
\noindent
Before looking into implementing these functions, we will need to
consider
\begin{itemize}
\item how to transform our inputs to suit the function; and
\item how to use the outputs from the functions to produce our desired
  results
\end{itemize}

We are assuming our input is a universally quantified formula.  Both
the CNF and DPLL procedures expect formulas without quantifiers.  We
also want to pass these procedures the negation of the original
formula.  Both of the required term manipulations required can be done
by functions found in the structure \ml{boolSyntax}.  (In general,
important theories (such as \theoryimp{bool}) are accompanied by
\ml{Syntax} modules containing functions for manipulating the
term-forms associated with that theory.)

In this case we need the functions
\begin{hol}
\begin{verbatim}
   strip_forall : term -> term list * term
   mk_neg       : term -> term
\end{verbatim}
\end{hol}
The function \ml{strip\_forall} strips a term of all its outermost
universal quantifications, returning the list of variables stripped
and the body of the quantification.  The function \ml{mk\_neg} takes a
term of type \holtxt{bool} and returns the term corresponding to its
negation.

Using these functions, it is easy to see how we will be able to take
$\forall\vec{v}.\;\varphi$ as input, and pass the term $\neg\varphi$
to the function \ml{toCNF}.  A more significant question is how to
use the results of these calls.   The call to \ml{toCNF} will return a
theorem
\begin{equation}
\vdash \neg\varphi = \varphi'
\label{eqn:tocnf-result}
\end{equation}
The formula $\varphi'$ is what will then be passed to \ml{DPLL}.  (We
can extract it by using the \ml{concl} and \ml{rhs} functions.) If
\ml{DPLL} returns the theorem $\vdash \varphi' = \holtxt{F}$, an
application of \ml{TRANS} to this and~(\ref{eqn:tocnf-result}) will
derive the formula $\vdash \neg\varphi = F$.  In order to derive the
final result, we will need to turn this into $\vdash\varphi$.  This is
best done by proving a bespoke theorem embodying the equality (there
isn't one such already in the system):
\begin{hol}
\begin{verbatim}
   val NEG_EQ_F = prove(
     ``(~p = F) = p``,
     REWRITE_TAC []);
\end{verbatim}
\end{hol}
To turn $\vdash \varphi$ into $\vdash (\forall
\vec{v}.\;\varphi) = \holtxt{T}$, we will perform the following proof:
\[
\infer[\texttt{\scriptsize EQT\_INTRO}]{
  \vdash (\forall \vec{v}.\;\varphi) = \holtxt{T}}{
  \infer[\texttt{\scriptsize GENL}(\vec{v})]{\vdash \forall \vec{v}.\;\varphi}{
    \vdash \varphi
  }
}
\]
The other possibility is that \ml{DPLL} will return a satisfying
assignment demonstrating that $\varphi'$ is satisfiable.  If this is
the case, we want to show that $\forall\vec{v}.\;\varphi$ is false.
We can do this by assuming this formula, and then specialising the
universally quantified variables in line with the provided map.  In
this way, it will be possible to produce the theorem
\[
\forall \vec{v}.\;\varphi \vdash \varphi[\vec{v} := \mbox{\emph{satisfying
  assignment}}]
\]
Because there are no free variables in $\forall\vec{v}.\;\varphi$, the
substitution will produce a completely ground boolean formula.  This
will straightforwardly rewrite to \holtxt{F} (if the assignment
makes $\neg\varphi$ true, it must make $\varphi$ false).  Turning
$\phi\vdash \holtxt{F}$ into $\vdash \phi = \holtxt{F}$ is a matter of
calling \ml{DISCH} and then rewriting with the built-in theorem
\ml{IMP\_F\_EQ\_F}:
\[
\vdash \forall t.\;t \Rightarrow \holtxt{F} = (t = \holtxt{F})
\]
Putting all of the above together, we can write our wrapper function:
\begin{hol}
\begin{verbatim}
   fun wrapper t = let
     val (vs, phi) = strip_forall t
     val cnf_eqn = toCNF (mk_neg phi)
     val (_, phi') = rhs (concl cnf_eq)
   in
     case DPLL phi' of
       Unsat phi'_eq_F => let
         val negphi_eq_F = TRANS cnf_eqn phi'_eq_F
         val phi_thm = CONV_RULE (REWR_CONV NEG_EQ_F) negphi_eq_F
       in
         EQT_INTRO (GENL vs phi_thm)
       end
     | Sat f => let
         val t_assumed = ASSUME t
         fun spec th =
             spec (SPEC (f (#1 (dest_forall (concl th)))) th)
             handle HOL_ERR _ => REWRITE_RULE [] th
       in
         CONV_RULE (REWR_CONV IMP_F_EQ_F) (DISCH t (spec t_assumed))
       end
   end
\end{verbatim}
\end{hol}

The auxiliary function \ml{spec} that is used in the second case
relies on the fact that \ml{dest\_forall} will raise a \ml{HOL\_ERR}
exception if the term it is applied to is not universally quantified.
When \ml{spec}'s argument is not universally quantified, this means
that the recursion has bottomed out, and all of the original formula's
universal variables have been specialised.  Then the resulting formula
can be rewritten to false (\ml{REWRITE\_RULE}'s built-in rewrites will
handle all of the necessary cases).

The \ml{wrapper} function also uses \ml{REWR\_CONV} in two places.
The \ml{REWR\_CONV} function applies a single (first-order) rewrite at
the top of a term.


\subsection{Conversion to Conjunctive Normal Form}
\label{sec:conv-conj-norm}


\subsection{The Core DPLL Procedure}
\label{sec:dpll-procedure}





%%% Local Variables:
%%% mode: latex
%%% TeX-master: "tutorial"
%%% End:
