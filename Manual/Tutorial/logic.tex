\chapter{The HOL Logic}
\label{HOLlogic}

The \HOL\  system  supports {\it  higher order  logic}.   This is  a version of
predicate calculus with three main extensions:

\begin{itemize}
\item Variables can range over functions and predicates
(hence `higher order').
\item The logic is {\it typed}.
\item There is no separate syntactic category of {\it formulae\/}
(terms of type \ml{bool} fulfill their role).
\end{itemize}

\section{Overview of higher order logic}

It is assumed the reader is familiar with predicate logic.  The syntax
and semantics of the particular logical system supported by \HOL\ is
described in detail in \DESCRIPTION.  The table below summarizes the
notation used.

\begin{center}
\begin{tabular}{|l|l|l|l|} \hline
\multicolumn{4}{|c|}{ } \\
\multicolumn{4}{|c|}{\bf Terms of the HOL Logic} \\
\multicolumn{4}{|c|}{ } \\
{\it Kind of term} & {\it \HOL\ notation} &
{\it Standard notation} &
{\it Description} \\ \hline
 & & & \\
Truth & {\small\verb|T|} & $\top$ & {\it true}\\ \hline
Falsity & {\small\verb|F|} & $\bot$ & {\it false}\\ \hline
Negation & {\small\verb|~|}$t$ & $\neg t$ & {\it not}$\ t$\\ \hline
Disjunction & $t_1${\small\verb|\/|}$t_2$ & $t_1\vee t_2$ &
$t_1\ ${\it or}$\ t_2$ \\ \hline
Conjunction & $t_1${\small\verb|/\|}$t_2$ & $t_1\wedge t_2$ &
$t_1\ ${\it and}$\ t_2$ \\ \hline
Implication & $t_1${\small\verb|==>|}$t_2$ & $t_1\imp t_2$ &
$t_1\ ${\it implies}$\ t_2$ \\ \hline
Equality & $t_1${\small\verb|=|}$t_2$ & $t_1 = t_2$ &
$t_1\ ${\it equals}$\ t_2$ \\ \hline
$\forall$-quantification & {\small\verb|!|}$x${\small\verb|.|}$t$ &
$\uquant{x}t$ & {\it for\ all\ }$x: t$ \\ \hline
$\exists$-quantification & {\small\verb|?|}$x${\small\verb|.|}$t$ &
$\equant{x}\ t$ & {\it for\ some\ }$x: t$ \\ \hline
$\hilbert$-term & {\small\verb|@|}$x${\small\verb|.|}$t$ &
$\hquant{x}t$ & {\it an}$\ x\ ${\it such\ that:}$\ t$ \\ \hline
Conditional & {\small\verb|(if|} $t$ {\small\verb|then|} $t_1$
              {\small\verb|else|} $t_2${\small\verb|)|} &
$(t\rightarrow t_1, t_2)$ & {\it if\ }$t${\it \ then\ }$t_1${\it\ else\ }$t_2$
 \\ \hline
\end{tabular}
\end{center}\label{logic-table}

\paragraph{Note on HOL example sessions}
All of the examples below assume that the user is running
\texttt{hol.unquote}, the executable for which is in the \texttt{bin/}
directory along with that for \texttt{hol}.  Further, the user needs
to execute the following commands before starting the sessions below:
\setcounter{sessioncount}{0}
\begin{session}
\begin{verbatim}
- app load ["arithmeticTheory", "pairTheory", "Psyntax"];
> val it = () : unit
- open Psyntax;
\end{verbatim}
\end{session}

\bigskip

Terms of the \HOL\ logic are represented in \ML\ by an {\it abstract
  type\/}\footnote{Abstract types appear to the user as primitive
  types with a collection of operations; they are described in
  \DESCRIPTION} called {\small\verb|term|}. They are normally input
between double back-quote marks.  For example, the expression
{\small\verb|``x /\ y ==> z``|} evaluates in \ML\ to a term representing
{\small\verb|x|}$\wedge${\small\verb|y|}$\Rightarrow${\small\verb|z|}.
Terms can be manipulated by various built-in \ML\ functions. For
example, the \ML\ function \ml{dest\_imp} with \ML\ type
{\small\verb|term -> term * term|} splits an implication into a pair
of terms consisting of its antecedent and consequent, and the \ML\
function \ml{dest\_conj} of type {\small\verb|term -> term * term|}
splits a conjunction into its two conjuncts.


\setcounter{sessioncount}{1}
\begin{session}
\begin{verbatim}
- ``x /\ y ==> z``;
> val it = ``x /\ y ==> z`` : term

- dest_imp it;
> val it = (``x /\ y``, ``z``) : term * term

- dest_conj(#1 it);
> val it = (``x``, ``y``) : term * term
\end{verbatim}
\end{session}

Terms of the \HOL\ logic are quite similar to \ML\ expressions, and
this can at first be confusing.  Indeed, terms of the logic have types
similar to those of \ML\ expressions.  For example,
{\small\verb|``(1,2)``|} is an \ML\ expression with \ML\ type
{\small\verb|term|}.  The \HOL\ type of this term is
{\small\verb|num # num|}.  By contrast, the \ML\ expression
{\small\verb|(``1``, ``2``)|} has type {\small\verb|term * term|}.

The types of \HOL\ terms form an \ML\ type called
{\small\verb|hol_type|}.  Types are usually input by applying the
parsing functionExpressions having the form
{\small\verb|``: |}$\cdots${\small\verb| ``|} evaluate to logical
types.
The built-in function {\small\verb|type_of|} has \ML\ type
{\small\verb|term->type|} and returns the logical type of a term.

\begin{session}
\begin{verbatim}
- ``(1,2)``;
> val it = ``(1,2)`` : term

- type_of it;
> val it = ``:num # num`` : hol_type

- (``1``, ``2``);
> val it = (``1``, ``2``) : term * term

- type_of(#1 it);
> val it = ``:num`` : hol_type
\end{verbatim}
\end{session}

To try to minimise confusion between the logical types of \HOL\ terms and
the \ML\ types of \ML\ expressions, the former will be referred to as {\it object
language types\/} and the latter as {\it meta-language types\/}.  For example,
{\small\verb|``(1,T)``|} is an \ML\ expression that has meta-language type
{\small\verb|term|} and evaluates to a term with object language type
{\small\verb|``:num#bool``|}.


\begin{session}
\begin{verbatim}
- ``(1,T)``;
> val it = ``(1,T)`` : term

- type_of it;
> val it = ``:num * bool`` : hol_type
\end{verbatim}
\end{session}

\HOL\ terms can be input using explicit {\it quotation\/}, as above, or
they can be constructed using \ML\ constructor functions. The function
{\small\verb|mk_var|} constructs a variable from a string and a type.  In
the example below, three variables of type {\small\verb|bool|} are
constructed.  These are used later.

\begin{session}
\begin{verbatim}
- val x = mk_var("x", ``:bool``)
  and y = mk_var("y", ``:bool``)
  and z = mk_var("z", ``:bool``);
> val x = ``x`` : term
  val y = ``y`` : term
  val z = ``z`` : term
\end{verbatim}
\end{session}

The constructors {\small\verb|mk_conj|} and {\small\verb|mk_imp|} construct
conjunctions and implications respectively.

\begin{session}
\begin{verbatim}
- val t = mk_imp(mk_conj(x,y),z);
> val t = ``x /\ y ==> z`` : term
\end{verbatim}
\end{session}

\section{Terms}

There are only four different kinds of terms:
\begin{enumerate}
\item Variables.
\item Constants.
\item Function applications: \ml{``$t_1$\ $t_2$``}.
\item $\lambda$-abstractions: {\small\verb|``\|}$x$\ml{.}$t$\ml{``}.
\end{enumerate}

Both variables and constants have a name and a type; the difference is
that constants cannot be bound by quantifiers, and their type is fixed
when they are declared (see below). The type checking algorithm uses
the types of constants to infer the types of variables in the same
quotation. If there is not enough type information type variables will
be guessed:

\begin{session}\begin{verbatim}
- ``~x``;
val it = ``~x`` : term

- ``x``;
<<HOL message: inventing new type variable names: 'a.>>
> val it = ``x`` : Term.term
- type_of it;
> val it = ``:'a`` : hol_type
\end{verbatim}\end{session}

    In the first case, the \HOL\ type checker used the known type
    \ml{bool->bool} of {\small\verb|~|} to deduce that the variable
    \ml{x} must have type \ml{bool}.  In the second case, it cannot
    deduce the type of \ml{x}.  The default `scope' of type
    information for type checking is a single quotation, so a type in
    one quotation cannot affect the type-checking of another.  If
    there is not enough contextually-determined type information to
    resolve the types of all variables in a quotation, then the system
    will guess different type variables for all the unconstrained
    variables.  Alternatively, it is possible to explicitly indicate
    the required types by using \ml{``$term$:$type$``} as illustrated
    below.

\begin{session}\begin{verbatim}
- ``(x,y)``;
<<HOL message: inventing new type variable names: 'a, 'b.>>
> val it = ``(x,y)`` : term
- type_of it;
> val it = ``:'a # 'b`` : hol_type

- ``x:num``;
> val it = ``x`` : term
- type_of it;
> val it = ``:num`` : hol_type
\end{verbatim}\end{session}

    Functions have types of the form \ml{$\sigma_1$->$\sigma_2$},
    where $\sigma_1$ and $\sigma_2$ are the types of the domain and
    range of the function, respectively.

\begin{session}\begin{verbatim}
- type_of ``$==>``;
> val it = ``:bool -> bool -> bool`` : hol_type

- type_of ``$+``;
> val it = ``:num -> num -> num`` : hol_type
\end{verbatim}\end{session}

\noindent Both \ml{+} and \ml{==>} are infixes, so their use in
contexts where they are not being used as such requires their
prefixing by the \texttt{\$}-sign.  This is analogous to the way in
which \texttt{op} is used in \ML. The session below illustrates the
use of these constants as infixes; it also illustrates object language
versus meta-language types.

\begin{session}\begin{verbatim}
- ``(x + 1, t1 ==> t2)``;
> val it = ``(x + 1,t1 ==> t2)`` : term

- type_of it;
> val it = ``:num # bool`` : hol_type

- (``x=1``, ``t1==>t2``);
> val it = (``x = 1``, ``t1 ==> t2``) : term * term

- (type_of (#1 it), type_of (#2 it));
> val it = (``:bool``, ``:bool``) : hol_type * hol_type
\end{verbatim}\end{session}

\noindent The types of constants are declared in {\it theories}.  This is
described later.

An application $t_1\ t_2$ is badly typed if $t_1$ is not a function:

\begin{session}\begin{verbatim}
- ``1 2``;

Type inference failure: unable to infer a type for the application of

(1 :num)

to

(2 :num)

unification failure message: unify failed
! Uncaught exception:
! HOL_ERR <poly>
\end{verbatim}\end{session}

\noindent or if it is a function, but $t_2$ is not in its range:

\begin{session}\begin{verbatim}
- ``~1``;

Type inference failure: unable to infer a type for the application of

$~

to

(1 :num)

unification failure message: unify failed
! Uncaught exception:
! HOL_ERR <poly>
\end{verbatim}\end{session}

    As before, the dollar in front of {\small\verb|~|} indicates that
    the constant has a special syntactic status (in this case a
    non-standard precedence). Putting {\small\verb|$|} in front of any
    symbol causes the parser to ignore any special syntactic status
    (like being an infix) it might have.

\begin{session}\begin{verbatim}
- ``$==> t1 t2``;
> val it = ``t1 ==> t2`` : term
- ``$/\ t1 t2``;
> val it = ``t1 /\ t2`` : term
\end{verbatim}\end{session}

    Lambda-terms, or $\lambda$-terms, denote functions. The symbol
    `{\small\verb|\|}' is used as an {\small ASCII} approximation to
    $\lambda$.  Thus `{\small\verb|\|}$x$\ml{.}$t$' should be read as
    `$\lquant{x}t$'. For example, {\small\verb|"\x. x+1"|} is a term
    that denotes the function $n\mapsto n{+}1$.

\begin{session}\begin{verbatim}
- ``\x. x + 1``;
> val it = ``\x. x + 1`` : term

- type_of it;
> val it = ``:num -> num`` : hol_type
\end{verbatim}\end{session}

The two most important quantifiers are \ml{!} and \ml{?}, universal
and existential quantifiers.  The logical statement that every number
is either even or odd might be phrased as
{\small\verb|!n. (n MOD 2 = 1) \/ (n MOD 2 = 0)|}, while the statement
of Euclid's result about the infinitude of primes is:
{\small\verb|!n. ?p. prime p /\ p > n|}






%%% Local Variables:
%%% mode: latex
%%% TeX-master: "tutorial"
%%% End:
