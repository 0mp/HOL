
\chapter{Euclid's theorem}
\label{chap:euclid}

\setcounter{sessioncount}{0}

In this chapter, we prove in \holn{} that for every number, there is a
prime number that is larger, \ie, that the prime numbers form an
infinite sequence. This proof has been excerpted and adapted from a
much larger example due to John Harrison, in which he proved the $n =
4$ case of Fermat's Last Theorem. The proof development will be
performed using the facilities of \ml{bossLib}, one of \HOL's many
libraries and is intended to serve as an introduction to performing
high-level interactive proofs in \holn.  Many of the details may be
difficult to grasp for the novice reader; nonetheless, it is
recommended that the example be followed through in order to gain a
true taste of using \HOL{} to prove non-trivial theorems.

Some tutorial descriptions of proof systems show the system performing
amazing feats of automated theorem proving. In this example, we will
{\it not\/} take this approach; instead, we try to show how one
actually goes about the business of proving theorems in \holn{}: when
more than one way to prove something is possible, we will consider the
choices; when a difficulty rears its ugly head, we will attempt to
explain how to fight one's way clear.

One `drives' \holn{} by interacting with the ML top-level loop. In this
interaction style, ML function calls are made to bring in
already-established logical context (usually via \ml{load}), to define
new context (via \ml{Hol\_datatype} and \ml{Define} from
\ml{bossLib}), and to perform proofs using the goalstack interface, and
the proof tools from \ml{bossLib} (or if they fail to do the job, from
lower-level libraries).

First, we start the system. We will use make use of the quotation
pre-processor in the example, so we invoke
\ml{.../<holdir>/bin/hol.unquote}.  Now, we ``\ml{open}'' the
arithmetic theory, and specialize the rewriter provided by
\ml{bossLib} to a simplification set that knows about arithmetic.  The
former means that all of the \ML{} bindings from the \HOL{} theory of
arithmetic are available at the top level.  The latter is not
necessary, but serves to make some of the proofs typeset more nicely.
\begin{session}
\begin{verbatim}
- open arithmeticTheory
  ...

- val ARW_TAC = RW_TAC arith_ss;
> val ARW_TAC =
    fn
    : Thm.thm list -> Term.term list * Term.term ->
      (Term.term list * Term.term) list * (Thm.thm list -> Thm.thm)
\end{verbatim}
\end{session}
The ML type of \ml{ARW\_TAC} is $\mbox{\it thm list} \longrightarrow
\mbox{\it tactic}$. When \ml{ARW\_TAC} is applied to a list of theorems, the
theorems will be added to \verb+arith_ss+ as rewrite rules.  We will see
that \ml{ARW\_TAC} is fairly knowledgeable about
arithmetic.\footnote{Linear arithmetic especially: purely universal
statements involving the operators {\tt SUC}, $+$, $-$, numeric
literals, $<$, $\leq$, $>$, $\geq$, $=$, and multiplication by numeric
literals.}

We now begin the formalization. In order to define the concept of  \emph
{prime} number, we first need to define the \emph{divisibility} relation:

\begin{session}\begin{verbatim}
- val divides = Define `divides a b = ?x. b = a * x`;

> Definition stored under "divides_def".
> val divides = |- !a b. divides a b = ?x. b = a * x : Thm.thm
\end{verbatim}\end{session}
    The definition is added to the current theory with the name
    \ml{divides\_def}, and also returned from the invocation of
    \ml{Define}. We take advantage of this and make an ML binding of
    the name \ml{divides} to the definition. In the usual way of
    interacting with \HOL, such an \ML binding is made for each
    definition and (useful) proved theorem: the \ML environment is
    thus being used as a convenient place to hold definitions and
    theorems for later reference in the session.

We want to treat \ml{divides} as a (right associative) infix:
\begin{session}\begin{verbatim}
- set_fixity "divides" (Infixr 450);
\end{verbatim}\end{session}
Now we can define the property of a number being \emph{prime}: a number $p$ is
prime if and only if it is not equal to $1$ and it has no divisors other
than $1$ and itself:

\begin{session}\begin{verbatim}
- val prime =
    Define `prime p = ~(p=1) /\ !x. x divides p ==> (x=1) \/ (x=p)`;

Definition stored under "prime_def".
> val prime =
    |- !p. prime p = ~(p = 1) /\ !x. x divides p ==> (x = 1) \/ (x = p)
    : Thm.thm
\end{verbatim}\end{session}

That concludes the definitions to be made. Now we ``just'' have to prove
that there are an infinite number of primes. If we were coming to this
problem fresh, then we would have to go through a not-well-understood
and often tremendously difficult process of finding the right lemmas
required to prove our target theorem.\footnote{This is of course a
general problem in doing any kind of proof.} Fortunately, we are working
from a detailed and accurate source and can devote ourselves to the far
simpler problem of explaining how to prove the required theorems.

The development will illustrate that there is often more than one way to
tackle a HOL proof, even if one has only a single (informal) proof in
mind. We often \emph{find} the proof using \ml{ARW\_TAC} to unwind
definitions and perform basic simplifications, \ie, to reduce the goal
to its essence. Sometimes this proves the goal immediately. Often
however, we are left with a goal that requires some study before one
realizes what lemmas are needed to conclude the proof. Once these lemmas
have been proven (or located in ancestor theories), \ml{PROVE\_TAC} can
be invoked with them, with the expectation that it will find the right
instantiations needed to finish the proof. (These two operations do not
suffice to perform all proofs; in particular, our development will also need
case analysis and induction.)

This raises the following question: how does one find the right lemmas
to use? This is quite a problem, especially when the number of
theorems in ancestor theories is large. There are are couple of
possibilities: the help system can be used to look up definitions and
theorems, as well as proof procedures; for example, an invocation of
\[
\mbox{\texttt{help "arithmeticTheory"}}
\]
will display all the definitions and theorems that have been stored in
the theory of arithmetic. However, the complete name of the item being
searched for must be known before the help system is useful.
Alternatively, the functions in \verb+DB+ are often easier to use.
\verb+DB.match+ allows the use of first order patterns to look for the
relevant items, while \verb+DB.find+ will use fragments of names as
keys with which to lookup information.

Once a proof of a proposition has been found, it is customary, although
not necessary, to embark on a process of \emph{revision}, in which the
original sequence of tactics is composed into a single tactic. Sometimes
the resulting tactic is much shorter, and more aesthetically pleasing in
some sense. Some users spend a fair bit of time polishing these tactics,
although there doesn't seem much real benefit in doing so, since they
are \emph{ad hoc} proof recipes, one for each theorem. In the
following, we will show how this is done in a few cases.

\section{Divisibility}

We start by proving a number of theorems about the \verb+divides+
relation.  We will see that each of these initial theorems can be
proved with a single invocation of \ml{PROVE\_TAC}. Both \ml{ARW\_TAC}
and \ml{PROVE\_TAC} are quite powerful reasoners, and the choice of a
reasoner in a particular situation is a matter of experience.  The
major reason that \ml{PROVE\_TAC} works so well is that \verb+divides+
is defined by means of an existential quantifier, and \ml{PROVE\_TAC}
is quite good at automatically instantiating existentials in the
course of proof. For a simple example, consider proving $\forall x.\
x\; \mbox{\tt divides}\; 0$. A new proposition to be proved is entered
to the proof manager via ``{\tt g}'', which starts a fresh goalstack:

\begin{session}\begin{verbatim}
- g `!x. x divides 0`;

> val it =
>    Proof manager status: 1 proof.
>    1. Incomplete:
>         Initial goal:
>         !x. x divides 0
>
>    : GoalstackPure.proofs
\end{verbatim}\end{session}
The proof manager tells us that it has only one proof to manage, and
echoes the given goal.  Now we expand the definition of
\verb+divides+. Notice that $\alpha$-conversion takes place in order to
keep distinct the $x$ of the goal and the $x$ in the definition of
\ml{divides}:
\begin{session}\begin{verbatim}
- e (ARW_TAC [divides]);

> OK..
> 1 subgoal:
> val it =
>    ?x'. (x = 0) \/ (x' = 0)
\end{verbatim}\end{session}
It is of course quite easy to instantiate the existential quantifier by
hand.
\begin{session}\begin{verbatim}
- e (EXISTS_TAC ``0``);

> OK..
> 1 subgoal:
> val it =
>     (x = 0) \/ (0 = 0)
\end{verbatim}\end{session}
Then a simplification step finishes the proof.
\begin{session}\begin{verbatim}
- e (ARW_TAC []);

> OK..
>
> Goal proved.
> |- (x = 0) \/ (0 = 0)
>
> Goal proved.
> |- ?x'. (x = 0) \/ (x' = 0)
> val it =
>     Initial goal proved.
>     |- !x. x divides 0
\end{verbatim}\end{session}

What just happened here? The application of \ml{ARW\_TAC} to the goal
decomposed it to an empty list of subgoals; in other words the goal was
proved by \ml{ARW\_TAC}.  Once a goal has been proved, it is popped off
the goalstack, prettyprinted to the output, and the theorem becomes
available for use by the level of the stack. When all the sub-goals
required by {\it that\/} level are proven, the corresponding goal at
that level can be proven too.  This `unwinding' process continues until
the stack is empty, or until it hits a goal with more than one remaining
unproved subgoal. This process may be hard to
visualize,\footnote{Perhaps since we have used a stack to implement what
is notionally a tree!} but that doesn't matter, since the goalstack was
expressly written to allow the user to ignore such details.

If the three interactions are joined together with \ml{THEN} to
form a single tactic, we can try the proof again from the
beginning (using the \ml{restart} function) and this time it will
take just one step:
\begin{session}\begin{verbatim}
- restart();
>   ...

- e (ARW_TAC [divides] THEN EXISTS_TAC ``0`` THEN ARW_TAC[]);

> OK..
> val it =
>     Initial goal proved.
>     |- !x. x divides 0
\end{verbatim}\end{session}
We have seen one way to prove the theorem. However, as mentioned
earlier, there is another: one can let \ml{PROVE\_TAC} expand the
definition of \ml{divides} and find the required instantiation for
\verb+x'+ from the theorem \ml{MULT\_CLAUSES}.\footnote{You might
  like to try typing \ml{MULT\_CLAUSES} into the interactive loop
  to see exactly what it states.}
\begin{session}\begin{verbatim}
- restart();
>   ...

- e (PROVE_TAC [divides, MULT_CLAUSES]);

> OK..
> Meson search level: .....
> val it =
>     Initial goal proved.
>     |- !x. x divides 0
\end{verbatim}\end{session}
    In any case, having done our proof inside the goalstack package,
    we now want to have access to the theorem value that we have
    proved.  We use the \ml{top\_thm} function to do this, and then
    use \ml{drop} to dispose of the stack:
\begin{session}\begin{verbatim}
- val DIVIDES_0 = top_thm();

> val DIVIDES_0 = |- !x. x divides 0 : Thm.thm

- drop();
> OK..
> val it = There are currently no proofs. : GoalstackPure.proofs
\end{verbatim}\end{session}

We have used \ml{PROVE\_TAC} in this way to prove the following
collection of theorems about \ml{divides}. As mentioned previously, the
theorems supplied to \ml{PROVE\_TAC} in the following proofs did not
(usually) come from thin air: in most cases some exploratory work with
\ml{ARW\_TAC} was done to open up definitions and see what lemmas would
be required by \ml{PROVE\_TAC}.

\begin{description}

\item [\small{({\it DIVIDES\_0\/})}]
\begin{tabular}[t]{l}
\verb+!x. x divides 0+ \\ \hline
 \verb+PROVE_TAC [divides, MULT_CLAUSES]+
\end{tabular}

\item[\small{({\it DIVIDES\_ZERO\/})}]
\begin{tabular}[t]{l}
\verb+!x. 0 divides x = (x = 0)+ \\ \hline
 \verb+PROVE_TAC [divides, MULT_CLAUSES]+
\end{tabular}

\item[\small{({\it DIVIDES\_ONE\/})}]
\begin{tabular}[t]{l}
\verb+!x. x divides 1 = (x = 1)+ \\ \hline
 \verb+PROVE_TAC [divides, MULT_CLAUSES, MULT_EQ_1]+
\end{tabular}

\item[\small{({\it DIVIDES\_REFL\/})}]
\begin{tabular}[t]{l}
\verb+!x. x divides x+ \\ \hline
 \verb+PROVE_TAC [divides, MULT_CLAUSES]+ \\
\end{tabular}

\item[\small{({\it DIVIDES\_TRANS\/})}]
\begin{tabular}[t]{l}
\verb+!a b c. a divides b /\ b divides c ==> a divides c+ \\ \hline
 \verb+PROVE_TAC [divides, MULT_ASSOC]+ \\
\end{tabular}
\item[\small{({\it DIVIDES\_ADD\/})}]
\begin{tabular}[t]{l}
\verb|!d a b. d divides a /\ d divides b ==> d divides (a+b)| \\ \hline
 \verb|PROVE_TAC [divides,LEFT_ADD_DISTRIB]|
\end{tabular}

\item[\small{({\it DIVIDES\_SUB\/})}]
\begin{tabular}[t]{l}
\verb+!d a b. d divides a /\ d divides b ==> d divides (a-b)+ \\ \hline
 \verb+PROVE_TAC [divides, LEFT_SUB_DISTRIB]+ \\
\end{tabular}

\item[\small{({\it DIVIDES\_ADDL\/})}]
\begin{tabular}[t]{l}
\verb|!d a b. d divides a /\ d divides (a+b) ==> d divides b| \\ \hline
 \verb+PROVE_TAC [ADD_SUB, ADD_SYM, DIVIDES_SUB]+ \\
\end{tabular}

\item[\small{({\it DIVIDES\_LMUL\/})}]
\begin{tabular}[t]{l}
\verb+!d a x. d divides a ==> d divides (x * a)+ \\ \hline
 \verb+PROVE_TAC [divides, MULT_ASSOC, MULT_SYM]+ \\
\end{tabular}

\item[\small{({\it DIVIDES\_RMUL\/})}]
\begin{tabular}[t]{l}
\verb+!d a x. d divides a ==> d divides (a * x)+ \\ \hline
 \verb+PROVE_TAC [MULT_SYM, DIVIDES_LMUL]+ \\
\end{tabular}

\end{description}

\noindent We'll assume that the above proofs have been performed, and
that the appropriate ML names have been given to all of the theorems.
Now we encounter a lemma about divisibility that doesn't succumb to a
single invocation of \ml{PROVE\_TAC}:
\begin{description}
\item [\small{({\it DIVIDES\_LE\/})}]
\begin{tabular}[t]{l}
\verb+!m n. m divides n ==> m <= n \/ (n = 0)+ \\ \hline
\verb+ARW_TAC [divides]+ \\
\verb+   THEN Cases_on `x`+ \\
\verb+   THEN ARW_TAC [MULT_CLAUSES]+ \\
\end{tabular}
\end{description}
Let's see how this is proved. The easiest way to start is to simplify
with the definition of \ml{divides}:
\begin{session}\begin{verbatim}
- g `!m n . m divides n ==> m <= n \/ (n = 0)`;
>   ...

- e (ARW_TAC [divides]);

> 1 subgoal:
> val it =
>     m <= m * x \/ (m * x = 0)
\end{verbatim}\end{session}

Considering the goal, we basically have three choices: (1) find a
collection of lemmas that together imply the goal and use
\ml{PROVE\_TAC}; (2) do a case split on $m$; or (3) do a case split on
$x$. The first doesn't seem simple, because the goal doesn't really fit
in the `shape' of any pre-proved theorem(s) that the author knows
about. Although option (2) will be rejected in the end, let's try it
anyway. To perform the case split, we use \verb+Cases_on+, which stands
for ``find the given term in the goal and do a case split on the
possible means of building it out of datatype constructors''. Since the
occurrence of $m$ in the goal has type $num$, the cases considered will
be whether $m$ is $0$ or a successor.
\begin{session}\begin{verbatim}
- e (Cases_on `m`);

> OK..
> 2 subgoals:
> val it =
>     SUC n <= SUC n * x \/ (SUC n * x = 0)
>
>    0 <= 0 * x \/ (0 * x = 0)
\end{verbatim}\end{session}
\noindent The first subgoal (the last one printed) is trivial:

\begin{session}\begin{verbatim}
- e (ARW_TAC []);

> OK..
>
> Goal proved.
>   ...
>
> Remaining subgoals:
> val it =
>     SUC n <= SUC n * x \/ (SUC n * x = 0)
\end{verbatim}\end{session}
\noindent Let's try \ml{ARW\_TAC} again:
\begin{session}\begin{verbatim}
- e (ARW_TAC []);

> OK..
> 1 subgoal:
> val it =
>     SUC n <= SUC n * x \/ (x = 0)
\end{verbatim}\end{session}
The right disjunct has been simplified; however, the left disjunct has
failed to expand the definition of multiplication in the expression
$\mbox{\tt SUC}\ n * x$, which would have been convenient. Why not, when
\verb+arith_ss+ and hence \ml{ARW\_TAC} is supposed to be expert in
arithmetic? The answer is that the recursive clauses for addition and
multiplication are not in \verb+arith_ss+ because uncontrolled
application of them by the rewriter seems, in general, to make some
proofs \emph{more} complicated, rather than simpler. OK, so let's
add in the definition of multiplication. This uncovers a new problem: how
to locate this definition. The function
\begin{boxed}\begin{verbatim}
   DB.match : string list -> term
                -> ((string * string) * (thm * DB.class)) list
\end{verbatim}\end{boxed}

\noindent
is often helpful for such tasks. It takes a list of theory names, and
a pattern, and looks in the list of theories for any theorem,
definition, or axiom that has an instance of the pattern as a subterm.
If the list of theory names is empty, then all loaded theories are
included in the search. Let's look in the theory of arithmetic for the
subterm to be rewritten.

\begin{session}\begin{verbatim}
- DB.match ["arithmetic"] (Term`SUC n * x`);

> val it =
>    [(("arithmetic", "FACT"),
>      (|- (FACT 0 = 1) /\ !n. FACT (SUC n) = SUC n * FACT n, DB.Def)),
>     (("arithmetic", "LESS_MULT_MONO"),
>      (|- !m i n. SUC n * m < SUC n * i = m < i, DB.Thm)),
>     (("arithmetic", "MULT"),
>      (|- (!n. 0 * n = 0) /\ !m n. SUC m * n = m * n + n, DB.Def)),
>     (("arithmetic", "MULT_CLAUSES"),
>      (|- !m n.
>            (0 * m = 0) /\ (m * 0 = 0) /\ (1 * m = m) /\ (m * 1 = m) /\
>            (SUC m * n = m * n + n) /\ (m * SUC n = m + m * n), DB.Thm)),
>     (("arithmetic", "MULT_LESS_EQ_SUC"),
>      (|- !m n p. m <= n = SUC p * m <= SUC p * n, DB.Thm)),
>     (("arithmetic", "MULT_MONO_EQ"),
>      (|- !m i n. (SUC n * m = SUC n * i) = m = i, DB.Thm)),
>     (("arithmetic", "ODD_OR_EVEN"),
>      (|- !n. ?m. (n = SUC (SUC 0) * m) \/ (n = SUC (SUC 0) * m + 1), DB.Thm))]
\end{verbatim}\end{session}

For some, this returns slightly too much information; however, we can
focus the search by stipulating that the pattern look like a rewrite
rule:

\begin{session}\begin{verbatim}
- DB.match [] (Term`SUC n * x = M`);

> val it =
>     [(("arithmetic", "MULT"),
>       (|- (!n. 0 * n = 0) /\ !m n. SUC m * n = m * n + n, DB.Def)),
>      (("arithmetic", "MULT_CLAUSES"),
>       (|- !m n.
>             (0 * m = 0) /\ (m * 0 = 0) /\ (1 * m = m) /\ (m * 1 = m) /\
>             (SUC m * n = m * n + n) /\ (m * SUC n = m + m * n), DB.Thm)),
>      (("arithmetic", "MULT_MONO_EQ"),
>       (|- !m i n. (SUC n * m = SUC n * i) = m = i, DB.Thm))]
\end{verbatim}\end{session}

Either {\small\verb+arithmeticTheory.MULT+} or
{\small\verb+arithmeticTheory.MULT_CLAUSES+} would be acceptable; we
choose the latter.

\begin{session}\begin{verbatim}
- e (ARW_TAC [MULT_CLAUSES]);

> OK..
> 1 subgoal:
> val it =
>     SUC n <= x + n * x \/ (x = 0)
\end{verbatim}\end{session}
Now we see that, in order to make progress in the proof, we will have to
do a case split on $x$ anyway, and that we should have split on it
originally. Hence we backup. We will have to backup (undo) four times:
\begin{session}\begin{verbatim}
- b();
> val it =
    SUC n <= SUC n * x \/ (x = 0)

- b();
> val it =
    SUC n <= SUC n * x \/ (SUC n * x = 0)

- b();
> val it =
    SUC n <= SUC n * x \/ (SUC n * x = 0)


    0 <= 0 * x \/ (0 * x = 0)

- b();
> val it =
    m <= m * x \/ (m * x = 0)
\end{verbatim}\end{session}

Now we can go forward and do case analysis on $x$. We will
    also make a compound tactic invocation, since we already know that
    we'll have to invoke \ml{ARW\_TAC} in both branches of the case
    split. This can be done using \ml{THEN}.  When $t_1 \
    \mbox{\ml{THEN}}\ t_2$ is applied to a goal $g$, first $t_1$ is
    applied to $g$, giving a list of new subgoals, then $t_2$ is
    applied to each member of the list. All goals resulting from these
    applications of $t_2$ are gathered together and returned.
\begin{session}\begin{verbatim}
- e (Cases_on `x` THEN ARW_TAC [MULT_CLAUSES]);

> OK..
>
> Goal proved.
> |- m <= m * x \/ (m * x = 0)
> val it =
>     Initial goal proved.
>     |- !m n. m divides n ==> m <= n \/ (n = 0)
\end{verbatim}\end{session}
    That was easy! Obviously making a case split on $x$ was the right
    choice. The process of {\it finding\/} the proof has now finished,
    and all that remains is for the proof to be packaged up into the
    single tactic we saw above.  Rather than use \ml{top\_thm} and the
    goalstack, we can bypass it and use the \ml{store\_thm} function.
    This function takes a string, a term and a tactic and applies the
    tactic to the term to get a theorem, and then stores the theorem
    in the current theory under the given name.
\begin{session}\begin{verbatim}
- val DIVIDES_LE = store_thm (
     "DIVIDES_LE",
     ``!m n. m divides n ==> m <= n \/ (n = 0)``,
     ARW_TAC [divides]
       THEN Cases_on `x`
       THEN ARW_TAC [MULT]);

> val DIVIDES_LE = |- !m n. m divides n ==> m <= n \/ (n = 0) : Thm.thm
\end{verbatim}\end{session}
    Storing theorems in our script record of the session in this style
    (rather than with the goalstack) results in a more concise script,
    and also makes it easier to turn our script into a theory file, as
    we do in section~\ref{sec:script-to-theory}.

\subsection{Divisibility and factorial}

The next lemma, {\small{\it DIVIDES\_FACT\/}}, says that every number
greater than $0$ and less-than-or-equal-to $n$ divides the factorial of
$n$. Factorial is found at \verb+arithmeticTheory.FACT+ and has been
defined by primitive recursion:
\begin{description}
\item [\small{({\it FACT\/})}]
\begin{tabular}[t]{l}
\verb+(FACT 0 = 1) /\+ \\
\verb+(!n. FACT (SUC n) = SUC n * FACT n)+ \\
\end{tabular}
\end{description}
A polished proof of {\small{\it DIVIDES\_FACT\/}} is the following:
\begin{description}
\item [\small{({\it DIVIDES\_FACT\/})}]
\begin{tabular}[t]{l}
\verb+!m n. 0 < m /\ m <= n ==> m divides (FACT n)+ \\ \hline
\verb+ARW_TAC [LESS_EQ_EXISTS]+ \\
\verb+ THEN Induct_on `p`+ \\
\verb+ THEN ARW_TAC [FACT,ADD_CLAUSES]+ \\
\verb+ THENL [Cases_on `m`, ALL_TAC]+ \\
\verb+ THEN PROVE_TAC [FACT, DECIDE `!x. ~(x < x)`,+ \\
\verb+             DIVIDES_RMUL, DIVIDES_LMUL, DIVIDES_REFL]+ \\
\end{tabular}
\end{description}
We will examine this proof in detail, so we should first attempt to
understand why the theorem is true. What's the underlying intuition?
Suppose $0 < m \leq n$, and so $\mbox{\tt FACT}\ n = 1 * \cdots * m *
\cdots * n$. To show $m\ \mbox{\tt divides}\ (\mbox{\tt FACT}\ n)$
means exhibiting a $q$ such that $q * m = \mbox{\tt FACT}\ n$. Thus $q
= \mbox{\tt FACT}\ n \div m$. If we were to take this approach to the
proof, we would end up having to find and apply lemmas about $\div$.
This seems to take us a little out of our way; isn't there a proof
that doesn't use division? Well yes, we can prove the theorem by
induction on $n - m$: in the base case, we will have to prove $n\;
\mbox{\tt divides}\ (\mbox{\tt FACT}\; n)$, which ought to be easy; in
the inductive case, the inductive hypothesis seems like it should give
us what we need. This strategy for the inductive case is a bit vague,
because we are trying to mentally picture a slightly complicated
formula, but we can rely on the system to accurately calculate the
cases of the induction for us. If the inductive case turns out to be
not what we expect, we will have to re-think our approach.
\begin{session}\begin{verbatim}
- g `!m n. 0 < m /\ m <= n ==> m divides (FACT n)`;

> val it =
>    Proof manager status: 1 proof.
>    1. Incomplete:
>         Initial goal:
>         !m n. 0 < m /\ m <= n ==> m divides FACT n
\end{verbatim}\end{session}
Instead of directly inducting on $n-m$, we will induct on a witness
variable, obtained by use of the theorem \verb+LESS_EQ_EXISTS+.
\begin{session}\begin{verbatim}
- LESS_EQ_EXISTS;
> val it = |- !m n. m <= n = (?p. n = m + p) : Thm.thm

- e (ARW_TAC [LESS_EQ_EXISTS]);

> OK..
> 1 subgoal:
> val it =
>    m divides FACT (m + p)
>    ------------------------------------
>       0 < m
\end{verbatim}\end{session}
\noindent Now we induct on $p$:
\begin{session}\begin{verbatim}
- e (Induct_on `p`);

> OK..
> 2 subgoals:
> val it =
>     m divides FACT (m + SUC p)
>     ------------------------------------
>       0.  0 < m
>       1.  m divides FACT (m + p)
>
>     m divides FACT (m + 0)
>    ------------------------------------
>       0 < m
\end{verbatim}\end{session}
\noindent The first goal can obviously be simplified:
\begin{session}\begin{verbatim}
- e (ARW_TAC []);

> OK..
> 1 subgoal:
> val it =
>     m divides FACT m
>     ------------------------------------
>       0 < m
\end{verbatim}\end{session}
\noindent Now we can do a case analysis on $m$: if it is $0$, we have a
trivial goal; if it is a successor, then we can use the definition of
\ml{FACT} and the theorems \ml{DIVIDES\_RMUL} and
\ml{DIVIDES\_REFL}.
\begin{session}\begin{verbatim}
- e (Cases_on `m`);

> OK..
> 2 subgoals:
> val it =
>     SUC n divides FACT (SUC n)
>     ------------------------------------
>       0 < SUC n
>
>     0 divides FACT 0
>     ------------------------------------
>       0 < 0
\end{verbatim}\end{session}

    Here the first sub-goal goal has an assumption that is false.  We
    can demonstrate this to the system by using the \ml{DECIDE}
    function to prove a simple fact about arithmetic (namely, that no
    number $x$ is less than itself), and then passing the resulting
    theorem to \ml{PROVE\_TAC}, which can combine this with the
    contradictory assumption.\footnote{Note how the interactive system
      prints out the proved theorem with \ml{[.]} before the
      turnstile.  This notation indicates that a theorem has an
    assumption (the false $0 < 0$ in this case).}

\begin{session}\begin{verbatim}
- e (PROVE_TAC [DECIDE `!x. ~(x < x)`]);

> OK..
> Meson search level: ..
>
> Goal proved.
>  [.] |- 0 divides FACT 0
>
> Remaining subgoals:
> val it =
>     SUC n divides FACT (SUC n)
>     ------------------------------------
>       0 < SUC n
\end{verbatim}\end{session}
Using the theorems identified above, this, the second sub-goal, can
be proved with \ml{ARW\_TAC}.

\begin{session}\begin{verbatim}
- e (ARW_TAC [FACT, DIVIDES_RMUL, DIVIDES_REFL]);

> OK..
>
> Goal proved.   ...
>
> Remaining subgoals:
> val it =
>     m divides FACT (m + SUC p)
>     ------------------------------------
>       0.  0 < m
>       1.  m divides FACT (m + p)
\end{verbatim}\end{session}
Note that this last step (the invocation of \ml{ARW\_TAC})
could also have been accomplished with \ml{PROVE\_TAC}:
\begin{session}\begin{verbatim}
- b();

> ...

- e (PROVE_TAC [FACT, DIVIDES_RMUL, DIVIDES_REFL]);
> OK..
>
> Goal proved.  ...
\end{verbatim}\end{session}
Now we have finished the base case of the induction and can move to the
step case. An obvious thing to try is simplification with the
definitions of addition and factorial:
\begin{session}\begin{verbatim}
- e (ARW_TAC [FACT, ADD_CLAUSES]);

> OK..
> 1 subgoal:
> val it =
>     m divides SUC (m + p) * FACT (m + p)
>     ------------------------------------
>       0.  0 < m
>       1.  m divides FACT (m + p)
\end{verbatim}\end{session}
\noindent And now, by \ml{DIVIDES\_LMUL} and the inductive hypothesis, we are
done:
\begin{session}\begin{verbatim}
- e (PROVE_TAC [DIVIDES_LMUL]);

> OK..
> Meson search level: ...
> Goal proved.
>   ...
> val it =
>     Initial goal proved.
>     |- !m n. 0 < m /\ m <= n ==> m divides FACT n
\end{verbatim}\end{session}
We have finished the search for the proof, and now turn to the task of
making a single tactic out of the sequence of tactic invocations we have
just made. We assume that the sequence of invocations has been kept
track of in a file or a text editor buffer. We would thus have something
like the following:
{\small \begin{verbatim}
    e (ARW_TAC [LESS_EQ_EXISTS]);
    e (Induct_on `p`);
    (*1*)
    e (ARW_TAC []);
    e (Cases_on `m`);
    (*1.1*)
    e (PROVE_TAC [DECIDE `!x. ~(x < x)`]);
    (*1.2*)
    e (ARW_TAC [FACT, DIVIDES_RMUL, DIVIDES_REFL]);
    (*2*)
    e (ARW_TAC [FACT, ADD_CLAUSES]);
    e (PROVE_TAC [DIVIDES_LMUL]);
\end{verbatim}}
\noindent

We have added a numbering scheme to keep track of the branches in the
proof. We can stitch the above directly into the following compound
tactic:

{\small\begin{verbatim}
    ARW_TAC [LESS_EQ_EXISTS]
     THEN Induct_on `p`
     THENL [ARW_TAC [] THEN Cases_on `m`
            THENL [PROVE_TAC [DECIDE `!x. ~(x < x)`],
                   ARW_TAC [FACT, DIVIDES_RMUL, DIVIDES_REFL]],
            ARW_TAC [FACT, ADD_CLAUSES] THEN PROVE_TAC [DIVIDES_LMUL]]
\end{verbatim}}

\noindent This can be tested to see that we have made no errors:

\begin{session}\begin{verbatim}
- restart();

> ...

- e (ARW_TAC [LESS_EQ_EXISTS]
       THEN Induct_on `p`
       THENL [ARW_TAC [] THEN Cases_on `m`
              THENL [PROVE_TAC [DECIDE `!x. ~(x < x)`],
                     ARW_TAC [FACT, DIVIDES_RMUL, DIVIDES_REFL]],
              ARW_TAC [FACT, ADD_CLAUSES] THEN PROVE_TAC [DIVIDES_LMUL]]);
> OK..
> Meson search level: ...
> Meson search level: ..
> val it =
>     Initial goal proved.
>     |- !m n. 0 < m /\ m <= n ==> m divides FACT n
\end{verbatim}\end{session}
    For many users, this would be the end of dealing with this proof:
    the tactic can now be packaged into an invocation of
    \ml{prove}\footnote{The \ml{prove} function takes a term and a
      tactic and attempts to prove the term using the supplied tactic.
      It returns the proved theorem if the tactic succeeds.  It
      doesn't save the theorem to the developing theory.} or
    \ml{store\_thm} and that would be the end of it. However, another
    class of user would notice that this tactic could be shortened.

To start, both arms of the induction start with an invocation of
\ml{ARW\_TAC}, and the semantics of \ml{THEN} allow us to merge the
occurrences of \ml{ARW\_TAC} above the \ml{THENL}. The recast tactic
is
{\small\begin{verbatim}
    ARW_TAC [LESS_EQ_EXISTS]
      THEN Induct_on `p`
      THEN ARW_TAC [FACT, ADD_CLAUSES]
      THENL [Cases_on `m`
              THENL [PROVE_TAC [DECIDE `!x. ~(x < x)`],
                     ARW_TAC [FACT, DIVIDES_RMUL, DIVIDES_REFL]],
             PROVE_TAC [DIVIDES_LMUL]]
\end{verbatim}}
(Of course, when a tactic has been revised, it should be tested to see
if it still proves the goal!) Now recall that the use of \ml{ARW\_TAC}
in the base case could be replaced by a call to \ml{PROVE\_TAC}. Thus
it seems possible to merge the two sub-cases of the base case into a
single invocation of \ml{PROVE\_TAC}:

{\small\begin{verbatim}
    ARW_TAC [LESS_EQ_EXISTS]
      THEN Induct_on `p`
      THEN ARW_TAC [FACT, ADD_CLAUSES]
      THENL [Cases_on `m`
              THEN PROVE_TAC [DECIDE `!x. ~(x < x)`,
                              FACT, DIVIDES_RMUL, DIVIDES_REFL],
             PROVE_TAC [DIVIDES_LMUL]]
\end{verbatim}}

\noindent
Finally, pushing this dubious revisionism nearly to its limit, we'd
like there to be only a single invocation of \ml{PROVE\_TAC} to finish
the proof off. The semantics of \ml{THEN} and \ml{ALL\_TAC} come to
our rescue: we will split on the construction of $m$ in the base case,
as in the current incarnation of the tactic, but we will let the
inductive case pass unaltered through the \ml{THENL}. This is achieved
by using \verb+ALL_TAC+, which is a tactic that acts as an identity
function on the goal.
{\small\begin{verbatim}
    ARW_TAC [LESS_EQ_EXISTS]
      THEN Induct_on `p`
      THEN ARW_TAC [FACT, ADD_CLAUSES]
      THENL [Cases_on `m`, ALL_TAC]
      THEN PROVE_TAC [DECIDE `!x. ~(x < x)`, FACT,
                      DIVIDES_RMUL, DIVIDES_REFL, DIVIDES_LMUL]
\end{verbatim}}

\noindent
The result is that there will be three subgoals emerging from the
\ml{THENL}: the two sub-cases in the base case and the unaltered step
case. Each is proved with a call to \ml{PROVE\_TAC}. We have now
finished our exercise in tactic polishing.

\subsection{Divisibility and factorial (again!)}

In the previous proof, we made an initial simplification step in order
to expose a variable upon which to induct. However, the proof is
really by induction on $n - m$. Can we express this directly? The
answer is a qualified yes: the induction can be naturally stated, but
it leads to somewhat less natural goals.
\begin{session}\begin{verbatim}
- restart();

- e (Induct_on `n - m`);

> OK..
2 subgoals:
> val it =
>     !n m. (SUC v = n - m) ==> 0 < m /\ m <= n ==> m divides FACT n
>     ------------------------------------
>       !n m. (v = n - m) ==> 0 < m /\ m <= n ==> m divides FACT n
>
>     !n m. (0 = n - m) ==> 0 < m /\ m <= n ==> m divides FACT n
\end{verbatim}\end{session}
    This is slighly hard to read, so we use \ml{STRIP\_TAC} and
    \ml{REPEAT} to move the antecedents of the goals to the
    assumptions. Use of \ml{THEN} ensures that the tactic gets applied
    in both branches of the induction.
\begin{session}\begin{verbatim}
- b();
  ...

- e (Induct_on `n - m` THEN REPEAT STRIP_TAC);

> OK..
> 2 subgoals:
> val it =
>     m divides FACT n
>     ------------------------------------
>       0.  !n m. (v = n - m) ==> 0 < m /\ m <= n ==> m divides FACT n
>       1.  SUC v = n - m
>       2.  0 < m
>       3.  m <= n
>
>     m divides FACT n
>     ------------------------------------
>       0.  0 = n - m
>       1.  0 < m
>       2.  m <= n
\end{verbatim}\end{session}
Looking at the first goal, we reason that if $0 = n - m$ and $m
\leq n$, then $m = n$. We can prove this fact, and add it to the
hypotheses by use of the infix operator ``\ml{by}'':
\begin{session}\begin{verbatim}
- e (`m = n` by DECIDE_TAC);
OK..
1 subgoal:
> val it =
    m divides FACT n
    ------------------------------------
      0.  0 = n - m
      1.  0 < m
      2.  m <= n
      3.  m = n
\end{verbatim}\end{session}

We can now use \ml{ARW\_TAC} to propagate the newly derived equality
throughout the goal.
\begin{session}\begin{verbatim}
- e (ARW_TAC []);

> OK..
> 1 subgoal:
> val it =
>     m divides FACT m
>     ------------------------------------
>       0.  0 = m - m
>       1.  0 < m
>       2.  m <= m
\end{verbatim}\end{session}
    At this point in the previous proof we did a case analysis on $m$.
    However, we already have the hypothesis that $m$ is positive. Thus
    we know that $m$ is the successor of some number $k$. We might
    wish to assert this fact with an invocation of ``\ml{by}'' as
    follows:
\[
    \mbox{\ml{`?k. m = SUC k` by <tactic>}}
\]
But what is the tactic? If we try \ml{DECIDE\_TAC}, it will fail since
it doesn't handle existential statements. An application of
\ml{ARW\_TAC} will also prove to be unsatisfactory. What to do?

When such situations occur, it is often best to start a new proof for
the required lemma. This can be done simply by invoking ``\ml{g}''
again. A new goalstack will be created and stacked upon the current
one\footnote{This stacking of proof attempts (goalstacks) is different
  than the stacking of goals and justifications inside a particular
  goalstack.}  and an overview of the extant proof attempts will be
printed:
\begin{session}\begin{verbatim}
- g `!m. 0 < m ==> ?k. m = SUC k`;

> val it =
>     Proof manager status: 2 proofs.
>     2. Incomplete:
>          Initial goal:
>          !m n. 0 < m /\ m <= n ==> m divides FACT n
>
>
>          Current goal:
>          m divides FACT m
>          ------------------------------------
>            0.  0 = m - m
>            1.  0 < m
>            2.  m <= m
>
>     1. Incomplete:
>          Initial goal:
>          !m. 0 < m ==> ?k. m = SUC k
\end{verbatim}\end{session}
    Our new goal can be proved quite quickly. Once we have proved it,
    we can bind it to an ML name and use it in the previous proof, by
    some sleight of hand with the ``\ml{before}''\footnote{An infix
      version of the {\tt K} combinator, defined by {\tt fun (x before
        y) = x}.} function.
\begin{session}\begin{verbatim}
- e (Cases THEN ARW_TAC []);

> OK..
> val it =
>     Initial goal proved.
>     |- !m. 0 < m ==> ?k. m = SUC k

- val lem = top_thm() before drop();

> OK..
> val lem = |- !m. 0 < m ==> ?k. m = SUC k : Thm.thm
\end{verbatim}\end{session}

Now we can return to the main thread of the proof.  The state of the
current sub-goal of the proof can be displayed using the function
``\ml{p}''.

\begin{session}\begin{verbatim}
- p ();

> val it =
>     m divides FACT m
>     ------------------------------------
>       0.  0 = m - m
>       1.  0 < m
>       2.  m <= m
\end{verbatim}\end{session}
    Now we can use \ml{lem} in the proof. Somewhat opportunistically,
    we will tack on the invocation used in the earlier proof at
    (roughly) the same point, hoping that it will solve the goal:
\begin{session}\begin{verbatim}
- e (`?k. m = SUC k` by
      PROVE_TAC [lem] THEN ARW_TAC [FACT, DIVIDES_RMUL, DIVIDES_REFL]);

> OK..
> Meson search level: ...
>
> Goal proved.   ...
>
> Remaining subgoals:
> val it =
>     m divides FACT n
>     ------------------------------------
>       0.  !n m. (v = n - m) ==> 0 < m /\ m <= n ==> m divides FACT n
>       1.  SUC v = n - m
>       2.  0 < m
>       3.  m <= n
\end{verbatim}\end{session}
    It does! That takes care of the base case. For the induction step,
    things look a bit more difficult than in the earlier proof.
    However, we can make progress by realizing that the hypotheses
    imply that $0 < n$ and so, again by \ml{lem}, we can transform $n$
    into a successor, thus enabling the unfolding of \ml{FACT}, as in
    the previous proof:
\begin{session}\begin{verbatim}
- e (`0 < n` by DECIDE_TAC THEN `?k. n = SUC k` by PROVE_TAC [lem]);

> OK..
> Meson search level: ...
> 1 subgoal:
> val it =
>     m divides FACT n
>     ------------------------------------
>       0.  !n m. (v = n - m) ==> 0 < m /\ m <= n ==> m divides FACT n
>       1.  SUC v = n - m
>       2.  0 < m
>       3.  m <= n
>       4.  0 < n
>       5.  n = SUC k
\end{verbatim}\end{session}
\noindent The proof now finishes in much the same manner as the previous one:
\begin{session}\begin{verbatim}
- e (ARW_TAC [FACT, DIVIDES_LMUL]);

> OK..
>
> Goal proved.  ...
> val it =
>     Initial goal proved.
>     |- !m n. 0 < m /\ m <= n ==> m divides FACT n
\end{verbatim}\end{session}
\noindent We leave the details of stitching the proof together to the interested
reader.

\section{Primality}

Now we move on to establish some facts about the primality of the
first few numbers: $0$ and $1$ are not prime, but $2$ is. Also, all
primes are positive. These are all quite simple to prove.

\begin{description}

\item [\small{({\it NOT\_PRIME\_0\/})}]
\begin{tabular}[t]{l}
\verb+~prime 0+ \\ \hline
\verb+ARW_TAC [prime,DIVIDES_0]+ \\
\end{tabular}

\item [\small{({\it NOT\_PRIME\_1\/})}]
\begin{tabular}[t]{l}
\verb+~prime 1+ \\ \hline
\verb+ARW_TAC [prime]+ \\
\end{tabular}

\item [\small{({\it PRIME\_2\/})}]
\begin{tabular}[t]{l}
\verb+prime 2+ \\ \hline
\verb+ARW_TAC [prime]+ \\
\verb+ THEN PROVE_TAC [DIVIDES_LE, DIVIDES_ZERO,+ \\
\verb+                 DECIDE `~(2=1)`, DECIDE `~(2=0)`,+ \\
\verb+                 DECIDE `x <= 2 = (x=0) \/ (x=1) \/ (x=2)`]+ \\
\end{tabular}

\item [\small{({\it PRIME\_POS\/})}]
\begin{tabular}[t]{l}
\verb+!p. prime p ==> 0<p+ \\ \hline
\verb+Cases THEN ARW_TAC[NOT_PRIME_0]+ \\
\end{tabular}
\end{description}

\section{Existence of prime factors}

Now we are in position to prove a more substantial lemma: every number
other than $1$ has a prime factor. The proof proceeds by a
\emph{complete induction} on $n$. Complete induction is
necessary since a prime factor won't be the predecessor. After
induction, the proof splits into cases on whether $n$ is prime or
not. The first case ($n$ is prime) is
trivial. In the second case, there must be an $x$ that divides $n$, and
$x$ is not $1$ or $n$. By {\small\it DIVIDES\_LE}, $n=0$ or $x \leq n$. If
$n=0$, then $2$ is a prime that divides $0$. On the other hand, if $x \leq
n$, there are two cases: if $x < n$ then we can use the inductive
hypothesis and by transitivity of divides we are done; otherwise,
$x=n$ and then we have a contradiction with the fact that $x$ is not 1
or $n$.  The polished tactic is the following:
\begin{description}
\item [\small{({\it PRIME\_FACTOR\/})}]
\begin{tabular}[t]{l}
\verb+!n. ~(n = 1) ==> ?p. prime p /\ p divides n+ \\ \hline
\verb+completeInduct_on `n`+ \\
\verb+  THEN ARW_TAC []+ \\
\verb+  THEN Cases `prime n` THENL+ \\
\verb+  [PROVE_TAC [DIVIDES_REFL], + \\
\verb+   `?x. x divides n /\ ~(x=1) /\ ~(x=n)` + \\
\verb+    by PROVE_TAC[prime]+ \\
\verb+     THEN PROVE_TAC [LESS_OR_EQ, PRIME_2, +\\
\verb+                  DIVIDES_LE,DIVIDES_TRANS,DIVIDES_0]]+ \\
\end{tabular}
\end{description}
We start by invoking complete induction. This gives us an inductive
hypothesis that holds at every number $m$ strictly smaller than $n$:
\begin{session}\begin{verbatim}
- g `!n. ~(n = 1) ==> ?p. prime p /\ p divides n`;

- e (completeInduct_on `n`);

> OK..
> 1 subgoal:
> val it =
>     ~(n = 1) ==> ?p. prime p /\ p divides n
>     ------------------------------------
>       !m. m < n ==> ~(m = 1) ==> ?p. prime p /\ p divides m
\end{verbatim}\end{session}
We can move the antecedent to the hypotheses and make our case
split. Notice that the term given to \ml{Cases\_on} need not occur in
the goal:
\begin{session}\begin{verbatim}
- e (ARW_TAC [] THEN Cases_on `prime n`);
OK..
2 subgoals:
> val it =
    ?p. prime p /\ p divides n
    ------------------------------------
      0.  !m. m < n ==> ~(m = 1) ==> ?p. prime p /\ p divides m
      1.  ~(n = 1)
      2.  ~prime n

    ?p. prime p /\ p divides nnn
    ------------------------------------
      0.  !m. m < n ==> ~(m = 1) ==> ?p. prime p /\ p divides m
      1.  ~(n = 1)
      2.  prime n
\end{verbatim}\end{session}
\noindent As mentioned, the first case is proved with the reflexivity of
divisibility:
\begin{session}\begin{verbatim}
- e (PROVE_TAC [DIVIDES_REFL]);

> OK..
> Meson search level: ...
>
> Goal proved.  ...
\end{verbatim}\end{session}
\noindent
In the second case, we can get a divisor of $n$ that isn't $1$ or $n$
(since $n$ is not prime):
\begin{session}\begin{verbatim}
- e (`?x. x divides n /\ ~(x=1) /\ ~(x=n)` by PROVE_TAC [prime]);

> OK..
> Meson search level: ............
> 1 subgoal:
> val it =
>     ?p. prime p /\ p divides n
>     ------------------------------------
>       0.  !m. m < n ==> ~(m = 1) ==> ?p. prime p /\ p divides m
>       1.  ~(n = 1)
>       2.  ~prime n
>       3.  x divides n
>       4.  ~(x = 1)
>       5.  ~(x = n)
\end{verbatim}\end{session}
At this point, the polished tactic simply invokes \ml{PROVE\_TAC} with
a collection of theorems. We will attempt a more detailed
exposition. Given the hypotheses, and by {\small\it DIVIDES\_LE}, we can
assert $x < n \lor n = 0$ and thus split the proof into two cases:
\begin{session}\begin{verbatim}
- e (`x < n \/ (n=0)` by PROVE_TAC [DIVIDES_LE,LESS_OR_EQ]);

> OK..
> Meson search level: ......
> 2 subgoals:
> val it =
>     ?p. prime p /\ p divides n
>     ------------------------------------
>       0.  !m. m < n ==> ~(m = 1) ==> ?p. prime p /\ p divides m
>       1.  ~(n = 1)
>       2.  ~prime n
>       3.  x divides n
>       4.  ~(x = 1)
>       5.  ~(x = n)
>       6.  n = 0
>
>     ?p. prime p /\ p divides n
>     ------------------------------------
>       0.  !m. m < n ==> ~(m = 1) ==> ?p. prime p /\ p divides m
>       1.  ~(n = 1)
>       2.  ~prime n
>       3.  x divides n
>       4.  ~(x = 1)
>       5.  ~(x = n)
>       6.  x < n
\end{verbatim}\end{session}
In the first subgoal, we can see that the antecedents of the inductive
hypothesis are met and so $x$ has a prime divisor. We can then use the
transitivity of divisibility to get the fact that this divisor of $x$ is
also a divisor of $n$, thus finishing this branch of the proof:
\begin{session}\begin{verbatim}
- e (PROVE_TAC [DIVIDES_TRANS]);

> OK..
> Meson search level: .........
> Goal proved.
\end{verbatim}\end{session}
\noindent The remaining goal can be clarified by simplification:
\begin{session}\begin{verbatim}
- e (ARW_TAC []);

> OK..
> 1 subgoal:
> val it =
>     ?p. prime p /\ p divides 0
>     ------------------------------------
>       0.  !m. m < 0 ==> ~(m = 1) ==> ?p. prime p /\ p divides m
>       1.  ~(0 = 1)
>       2.  ~prime 0
>       3.  x divides 0
>       4.  ~(x = 1)
>       5.  ~(x = 0)

- DIVIDES_0;

> val it = |- !x. x divides 0 : Thm.thm

- e (ARW_TAC [it]);

> OK..
> 1 subgoal:
> val it =
>     ?p. prime p
>     ------------------------------------
>       0.  !m. m < 0 ==> ~(m = 1) ==> ?p. prime p /\ p divides m
>       1.  ~(0 = 1)
>       2.  ~prime 0
>       3.  x divides 0
>       4.  ~(x = 1)
>       5.  ~(x = 0)
\end{verbatim}\end{session}
The two steps of exploratory simplification have led us to a state where
all we have to do is exhibit a prime. And we already have one to hand:
\begin{session}\begin{verbatim}
- e (PROVE_TAC [PRIME_2]);

> OK..
> Meson search level: ..
>
> Goal proved.   ...
> val it =
>     Initial goal proved.
>     |- !n. ~(n = 1) ==> ?p. prime p /\ p divides n
\end{verbatim}\end{session}
Again, work now needs to be done to compose and perhaps polish a single
tactic from the individual proof steps, but we will not describe
it. Instead we move forward, because our ultimate goal is in reach.

\section{Euclid's theorem}

\noindent{\bf Theorem.} Every number has a prime greater than it.\\
\noindent  {\it Informal proof.} \\
\noindent Suppose the opposite; then there's an $n$
such that all $p$ greater than $n$ are not prime. Consider $\mbox{\tt
FACT}(n) + 1$: it's not equal to 1 so, by {\small{\it PRIME\_FACTOR}},
there's a prime $p$ that divides it. Note that $p$ also divides
$\mbox{\tt FACT}(n)$ because $p \leq n$. By {\small{\it DIVIDES\_ADDL}},
we have $p=1$. But then $p$ is not prime, which is a contradiction. \\
\noindent {\it End of proof}.

A HOL rendition of the proof may be given as follows:
\begin{description}
\item [\small{({\it EUCLID\/})}]
\begin{tabular}[t]{l}
\verb+!n. ?p. n < p /\ prime p+ \\ \hline
\verb+SPOSE_NOT_THEN STRIP_ASSUME_TAC+ \\
\verb!  THEN MP_TAC (SPEC ``FACT n + 1`` PRIME_FACTOR)! \\
\verb+  THEN ARW_TAC [FACT_LESS, DECIDE `~(x=0) = 0<x`]+ \\
\verb+  THEN PROVE_TAC [NOT_PRIME_1, NOT_LESS, PRIME_POS, + \\
\verb+                  DIVIDES_FACT, DIVIDES_ADDL, DIVIDES_ONE]+ \\
\end{tabular}
\end{description}
Let's prise this apart and look at it in some detail. A proof by
contradiction can be started by using the \ml{bossLib} function
\ml{SPOSE\_NOT\_THEN}. With it, one assumes the negation of the
current goal and then uses that in an attempt to prove falsity
(\verb+F+). The assumed negation $\neg(\forall n.\ \exists p.\ n < p
\land \mbox{\tt prime}\ p)$ is simplified a bit into $\exists n.\
\forall p.\ n < p \supset \, \neg \,\mbox{\tt prime}\ p$ and then is
passed to the tactic \ml{STRIP\_ASSUME\_TAC}. This moves its argument
to the assumption list of the goal after eliminating the existential
quantification on $n$.
\begin{session}\begin{verbatim}
- g `!n. ?p. n < p /\ prime p`;

- e (SPOSE_NOT_THEN STRIP_ASSUME_TAC);

> OK..
> 1 subgoal:
> val it =
>     F
>     ------------------------------------
>       !p. n < p ==> ~prime p
\end{verbatim}\end{session}
Thus we have the hypothesis that all $p$ beyond a certain unspecified
$n$ are not prime, and our task is to show that this cannot be. At this
point we take advantage of Euclid's great inspiration and we build an
explicit term from $n$. In the informal proof we are asked to `consider'
the term $\mbox{\tt FACT}\ n + 1$.\footnote{The HOL parser thinks
$\mbox{\tt FACT}\ n + 1$ is equivalent to $(\mbox{\tt FACT}\ n) + 1$.}
This term will have certain properties (\ie, it has a prime factor) that
lead to contradiction. Question: how do we `consider' this term in the
formal HOL proof? Answer: by instantiating a lemma with it and bringing the
lemma into the proof. The lemma and its instantiation are:\footnote{The
function {\tt SPEC} implements the rule of universal specialization.}
\begin{session}\begin{verbatim}
- PRIME_FACTOR;

> val it = |- !n. ~(n = 1) ==> (?p. prime p /\ p divides n) : Thm.thm

- val th = SPEC ``FACT n + 1`` PRIME_FACTOR;

> val th =
>     |- ~(FACT n + 1 = 1) ==> (?p. prime p /\ p divides FACT n + 1)
\end{verbatim}\end{session}
It is evident that the antecedent of \ml{th} can be eliminated. In
\holn{}, one could do this in a so-called {\it forward\/} proof style (by
proving $\vdash \neg(\mbox{\tt FACT}\ n + 1 = 1)$ and then applying {\it
modus ponens}, the result of which can then be used in the proof), or
one could bring \ml{th} into the proof and simplify it {\it in
situ}. We choose the latter approach.
\begin{session}\begin{verbatim}
- e (MP_TAC (SPEC ``FACT n + 1`` PRIME_FACTOR));

> OK..
> 1 subgoal:
> val it =
>     (~(FACT n + 1 = 1) ==> ?p. prime p /\ p divides FACT n + 1) ==> F
>     ------------------------------------
>       !p. n < p ==> ~prime p
\end{verbatim}\end{session}
    The invocation \ml{MP\_TAC} ($\vdash M$) applied to a goal
    $(\Delta, g)$ returns the goal $(\Delta, M \supset g)$. Now we
    simplify:
\begin{session}\begin{verbatim}
- e (ARW_TAC []);

> OK..
> 2 subgoals:
> val it =
>     ~(p divides FACT n + 1)
>     ------------------------------------
>       0.  !p. n < p ==> ~prime p
>       1.  prime p
>
>     ~(FACT n = 0)
>     ------------------------------------
>       !p. n < p ==> ~prime p
\end{verbatim}\end{session}
    We recall that zero is less than every factorial, a fact found in
    \ml{arithmeticTheory} under the name \ml{FACT\_LESS}. Thus we can
    solve the top goal by simplification:
\begin{session}\begin{verbatim}
- e (ARW_TAC [FACT_LESS, DECIDE `!x. ~(x=0) = 0 < x`]);

> OK..
> Goal proved.  ...
\end{verbatim}\end{session}
Notice the `on-the-fly' use of \verb+DECIDE+ to provide an {\it ad hoc\/}
rewrite. Looking at the remaining goal, one might think that our aim, to
prove falsity, has been lost. But this is not so: a goal $\neg
M$ is equivalent to $M \supset \mbox{\tt F}$. We can quickly proceed to
show that $p \ \mbox{\tt divides}\ (\mbox{\tt FACT}\ n)$, and thus that
$p = 1$, hence that $p$ is not prime, at which point we are done. This
can all be packaged into a single invocation of \ml{PROVE\_TAC}:
\begin{session}\begin{verbatim}
- e (PROVE_TAC [PRIME_POS, NOT_LESS, DIVIDES_FACT,
                DIVIDES_ADDL, DIVIDES_ONE, NOT_PRIME_1]);
> OK..
> Meson search level: ............
>
> Goal proved.
>  [..] |- ~(p divides FACT n + 1)
>
> Goal proved.
>  [.]
> |- (~(FACT n + 1 = 1) ==> ?p. prime p /\ p divides FACT n + 1) ==> F
>
> Goal proved.
>  [.] |- F
> val it =
>     Initial goal proved.
>     |- !n. ?p. n < p /\ prime p
\end{verbatim}\end{session}
    Euclid's theorem is now proved, and we can rest. However, this
    presentation of the final proof will be unsatisfactory to some,
    because the proof is completely hidden in the invocation of the
    automated reasoner. Well then, let's try another proof, this time
    employing the so-called `assertional' style. When used uniformly,
    this can allow a readable linear presentation that mirrors the
    informal proof. The following proves Euclid's theorem in the
    assertional style. We think it is fairly readable, certainly much
    more so than the standard tactic proof just given.\footnote{Note
      that {\tt CCONTR\_TAC}, which is used to start the proof,
      initiates a proof by contradiction by negating the goal and
      placing it on the hypotheses, leaving {\tt F} as the new goal.}

\begin{description}
\item [\small{({\it AGAIN\/})}]
\begin{tabular}[t]{l}
\verb+!n. ?p. n < p /\ prime p+ \\ \hline
\verb|CCONTR_TAC THEN | \\
\verb|`?n. !p. n < p ==> ~prime p`  by PROVE_TAC []             THEN| \\
\verb|`~(FACT n + 1 = 1)`           by ARW_TAC [FACT_LESS,| \\
\verb|                                      DECIDE`~(x=0)=0<x`] THEN| \\
\verb|`?p. prime p /\  | \\
\verb|     p divides (FACT n + 1)`  by PROVE_TAC [PRIME_FACTOR] THEN| \\
\verb|`0 < p`                       by PROVE_TAC [PRIME_POS]    THEN| \\
\verb|`p <= n`                      by PROVE_TAC [NOT_LESS]     THEN| \\
\verb|`p divides FACT n`            by PROVE_TAC [DIVIDES_FACT] THEN| \\
\verb|`p divides 1`                 by PROVE_TAC [DIVIDES_ADDL] THEN| \\
\verb|`p = 1`                       by PROVE_TAC [DIVIDES_ONE]  THEN| \\
\verb|`~prime p`                    by PROVE_TAC [NOT_PRIME_1]  THEN| \\
\verb|PROVE_TAC []| \\
\end{tabular}
\end{description}

\section{Turning the script into a theory}
\label{sec:script-to-theory}

Having proved our result, we probably want to package it up in a way
that makes it available to future sessions, but which doesn't require
us to go all through the theorem-proving effort again.  Even having a
complete script from which it would be possible to cut-and-paste is an
error-prone solution.

In order to do this we need to create a file with the name
$x$\ml{Script.sml}, where $x$ is the name of the theory we wish to
export.  This file then needs to be compiled.  In fact, we really do
use the Moscow ML compiler, carefully augmented with the appropriate
logical context.  However, the language accepted by the compiler is
not quite the same as that accepted by the interactive system, so we
will need to do a little work to massage the original script into the
correct form.

We'll give an illustration of converting to a form that can be
compiled using the script
\[
  \mbox{\ml{<holdir>/examples/euclid.sml}}
\] as our base-line.  This
file is already close to being in the right form.  It has all of the
proofs of the theorems in ``sewn-up'' form so that when run, it does
not involve the goal-stack at all.  In its given form, it can be run
as input to \textsf{hol.unquote} thus:

\setcounter{sessioncount}{0}
\begin{session}
\begin{verbatim}
$ cd examples/
$ ../bin/hol.unquote < euclid.sml
Moscow ML version 1.44 (August 1999)
Enter `quit();' to quit.
For HOL help, type: help "hol";
  ...

> val EUCLID_AGAIN = |- !n. ?p. n < p /\ prime p : Thm.thm
- Theory: scratch
  ...

Theorems:
    DIVIDES_0 |- !x. x divides 0
    DIVIDES_ZERO |- !x. 0 divides x = x = 0
    DIVIDES_ONE |- !x. x divides 1 = x = 1
  ...
    PRIME_POS |- !p. prime p ==> 0 < p
    PRIME_FACTOR |- !n. ~(n = 1) ==> ?p. prime p /\ p divides n
    EUCLID |- !n. ?p. n < p /\ prime p

Theory "scratch" is inconsistent with disk.
-
\end{verbatim}
\end{session}

However, we now want to create a \ml{euclidTheory} that we can load in
other interactive sessions.  So, our first step is to create a file
\ml{euclidScript.sml}, and to copy the body of \ml{euclid.sml} into
it.

The first non-comment line opens \ml{arithmeticTheory}.  However, when
writing for the compiler, we need to explicitly mention the other
\HOL{} modules that we depend on.  We must add
\[
\mbox{\ml{open HolKernel boolLib Parse bossLib}}
\]
Further, while \textsf{hol} (and \textsf{hol.unquote}) know that
\ml{THEN} and \ml{THENL} are infixes, the compiler doesn't, so we must
also add
\[
\mbox{\ml{infix THEN THENL}}
\]
Similarly, we need to specify that \ml{by} is a tightly binding
infix.  \[
\ml{infix 8 by}
\]
The next line that poses a difficulty is
\[
  \mbox{\ml{set\_fixity "divides" (Infixr 450);}}
\]
While it is legitimate to type expressions directly into the
interactive system, the compiler requires that every top-level phrase
be a declaration.  We satisfy this requirement by altering this line
into a ``do nothing'' declaration that does not record the result of
the expression:
\[
\mbox{\ml{val \_{} = set\_fixity "divides" (Infixr 450)}}
\]
The only extra changes are to bracket the rest of the script file text
with calls to \ml{new\_theory} and \ml{export\_theory}.  So,
before the definition of \ml{divides}, we add:
\[
\mbox{\ml{val \_{} = new\_theory "euclid";}}
\]
and at the end of the file:
\[
\mbox{\ml{val \_{} = export\_theory();}}
\]

Now, we can compile the script we have created using the
\textsf{Holmake} tool.  To keep things a little tidier, we first move
our script into a new directory.

\begin{session}
\begin{verbatim}
$ mkdir euclid
$ mv euclidScript.sml euclid
$ cd euclid
$ ../../bin/Holmake
Analysing euclidScript.sml
Trying to create directory .HOLMK for dependency files
Compiling euclidScript.sml
Linking euclidScript.uo to produce theory building executable
<<HOL message: inventing new type variable names: 'a, 'b.>>
<<HOL message: Created theory "euclid".>>
Definition stored under "divides_def".
Definition stored under "prime_def".
Meson search level: .....
Meson search level: .................
 ...
Theory "euclid" is inconsistent with disk.
Exporting theory ... done.
Analysing euclidTheory.sml
Analysing euclidTheory.sig
Compiling euclidTheory.sig
Compiling euclidTheory.sml
\end{verbatim}
\end{session}

Now we have created four new files, various forms of \ml{euclidTheory}
with four different suffixes.  Only \ml{euclidTheory.sig} is really
suitable for human consumption.  While still in the \ml{euclid}
directory that we created, we can demonstrate:

\begin{session}
\begin{alltt}
\$ ../../bin/hol.unquote
[...]

[closing file "/local/scratch/mn200/Work/hol98/tools/end-init.sml"]
- load "euclidTheory";
> val it = () : unit
- open euclidTheory;
> type thm = Thm.thm
  val DIVIDES_TRANS =
    |- !a b c. a divides b /\ b divides c ==> a divides c
    : Thm.thm
  ...
  val DIVIDES_REFL = |- !x. x divides x : Thm.thm
  val DIVIDES_0 = |- !x. x divides 0 : Thm.thm
\end{alltt}
\end{session}

\section{Summary}

The reader has now seen an interesting theorem proved, in great detail,
in \holn{}. The discussion illustrated the high-level tools provided in
\ml{bossLib} and touched on issues including tool selection, undo,
`tactic polishing', exploratory simplification, and the `forking-off' of
new proof attempts. We also attempted to give a flavour of the thought
processes a user would employ. Following is a more-or-less random
collection of other observations.
\begin{itemize}

\item Even though the proof of Euclid's theorem is short and easy to
understand when presented informally, a perhaps surprising amount of
support development was required to set the stage for Euclid's classic
argument.

\item The proof support offered by \ml{bossLib}
(\verb+RW_TAC+, \ml{PROVE\_TAC}, \ml{DECIDE\_TAC}, \ml{DECIDE},
\ml{Cases\_on}, \ml{Induct\_on}, and the ``\ml{by}'' construct) was
nearly complete for this example: it was rarely necessary to resort to
lower-level tactics.

\item Simplification is a workhorse tactic; even when an automated
reasoner like \ml{PROVE\_TAC} is used, its application has often been
set up by some exploratory simplifications. It therefore pays to become
familiar with the strengths and weaknesses of the simplifier.

\item A common problem with interactive proof systems is dealing with
hypotheses. Often \ml{PROVE\_TAC} and the ``\ml{by}'' construct allow
the use of hypotheses without directly resorting to indexing into them
(or naming them, which amounts to the same thing). This is desirable,
since the hypotheses are notionally a {\it set}, and moreover,
experience has shown that profligate indexing into hypotheses results in
hard-to-maintain proof scripts. However, it can be clumsy to work with a
large set of hypotheses, in which case the following approaches may be
useful.

One can directly refer to hypotheses by using \ml{UNDISCH\_TAC} (makes
the designated hypothesis the antecedent to the goal),
\ml{ASSUM\_LIST} (gives the entire hypothesis list to a tactic),
\ml{POP\_ASSUM} (gives the top hypothesis to a tactic), and
\ml{PAT\_ASSUM} (gives the first {\it matching\/} hypothesis to a
tactic). (See the \REFERENCE{} for further details on all of these.)
The numbers attached to hypotheses by the proof manager could likely
be used to access hypotheses (it would be quite simple to write such a
tactic). However, starting a new proof is sometimes the most
clarifying thing to do.

In some cases, it is useful to be able to delete a hypothesis. This can
be accomplished by passing the hypothesis to a tactic that ignores
it. For example, to discard the top hypothesis, one could invoke
\ml{POP\_ASSUM (K ALL\_TAC)}.

\item In the example, we didn't use the more advanced features of
\ml{bossLib}, largely because they do not, as yet, provide much more
functionality than the simple sequencing of simplification, decision
procedures, and automated first order reasoning. The \ml{THEN}
tactical has thus served as an adequate replacement. In the future,
these entrypoints should become more powerful.

\item It is almost always necessary to have an idea of the {\it
    informal\/} proof in order to be successful when doing a formal
  proof. However, all too often the following strategy is adopted by
  novices: (1) rewrite the goal with a few relevant definitions, and
  then (2) rely on the syntax of the resulting goal to guide
  subsequent tactic selection. Such an approach constitutes a clear
  case of the tail wagging the dog, and is a poor strategy to adopt.
  Insight into the high-level structure of the proof is one of the
  most important factors in successful verification exercises.

The author has noticed that many of the most successful verification
experts work using a sheet of paper to keep track of the main steps that
need to be made. Perhaps looking away to the paper helps break the
mesmerizing effect of the computer screen.

On the other hand, one of the advantages of having a mechanized logic
is that the machine can be used as a formal expression calculator,
and thus the user can use it to quickly and accurately explore various
proof possibilities.
\item High powered tools like \ml{PROVE\_TAC}, \ml{DECIDE\_TAC}, and
\ml{RW\_TAC} are the principal way of advancing a proof in
\ml{bossLib}. In many cases, they do exactly what is desired, or even
manage to surprise the user with their power. In the formalization of
Euclid's theorem, the tools performed fairly well. However, sometimes
they are overly aggressive, or they simply flounder. In such cases, more
specialized proof tools need to be used, or even written, and hence the
support underlying \ml{bossLib} must eventually be learned.

\item Having a good knowledge of the available lemmas, and where they
are located, is an essential part of being successful. Often powerful
tools can replace lemmas in a restricted domain, but in general, one has
to know what has already been proved. We have found that the entrypoints
in \verb+DB+ help in quickly finding lemmas.

\end{itemize}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "tutorial"
%%% End:
