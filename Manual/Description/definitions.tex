\chapter{Advanced Definition Principles}\label{HOLdefinitions}

\section{Datatype Definition}
\index{type definitions, in HOL logic@type definitions, in \HOL{} logic!algebraic types}

There are several useful consequences of an object logic datatype
definition: structural induction, rewrite rules for constructors,
\etc\ However, these have not traditionally been automatically derived
at the invocation of the definition package: the user would have to
build the required theorems by explicitly invoking various proof
procedures.  The \verb+Hol_datatype+ function supports the definition of
concrete data types; the specifications of the types may be recursive, mutually
recursive, nested recursive, and involve records.  The syntax
of declarations that \verb+Hol_datatype+ accepts is found in Table
\ref{datatype}.

\newcommand{\ident}      {\mbox{\it ident}}
\newcommand{\clause}      {\mbox{\it clause}}
\newcommand{\type}       {\mbox{\it hol\_type}}
{
\newcommand{\binding} {\mbox{\it binding}}
\newcommand{\recdspec}  {\mbox{\it record-spec}}
\newcommand{\constr} {\mbox{\it constructor-spec}}

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|rcl|}
\hline
\multicolumn{3}{|l|}
{\texttt{Hol\_datatype `}[\binding\ \texttt{;}]* \binding\texttt{`}}\\
& &\\
\binding & \verb+::=+ & \ident\ \verb+=+ \constr\\
         & \verb+|+ & \ident\ \verb+=+ \recdspec\\
& & \\
\constr & \verb+::=+ & [\clause\ \verb+|+]* \clause \\
& & \\
\clause & \verb+::=+ & \ident \\
        & \verb+|+ & \ident\ \verb+of+\ [\type\ \verb+=>+]* \type\\
& & \\
\recdspec & \verb+::=+ & \verb+<|+ [\ident\ \verb+:+ \type\ \verb+;+]*
                                   \ident\ \verb+:+ \type\ \verb+|>+\\

\hline
\end{tabular}
\caption{Datatype Declaration}\label{datatype}
\end{center}
\end{table}
}

% Many formalizations require the definition of new types.  For
% example, ML-style datatypes are commonly used to model the abstract
% syntax of programming languages and the state-space of elaborate
% transition systems.  In HOL, such datatypes (at least, those that are
% inductive, or, alternatively, have a model in an initial algebra) may be
% specified using the invocation {Hol_datatype `<spec>`}, where
% {<spec>} should conform to the following grammar:
% {
%    spec    ::= [ <binding> ; ]* <binding>
%
%    binding ::= <ident> = [ <clause> | ]* <clause>
%             |  <ident> = <| [ <ident> : <type> ; ]* <ident> : <type> |>
%
%    clause  ::= <ident>
%             |  <ident> of [<type> => ]* <type>
% }
% When a datatype is successfully defined, a number of standard theorems
% are automatically proved about the new type: the constructors of the type
% are proved to be injective and disjoint, induction and case analysis
% theorems are proved, and each type also has a `size' function defined
% for it. All these theorems are stored in the current theory and added to
% a database accessed via the functions in {TypeBase}.
%
% The notation used to declare datatypes is, unfortunately, not the same
% as that of ML. For example, an ML declaration
% {
%    datatype ('a,'b) btree = Leaf of 'a
%                           | Node of ('a,'b) btree * 'b * ('a,'b) btree
% }
% would most likely be declared in HOL as
% {
%    Hol_datatype `btree = Leaf of 'a
%                        | Node of btree => 'b => btree`
% }
% The {=>} notation in a HOL datatype description is intended to replace
% {*} in an ML datatype description, and highlights the fact that, in
% HOL, constructors are by default curried.  Note also that any type
% parameters for the new type are not allowed; they are inferred (in an
% arbitrary order) from the right hand side of the binding.
%
% When a record type is defined, the parser is adjusted to allow new
% syntax (appropriate for records), and a number of useful
% simplification theorems are also proved.  The most useful of the
% latter are automatically stored in the {TypeBase} and can be inspected
% using the {simpls_of} function.  For further details on record types,
% see the DESCRIPTION.
%
% \EXAMPLE
% In the following, we shall give an overview of the kinds of types that
% may be defined by {Hol_datatype}.
%
% To start, enumerated types can be defined as in the following example:
% {
%    Hol_datatype `enum = A1  | A2  | A3  | A4  | A5
%                       | A6  | A7  | A8  | A9  | A10
%                       | A11 | A12 | A13 | A14 | A15
%                       | A16 | A17 | A18 | A19 | A20
%                       | A21 | A22 | A23 | A24 | A25
%                       | A26 | A27 | A28 | A29 | A30`
%
% }
% Other non-recursive types may be defined as well:
% {
%    Hol_datatype `foo = N of num
%                      | B of bool
%                      | Fn of 'a -> 'b
%                      | Pr of 'a # 'b`
% }
% Turning to recursive types, we can define a type of binary trees
% where the leaves are numbers.
% {
%     - Hol_datatype `tree = Leaf of num
%                          | Node of tree => tree`
% }
% We have already seen a type of binary trees having polymorphic
% values at internal nodes. This time, we will declare it in "paired" format.
% {
%     Hol_datatype `tree = Leaf of 'a
%                        | Node of tree # 'b # tree`
% }
% This specification seems closer to the declaration that one might make
% in ML, but is more difficult to deal with in proof than the curried format
% used above.
%
% The basic syntax of the named lambda calculus is easy to describe:
% {
%     - load "stringTheory";
%     > val it = () : unit
%
%     - Hol_datatype `lambda = Var of string
%                            | Const of 'a
%                            | Comb of lambda => lambda
%                            | Abs of lambda => lambda`
% }
% The syntax for `de Bruijn' terms is roughly similar:
% {
%    Hol_datatype `dB = Var of string
%                     | Const of 'a
%                     | Bound of num
%                     | Comb  of dB => dB
%                     | Abs   of dB`
% }
% Arbitrarily branching trees may be defined by allowing a node to hold
% the list of its subtrees. In such a case, leaf nodes do not need to be
% explicitly declared.
% {
%    Hol_datatype `ntree = Node of 'a => ntree list`
% }
% A type of `first order terms' can be declared as follows:
% {
%    Hol_datatype `term = Var of string
%                       | Fnapp of string # term list`
% }
% Mutally recursive types may also be defined. The following, extracted by
% Elsa Gunter from the Definition of Standard ML, captures a subset of
% Core ML.
% {
%    Hol_datatype
%         `atexp = var_exp of string
%                | let_exp of dec => exp ;
%
%            exp = aexp    of atexp
%                | app_exp of exp => atexp
%                | fn_exp  of match ;
%
%          match = match  of rule
%                | matchl of rule => match ;
%
%           rule = rule of pat => exp ;
%
%            dec = val_dec   of valbind
%                | local_dec of dec => dec
%                | seq_dec   of dec => dec ;
%
%        valbind = bind  of pat => exp
%                | bindl of pat => exp => valbind
%                | rec_bind of valbind ;
%
%            pat = wild_pat
%                | var_pat of string`
% }
% Simple record types may be introduced using the {<| ... |>} notation.
% {
%     Hol_datatype `state = <| Reg1 : num; Reg2 : num; Waiting : bool |>`
% }
% The use of record types may be recursive. For example, the following
% declaration could be used to formalize a simple file system.
% {
%    Hol_datatype
%         `file = Text of string
%               | Dir of directory
%           ;
%     directory = <| owner : string ;
%                    files : (string # file) list |>`
% }
%
% \FAILURE
% Now we address some types that cannot be declared with {Hol_datatype}.
% In some cases they cannot exist in HOL at all; in others, the type
% can be built in the HOL logic, but {Hol_datatype} is not able to make
% the definition.
%
% First, an empty type is not allowed in HOL, so the following attempt
% is doomed to fail.
% {
%    Hol_datatype `foo = A of foo`
% }
% So called `nested types', which are occasionally quite useful, cannot
% at present be built with {Hol_datatype}:
% {
%    Hol_datatype `btree = Leaf of 'a
%                        | Node of  ('a # 'a) btree`
% }
% Co-inductive types may not currently be built with {Hol_datatype}:
% {
%    Hol_datatype `lazylist = Nil
%                           | Cons of 'a # (one -> lazylist)`
% }
% This type can however be built in HOL: see {llistTheory}.
%
% Finally, for cardinality reasons, HOL does not allow the following attempt
% to model the untyped lambda calculus as a set (note the {->} in the clause
% for the {Abs} constructor):
% {
%     Hol_datatype `lambda = Var of string
%                          | Const of 'a
%                          | Comb of lambda => lambda
%                          | Abs of lambda -> lambda`
% }
% Instead, one would have to build a theory of complete partial orders
% (or something similar) with which to model the untyped lambda calculus.
%
% \COMMENTS
% The consequences of an invocation of {Hol_datatype} are stored in the
% current theory segment and in {TypeBase}. The principal consequences
% of a datatype definition are the primitive recursion and induction theorems.
% These provide the ability to define simple functions over the type, and
% an induction principle for the type. For a type named {ty},
% the primitive recursion theorem is stored under {ty_Axiom} and
% the induction theorem is put under {ty_induction}. Other
% consequences include the distinctness of constructors ({ty_distinct}),
% and the injectivity of constructors ({ty_11}). A `degenerate' version of
% {ty_induction} is also stored under {ty_nchotomy}: it provides for reasoning
% by cases on the construction of elements of {ty}. Finally, some
% special-purpose theorems are stored : {ty_case_cong} gives a congruence
% theorem for "case" statements on elements of {ty}. These case statements
% are introduced by {ty_case_def}. Also, a definition of the "size" of the type
% is added to the current theory, under the name {ty_size_def}.
%
% For example, invoking
% {
%    Hol_datatype `tree = Leaf of num
%                       | Node of tree => tree`;
% }
% results in the definitions
% {
%    tree_case_def =
%      |- (!f f1 a. case f f1 (Leaf a) = f a) /\
%          !f f1 a0 a1. case f f1 (Node a0 a1) = f1 a0 a1
%
%    tree_size_def
%      |- (!a. tree_size (Leaf a) = 1 + a) /\
%          !a0 a1. tree_size (Node a0 a1) = 1 + (tree_size a0 + tree_size a1)
% }
% being added to the current theory. The following theorems about the datatype
% are also stored in the current theory.
% {
%    tree_Axiom
%      |- !f0 f1.
%           ?fn. (!a. fn (Leaf a) = f0 a) /\
%                !a0 a1. fn (Node a0 a1) = f1 a0 a1 (fn a0) (fn a1)
%
%    tree_induction
%      |- !P. (!n. P (Leaf n)) /\
%             (!t t0. P t /\ P t0 ==> P (Node t t0))
%             ==>
%             !t. P t
%
%    tree_nchotomy  |- !t. (?n. t = Leaf n) \/ ?t' t0. t = Node t' t0
%
%    tree_11
%      |- (!a a'. (Leaf a = Leaf a') = (a = a')) /\
%          !a0 a1 a0' a1'. (Node a0 a1 = Node a0' a1') = (a0=a0') /\ (a1=a1')
%
%    tree_distinct  |- !a1 a0 a. ~(Leaf a = Node a0 a1)
%
%    tree_case_cong
%      |- !M M' f f1.
%           (M = M') /\
%           (!a. (M' = Leaf a) ==> (f a = f' a)) /\
%           (!a0 a1. (M' = Node a0 a1) ==> (f1 a0 a1 = f1' a0 a1))
%           ==>
%           (case f f1 M = case f' f1' M')
% }
% When a type involving records is defined, many more definitions are
% made and added to the current theory.
%
% A definition of mutually recursives types results in the above theorems and
% definitions being added for each of the defined types.

\index{type definitions, in HOL logic@type definitions, in \HOL{} logic!maintenance of TypeBase@maintenance of \ml{TypeBase}}
\index{TypeBase@\ml{TypeBase}}
%
\HOL{} maintains an underlying database of datatype facts called the
\ml{TypeBase}.  This database is used to support various high-level
proof tools (see Section~\ref{sec:bossLib}), and is augmented whenever
a \verb+Hol_datatype+ declaration is made.  When the \HOL{} system
starts up, the \ml{TypeBase} already contains the relevant entries for
the types \holtxt{bool}, \holtxt{prod}, \holtxt{num}, \holtxt{option},
and \holtxt{list}.  When a datatype is defined by \verb+Hol_datatype+,
the following information is derived and stored in the database.

\begin{itemize}
\item initiality theorem for the type
\item injectivity of the constructors
\item distinctness of the constructors
\item structural induction theorem
\item case analysis theorem
\item definition of the `case' constant for the type
\item congruence theorem for the case constant
\item definition of the `size' of the type
\end{itemize}

The \texttt{Hol\_datatype} function can be used to define types that
are parametrically polymorphic.  For example, the type of lists is
defined as
\begin{hol}
\begin{verbatim}
   Hol_datatype `list = NIL | CONS of 'a => list`;
\end{verbatim}
\end{hol}
\noindent Although the new \texttt{list} type is polymorphic, the
specification passed to \texttt{Hol\_datatype} does not explicitly
provide arguments for the new operator.  Contrast with SML, where one
would write
\begin{hol}
\begin{verbatim}
   datatype 'a list = nil | cons of 'a * 'a list
\end{verbatim}
\end{hol}
\noindent In \HOL{} neither occurrence of the new operator has its
arguments provided.  When defining a type that is polymorphic in more
than one argument, this raises the question of what the order of the
new operator's arguments will be.  For example, if one defines
\begin{hol}
\begin{verbatim}
   Hol_datatype `sum = Left of 'left | Right of 'right`;
\end{verbatim}
\end{hol}
%
and then writes \ml{('a,'b)sum}, will the \ml{'a} value be under the
\ml{Left} or \ml{Right} constructor?  The system chooses to make the
arguments corresponding to variables appear in the order given by the
dictionary ordering of the variables' names.  Thus, in the example
given, the \ml{'a} of \ml{('a,'b)sum} will be the \ml{Left} argument
because \ml{left} comes before \ml{right} in the standard (ASCII)
dictionary ordering.

\section{Record Types}
\index{type definitions, in HOL logic@type definitions, in \HOL{} logic!record types}

Record types are convenient ways of bundling together a number of
component types, and giving those components names so as to facilitate
access to them.  Record types are semantically equivalent to big pair
(product) types, but the ability to label the fields with names of
one's own choosing is a great convenience.  Record types as
implemented in \HOL{} are similar to C's \texttt{struct} types and to
Pascal's records.

Done correctly, record types provide useful maintainability features.
If one can always access the {\tt fieldn} field of a record type by
simply writing {\tt record.fieldn}, then changes to the type that
result in the addition or deletion of other fields will not invalidate
this reference.  One failing in SML's record types is that they do not
allow the same maintainability as far as (functional) updates of
records are concerned.  The HOL implementation allows one to write
\begin{verbatim}
  rec with fieldn := new_value
\end{verbatim}
which replaces the old value of {\tt fieldn} in the record {\tt rec}
with {\tt new\_value}.  This expression will not need to be changed if
another field is added, modified or deleted from the record's original
definition.

\paragraph{Defining a record type}
Record types are defined with the function \texttt{Hol\_datatype}, as
previously discussed.  For example, to create a record type called
{\tt person} with boolean, string and number fields called {\tt
  employed}, {\tt name} and {\tt age}, one would enter:
\begin{verbatim}
val _ = Hol_datatype `person = <| employed : bool ; age : num ;
                                  name : string
                               |>`;
\end{verbatim}
The order in which the fields are entered is not significant. As well
as defining the type (called {\tt person}), the datatype definition
function also defines two other sets of constants.  These are the
field access functions and functional update functions.  The field
access functions have names of the form
``$\langle$\textsl{record-type\/}$\rangle$\verb|_|$\langle$\textsl{field\/}$\rangle$''.
These functions can be used directly, or one can use standard field
selection notation to access the values of a record's field.  Thus,
one would write the expression: \mbox{\tt ``bob.employed``} in order
to return the value of {\tt bob}'s {\tt employed} field.  The
alternative, \texttt{``person\_employed bob``}, works, but would be
printed using the first syntax, with the full-stop.

The functional update functions are given the names
\mbox{``$\langle$\textsl{record-type}$\rangle$\texttt{\_}%
  $\langle$\textsl{field}$\rangle$\texttt{\_fupd}''} for each field in
the type.  They take two arguments, a function and a record to be
updated.  The function parameter is an endomorphism on the field type,
so that the resulting record is the same as the original, except that
the specified field has had the given function applied to it to
generate the new value for that field.  They can be written with the
keyword \texttt{with} and the \texttt{updated\_by} operator.  Thus
\begin{alltt}
  ``bob with employed updated_by \$~``
\end{alltt} \noindent
is a record value identical to the \texttt{bob} except that the
boolean value in the \texttt{employed} field has been inverted.

Additionally, there is syntactic sugar available to let one write a
record with one of its fields replaced by a specific value.  This is
done by using the \texttt{:=} operator instead of
\texttt{updated\_by}:
\begin{verbatim}
  ``bob with employed := T``
\end{verbatim}
This form is translated at parse-time to be a use of the corresponding
functional update, along with a use of the \textsf{K}-combinator from
the \texttt{combin} theory.  Thus, the above example  is really
\begin{verbatim}
  ``bob with employed updated_by (K T)``
\end{verbatim}
which is in turn a pretty form of
\begin{verbatim}
  ``person_employed_fupd (K T) bob``
\end{verbatim}
If a chain of updates is desired, then multiple updates can be
specified inside \texttt{<|}-\texttt{|>} pairs, separated by
semi-colons, thus:

\begin{verbatim}
  ``bob with <| age := 10; name := "Child labourer" |>``
\end{verbatim}
Both update forms (using \texttt{updated\_by} and \texttt{:=}) can be
used in a chain of updates.

\paragraph{Specifying record literals}

The parser accepts lists of field specifications between
\texttt{<|}-\texttt{|>} pairs without the \texttt{with} keyword.
These translate to sequences of updates of an arbitrary value
(literally, the HOL value \texttt{ARB}), and are treated as literals.
Thus,
\begin{verbatim}
  ``<| age := 21; employed := F; name := "Layabout" |>``
\end{verbatim}

\paragraph{Using the theorems produced by record definition}

As well as defining the type and the functions described above, record
type definition also proves a suite of useful theorems.  These are all
are saved (using {\tt save\_thm}) in the current segment.  %
%
\index{TypeBase@\ml{TypeBase}}
%
Some are also added to the \ml{TypeBase}'s simplifications for the
type, so they will be automatically applied when simplifying with the
\ml{srw\_ss()} simpset, or with the tactics \ml{RW\_TAC} and
\ml{SRW\_TAC} (see Section~\ref{sec:simpLib}).

All of the theorems are saved under names that begin with the name of
the type.  The list below is a sample of the theorems proved.  The
identifying strings are suffixes appended to the name of the type in
order to generate the final name of the theorem.

\newcommand{\rewruse}{This theorem is installed in the \texttt{TypeBase}.}
\newcommand{\field}[1]{\mbox{\it field}_{#1}}
\newcommand{\update}{\mbox{\tt\_fupd}}

\begin{description}
\item[\texttt{\_accessors}] The definitions of the accessor functions.
  \rewruse
\item[\texttt{\_fn\_updates}] The definitions of the functional update
  functions.
\item[\texttt{\_accfupds}] A theorem stating simpler forms for
  expressions of the form $\field{i}\, (\field{j}\update\;f\; r)$.  If
  $i = j$, then the RHS is $f (\field{i}(r))$, if not, it is $(\field{i}\;r)$.
  \rewruse
\item[\texttt{\_component\_equality}] A theorem stating that $(r_1 =
  r_2) \equiv \bigwedge_i (\field{i}(r_1) = \field{i}(r_2))$.
\item[\texttt{\_fupdfupds}] A thereom stating that $\field{i}\update
  \;f \,(\field{i}\update \;g\;r) = \field{i}\update\;(f \circ g)\;r$.
  \rewruse
\item[\texttt{\_fupdcanon}] A theorem that states commutativity results
  for all possible pairs of field updates.  They are constructed in
  such a way that if used as rewrites, they will canonicalise
  sequences of updates. Thus, for all $i < j$, \[
  \field{j}\update\;f\;(\field{i}\update\;g\;r) =
  \field{i}\update\;g\;(\field{j}\update\;f\;r)
  \] is generated.
 \rewruse
\end{description}

\paragraph{``Big'' records} The size of certain theorems proved in the
record type package increases as the square of the number of fields in
the record.  (In particular, the update canonicalisation and
\texttt{acc\_fupd} theorems have this property.) To avoid inefficiency
with big records, the implementation of record types uses a more
efficient underlying representation when the number of fields grows
too large.  The exact point at which this optimisation is applied is
controlled by the reference variable
\texttt{Datatype.big\_record\_size}.  This value is initialised to 20,
but users can change it as they choose.

Unfortunately, the big record representation has the drawback that
every update and accessor function has two forms: different terms that
are printed the same.  One form is a simple constant, and is the form
produced when a term is parsed.  The other is more complicated, but
allows for the use of smaller theorems when record values are
simplified.  Therefore, it is recommended that new, user-proved
theorems that mention big records' fields or field updates be passed
through a phase of simplification (\texttt{SIMP\_RULE}), applying the
\texttt{TypeBase}'s rewrites, before they are saved.

The pretty-printing of big records can be controlled with the
\texttt{pp\_bigrecs} trace-flag.


\section{Quotient Type Definition}\label{quotients}
\index{type definitions, in HOL logic@type definitions, in \HOL{} logic!quotients|(}
\index{quotient types, definition of}

\HOL{} provides a library for defining new types which are quotients
of existing types, with respect to partial equivalence relations.
This library is described in {\it ``Higher Order Quotients in Higher
Order Logic''} [HOQ], from which the following description is taken.

The quotient library is accessed by opening {\tt quotientLib},
which makes all its tools and theorems accessable.

The definition of new types corresponding to the quotients of
existing types by equivalence relations is called ``lifting''
the types from a lower, more representational level to a higher,
more abstract level.  Both levels describe similar objects, but
some details which are apparent at the lower level are no longer
visible at the higher level.  The logic is simplified.

However, simply forming a new type does not complete the quotient operation.
Rather, one wishes to recreate the
%significant parts of the
pre-existing logical environment at the new,
higher, and more abstract level.  This includes not only the new
types, but also new versions of the constants that form and
manipulate values of those types, and also new versions of the
theorems that describe properties of those constants.  All of these
%must be recreated at the higher level, in order to
form a logical layer, above which all the lower representational details
may be safely and forever forgotten.

This can be done in a single call of the
main tool of this package.

\begin{verbatim}
define_quotient_types :
        {types: {name: string,
                 equiv: thm} list,
         defs: {def_name: string,
                fname: string,
                func: Term.term,
                fixity: Parse.fixity} list,
         tyop_equivs : thm list,
         tyop_quotients : thm list,
         tyop_simps : thm list,
         respects : thm list,
         poly_preserves : thm list,
         poly_respects : thm list,
         old_thms : thm list} ->
        thm list
\end{verbatim}

{\tt define\_quotient\_types} takes a single argument which is a
record with the following fields.

{\it types\/} is a list of records, each of which contains two fields:
{\it name}, which is the name of a new quotient type to be created, and
{\it equiv}, which is
either 1)
a theorem that a binary relation {\it R\/}
is an equivalence relation
(see [HOQ] \S 4)
of the form
$$
\mbox{\tt |-}\
\forall x\ y.\ R\ x\ y \ \Leftrightarrow \
                (R\ x = R\ y),
$$
or 2)
a theorem that {\it R\/} is a nonempty partial equivalence relation,
(see [HOQ] \S 5)
of the form
$$
\mbox{\tt |-}\
(\exists x.\ R\ x\ x) \ \wedge \
(\forall x\ y.\ R\ x\ y \ \Leftrightarrow \
                R\ x\ x \wedge R\ y\ y \wedge (R\ x = R\ y)).
$$
The process of forming the new quotient types is described
in [HOQ] \S 8.

{\it defs\/} is a list of records specifying the constants to be lifted.
Each record contains the following four fields:
{\it func\/} is an HOL term, which must be a single constant, which is the
constant to be lifted.
{\it fname\/} is the name of the new constant being defined as the lifted version of {\it func}.
{\it fixity\/} is the HOL fixity of the new constant being created,
as specified in the HOL structure {\tt Parse}.
{\it def\_name} is the name under which the new constant definition is to
be stored in the current theory.
The
process of defining lifted constants
is described in [HOQ] \S 9.

{\it tyop\_equivs\/} is a list of conditional equivalence theorems
for type operators (see [HOQ] \S 4.1).
These are used for bringing into regular form
theorems on new type operators, so that they can be lifted
(see [HOQ] \S 11 and \S 12).

{\it tyop\_quotients\/} is a list of conditional quotient theorems
for type operators (see [HOQ] \S 5.2).
These are used for lifting both constants and theorems.

{\it tyop\_simps\/} is a list of theorems used to simplify type operator
relations and map functions, e.g.,
for pairs,
{\tt |- (\$= \#\#\# \$=) = \$=} and
{\tt |- (I \#\# I) = I}.

The rest of the arguments refer to the general process of lifting theorems
over the quotients being defined,
as described in [HOQ] \S 10.

{\it respects\/} is a list of theorems about the respectfulness of the
constants being lifted.
These theorems are described in
[HOQ] \S 10.1.

{\it poly\_preserves\/} is a list of theorems about the preservation of
polymorphic constants in the HOL logic
across a quotient operation.
%as if they were definitions across the quotient operation.
In other words, they state that any quotient operation preserves these
constants as a homomorphism.
These theorems are described in
[HOQ] \S 10.2.

{\it poly\_respects\/} is a list of theorems showing the respectfulness
of the polymorphic constants mentioned in {\it poly\_preserves}.
These are
described in
[HOQ] \S 10.3.

{\it old\_thms\/} is a list of theorems concerning the lower, representative
types and contants, which are to be automatically lifted and proved at the
higher, more abstract quotient level.
These theorems are described in
[HOQ] \S 10.4.

{\tt define\_quotient\_types} returns a list of theorems, which are the
lifted versions of the {\it old\_thms}.

A similar function,
{\tt define\_quotient\_types\_rule}, takes a single argument which is a
record with the same fields as above except for {\it old\_thms},
and returns an SML function of type {\tt thm -> thm}.
This result, typically called {\tt LIFT\_RULE},
is then used to lift the old theorems individually, one at a time.

For backwards compatibility with
the excellent quotients package
{\tt EquivType}
created by
John Harrison
%to whom much credit is due, and
(which provided much inspiration),
the following function is also provided:

\begin{verbatim}
define_equivalence_type :
        {name: string,
         equiv: thm,
         defs: {def_name: string,
                fname: string,
                func: Term.term,
                fixity: Parse.fixity} list,
         welldefs : thm list,
         old_thms : thm list} ->
        thm list
\end{verbatim}

\noindent
This function is limited to a single quotient type, but may be
more convenient when the generality of {\tt define\_quotient\_types}
is not needed.
This function is defined in terms of {\tt define\_quotient\_types} as

\begin{verbatim}
fun define_equivalence_type {name,equiv,defs,welldefs,old_thms} =
    define_quotient_types
     {types=[{name=name, equiv=equiv}], defs=defs, tyop_equivs=[],
      tyop_quotients=[FUN_QUOTIENT],
      tyop_simps=[FUN_REL_EQ,FUN_MAP_I], respects=welldefs,
      poly_preserves=[FORALL_PRS,EXISTS_PRS],
      poly_respects=[RES_FORALL_RSP,RES_EXISTS_RSP],
      old_thms=old_thms};
\end{verbatim}
\index{type definitions, in HOL logic@type definitions, in \HOL{} logic!quotients|)}


\section{Function Definition}\label{TFL}

\HOL{} provides a function definition mechanism based on the
wellfounded recursion theorem which is proved in \theoryimp{relation},
discussed in Section \ref{relation}.

\index{Define@\ml{Define}}
\index{xDefine@\ml{xDefine}}
\begin{verbatim}
   Define   : term quotation -> thm
   xDefine  : string -> term quotation -> thm
   Hol_defn : string -> term quotation -> Defn.defn
\end{verbatim}

The \texttt{Define} function is a general-purpose function definition
mechanism. The \texttt{xDefine} function is identical to
{\small\verb+Define+} except that it takes an explicit name to use when
storing the definition in the current theory. {\small\tt Define}
accepts the following syntax:

\begin{enumerate}

\item Non-recursive definition, varstructs allowed on left-hand side.
\begin{verbatim}
   Define `f w (x, y, z) = x + y / w + z`;
\end{verbatim}

\item Primitive recursive (or non-recursive) over known datatype.
\label{enum:prim-recursive}

\begin{verbatim}
   Define
       `(fold b f [] = b) /\
        (fold b f (h::t) = f h (fold b f t))`;
\end{verbatim}

\item Non-recursive definition, over complex patterns:

\begin{verbatim}
   Define
       `(g (0,x,y,z) = 1)
     /\ (g (w,0,y,z) = 2)
     /\ (g (w,x,0,z) = 3)
     /\ (g (w,x,y,0) = 4)`;
\end{verbatim}

\item Recursions (not mutual or nested) that aren't handled
  by~\ref{enum:prim-recursive}.

\begin{verbatim}
   Define `(flatten  []           = [])
      /\   (flatten ([]::rst)     = flatten rst)
      /\   (flatten ((h::t)::rst) = h::flatten(t::rst))`;
\end{verbatim}

\item Nested recursions.
\begin{verbatim}
   Define `N x = if x>100 then x-10 else N(N(x+11))`;
\end{verbatim}

\item Mutual recursion.
\begin{verbatim}
   xDefine "even_odd"
      `(even 0 = T)
   /\  (even (SUC n) = odd n)
   /\  (odd 0 = F)
   /\  (odd (SUC n) = even n)`;
\end{verbatim}

\item Schematic definitions (mutual and nested recursive schemata are
         accepted).
\begin{verbatim}
   Define `While s = if B s then While (C s) else s`;
\end{verbatim}
\end{enumerate}

For complex recursions, \ml{Define} attempts to find a measure under
which recursive calls become smaller (and to prove that they do indeed
become smaller). Currently, it examines the domain type of the
function being defined and synthesizes a ``size'' measure.  Then it
does some basic simplifications and then attempts to automatically
prove the termination constraints.  If this termination proof fails,
then the definition attempt fails. If the termination proof succeeds,
an induction theorem for the function is also automatically derived
and stored in the current theory.

\paragraph{Example.} Invoking
\begin{verbatim}
     Define
       `(gcd 0 y = y)
   /\   (gcd (SUC x) 0 = SUC x)
   /\   (gcd (SUC x) (SUC y) =
            if y <= x then gcd (x-y)   (SUC y)
                      else gcd (SUC x) (y-x))`;
\end{verbatim}
proves all termination conditions and stores the theorem
\begin{verbatim}
   |- (gcd 0 y = y)           /\
      (gcd (SUC x) 0 = SUC x) /\
      (gcd (SUC x) (SUC y) =
           if y <= x then gcd (x - y) (SUC y)
                     else gcd (SUC x) (y - x))
\end{verbatim}
in the current theory under the name \ml{"gcd\_def"} and also stores
the theorem
\begin{verbatim}
   !P. (!y. P 0 y)       /\
       (!x. P (SUC x) 0) /\
       (!x y. (~(y <= x) ==> P (SUC x) (y - x)) /\
                (y <= x  ==> P (x - y) (SUC y))
                 ==> P (SUC x) (SUC y))
          ==>
            !v v1. P v v1.
\end{verbatim}
in the current theory under the name \ml{"gcd\_ind"} before
returning the requested recursion equations.

Recall that, if the termination proof fails, an invocation of
\ml{Define}  (or \ml{xDefine}) fails. In such situations, the \ML{}
function \ml{Hol\_defn} should be used.
%
\index{Hol_defn@\ml{Hol\_defn}}

\begin{verbatim}
   Hol_defn     : string -> term quotation -> Defn.defn
   WF_REL_TAC   : term quotation -> tactic
\end{verbatim}

\ml{Hol\_defn} makes the requested definition, but defers the proof of
termination to the user. For setting up termination proofs, there are
several useful entrypoints, namely

\begin{verbatim}
   Defn.tgoal  : Defn.defn -> GoalstackPure.proofs
   Defn.tprove : Defn.defn * tactic -> thm * thm
\end{verbatim}
\ml{Defn.tgoal} is analogous to \ml{set\_goal} and \ml{Defn.tprove} is
analogous to \ml{prove}.

\paragraph{Example.} An invocation of {\small\verb+Define+} on
the following equations for Quicksort will currently fail, since the
termination proof is beyond the capabilities of our naive termination
prover. Instead, we make an application of {\small\verb+Hol_defn+}:

\setcounter{sessioncount}{0}
\begin{session}
\begin{verbatim}
val qsort_def =
  Hol_defn "qsort"
    `(qsort r [] = []) /\
     (qsort r (h::t) =
         APPEND (qsort r (FILTER (\x. r x h) t))
           (h :: qsort r (FILTER (\x. ~(r x h)) t)))`;
\end{verbatim}
\end{session}
which returns a value of type \ml{defn}, but does not try to prove
termination. Although it is possible to directly work with elements of
type \ml{defn}, it is more convenient to invoke \ml{Defn.tgoal
  qsort\_def}, which sets up a termination proof in a goalstack. The
goal is just to get the unrestricted recursion equations and induction
theorem.

\begin{session}
\begin{verbatim}
Defn.tgoal qsort_def;

> val it =
    Proof manager status: 1 proof.
    1. Incomplete:
         Initial goal:
         ?R.
           (!t h r. R (r,FILTER (\x. ~r x h) t) (r,h::t)) /\
           (!t h r. R (r,FILTER (\x. r x h) t) (r,h::t)) /\ WF R
\end{verbatim}
\end{session}

How to proceed? The function \ml{WF\_REL\_TAC} now shows its utility.
When given a \ml{defn} and a quotation denoting a termination relation
for the function, \ml{WF\_REL\_TAC} initiates the termination proof.
For our example, we obtain two subgoals both of which are easy to
prove.

\begin{session}
\begin{verbatim}
- e (WF_REL_TAC `measure (LENGTH o SND)`);
OK..
2 subgoals:
> val it =
    !t h r. LENGTH (FILTER (\x. r x h) t) < LENGTH (h::t)


    !t h r. LENGTH (FILTER (\x. ~r x h) t) < LENGTH (h::t)
\end{verbatim}
\end{session}


Both goals are provable; once the proof is completed, we can
encapsulate it with \ml{Defn.tprove}, which takes a \ml{defn}, builds
a termination goal from it, applies the given tactic, and, if the
initial goal is proved, returns a pair comprising the requested
equations and the induction theorem.

\begin{session}
\begin{verbatim}
- val (qsort_eqns,qsort_ind) =
     Defn.tprove
       (qsort_def,
        WF_REL_TAC `measure (LENGTH o SND)`
        THEN ...);

> val qsort_eqns =
    |- (qsort r [] = []) /\
       (qsort r (h::t) =
          APPEND (qsort r (FILTER (\x. r x h) t))
             (h::qsort r (FILTER (\x. ~r x h) t)))  : thm

  val qsort_ind =
     |- !P.
        (!r. P r []) /\
        (!r h t. P r (FILTER (\x. r x h) t) /\
                 P r (FILTER (\x. ~r x h) t) ==> P r (h::t))
        ==> !v v1. P v v1  : thm
\end{verbatim}
\end{session}

\section{Defining Inductive Relations}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "description"
%%% End:
