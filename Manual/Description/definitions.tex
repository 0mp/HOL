\chapter{Advanced Definition Principles}\label{HOLdefinitions}

\section{Datatype definition}

There are several useful consequences of an object logic datatype
definition: structural induction, rewrite rules for constructors,
\etc\ However, these have not traditionally been automatically derived
at the invocation of the definition package: the user would have to
build the required theorems by explicitly invoking various proof
procedures.  The \verb+Hol_datatype+ function supports the definition of 
concrete data types; the specifications of the types may be recursive, mutually
recursive, nested recursive, and involve records.  The syntax
of declarations that \verb+Hol_datatype+ accepts is found in Table
\ref{datatype}.

\newcommand{\ident}      {\mbox{\it ident}}
\newcommand{\clause}      {\mbox{\it clause}}
\newcommand{\type}       {\mbox{\it hol\_type}}
{
\newcommand{\binding} {\mbox{\it binding}}
\newcommand{\recdspec}  {\mbox{\it record-spec}}
\newcommand{\constr} {\mbox{\it constructor-spec}}

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|rcl|}
\hline
\multicolumn{3}{|l|}
{\texttt{Hol\_datatype `}[\binding\ \texttt{;}]* \binding\texttt{`}}\\
& &\\
\binding & \verb+::=+ & \ident\ \verb+=+ \constr\\
         & \verb+|+ & \ident\ \verb+=+ \recdspec\\
& & \\
\constr & \verb+::=+ & [\clause\ \verb+|+]* \clause \\
& & \\
\clause & \verb+::=+ & \ident \\
        & \verb+|+ & \ident\ \verb+of+\ [\type\ \verb+=>+]* \type\\
& & \\
\recdspec & \verb+::=+ & \verb+<|+ [\ident\ \verb+:+ \type\ \verb+;+]*
                                   \ident\ \verb+:+ \type\ \verb+|>+\\

\hline
\end{tabular}
\caption{Datatype Declaration}\label{datatype}
\end{center}
\end{table}
} There is an underlying database of datatype facts that is augmented
by the results of a \verb+Hol_datatype+ declaration.  This database
supports various high-level proof tools. When the \HOL{} system starts
up, this database already contains the relevant entries for the types
\verb+bool+, \verb+prod+, \verb+num+, \verb+option+, and \verb+list+.
When a datatype is defined by \verb+Hol_datatype+, the following
information is derived and stored in the database.

\begin{itemize}
\item initiality theorem for the type
\item injectivity of the constructors
\item distinctness of the constructors
\item structural induction theorem
\item case analysis theorem
\item definition of the `case' constant for the type
\item congruence theorem for the case constant
\item definition of the `size' of the type
\end{itemize}

\section{Record types}

Record types are convenient ways of bundling together a number of
component types, and giving those components names so as to facilitate
access to them.  Record types are semantically equivalent to big pair
(cross-product) types, but the ability to label the fields with names
of one's own choosing is a great convenience.  Record types as
implemented in \HOL{} are similar to C's {\tt struct} types and to
Pascal's records.

Done correctly, record types provide useful maintainability features.
If one can always access the {\tt fieldn} field of a record type by
simply writing {\tt record.fieldn}, then changes to the type that
result in the addition or deletion of other fields will not invalidate
this reference.  One failing in SML's record types is that they do not
allow the same maintainability as far as (functional) updates of
records are concerned.  The HOL implementation allows one to write
\begin{verbatim}
  rec with fieldn := new_value
\end{verbatim}
which replaces the old value of {\tt fieldn} in the record {\tt rec}
with {\tt new\_value}.  This expression will not need to be changed if
another field is added, modified or deleted from the record's original
definition.

\paragraph{Defining a record type}
Record types are defined with the function \texttt{Hol\_datatype}, as
previously discussed.  For example, to create a record type called
{\tt person} with boolean, string and number fields called {\tt
  employed}, {\tt name} and {\tt age}, one would enter:
\begin{verbatim}
val _ = Hol_datatype `person = <| employed : bool ; age : num ;
                                  name : string
                               |>`;
\end{verbatim}
The order in which the fields are entered is not significant. As well
as defining the type (called {\tt person}), the datatype definition
function also defines two other sets of constants.  These are the
field access functions and functional update functions.  The field
access functions have names of the form
``$\langle$\textsl{record-type\/}$\rangle$\verb|_|$\langle$\textsl{field\/}$\rangle$''.
These functions can be used directly, or one can use standard field
selection notation to access the values of a record's field.  Thus,
one would write the expression: \mbox{\tt ``bob.employed``} in order
to return the value of {\tt bob}'s {\tt employed} field.  The
alternative, \texttt{``person\_employed bob``}, works, but would be
printed using the first syntax, with the full-stop.

The functional update functions are given the names
\mbox{``$\langle$\textsl{record-type}$\rangle$\texttt{\_}%
  $\langle$\textsl{field}$\rangle$\texttt{\_fupd}''} for each field in
the type.  They take two arguments, a function and a record to be
updated.  The function parameter is an endomorphism on the field type,
so that the resulting record is the same as the original, except that
the specified field has had the given function applied to it to
generate the new value for that field.  They can be written with the
keyword \texttt{with} and the \texttt{updated\_by} operator.  Thus
\begin{alltt}
  ``bob with employed updated_by \$~``
\end{alltt} \noindent
is a record value identical to the \texttt{bob} except that the
boolean value in the \texttt{employed} field has been inverted.

Additionally, there is syntactic sugar available to let one write a
record with one of its fields replaced by a specific value.  This is
done by using the \texttt{:=} operator instead of
\texttt{updated\_by}:
\begin{verbatim}
  ``bob with employed := T``
\end{verbatim}
This form is translated at parse-time to be a use of the corresponding
functional update, along with a use of the \textsf{K}-combinator from
the \texttt{combin} theory.  Thus, the above example  is really
\begin{verbatim}
  ``bob with employed updated_by (K T)``
\end{verbatim}
which is in turn a pretty form of
\begin{verbatim}
  ``person_employed_fupd (K T) bob``
\end{verbatim}
If a chain of updates is desired, then multiple updates can be
specified inside \texttt{<|}-\texttt{|>} pairs, separated by
semi-colons, thus:

\begin{verbatim}
  ``bob with <| age := 10; name := "Child labourer" |>``
\end{verbatim}
Both update forms (using \texttt{updated\_by} and \texttt{:=}) can be
used in a chain of updates.

\paragraph{Specifying record literals}

The parser accepts lists of field specifications between
\texttt{<|}-\texttt{|>} pairs without the \texttt{with} keyword.
These translate to sequences of updates of an arbitrary value
(literally, the HOL value \texttt{ARB}), and are treated as literals.
Thus,
\begin{verbatim}
  ``<| age := 21; employed := F; name := "Layabout" |>``
\end{verbatim}

\paragraph{Using the theorems produced by record definition}

As well as defining the type and the functions described above, record
type definition also proves a suite of useful theorems.  These are all
are saved (using {\tt save\_thm}) in the current segment.  Some are
also added to the \texttt{TypeBase}'s simplifications for the type, so
they will be automatically applied when simplifying with the
\texttt{srw\_ss()} simpset, or with the tactics \texttt{RW\_TAC} and
\texttt{SRW\_TAC} (see Sections~\ref{sec:automated-reasoners}
and~\ref{sec:simpLib}).

All of the theorems are saved under names that begin with the name of
the type.  The list below is a sample of the theorems proved.  The
identifying strings are suffixes appended to the name of the type in
order to generate the final name of the theorem.

\newcommand{\rewruse}{This theorem is installed in the \texttt{TypeBase}.}
\newcommand{\field}[1]{\mbox{\it field}_{#1}}
\newcommand{\update}{\mbox{\tt\_fupd}}

\begin{description}
\item[\texttt{\_accessors}] The definitions of the accessor functions.
  \rewruse
\item[\texttt{\_fn\_updates}] The definitions of the functional update
  functions.
\item[\texttt{\_accfupds}] A theorem stating simpler forms for
  expressions of the form $\field{i}\, (\field{j}\update\;f\; r)$.  If
  $i = j$, then the RHS is $f (\field{i}(r))$, if not, it is $(\field{i}\;r)$.
  \rewruse
\item[\texttt{\_component\_equality}] A theorem stating that $(r_1 =
  r_2) \equiv \bigwedge_i (\field{i}(r_1) = \field{i}(r_2))$.
\item[\texttt{\_fupdfupds}] A thereom stating that $\field{i}\update
  \;f \,(\field{i}\update \;g\;r) = \field{i}\update\;(f \circ g)\;r$.
  \rewruse
\item[\texttt{\_fupdcanon}] A theorem that states commutativity results
  for all possible pairs of field updates.  They are constructed in
  such a way that if used as rewrites, they will canonicalise
  sequences of updates. Thus, for all $i < j$, \[
  \field{j}\update\;f\;(\field{i}\update\;g\;r) =
  \field{i}\update\;g\;(\field{j}\update\;f\;r)
  \] is generated.
 \rewruse
\end{description}

\paragraph{``Big'' records} The size of certain theorems proved in the
record type package increases as the square of the number of fields in
the record.  (In particular, the update canonicalisation and
\texttt{acc\_fupd} theorems have this property.) To avoid inefficieny
with big records, the implementation of record types uses a more
efficient underlying representation when the number of fields grows
too large.  The exact point at which this optimisation is applied is
controlled by the reference variable
\texttt{Datatype.big\_record\_size}.  This value is initialised to 20,
but users can change it as they choose.

Unfortunately, the big record representation has the drawback that
every update and accessor function has two forms: different terms that
are printed the same.  One form is a simple constant, and is the form
produced when a term is parsed.  The other is more complicated, but
allows for the use of smaller theorems when record values are
simplified.  Therefore, it is recommended that new, user-proved
theorems that mention big records' fields or field updates be passed
through a phase of simplification (\texttt{SIMP\_RULE}), applying the
\texttt{TypeBase}'s rewrites, before they are saved.

The pretty-printing of big records can be controlled with the
\texttt{pp\_bigrecs} trace-flag.


\section{Function definition}

\HOL{} provides a function definition mechanism based on the
wellfounded recursion theorem which is proved in \texttt{relationTheory}.

\begin{verbatim}
    Define   : term quotation -> thm
    xDefine  : string -> term quotation -> thm
    Hol_defn : string -> term quotation -> Defn.defn
\end{verbatim}

The \texttt{Define} function is a general-purpose function definition
mechanism. The \texttt{xDefine} function is identical to
{\small\verb+Define+} except that it takes an explicit name to use when
storing the definition in the current theory. {\small\tt Define}
accepts the following syntax:

\begin{enumerate}

\item Non-recursive definition, varstructs allowed on lhs.
\begin{verbatim}
         Define `f w (x, y, z) = x + y / w + z`;
\end{verbatim}

\item Primitive recursive (or non-recursive) over known datatype.

\begin{verbatim}
 Define
     `(fold b f [] = b) /\
      (fold b f (h::t) = f h (fold b f t))`;

\end{verbatim}

\item Non-recursive definition, over complex patterns:

\begin{verbatim}
Define
    `(g (0,x,y,z) = 1)
  /\ (g (w,0,y,z) = 2)
  /\ (g (w,x,0,z) = 3)
  /\ (g (w,x,y,0) = 4)`;
\end{verbatim}

\item Recursions (not mutual or nested) that aren't handled by 2.

\begin{verbatim}
  Define `(flatten  []           = [])
     /\   (flatten ([]::rst)     = flatten rst)
     /\   (flatten ((h::t)::rst) = h::flatten(t::rst))`;
\end{verbatim}

\item Nested recursions.
\begin{verbatim}
 Define `N x = if x>100 then x-10 else N(N(x+11))`;
\end{verbatim}

\item Mutual recursion.
\begin{verbatim}
  xDefine "even_odd"
     `(even 0 = T)
  /\  (even (SUC n) = odd n)
  /\  (odd 0 = F)
  /\  (odd (SUC n) = even n)`;
\end{verbatim}

\item Schematic definitions (mutual and nested recursive schemata are
         accepted).
\begin{verbatim}
      Define `While s = if B s then While (C s) else s`;
\end{verbatim}
\end{enumerate}

For complex recursions, {\small\verb+Define+} attempts to find a measure
under which recursive calls become smaller (and to prove that they do
indeed become smaller). Currently, it examines the domain type of the
function being defined and synthesizes a ``size'' measure.  Then it does
some basic simplifications and then attempts to automatically prove the
termination constraints.  If this termination proof fails, then the
definition attempt fails. If the termination proof succeeds, an
induction theorem for the function is also automatically derived and
stored in the current theory.

\noindent {\bf Example.} Invoking
\begin{verbatim}
      Define
        `(gcd 0 y = y)
    /\   (gcd (SUC x) 0 = SUC x)
    /\   (gcd (SUC x) (SUC y) =
             if y <= x then gcd (x-y)   (SUC y)
                       else gcd (SUC x) (y-x))`;
\end{verbatim}
proves all termination conditions and stores the theorem
\begin{verbatim}
      |- (gcd 0 y = y)           /\
         (gcd (SUC x) 0 = SUC x) /\
         (gcd (SUC x) (SUC y) =
              if y <= x then gcd (x - y) (SUC y)
                        else gcd (SUC x) (y - x))
\end{verbatim}
\noindent in the current theory under the name \verb+"gcd_def"+ and
also stores the theorem
\begin{verbatim}
          !P. (!y. P 0 y)       /\
              (!x. P (SUC x) 0) /\
              (!x y. (~(y <= x) ==> P (SUC x) (y - x)) /\
                       (y <= x  ==> P (x - y) (SUC y))
                        ==> P (SUC x) (SUC y))
                 ==>
                   !v v1. P v v1.
\end{verbatim}
\noindent in the current theory under the name \verb+"gcd_ind"+ before
returning the requested recursion equations.

Recall that, if the termination proof fails, an invocation of
\verb+Define+  (or \verb+xDefine+) fails. In such situations, the \ML\
function \verb+Hol_defn+ should be used.

\begin{verbatim}
   Hol_defn     : string -> term quotation -> Defn.defn
   WF_REL_TAC   : Defn.defn -> term quotation -> tactic
\end{verbatim}

\verb+Hol_defn+ makes the requested definition, but defers the proof of
termination to the user. For setting up termination proofs, there are
several useful entrypoints, namely

\begin{verbatim}
   Defn.tgoal  : Defn.defn -> GoalstackPure.proofs
   Defn.tprove : Defn.defn * tactic -> thm * thm
\end{verbatim}

{\small\verb+Defn.tgoal+} is analogous to {\small\verb+set_goal+} and
{\small\verb+Defn.tprove+} is analogous to {\small\verb+prove+}.

\noindent {\bf Example.} An invocation of {\small\verb+Define+} on
the following equations for Quicksort will currently fail, since the
termination proof is beyond the capabilities of our naive termination
prover. Instead, we make an application of {\small\verb+Hol_defn+}:

\begin{verbatim}
    val qsort_def =
      Hol_defn "qsort"
        `(qsort r [] = []) /\
         (qsort r (h::t) =
             APPEND (qsort r (FILTER (\x. r x h) t))
               (h :: qsort r (FILTER (\x. ~(r x h)) t)))`;
\end{verbatim}
which returns a {\small\verb+defn+}, but does not try to prove
termination. Although it is possible to directly work with elements of
type {\small\verb+defn+}, it is more convenient to invoke
`{\small\tt Defn.tgoal qsort\_def}', which sets up a termination
proof in a goalstack. The goal is just to get the unrestricted recursion
equations and induction theorem.

\begin{verbatim}
Defn.tgoal qsort_def;

> val it =
>    Proof manager status: 1 proof.
>    1. Incomplete:
>         Initial goal:
>         ((qsort r [] = []) /\
>          (qsort r (h::t) =
>           APPEND (qsort r (FILTER (\x. r x h) t))
>             (h::qsort r (FILTER (\x. ~r x h) t)))) /\
>         !P.
>           (!r. P r []) /\
>           (!r h t. P r (FILTER (\x. r x h) t) /\
>                    P r (FILTER (\x. ~r x h) t) ==> P r (h::t))
>           ==> !v v1. P v v1
\end{verbatim}

How to proceed? The function {\small\verb+WF_REL_TAC+} now shows its
utility. When given a {\small\verb+defn+} and a quotation denoting a
termination relation for the function, {\small\verb+WF_REL_TAC+}
initiates the termination proof. For our example, we obtain two subgoals
both of which are easy to prove.

\begin{verbatim}
    - e (WF_REL_TAC qsort_def `measure (LENGTH o SND)`
>   OK..
>
>   2 subgoals:
>   val it =
>      !t h r. LENGTH (FILTER (\x. r x h) t) < LENGTH (h::t)
>
>
>      !t h r. LENGTH (FILTER (\x. ~r x h) t) < LENGTH (h::t)
\end{verbatim}


Both goals are provable; once the proof is completed, we can encapsulate
it with {\small\verb+Defn.tprove+}, which takes a
{\small\verb+defn+}, builds a termination goal from it, applies the
given tactic, and, if the initial goal is proved, returns a pair
comprising the requested equations and the induction theorem.

\begin{verbatim}
   val (qsort_eqns,qsort_ind) =
      Defn.tprove
       (qsort_def,
        WF_REL_TAC qsort_def `measure (LENGTH o SND)`
        THEN ...);

   > val qsort_eqns =
   >  |- (qsort r [] = []) /\
   >     (qsort r (h::t) =
   >        APPEND (qsort r (FILTER (\x. r x h) t))
   >           (h::qsort r (FILTER (\x. ~r x h) t)))  : thm

   >  val qsort_ind =
   >   |- !P.
   >      (!r. P r []) /\
   >      (!r h t. P r (FILTER (\x. r x h) t) /\
   >               P r (FILTER (\x. ~r x h) t) ==> P r (h::t))
   >      ==> !v v1. P v v1
\end{verbatim}
