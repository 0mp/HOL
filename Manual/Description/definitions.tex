\chapter{Advanced Definition Principles}\label{HOLdefinitions}

\section{Datatype definition}

There are several useful consequences of an object logic datatype
definition: structural induction, rewrite rules for constructors,
\etc\ However, these have not traditionally been automatically derived
at the invocation of the definition package: the user would have to
build the required theorems by explicitly invoking various proof
procedures.  The \verb+Hol_datatype+ function supports the definition of 
concrete data types; the specifications of the types may be recursive, mutually
recursive, nested recursive, and involve records.  The syntax
of declarations that \verb+Hol_datatype+ accepts is found in Table
\ref{datatype}.

\newcommand{\ident}      {\mbox{\it ident}}
\newcommand{\clause}      {\mbox{\it clause}}
\newcommand{\type}       {\mbox{\it hol\_type}}
{
\newcommand{\binding} {\mbox{\it binding}}
\newcommand{\recdspec}  {\mbox{\it record-spec}}
\newcommand{\constr} {\mbox{\it constructor-spec}}

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|rcl|}
\hline
\multicolumn{3}{|l|}
{\texttt{Hol\_datatype `}[\binding\ \texttt{;}]* \binding\texttt{`}}\\
& &\\
\binding & \verb+::=+ & \ident\ \verb+=+ \constr\\
         & \verb+|+ & \ident\ \verb+=+ \recdspec\\
& & \\
\constr & \verb+::=+ & [\clause\ \verb+|+]* \clause \\
& & \\
\clause & \verb+::=+ & \ident \\
        & \verb+|+ & \ident\ \verb+of+\ [\type\ \verb+=>+]* \type\\
& & \\
\recdspec & \verb+::=+ & \verb+<|+ [\ident\ \verb+:+ \type\ \verb+;+]*
                                   \ident\ \verb+:+ \type\ \verb+|>+\\

\hline
\end{tabular}
\caption{Datatype Declaration}\label{datatype}
\end{center}
\end{table}
} 

% Many formalizations require the definition of new types.  For
% example, ML-style datatypes are commonly used to model the abstract
% syntax of programming languages and the state-space of elaborate
% transition systems.  In HOL, such datatypes (at least, those that are
% inductive, or, alternatively, have a model in an initial algebra) may be
% specified using the invocation {Hol_datatype `<spec>`}, where
% {<spec>} should conform to the following grammar:
% {
%    spec    ::= [ <binding> ; ]* <binding>
% 
%    binding ::= <ident> = [ <clause> | ]* <clause>
%             |  <ident> = <| [ <ident> : <type> ; ]* <ident> : <type> |>
% 
%    clause  ::= <ident>
%             |  <ident> of [<type> => ]* <type>
% }
% When a datatype is successfully defined, a number of standard theorems
% are automatically proved about the new type: the constructors of the type
% are proved to be injective and disjoint, induction and case analysis
% theorems are proved, and each type also has a `size' function defined
% for it. All these theorems are stored in the current theory and added to
% a database accessed via the functions in {TypeBase}.
% 
% The notation used to declare datatypes is, unfortunately, not the same
% as that of ML. For example, an ML declaration
% {
%    datatype ('a,'b) btree = Leaf of 'a
%                           | Node of ('a,'b) btree * 'b * ('a,'b) btree
% }
% would most likely be declared in HOL as
% {
%    Hol_datatype `btree = Leaf of 'a
%                        | Node of btree => 'b => btree`
% }
% The {=>} notation in a HOL datatype description is intended to replace
% {*} in an ML datatype description, and highlights the fact that, in
% HOL, constructors are by default curried.  Note also that any type
% parameters for the new type are not allowed; they are inferred (in an
% arbitrary order) from the right hand side of the binding.
% 
% When a record type is defined, the parser is adjusted to allow new
% syntax (appropriate for records), and a number of useful
% simplification theorems are also proved.  The most useful of the
% latter are automatically stored in the {TypeBase} and can be inspected
% using the {simpls_of} function.  For further details on record types,
% see the DESCRIPTION.
% 
% \EXAMPLE
% In the following, we shall give an overview of the kinds of types that
% may be defined by {Hol_datatype}.
% 
% To start, enumerated types can be defined as in the following example:
% {
%    Hol_datatype `enum = A1  | A2  | A3  | A4  | A5
%                       | A6  | A7  | A8  | A9  | A10
%                       | A11 | A12 | A13 | A14 | A15
%                       | A16 | A17 | A18 | A19 | A20
%                       | A21 | A22 | A23 | A24 | A25
%                       | A26 | A27 | A28 | A29 | A30`
% 
% }
% Other non-recursive types may be defined as well:
% {
%    Hol_datatype `foo = N of num
%                      | B of bool
%                      | Fn of 'a -> 'b
%                      | Pr of 'a # 'b`
% }
% Turning to recursive types, we can define a type of binary trees
% where the leaves are numbers.
% {
%     - Hol_datatype `tree = Leaf of num
%                          | Node of tree => tree`
% }
% We have already seen a type of binary trees having polymorphic
% values at internal nodes. This time, we will declare it in "paired" format.
% {
%     Hol_datatype `tree = Leaf of 'a
%                        | Node of tree # 'b # tree`
% }
% This specification seems closer to the declaration that one might make
% in ML, but is more difficult to deal with in proof than the curried format
% used above.
% 
% The basic syntax of the named lambda calculus is easy to describe:
% {
%     - load "stringTheory";
%     > val it = () : unit
% 
%     - Hol_datatype `lambda = Var of string
%                            | Const of 'a
%                            | Comb of lambda => lambda
%                            | Abs of lambda => lambda`
% }
% The syntax for `de Bruijn' terms is roughly similar:
% {
%    Hol_datatype `dB = Var of string
%                     | Const of 'a
%                     | Bound of num
%                     | Comb  of dB => dB
%                     | Abs   of dB`
% }
% Arbitrarily branching trees may be defined by allowing a node to hold
% the list of its subtrees. In such a case, leaf nodes do not need to be
% explicitly declared.
% {
%    Hol_datatype `ntree = Node of 'a => ntree list`
% }
% A type of `first order terms' can be declared as follows:
% {
%    Hol_datatype `term = Var of string
%                       | Fnapp of string # term list`
% }
% Mutally recursive types may also be defined. The following, extracted by
% Elsa Gunter from the Definition of Standard ML, captures a subset of
% Core ML.
% {
%    Hol_datatype
%         `atexp = var_exp of string
%                | let_exp of dec => exp ;
% 
%            exp = aexp    of atexp
%                | app_exp of exp => atexp
%                | fn_exp  of match ;
% 
%          match = match  of rule
%                | matchl of rule => match ;
% 
%           rule = rule of pat => exp ;
% 
%            dec = val_dec   of valbind
%                | local_dec of dec => dec
%                | seq_dec   of dec => dec ;
% 
%        valbind = bind  of pat => exp
%                | bindl of pat => exp => valbind
%                | rec_bind of valbind ;
% 
%            pat = wild_pat
%                | var_pat of string`
% }
% Simple record types may be introduced using the {<| ... |>} notation.
% {
%     Hol_datatype `state = <| Reg1 : num; Reg2 : num; Waiting : bool |>`
% }
% The use of record types may be recursive. For example, the following
% declaration could be used to formalize a simple file system.
% {
%    Hol_datatype
%         `file = Text of string
%               | Dir of directory
%           ;
%     directory = <| owner : string ;
%                    files : (string # file) list |>`
% }
% 
% \FAILURE
% Now we address some types that cannot be declared with {Hol_datatype}.
% In some cases they cannot exist in HOL at all; in others, the type
% can be built in the HOL logic, but {Hol_datatype} is not able to make
% the definition.
% 
% First, an empty type is not allowed in HOL, so the following attempt
% is doomed to fail.
% {
%    Hol_datatype `foo = A of foo`
% }
% So called `nested types', which are occasionally quite useful, cannot
% at present be built with {Hol_datatype}:
% {
%    Hol_datatype `btree = Leaf of 'a
%                        | Node of  ('a # 'a) btree`
% }
% Co-inductive types may not currently be built with {Hol_datatype}:
% {
%    Hol_datatype `lazylist = Nil
%                           | Cons of 'a # (one -> lazylist)`
% }
% This type can however be built in HOL: see {llistTheory}.
% 
% Finally, for cardinality reasons, HOL does not allow the following attempt
% to model the untyped lambda calculus as a set (note the {->} in the clause
% for the {Abs} constructor):
% {
%     Hol_datatype `lambda = Var of string
%                          | Const of 'a
%                          | Comb of lambda => lambda
%                          | Abs of lambda -> lambda`
% }
% Instead, one would have to build a theory of complete partial orders
% (or something similar) with which to model the untyped lambda calculus.
% 
% \COMMENTS
% The consequences of an invocation of {Hol_datatype} are stored in the
% current theory segment and in {TypeBase}. The principal consequences
% of a datatype definition are the primitive recursion and induction theorems.
% These provide the ability to define simple functions over the type, and
% an induction principle for the type. For a type named {ty},
% the primitive recursion theorem is stored under {ty_Axiom} and
% the induction theorem is put under {ty_induction}. Other
% consequences include the distinctness of constructors ({ty_distinct}),
% and the injectivity of constructors ({ty_11}). A `degenerate' version of
% {ty_induction} is also stored under {ty_nchotomy}: it provides for reasoning
% by cases on the construction of elements of {ty}. Finally, some
% special-purpose theorems are stored : {ty_case_cong} gives a congruence
% theorem for "case" statements on elements of {ty}. These case statements
% are introduced by {ty_case_def}. Also, a definition of the "size" of the type
% is added to the current theory, under the name {ty_size_def}.
% 
% For example, invoking
% {
%    Hol_datatype `tree = Leaf of num
%                       | Node of tree => tree`;
% }
% results in the definitions
% {
%    tree_case_def =
%      |- (!f f1 a. case f f1 (Leaf a) = f a) /\
%          !f f1 a0 a1. case f f1 (Node a0 a1) = f1 a0 a1
% 
%    tree_size_def
%      |- (!a. tree_size (Leaf a) = 1 + a) /\
%          !a0 a1. tree_size (Node a0 a1) = 1 + (tree_size a0 + tree_size a1)
% }
% being added to the current theory. The following theorems about the datatype
% are also stored in the current theory.
% {
%    tree_Axiom
%      |- !f0 f1.
%           ?fn. (!a. fn (Leaf a) = f0 a) /\
%                !a0 a1. fn (Node a0 a1) = f1 a0 a1 (fn a0) (fn a1)
% 
%    tree_induction
%      |- !P. (!n. P (Leaf n)) /\
%             (!t t0. P t /\ P t0 ==> P (Node t t0))
%             ==>
%             !t. P t
% 
%    tree_nchotomy  |- !t. (?n. t = Leaf n) \/ ?t' t0. t = Node t' t0
% 
%    tree_11
%      |- (!a a'. (Leaf a = Leaf a') = (a = a')) /\
%          !a0 a1 a0' a1'. (Node a0 a1 = Node a0' a1') = (a0=a0') /\ (a1=a1')
% 
%    tree_distinct  |- !a1 a0 a. ~(Leaf a = Node a0 a1)
% 
%    tree_case_cong
%      |- !M M' f f1.
%           (M = M') /\
%           (!a. (M' = Leaf a) ==> (f a = f' a)) /\
%           (!a0 a1. (M' = Node a0 a1) ==> (f1 a0 a1 = f1' a0 a1))
%           ==>
%           (case f f1 M = case f' f1' M')
% }
% When a type involving records is defined, many more definitions are
% made and added to the current theory.
% 
% A definition of mutually recursives types results in the above theorems and
% definitions being added for each of the defined types.

There is an underlying database of datatype facts that is augmented
by the results of a \verb+Hol_datatype+ declaration.  This database
supports various high-level proof tools. When the \HOL{} system starts
up, this database already contains the relevant entries for the types
\verb+bool+, \verb+prod+, \verb+num+, \verb+option+, and \verb+list+.
When a datatype is defined by \verb+Hol_datatype+, the following
information is derived and stored in the database.

\begin{itemize}
\item initiality theorem for the type
\item injectivity of the constructors
\item distinctness of the constructors
\item structural induction theorem
\item case analysis theorem
\item definition of the `case' constant for the type
\item congruence theorem for the case constant
\item definition of the `size' of the type
\end{itemize}

\section{Record types}

Record types are convenient ways of bundling together a number of
component types, and giving those components names so as to facilitate
access to them.  Record types are semantically equivalent to big pair
(cross-product) types, but the ability to label the fields with names
of one's own choosing is a great convenience.  Record types as
implemented in \HOL{} are similar to C's {\tt struct} types and to
Pascal's records.

Done correctly, record types provide useful maintainability features.
If one can always access the {\tt fieldn} field of a record type by
simply writing {\tt record.fieldn}, then changes to the type that
result in the addition or deletion of other fields will not invalidate
this reference.  One failing in SML's record types is that they do not
allow the same maintainability as far as (functional) updates of
records are concerned.  The HOL implementation allows one to write
\begin{verbatim}
  rec with fieldn := new_value
\end{verbatim}
which replaces the old value of {\tt fieldn} in the record {\tt rec}
with {\tt new\_value}.  This expression will not need to be changed if
another field is added, modified or deleted from the record's original
definition.

\paragraph{Defining a record type}
Record types are defined with the function \texttt{Hol\_datatype}, as
previously discussed.  For example, to create a record type called
{\tt person} with boolean, string and number fields called {\tt
  employed}, {\tt name} and {\tt age}, one would enter:
\begin{verbatim}
val _ = Hol_datatype `person = <| employed : bool ; age : num ;
                                  name : string
                               |>`;
\end{verbatim}
The order in which the fields are entered is not significant. As well
as defining the type (called {\tt person}), the datatype definition
function also defines two other sets of constants.  These are the
field access functions and functional update functions.  The field
access functions have names of the form
``$\langle$\textsl{record-type\/}$\rangle$\verb|_|$\langle$\textsl{field\/}$\rangle$''.
These functions can be used directly, or one can use standard field
selection notation to access the values of a record's field.  Thus,
one would write the expression: \mbox{\tt ``bob.employed``} in order
to return the value of {\tt bob}'s {\tt employed} field.  The
alternative, \texttt{``person\_employed bob``}, works, but would be
printed using the first syntax, with the full-stop.

The functional update functions are given the names
\mbox{``$\langle$\textsl{record-type}$\rangle$\texttt{\_}%
  $\langle$\textsl{field}$\rangle$\texttt{\_fupd}''} for each field in
the type.  They take two arguments, a function and a record to be
updated.  The function parameter is an endomorphism on the field type,
so that the resulting record is the same as the original, except that
the specified field has had the given function applied to it to
generate the new value for that field.  They can be written with the
keyword \texttt{with} and the \texttt{updated\_by} operator.  Thus
\begin{alltt}
  ``bob with employed updated_by \$~``
\end{alltt} \noindent
is a record value identical to the \texttt{bob} except that the
boolean value in the \texttt{employed} field has been inverted.

Additionally, there is syntactic sugar available to let one write a
record with one of its fields replaced by a specific value.  This is
done by using the \texttt{:=} operator instead of
\texttt{updated\_by}:
\begin{verbatim}
  ``bob with employed := T``
\end{verbatim}
This form is translated at parse-time to be a use of the corresponding
functional update, along with a use of the \textsf{K}-combinator from
the \texttt{combin} theory.  Thus, the above example  is really
\begin{verbatim}
  ``bob with employed updated_by (K T)``
\end{verbatim}
which is in turn a pretty form of
\begin{verbatim}
  ``person_employed_fupd (K T) bob``
\end{verbatim}
If a chain of updates is desired, then multiple updates can be
specified inside \texttt{<|}-\texttt{|>} pairs, separated by
semi-colons, thus:

\begin{verbatim}
  ``bob with <| age := 10; name := "Child labourer" |>``
\end{verbatim}
Both update forms (using \texttt{updated\_by} and \texttt{:=}) can be
used in a chain of updates.

\paragraph{Specifying record literals}

The parser accepts lists of field specifications between
\texttt{<|}-\texttt{|>} pairs without the \texttt{with} keyword.
These translate to sequences of updates of an arbitrary value
(literally, the HOL value \texttt{ARB}), and are treated as literals.
Thus,
\begin{verbatim}
  ``<| age := 21; employed := F; name := "Layabout" |>``
\end{verbatim}

\paragraph{Using the theorems produced by record definition}

As well as defining the type and the functions described above, record
type definition also proves a suite of useful theorems.  These are all
are saved (using {\tt save\_thm}) in the current segment.  Some are
also added to the \texttt{TypeBase}'s simplifications for the type, so
they will be automatically applied when simplifying with the
\texttt{srw\_ss()} simpset, or with the tactics \texttt{RW\_TAC} and
\texttt{SRW\_TAC} (see Sections~\ref{sec:automated-reasoners}
and~\ref{sec:simpLib}).

All of the theorems are saved under names that begin with the name of
the type.  The list below is a sample of the theorems proved.  The
identifying strings are suffixes appended to the name of the type in
order to generate the final name of the theorem.

\newcommand{\rewruse}{This theorem is installed in the \texttt{TypeBase}.}
\newcommand{\field}[1]{\mbox{\it field}_{#1}}
\newcommand{\update}{\mbox{\tt\_fupd}}

\begin{description}
\item[\texttt{\_accessors}] The definitions of the accessor functions.
  \rewruse
\item[\texttt{\_fn\_updates}] The definitions of the functional update
  functions.
\item[\texttt{\_accfupds}] A theorem stating simpler forms for
  expressions of the form $\field{i}\, (\field{j}\update\;f\; r)$.  If
  $i = j$, then the RHS is $f (\field{i}(r))$, if not, it is $(\field{i}\;r)$.
  \rewruse
\item[\texttt{\_component\_equality}] A theorem stating that $(r_1 =
  r_2) \equiv \bigwedge_i (\field{i}(r_1) = \field{i}(r_2))$.
\item[\texttt{\_fupdfupds}] A thereom stating that $\field{i}\update
  \;f \,(\field{i}\update \;g\;r) = \field{i}\update\;(f \circ g)\;r$.
  \rewruse
\item[\texttt{\_fupdcanon}] A theorem that states commutativity results
  for all possible pairs of field updates.  They are constructed in
  such a way that if used as rewrites, they will canonicalise
  sequences of updates. Thus, for all $i < j$, \[
  \field{j}\update\;f\;(\field{i}\update\;g\;r) =
  \field{i}\update\;g\;(\field{j}\update\;f\;r)
  \] is generated.
 \rewruse
\end{description}

\paragraph{``Big'' records} The size of certain theorems proved in the
record type package increases as the square of the number of fields in
the record.  (In particular, the update canonicalisation and
\texttt{acc\_fupd} theorems have this property.) To avoid inefficieny
with big records, the implementation of record types uses a more
efficient underlying representation when the number of fields grows
too large.  The exact point at which this optimisation is applied is
controlled by the reference variable
\texttt{Datatype.big\_record\_size}.  This value is initialised to 20,
but users can change it as they choose.

Unfortunately, the big record representation has the drawback that
every update and accessor function has two forms: different terms that
are printed the same.  One form is a simple constant, and is the form
produced when a term is parsed.  The other is more complicated, but
allows for the use of smaller theorems when record values are
simplified.  Therefore, it is recommended that new, user-proved
theorems that mention big records' fields or field updates be passed
through a phase of simplification (\texttt{SIMP\_RULE}), applying the
\texttt{TypeBase}'s rewrites, before they are saved.

The pretty-printing of big records can be controlled with the
\texttt{pp\_bigrecs} trace-flag.


\section{Function definition}\label{TFL}

\HOL{} provides a function definition mechanism based on the
wellfounded recursion theorem which is proved in \theoryimp{relation},
discussed in Section \ref{relation}.

\begin{verbatim}
    Define   : term quotation -> thm
    xDefine  : string -> term quotation -> thm
    Hol_defn : string -> term quotation -> Defn.defn
\end{verbatim}

The \texttt{Define} function is a general-purpose function definition
mechanism. The \texttt{xDefine} function is identical to
{\small\verb+Define+} except that it takes an explicit name to use when
storing the definition in the current theory. {\small\tt Define}
accepts the following syntax:

\begin{enumerate}

\item Non-recursive definition, varstructs allowed on lhs.
\begin{verbatim}
         Define `f w (x, y, z) = x + y / w + z`;
\end{verbatim}

\item Primitive recursive (or non-recursive) over known datatype.

\begin{verbatim}
 Define
     `(fold b f [] = b) /\
      (fold b f (h::t) = f h (fold b f t))`;

\end{verbatim}

\item Non-recursive definition, over complex patterns:

\begin{verbatim}
Define
    `(g (0,x,y,z) = 1)
  /\ (g (w,0,y,z) = 2)
  /\ (g (w,x,0,z) = 3)
  /\ (g (w,x,y,0) = 4)`;
\end{verbatim}

\item Recursions (not mutual or nested) that aren't handled by 2.

\begin{verbatim}
  Define `(flatten  []           = [])
     /\   (flatten ([]::rst)     = flatten rst)
     /\   (flatten ((h::t)::rst) = h::flatten(t::rst))`;
\end{verbatim}

\item Nested recursions.
\begin{verbatim}
 Define `N x = if x>100 then x-10 else N(N(x+11))`;
\end{verbatim}

\item Mutual recursion.
\begin{verbatim}
  xDefine "even_odd"
     `(even 0 = T)
  /\  (even (SUC n) = odd n)
  /\  (odd 0 = F)
  /\  (odd (SUC n) = even n)`;
\end{verbatim}

\item Schematic definitions (mutual and nested recursive schemata are
         accepted).
\begin{verbatim}
      Define `While s = if B s then While (C s) else s`;
\end{verbatim}
\end{enumerate}

For complex recursions, {\small\verb+Define+} attempts to find a measure
under which recursive calls become smaller (and to prove that they do
indeed become smaller). Currently, it examines the domain type of the
function being defined and synthesizes a ``size'' measure.  Then it does
some basic simplifications and then attempts to automatically prove the
termination constraints.  If this termination proof fails, then the
definition attempt fails. If the termination proof succeeds, an
induction theorem for the function is also automatically derived and
stored in the current theory.

\noindent {\bf Example.} Invoking
\begin{verbatim}
      Define
        `(gcd 0 y = y)
    /\   (gcd (SUC x) 0 = SUC x)
    /\   (gcd (SUC x) (SUC y) =
             if y <= x then gcd (x-y)   (SUC y)
                       else gcd (SUC x) (y-x))`;
\end{verbatim}
proves all termination conditions and stores the theorem
\begin{verbatim}
      |- (gcd 0 y = y)           /\
         (gcd (SUC x) 0 = SUC x) /\
         (gcd (SUC x) (SUC y) =
              if y <= x then gcd (x - y) (SUC y)
                        else gcd (SUC x) (y - x))
\end{verbatim}
\noindent in the current theory under the name \verb+"gcd_def"+ and
also stores the theorem
\begin{verbatim}
          !P. (!y. P 0 y)       /\
              (!x. P (SUC x) 0) /\
              (!x y. (~(y <= x) ==> P (SUC x) (y - x)) /\
                       (y <= x  ==> P (x - y) (SUC y))
                        ==> P (SUC x) (SUC y))
                 ==>
                   !v v1. P v v1.
\end{verbatim}
\noindent in the current theory under the name \verb+"gcd_ind"+ before
returning the requested recursion equations.

Recall that, if the termination proof fails, an invocation of
\verb+Define+  (or \verb+xDefine+) fails. In such situations, the \ML\
function \verb+Hol_defn+ should be used.

\begin{verbatim}
   Hol_defn     : string -> term quotation -> Defn.defn
   WF_REL_TAC   : Defn.defn -> term quotation -> tactic
\end{verbatim}

\verb+Hol_defn+ makes the requested definition, but defers the proof of
termination to the user. For setting up termination proofs, there are
several useful entrypoints, namely

\begin{verbatim}
   Defn.tgoal  : Defn.defn -> GoalstackPure.proofs
   Defn.tprove : Defn.defn * tactic -> thm * thm
\end{verbatim}

{\small\verb+Defn.tgoal+} is analogous to {\small\verb+set_goal+} and
{\small\verb+Defn.tprove+} is analogous to {\small\verb+prove+}.

\noindent {\bf Example.} An invocation of {\small\verb+Define+} on
the following equations for Quicksort will currently fail, since the
termination proof is beyond the capabilities of our naive termination
prover. Instead, we make an application of {\small\verb+Hol_defn+}:

\begin{verbatim}
    val qsort_def =
      Hol_defn "qsort"
        `(qsort r [] = []) /\
         (qsort r (h::t) =
             APPEND (qsort r (FILTER (\x. r x h) t))
               (h :: qsort r (FILTER (\x. ~(r x h)) t)))`;
\end{verbatim}
which returns a {\small\verb+defn+}, but does not try to prove
termination. Although it is possible to directly work with elements of
type {\small\verb+defn+}, it is more convenient to invoke
`{\small\tt Defn.tgoal qsort\_def}', which sets up a termination
proof in a goalstack. The goal is just to get the unrestricted recursion
equations and induction theorem.

\begin{verbatim}
Defn.tgoal qsort_def;

> val it =
>    Proof manager status: 1 proof.
>    1. Incomplete:
>         Initial goal:
>         ((qsort r [] = []) /\
>          (qsort r (h::t) =
>           APPEND (qsort r (FILTER (\x. r x h) t))
>             (h::qsort r (FILTER (\x. ~r x h) t)))) /\
>         !P.
>           (!r. P r []) /\
>           (!r h t. P r (FILTER (\x. r x h) t) /\
>                    P r (FILTER (\x. ~r x h) t) ==> P r (h::t))
>           ==> !v v1. P v v1
\end{verbatim}

How to proceed? The function {\small\verb+WF_REL_TAC+} now shows its
utility. When given a {\small\verb+defn+} and a quotation denoting a
termination relation for the function, {\small\verb+WF_REL_TAC+}
initiates the termination proof. For our example, we obtain two subgoals
both of which are easy to prove.

\begin{verbatim}
    - e (WF_REL_TAC qsort_def `measure (LENGTH o SND)`
>   OK..
>
>   2 subgoals:
>   val it =
>      !t h r. LENGTH (FILTER (\x. r x h) t) < LENGTH (h::t)
>
>
>      !t h r. LENGTH (FILTER (\x. ~r x h) t) < LENGTH (h::t)
\end{verbatim}


Both goals are provable; once the proof is completed, we can encapsulate
it with {\small\verb+Defn.tprove+}, which takes a
{\small\verb+defn+}, builds a termination goal from it, applies the
given tactic, and, if the initial goal is proved, returns a pair
comprising the requested equations and the induction theorem.

\begin{verbatim}
   val (qsort_eqns,qsort_ind) =
      Defn.tprove
       (qsort_def,
        WF_REL_TAC qsort_def `measure (LENGTH o SND)`
        THEN ...);

   > val qsort_eqns =
   >  |- (qsort r [] = []) /\
   >     (qsort r (h::t) =
   >        APPEND (qsort r (FILTER (\x. r x h) t))
   >           (h::qsort r (FILTER (\x. ~r x h) t)))  : thm

   >  val qsort_ind =
   >   |- !P.
   >      (!r. P r []) /\
   >      (!r h t. P r (FILTER (\x. r x h) t) /\
   >               P r (FILTER (\x. ~r x h) t) ==> P r (h::t))
   >      ==> !v v1. P v v1
\end{verbatim}
