\chapter{The HOL Logic in ML}\label{HOLsyschapter}

In this chapter, the concrete representation of the \HOL\ logic is
described.  This involves describing the \ML\ functions that comprise
the interface to the logic (up to and including
Section~\ref{avra_terms}); the quotation, printing and parsing of
logical terms (Section~\ref{quotation}); the representation of
theorems (Section~\ref{avra_theorems}); the representation of theories
(Section~\ref{theoryfns}); some useful \HOL\ theories
(Sections~\ref{HOL-theory} and \ref{rules}); the methods for extending
theories (throughout Section~\ref{HOL-ancestry} and in
Section~\ref{types-package}); and the \ML\ system functions
concerning the logic (Section~\ref{HOLflags}).  It is assumed that the
reader is familiar with \ML.  If not, the introduction to \ML\ in
{\sl Getting Started with HOL\/} in \TUTORIAL\ should be read first.

The \HOL\ system provides \ML\ types \ml{hol\_type} and \ml{term} to represent
types and terms of the \HOL\ logic, as defined in Sections~\ref{types} and
\ref{terms}, respectively. It also provides primitive \ML\ functions for
creating and manipulating values of these types.  The key idea of the \HOL\
system, due to Robin Milner\index{Milner, R.}, and discussed in this chapter,
is that theorems are represented as an abstract \ML\ type whose only
pre-defined values are axioms, and whose only operations are rules of
inference. This means that the only way to construct theorems in \HOL\ is
to apply rules of inference to axioms or existing theorems; hence the
consistency of the logic is preserved.

The purpose of the meta-language \ML\ is to provide a programming
environment in which to build theorem proving tools to assist in the
construction of proofs.  When the \HOL\ system is built, a range of
useful theorems is pre-proved and a set of tools pre-defined. The basic
system thus offers a rich initial environment; users can further enrich
it by implementing their own application specific tools and building
their own application specific theories.


\section{Lexical matters}
\label{HOL-lex}

\index{identifiers, in HOL logic@identifiers, in \HOL\ logic|(} The name
of a \HOL\ variable\index{variables, in HOL logic@variables, in \HOL\
logic!names of|(} can be any \ML\ string, but the quotation mechanism
will parse only names that are identifiers (see Section~\ref{ident}
below).  The use of non-identifiers as variable names is discouraged
except in special circumstances (for example, when writing derived rules
that generate variables with names that are guaranteed to be different
from existing names). The name of a type variable\index{type variables,
in HOL logic@type variables, in \HOL\ logic!names of} in the \HOL\ logic
is formed by a prime (\ml{'}) followed by an alphanumeric which itself
contains no prime (see Section~\ref{tyvars} for examples).  The name of
a type constant or a term constant in the \HOL\ logic can be any
identifier, although some names are treated specially by the HOL parser
and printer and should therefore be avoided.
\index{identifiers, in HOL logic@identifiers, in \HOL\ logic|)}

\subsection{Identifiers}
\label{ident}

A \HOL\ identifier can be of two forms:
\begin{myenumerate}
\item A finite sequence of alphanumerics starting with a letter.
\item A \emph{symbolic} identifier, \ie, a finite sequence formed by any
combination of the following characters:
\begin{hol}\begin{verbatim}
  #  ?  +  *  /  \  =  <  >  &  %  @  !  ,  :  ;  _  |  ~  -
\end{verbatim}\end{hol}

\end{myenumerate}

\noindent A letter is a member of the list:

\begin{hol}\begin{verbatim}
   a b c d e f g h i j k l m n o p q r s t u v w x y z

   A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
\end{verbatim}\end{hol}

\noindent \HOL\ is case-sensitive: upper and lower case letters are
considered to be different.

Alphanumerics are letters or digits or underscores (\ml{\_}) or primes
(\ml{'}).  A digit is one of
{\small\verb%0%}, {\small\verb%1%}, {\small\verb%2%}, {\small\verb%3%},
{\small\verb%4%}, {\small\verb%5%}, {\small\verb%6%}, {\small\verb%7%},
{\small\verb%8%}, or {\small\verb%9%}.
A {\it number\/} is a string of one or more digits.

\subsubsection{Separators}

The separators used by the \HOL\ lexical analyser are (with ascii codes in
brackets):

\bigskip

space (32), carriage return (13), line feed (10), tab ({\verb%^%}I, 9),
form feed ({\verb%^%}L, 12)


\subsubsection{Special identifiers}

The following valid identifiers should not be used as the name of
a variable or a constant.

{\small \begin{verbatim}
   let  in  and  \  ;  =>  |  :  :=  with  updated_by
\end{verbatim}}

\subsubsection{Type variable names}
\label{tyvars}

The name of a type variable in the \HOL\ logic is a string
beginning with a prime (\ml{'}) followed by an alphanumeric which itself
contains no prime; for example all of the following are valid type
variable names except for the last:

\begin{hol}\begin{verbatim}
   'a   'b   'cat   'A11   'g_a_p   'f'oo
\end{verbatim}\end{hol}


\section{Types}\index{types, in HOL logic@types, in \HOL\ logic}

The allowed types\index{type constraint!in HOL logic@in \HOL\ logic}
depend on which type constants\index{type constants, in HOL logic@type
constants, in \HOL\ logic} have been declared in the
current theory. See Section~\ref{theoryfns} for details of how such
declarations are made.


There are two primitive constructor\index{types, in HOL logic@types, in \HOL\ logic!constructors for}
\index{type constructors!in HOL logic@in \HOL\ logic} functions for
values of type \ml{hol\_type}:


\begin{boxed}
\index{function types, in HOL logic@function types, in \HOL\
logic!constructors for}\index{mk_vartype@\ml{mk\_vartype}|pin}
\index{mk_type@\ml{mk\_type}|pin}
\begin{verbatim}
   mk_vartype : string -> hol_type
   mk_type    : (string * hol_type list) -> hol_type
\end{verbatim}\end{boxed}

The function \ml{mk\_vartype}
 constructs a type variable\index{type variables, in HOL logic@type
 variables, in \HOL\ logic!constructor for} with a given name;
it fails if the name is not an allowable type variable name (\ie\ not
a \ml{'} followed by an alphanumeric).

The function \ml{mk\_type} constructs a compound type\index{compound
 types, in HOL logic@compound types, in \HOL\ logic!constructors for}
 from a string
representing the name of the type operator and a list of types representing the
arguments to   the  operator.     Function types  $\sigma_1\fun\sigma_2$
of the logic are
represented in \ML\ as though they were compound types
$(\sigma_1,\sigma_2)$\ml{fun} (in  Section~\ref{types}, however,
function types were not regarded as compound types).

The evaluation of
\ml{mk\_type("}$name$\ml{",\ [}$\sigma_1$\ml{,}$\cdots$\ml{,}$\sigma_n$\ml{])}
fails if
\begin{myenumerate}
% \item $name$ is not an identifier;
\item $name$ is not a type operator of the current theory;
\item $name$ is a type operator of the current theory,
but its arity is not $n$.
\end{myenumerate}

For example, \ml{mk\_type("bool",[])}\index{truth values, in HOL logic@truth values, in \HOL\ logic}\index{bool, the type in HOL logic@\ml{bool}, the type in \HOL\ logic} evaluates to
an \ML\ value of type term representing the type \ty{bool} and
{\small\verb%mk_type("fun", [mk_type("ind",[]), mk_type("bool",[])])%}
evaluates to a value representing $\ty{ind}\fun\ty{bool}$.
(These types are introduced in Section~\ref{boolthy}).

There are two primitive destructor\index{types, in HOL logic@types, in
\HOL\ logic!destructors for}\index{type destructors, in HOL logic@type
destructors, in \HOL\ logic}  functions for values of type \ml{hol\_type}:


\begin{boxed}
\index{function types, in HOL logic@function types, in \HOL\
logic!destructors for}
\index{dest_vartype@\ml{dest\_vartype}|pin}
\index{dest_type@\ml{dest\_type}|pin}
\begin{verbatim}
   dest_vartype : hol_type -> string
   dest_type    : hol_type -> (string * hol_type list)
\end{verbatim}\end{boxed}

\noindent The function \ml{dest\_vartype}\index{type variables, in HOL
 logic@type variables, in \HOL\ logic!destructors for}\index{compound
 types, in HOL logic@compound types, in \HOL\ logic!destructors for}
 extracts the name of a type variable.
The function \ml{dest\_type}  destructs a  compound type  into the  name
 of the type operator  and  a  list  of  the  argument  types;
 \ml{dest\_vartype}  and \ml{dest\_type} are  thus the  inverses of
 \ml{mk\_vartype} and \ml{mk\_type}, respectively.  The destructors fail
 on arguments of the wrong form.


Types are printed\index{ type constraint, in HOL logic@\ml{:} (type
constraint, in \HOL\ logic)} \index{printing, in HOL logic@printing, in
\HOL\ logic!of types} in the form \ml{`:}$\ \cdots\ $\ml{`}
using the quotation syntax described in Section~\ref{quotation}.
For example, the \ML\ value of type \ml{hol\_type} representing
$\ty{ind}\fun(\ty{ind}\fun\ty{bool})$ would be printed
as \ml{`:ind -> ind -> bool`}.

\section{Terms}
\label{avra_terms}

The four primitive kinds of terms of the logic are described in
Section~\ref{terms}.  The \ML\ functions for manipulating these are
described in this section.  There are also various derived terms that
are described in Section~\ref{derived-terms}.

The allowed terms depend on which constants have been declared
in the current theory. See Section~\ref{theoryfns} for details
of how such declarations are made.

There are four primitive constructor\index{variables, in HOL
logic@variables, in \HOL\ logic!constructor for}\index{terms, in HOL
logic@terms, in \HOL\ logic!constructors for}\index{term constructors,
in HOL logic@term constructors, in \HOL\ logic} functions for values of
type \ml{term}:

\begin{boxed}
\index{mk_var@\ml{mk\_var}|pin}
\begin{verbatim}
   mk_var : (string * hol_type) -> term
\end{verbatim}\end{boxed}

\noindent\ml{mk\_var(}$x$\ml{,}$\sigma$\ml{)} evaluates to a variable
with name $x$ and type $\sigma$; it always succeeds.

\begin{boxed}
\index{mk_const@\ml{mk\_const}|pin}
\begin{verbatim}
   mk_const : (string * hol_type) -> term
\end{verbatim}\end{boxed}


\noindent\ml{mk\_const(}$c$\ml{,}$\sigma$\ml{)} evaluates to a
term representing
the constant\index{constants, in HOL logic@constants, in \HOL\ logic!constructor for} with name $c$ and type $\sigma$; it fails if:
\begin{myenumerate}
% \item $c$ is not an allowable constant name;
\item $c$ is not the name of a constant in the current theory;
\item $\sigma$ is not an instance of the generic type of $c$
(the generic type of a constant is established when the constant is defined;
see Section~\ref{theoryfns}).
\end{myenumerate}

\begin{boxed}\index{mk_comb@\ml{mk\_comb}|pin}
\begin{verbatim}
   mk_comb : (term * term) -> term
\end{verbatim}\end{boxed}

\noindent\ml{mk\_comb(}$t_1$\ml{,}$t_2$\ml{)}\index{function application, in HOL logic@function application, in \HOL\ logic!constructor for} evaluates to a term
representing the combination\index{combinations, in HOL logic@combinations, in \HOL\ logic!constructor for}
$t_1\ t_2$. It fails if:
\begin{myenumerate}
\item the type of $t_1$ does not have the form \ml{$\sigma'$->$\sigma$};
\item the type of $t_1$ has the form \ml{$\sigma'$->$\sigma$}, but the
type of $t_2$ is not equal to $\sigma'$.
\end{myenumerate}

\begin{boxed}
\index{mk_abs@\ml{mk\_abs}|pin}
\begin{verbatim}
   mk_abs : (term * term) -> term
\end{verbatim}\end{boxed}

\noindent\ml{mk\_abs(}$x$\ml{,}$t$\ml{)} evaluates to a term representing
the abstraction\index{function abstraction, in HOL logic@function abstraction, in \HOL\ logic!constructor for} $\lquant{x}t$; it fails if $x$ is not a variable.


There are four primitive destructor\index{term destructors, in HOL logic@term destructors, in \HOL\ logic}\index{variables, in HOL logic@variables, in \HOL\ logic!destructor for}\index{constants, in HOL logic@constants, in \HOL\ logic!destructor for}\index{combinations, in HOL logic@combinations, in \HOL\ logic!destructor for}\index{function abstraction, in HOL logic@function abstraction, in \HOL\ logic!destructor for}\index{function application, in HOL logic@function application, in \HOL\ logic!destructor for} functions on terms:

\begin{boxed}

\index{dest_var@\ml{dest\_var}|pin
}\index{dest_const@\ml{dest\_const}|pin}
\index{dest_comb@\ml{dest\_comb}|pin}
\index{dest_abs@\ml{dest\_abs}|pin}
\begin{verbatim}
   dest_var   : term -> (string * hol_type)
   dest_const : term -> (string * hol_type)
   dest_comb  : term -> (term * term)
   dest_abs   : term -> (term * term)
\end{verbatim}\end{boxed}

These are the inverses of \ml{mk\_var}, \ml{mk\_const},
\ml{mk\_comb} and \ml{mk\_abs}, respectively. They fail when applied
to terms of the wrong form. Other useful destructor functions are
\ml{rator}\index{rator@\ml{rator}},
\ml{rand}\index{rand@\ml{rand}},
\ml{bvar}\index{bvar@\ml{bvar}},
\ml{body}\index{body@\ml{body}},
\ml{lhs}\index{lhs@\ml{lhs}} and
\ml{rhs}\index{rhs@\ml{rhs}}.
See \REFERENCE\ for details.

The function

\begin{boxed}\index{type_of@\ml{type\_of}|pin}
\begin{verbatim}
   type_of : term -> hol_type
\end{verbatim}\end{boxed}

\noindent returns the type\index{types, in HOL logic@types, in \HOL\
logic!determination of} of a term. It could be defined (recursively)
in terms of the destructors but is predefined for convenience.

Terms are printed in the form \ml{`}$\ \cdots\ $\ml{`}
using the quotation syntax\index{quotation, in HOL logic@quotation, in \HOL\ logic} described in Section~\ref{quotation}.
For example, the term representing

\[ \uquant{x\ y}x<y \imp\equant{z}x+z = y \]

\noindent would be printed as:

\[ \ml{`!x y. x < y ==> ?z. x + z = y`} \]

Note that a colon\index{ type constraint, in HOL logic@\ml{:} (type constraint, in \HOL\ logic)}
 is used to distinguish type quotation from term quotation;
the former have the form \ml{`:}$\ \cdots\ $\ml{`} and the latter have
 the form \ml{`}$\ \cdots\ $\ml{`}.


\section{Quotation}
\label{quotation}\label{gen-abs}\label{let}
\index{type checking, in HOL logic@type checking, in \HOL\ logic!of quotation syntax|(}

\index{quotation, in HOL logic@quotation, in \HOL\ logic|(}
\index{ type quotes, in ML@\ml{"":$\cdots$""} (type quotes, in \ML)|(}
\index{ term quotes, in ML@\ml{""$\cdots$""} (term quotes, in \ML)|(}
\HOL\ types and terms can be input\index{terms, in HOL logic@terms, in \HOL\ logic!input of} to the system in two ways:  by using
constructor functions, or by using {\it quotation\/}.  The former
allows some terms to be built which cannot be  constructed using quotation.
For example, a term containing two variables with  the same name but different
types, \eg\ the term  $x_{\ty{bool}}=(x_{\ty{num}}=1)$,
 can be built only by using
constructors.

It would be tedious, however, to always have to input types and terms using the
constructor functions. The \HOL\ system, adapting the approach taken in
\LCF, \index{LCF@\LCF}, has special quotation\index{quotation, in HOL
logic@quotation, in \HOL\ logic!parser for}\index{parsing, of HOL
logic@parsing, of \HOL\ logic!of quotation syntax} parsers for \HOL\
types and terms (named {\small\verb%Type%} and  {\small\verb%Term%}, respectively)
which enables types and terms to be input using a fairly standard
syntax.  The \HOL\ printer also outputs types and terms using this
syntax\index{printing, in HOL logic@printing, in \HOL\ logic!of quotation syntax}.

For example, the \ML\ expression

\begin{verbatim}
    Type `:bool -> bool`
\end{verbatim}

denotes exactly the same value (of \ML\ type {\small\verb%type%}) as

\begin{hol}\index{bool, the type in HOL logic@\ml{bool}, the type in
\HOL\ logic}
\begin{verbatim}
    mk_type("fun",[mk_type("bool",[]), mk_type("bool",[])])
\end{verbatim}\end{hol}

\noindent and

\begin{verbatim}
    Term `\x.x+1`
\end{verbatim}

\index{function abstraction, in HOL
logic@function abstraction, in \HOL\ logic}
\noindent can be used
instead of\footnote{In order to be processed successfully, the latter
quotation (which features a numeral) requires the theory of arithmetic
to have already been loaded. This can be accomplished by
{\tt load "arithmeticTheory"}.}

\newpage %PBHACK

{\small\baselineskip\HOLSpacing\begin{verbatim}

   mk_abs
    (mk_var("x",mk_type("num",[])),
     mk_comb
     (mk_comb
      (mk_const
       ("+",
        mk_type("fun",[mk_type("num",[]),
                       mk_type("fun",[mk_type("num",[]),
                                      mk_type("num",[])])])),
       mk_var("x", mk_type("num",[]))),
      mk_numeral (Arbnum.fromString "1")))
\end{verbatim}}

\index{type constraint!in HOL logic@in \HOL\ logic|(}It should be noted
that there is no  explicit type  information in {\small\verb%\x.x+1%}.
The \HOL\ type checker knows that \ml{1} has type \ml{num} and  \ml{+} has type
\ml{num->(num->num)}.  From this information it can infer that both occurrences
of {\small\verb%x%} in {\small\verb%\x.x+1%} could have type
{\small\verb%num%}.  This  is  not  the  only  possible type  assignment;  for
example, the first occurrence of {\small\verb%x%} could have type \ml{bool} and
the second one have type {\small\verb%num%}.  In that  case there  would be two
{\it different\/} variables with name {\small\verb%x%}, namely
{\small\verb%x%}$_{\tt bool}$ and  {\small\verb%x%}$_{\tt num}$,  the second of
which is free.  In fact, as mentioned, the only  way to  construct a
term with this second type assignment is  by using  constructors, since
the type checker uses the heuristic that all variables in a term with
the same name  have the  same type.   This is illustrated in the
following session.

\setcounter{sessioncount}{1}
\begin{session}\begin{verbatim}
  - Term `x = (x = 1)`;
  Type inference failure: unable to infer a type for the application of

  $= (x :num)

  which has type

  :num -> bool

  to

  (x :num) = (1 :num)

  which has type

  :bool

  unification failure message: unify failed

  - mk_eq
     (mk_var("x",mk_type("bool",[])),
      mk_eq
       (mk_var("x",mk_type("num",[])),
        mk_numeral (Arbnum.fromString "1")));
  > val it = `x = x = 1` : term
\end{verbatim}\end{session}

The original quotation type checker was designed and implemented by
Robin Milner\index{Milner, R.}.  It employs heuristics like the one
above to infer a sensible type for all variables occurring in a term.

At times, the user may want to
control the exact type of a subterm. To support such functionality,
types can be  explicitly indicated by following any subterm with a colon
and then a type.  For example, {\small\verb%Term `f(x:num):bool`%} will
type check with {\small\verb%f%} and {\small\verb%x%} getting types  {\small\verb%num->bool%} and {\small\verb%num%}
respectively.  \noindent This treatment of types within quotations is inherited from \LCF\index{LCF@\LCF}.
\index{type constraint!in HOL logic@in \HOL\ logic|)}
\index{ term quotes, in ML@\ml{`$\cdots$`} (term quotes, in \ML)|)}

The type inference \index{type checker, for HOL logic vs ML@type checker,
for \HOL\ logic {\it vs} \ML} algorithm used for the \HOL\ logic is
almost identical to that used for \ML. For example, the \ML\ expression
{\small\verb%fn x => x%}\index{terms, in HOL logic@terms, in \HOL\ logic!function abstraction}\index{function abstraction, in HOL logic@function abstraction, in \HOL\ logic!type checking of}\index{function abstraction, in HOL logic@function abstraction, in \HOL\ logic!syntax of}
will be ascribed \ML\ type {\small\verb%'a -> 'a%}, and the \HOL\ term constructed by
{\small\verb%Term `\x.x`%} will get an analogous type, as shown in the
session below. This session also shows that a \HOL\ term has both an \ML\ type
(namely {\small\verb%hol_type%}) and a \HOL\ type ({\small\verb%: 'a -> 'a%}
in this case).

\begin{session}\begin{verbatim}
- Term `\x. x`;
<<HOL message: inventing new type variable names: 'a.>>
> val it = `\x. x` : term

- type_of it;
> val it = `:'a -> 'a` : hol_type
\end{verbatim}\end{session}

\noindent For terms of polymorphic type, \ie, terms whose types have
type variables, the type checker will invent names for the type
variables (as in the above session).  This is further shown in the
following session (in which we first tell the \HOL\ printer to output
type information):

\begin{session}\begin{verbatim}
- show_types := true;
> val it = () : unit

- Term `f x`;
<<HOL message: inventing new type variable names: 'a, 'b.>>
> val it = `(f :'a -> 'b) (x :'a)` : term
\end{verbatim}\end{session}

\noindent In this example, {\small\verb%x%} is unconstrained in the term
{\small\verb+f x+}, since it appears only as an argument. The system assigns
it the type variable {\small\verb%'a%}. On the other hand, {\small\verb%f%} is a function,
since it is applied to {\small\verb%x%}. Thus {\small\verb%f%} has a
function type, the domain of which is {\small\verb%'a%}; moreover, since
the result of the application is also unconstrained, the range of the
function type is chosen to be the next type variable different from
{\small\verb%'a%}, \ie, {\small\verb%'b%}.

Allowing the system to invent type variables introduces a degree of
non-determinism that may not be suitable for some applications. In such
cases, explicit type constraints should be used. The system can be
prevented from inventing type variables by setting the flag
{\small\verb+Globals.guessing_tyvars+} to {\small\verb+false+}.

\subsection{Overloading}

A limited amount of overloading resolution is performed by the quotation
parser for terms. For example, the tilde symbol ({\small\verb+~+})
denotes boolean negation in the initial theory of \HOL\, and it also denotes
the additive inverse in the {\small\verb+integer+} and
{\small\verb+real+} theories. If we load the {\small\verb+integer+}
theory and enter an ambiguous term featuring {\small\verb+~+}, the
system will inform us that overloading resolution is being performed.

\setcounter{sessioncount}{1}
\begin{session}\begin{verbatim}
- load "integerTheory";
> val it = () : unit

- Term `~~x`;
<<HOL message: more than one resolution of overloading was possible.>>
> val it = `~~x` : term

- type_of it;
> val it = `:bool` : hol_type
\end{verbatim}\end{session}

A priority mechanism is used to resolve multiple possible choices. In
the example, {\small\verb+~+} could be consistently chosen to have type
{\small\verb+:bool -> bool+} or {\small\verb+:int -> int+}, and the
mechanism has chosen the former. For finer control, explicit type
constraints may be used. In the following session, the
{\small\verb+~~x+} in the first quotation has type {\small\verb+:bool+},
while in the second, a type constraint ensures that {\small\verb+~~x+} has
type {\small\verb+:int+}.

\begin{session}\begin{verbatim}
- show_types := true;
> val it = () : unit

- Term `~(x = ~~x)`;
<<HOL message: more than one resolution of overloading was possible.>>
> val it = `~((x :bool) = ~~x)` : term

- Term `~(x:int = ~~x)`;
> val it = `~((x :int) = ~~x)` : term
\end{verbatim}\end{session}

Note that the symbol {\small\verb+~+} stands for two different constants in
the second quotation; its first occurrence is boolean negation, while
the other two occurrences are the additive inverse operation for integers.
For more information on how to set up and use overloading, consult
\REFERENCE.


\subsection{Antiquotation}

Within a quotation, expressions of the form
{\small\verb%^(%}$t${\small\verb%)%}\index{ antiquotation, in HOL logic@{\small\verb+^+} (antiquotation, in \HOL\ logic)} (where $t$ is an \ML\ expression of
type\index{type checking, in HOL logic@type checking, in \HOL\ logic!antiquotation in} {\small\verb%term%} or {\small\verb%type%}) are called {\it
antiquotations\/}\index{terms, in HOL logic@terms, in \HOL\ logic!antiquotation}\index{antiquotation, in HOL logic terms@antiquotation, in \HOL\ logic terms}.
An antiquotation {\small\verb%^(%}$t${\small\verb%)%}
evaluates to the \ML\ value of $t$. For example,
{\small\verb%Term `x \/ ^(mk_conj(Term`y:bool`, Term`z:bool`))`%} evaluates to the same
term as {\small\verb%Term `x \/ (y /\ z)`%}. The most common use of antiquotation
is when the term $t$ is just an \ML\ variable $x$. In this case
{\small\verb%^(%}$x${\small\verb%)%} can be abbreviated by
{\small\verb%^%}$x$.

The following session illustrates antiquotation.

\setcounter{sessioncount}{1}
\begin{session}\begin{verbatim}
- load "arithmeticTheory";
> val it = () : unit

- val y = Term `x+1`;
> val y = `x + 1` : term

val z = Term `y = ^y`;
> val z = `y = x + 1` : term

- Term `!x:num.?y:num.^z`;
> val it = `!x. ?y. y = x + 1` : term
\end{verbatim}\end{session}

\noindent Types may be antiquoted as well:

\setcounter{sessioncount}{1}
\begin{session}\begin{verbatim}
- val pred = Type `:'a -> bool`;
> val pred = `:'a -> bool` : hol_type

- Type`:^pred -> bool`;
> val it = `:('a -> bool) -> bool` : hol_type
\end{verbatim}\end{session}

One requirement of the system is that antiquoting a type into a term
quotation requires the use of {\small\verb+ty_antiq+}. For example,

\begin{session}\begin{verbatim}
- Term `!P:^pred. P x ==> Q x`;

! Toplevel input:
! Term `!P:^pred. P x ==> Q x`;
!           ^^^^
! Type clash: expression of type
!   hol_type
! cannot have type
!   term

- Term `!P:^(ty_antiq pred). P x ==> Q x`;
> val it = `!P. P x ==> Q x` : term
\end{verbatim}\end{session}



\section{Ways to construct types and terms}

\index{type variables, in HOL logic@type variables, in \HOL\ logic!constructor for}
\index{type constructors!in HOL logic@in \HOL\ logic}
\index{term constructors, in HOL logic@term constructors, in \HOL\ logic|(}
\index{terms, in HOL logic@terms, in \HOL\ logic!constructors for|(}
The table below shows \ML\ expressions for various kinds of type
quotations\index{quotation, in HOL logic@quotation, in \HOL\ logic!of types}.
The expressions in the same row are equivalent.

\bigskip


\begin{center}
\index{compound types, in HOL logic@compound types, in \HOL\ logic!constructors for}
\index{ type variables, in HOL logic@\ml{*,\,**,\,}$\ldots$ (type variables, in \HOL\ logic)}
\index{types, in HOL logic@types, in \HOL\ logic!constructors for}
\index{ function type operator, in HOL logic@\ml{->} (function type operator, in \HOL\ logic)}
\index{mk_vartype@\ml{mk\_vartype}}
\index{mk_type@\ml{mk\_type}}
\begin{tabular}{|l|l|l|} \hline
\multicolumn{3}{|c|}{ } \\
\multicolumn{3}{|c|}{\bf Types} \\
\multicolumn{3}{|c|}{ } \\
{\it Kind of type} & {\it \ML\ quotation} &
{\it Constructor expression}  \\ \hline
 & & \\
Type variable &
{\small\verb+: '+}{\small $alphanum$}  & {\small\verb%mk_vartype("'%$alphanum$\verb%")%}   \\ \hline
Type constant &
$:op$ & {\small\verb%mk_type("%}$op${\small\verb%",[])%}   \\ \hline
Function type &
$: \sigma_1$ {\small\verb%->%} $\sigma_2$ &
{\small\verb%mk_type("fun", [%} $\sigma_1$ {\small\verb%,%} $\sigma_2$ {\small\verb%])%} \\ \hline
Compound type &
{\small\verb+:(+}$\sigma_1${\small\verb%,%} $\ldots$ {\small\verb%,%} $\sigma_n${\small\verb%)%}$op$ &
{\small\verb%mk_type("%}$op${\small\verb%", [%}
 $\sigma_1$ {\small\verb%,%} $\ldots$ {\small\verb%,%} $\sigma_n${\small\verb%])%}
\\ \hline
\end{tabular}
\end{center}

\index{type quotes, in ML@\ml{`:$\cdots$`} (type quotes, in \ML)|)}

\index{terms, in HOL logic@terms, in \HOL\ logic!syntax of|(}

Equivalent ways of inputting the four primitive kinds of term are shown in
the next table.

\bigskip

\begin{center}
\index{combinations, in HOL logic@combinations, in \HOL\ logic!quotation of}
\index{terms, in HOL logic@terms, in \HOL\ logic!primitive}
\index{terms, in HOL logic@terms, in \HOL\ logic!constructors for}
\index{quotation, in HOL logic@quotation, in \HOL\ logic!of primitive terms}
\index{function abstraction, in HOL logic@function abstraction, in \HOL\ logic!symbol for}
\index{function application, in HOL logic@function application, in \HOL\ logic!constructor for}
\index{function application, in HOL logic@function application, in \HOL\ logic!syntax of}
\index{variables, in HOL logic@variables, in \HOL\ logic!constructor for}
\index{variables, in HOL logic@variables, in \HOL\ logic!syntax of}
\index{mk_var@\ml{mk\_var}}
\index{mk_const@\ml{mk\_const}}
\index{mk_comb@\ml{mk\_comb}}
\index{mk_abs@\ml{mk\_abs}}
\begin{tabular}{|l|l|l|} \hline
\multicolumn{3}{|c|}{ } \\
\multicolumn{3}{|c|}{\bf Primitive terms} \\
\multicolumn{3}{|c|}{ } \\
{\it Kind of term} & {\it \ML\ quotation} &
{\it Constructor expression}  \\ \hline
 & & \\
Variable & $var${\small\verb%:%}$\sigma$ &
{\small\verb%mk_var("%}$var${\small\verb%",%}$\sigma${\small\verb%)%} \\ \hline
Constant & $const${\small\verb%:%}$\sigma$ &
{\small\verb%mk_const("%}$const${\small\verb%",%}$\sigma${\small\verb%)%} \\ \hline
Combination & $t_1\ t_2$ &
{\small\verb%mk_comb(%}$t_1${\small\verb%, %}$t_2${\small\verb%)%} \\ \hline
Abstraction & {\small\verb%\%}$x${\small\verb%.%}$t$ &
{\small\verb%mk_abs(%}$x${\small\verb%, %}$t${\small\verb%)%} \\ \hline
\end{tabular}
\end{center}\index{type checking, in HOL logic@type checking, in \HOL\ logic!of quotation syntax|)}

\subsection{Derived syntactic forms}\label{derived-terms}

\index{type checking, in HOL logic@type checking, in \HOL\ logic!special forms in|(}
\index{quotation, in HOL logic@quotation, in \HOL\ logic!of non-primitive terms|(}
The \HOL\ quotation parser\index{quotation, in HOL logic@quotation, in \HOL\ logic!parser for} can translate
various standard logical notations\index{parsing, of HOL logic@parsing,
of \HOL\ logic!of standard notations} into primitive terms. For example,
if {\small\verb%+%} has been
declared an infix\index{infixes, in HOL logic@infixes, in \HOL\ logic}
(as explained in Section~\ref{theoryfns}) (as it is when
{\small\verb+arithmeticTheory+} has been loaded), then
{\small\verb%`x+1`%} is translated to {\small\verb%`$+ x 1`%}. The escape
character {\small\verb%$%}\index{ escape, in HOL logic parser@{\small\verb+$+} (escape, in \HOL\ logic parser)}\index{declared constants, in HOL logic@declared constants, in \HOL\ logic}\index{infixes, in HOL logic@infixes, in \HOL\ logic}
 suppresses the infix behaviour of
{\small\verb%+%} and prevents the quotation parser getting confused.  In
general, {\small\verb%$%} can be used to suppress any special syntactic
behaviour a constant name\index{constants, in HOL logic@constants, in \HOL\ logic!supressing parsing behaviour of} might have. This is illustrated in the table
below, in which the terms in the column headed `{\it \ML\ quotation}' are
translated by the quotation parser to the corresponding terms in the column
headed `{\it Primitive term\/}'. Conversely, the terms in the latter
column are always printed in the form shown in the former one.
\label{cond}The \ML\ constructor expressions in the rightmost column
evaluate to the same values (of type {\small\verb%term%}) as the other
quotations in the same row.

\bigskip

\begin{center}
\index{choice operator, in HOL logic@choice operator, in \HOL\ logic!syntax of}
\index{ negation, in HOL logic@{\small\verb+~+} (negation, in \HOL\ logic)}
\index{ disjunction, in HOL logic@{\small\verb+\/+} (disjunction, in \HOL\ logic)}
\index{ conjunction, in HOL logic@{\small\verb+/\+} (conjunction, in \HOL\ logic)}
\index{ implication, in HOL logic@{\small\verb+==>+} (implication, in \HOL\ logic)}
\index{ equality, in HOL logic@\ml{=} (equality, in \HOL\ logic)}
\index{ universal quantifier, in HOL logic@{\small\verb+"!+} (universal quantifier, in \HOL\ logic)}
\index{ existential quantifier, in HOL logic@{\small\verb+?+} (existential quantifier, in \HOL\ logic)}
\index{ choice function, in HOL logic@{\small\verb+"@+} (choice function, in \HOL\ logic)}
\index{terms, in HOL logic@terms, in \HOL\ logic!non-primitive}
\index{terms, in HOL logic@terms, in \HOL\ logic!constructors for}
\index{conditional predicate, in HOL logic@conditional predicate, in \HOL\ logic}
\index{conditionals, in HOL logic@conditionals, in \HOL\ logic}
\index{conjunction, in HOL logic@conjunction, in \HOL\ logic!constructor for}
\index{disjunction, in HOL logic@disjunction, in \HOL\ logic!constructor for}
\index{equality, in HOL logic@equality, in \HOL\ logic!syntax of}
\index{negation, in HOL logic@negation, in \HOL\ logic!syntax of}
\index{negation, in HOL logic@negation, in \HOL\ logic!constructor for}
\index{existential quantifier, in HOL logic@existential quantifier, in \HOL\ logic!syntax of}
\index{universal quantifier, in HOL logic@universal quantifier, in \HOL\ logic!syntax of}
\index{implication, in HOL logic@implication, in \HOL\ logic!syntax of}
\index{mk_neg@\ml{mk\_neg}}
\index{mk_disj@\ml{mk\_disj}}
\index{mk_conj@\ml{mk\_conj}}
\index{mk_imp@\ml{mk\_imp}}
\index{mk_eq@\ml{mk\_eq}}
\index{mk_forall@\ml{mk\_forall}}
\index{mk_exists@\ml{mk\_exists}}
\index{mk_select@\ml{mk\_select}}
\index{mk_cond@\ml{mk\_cond}}
\index{mk_let@\ml{mk\_let}}
\index{conjunction, in HOL logic@conjunction, in \HOL\ logic!syntax of}
\begin{tabular}{|l|l|l|l|} \hline
\multicolumn{4}{|c|}{ } \\
\multicolumn{4}{|c|}{\bf Non-primitive terms} \\
\multicolumn{4}{|c|}{ } \\
{\it Kind of term} & {\it \ML\ quotation} &
{\it Primitive term} &
{\it Constructor expression} \\ \hline
 & & & \\
Negation & {\small\verb%~%}$t$ & {\small\verb%$~ %}$t$ & {\small\verb%mk_neg(%}$t${\small\verb%)%} \\ \hline
Disjunction & $t_1${\small\verb%\/%}$t_2$ & {\small\verb%$\/ %}$t_1\ t_2$ &
{\small\verb%mk_disj(%}$t_1${\small\verb%,%}$t_2${\small\verb%)%} \\ \hline
Conjunction & $t_1${\small\verb%/\%}$t_2$ & {\small\verb%$/\ %}$t_1\ t_2$ &
{\small\verb%mk_conj(%}$t_1${\small\verb%,%}$t_2${\small\verb%)%} \\ \hline
Implication & $t_1${\small\verb%==>%}$t_2$ & {\small\verb%$==> %}$t_1\ t_2$ &
{\small\verb%mk_imp(%}$t_1${\small\verb%,%}$t_2${\small\verb%)%} \\ \hline
Equality & $t_1${\small\verb%=%}$t_2$ & {\small\verb%$= %}$t_1\ t_2$ &
{\small\verb%mk_eq(%}$t_1${\small\verb%,%}$t_2${\small\verb%)%} \\ \hline
$\forall$-quantification & {\small\verb%!%}$x${\small\verb%.%}$t$ &
{\small\verb%$!(\%}$x${\small\verb%.%}$t${\small\verb%)%} & {\small\verb%mk_forall(%}$x${\small\verb%,%}$t${\small\verb%)%} \\ \hline
$\exists$-quantification & {\small\verb%?%}$x${\small\verb%.%}$t$ &
{\small\verb%$?(\%}$x${\small\verb%.%}$t${\small\verb%)%} & {\small\verb%mk_exists(%}$x${\small\verb%,%}$t${\small\verb%)%} \\ \hline
$\hilbert$-term & {\small\verb%@%}$x${\small\verb%.%}$t$ &
{\small\verb%$@(\%}$x${\small\verb%.%}$t${\small\verb%)%} & {\small\verb%mk_select(%}$x${\small\verb%,%}$t${\small\verb%)%} \\ \hline
Conditional\index{COND@\ml{COND}} & {\small\verb%(%}$t${\small\verb%=>%}$t_1${\small\verb%|%}$t_2${\small\verb%)%} &
{\small\verb%COND %}$t\ t_1\ t_2$ & {\small\verb%mk_cond(%}$t${\small\verb%,%}$t_1${\small\verb%,%}$t_2${\small\verb%)%}
 \\ \hline
{\small\verb%let%}-expression & {\small\verb%let %}$x${\small\verb%=%}$t_1${\small\verb% in %}$t_2$ &
{\small\verb%LET(\%}$x${\small\verb%.%}$t_2${\small\verb%)%}$t_1$ &
{\small\verb%mk_let(\%}$x${\small\verb%.%}$t_1${\small\verb%,%}$t_2${\small\verb%)%} \\ \hline
\end{tabular}
\end{center}

\bigskip

There are constructors, destructors and indicators for all the
obvious constructs. (Indicators, \eg\ \ml{is\_neg}, return truth
values indicating whether or not a term belongs to the syntax
class in question.) In addition to the constructors listed in the table there
are constructors, destructors, and indicators for pairs and lists, namely
\ml{mk\_pair}\index{mk_pair@\ml{mk\_pair}},
\ml{mk\_cons}\index{mk_cons@\ml{mk\_cons}} and
\ml{mk\_list}\index{mk_list@\ml{mk\_list}} (see \REFERENCE).
The constants {\small\verb%COND%}\index{COND@\ml{COND}} and {\small\verb%LET%} are explained in
Sections~\ref{conditionals} and \ref{let-exp}, respectively.
The constants {\small\verb%\/%}\index{disjunction, in HOL logic@disjunction, in \HOL\ logic!syntax of}, {\small\verb%/\%},
{\small\verb%==>%} and {\small\verb%=%} are examples of {\it infixes\/}
and represent $\vee$, $\wedge$, $\imp$ and equality, respectively. If
$c$ is declared to be an infix, then the \HOL\ parser will translate
$t_1\ c\ t_2$ to
{\small\verb%$%}$c\ t_1\ t_2$.

The constants {\small\verb%!%}, {\small\verb%?%} and {\small\verb%@%} are examples
of \label{binder} {\it binders\/}\index{binders, in HOL logic@binders, in \HOL\ logic}
 and represent $\forall$, $\exists$ and $\hilbert$, respectively.  If $c$
is declared to be a binder, then the
\HOL\ parser will translate $c\ x${\small\verb%.%}$t$ to the combination
{\small\verb%$%}$c${\small\verb%(\%}$x${\small\verb%.%}$t${\small\verb%)%}
(\ie\ the application of the constant $c$ to the representation of
the abstraction $\lquant{x}t$)\index{ function abstraction binder, in HOL logic@{\small\verb+\+} (function abstraction binder, in \HOL\ logic)}.

In addition to the kinds of terms in the tables above,
the parser also supports the following syntactic abbreviations.


\begin{center}

\index{variables, in HOL logic@variables, in \HOL\ logic!multiple bound}
\index{list_mk_comb@\ml{list\_mk\_comb}|pin}
\index{list_mk_abs@\ml{list\_mk\_abs}|pin}
\index{list_mk_forall@\ml{list\_mk\_forall}|pin}
\index{list_mk_exists@\ml{list\_mk\_exists}|pin}
\index{combinations, in HOL logic@combinations, in \HOL\ logic!abbreviation for multiple}
\index{existential quantifier, in HOL logic@existential quantifier, in \HOL\ logic!abbreviation for multiple}
\index{universal quantifier, in HOL logic@universal quantifier, in \HOL\ logic!abbreviation for multiple}
\begin{tabular}{|l|l|l|} \hline
\multicolumn{3}{|c|}{ } \\
\multicolumn{3}{|c|}{\bf Syntactic abbreviations} \\
\multicolumn{3}{|c|}{ } \\
{\it Abbreviated term} & {\it Meaning} &
{\it Constructor expression} \\ \hline
 & &  \\
$t\ t_1 \cdots t_n$ &
{\small\verb%(%}$\cdots${\small\verb%(%}$t\ t_1${\small\verb%)%}$\cdots t_n${\small\verb%)%} &
{\small\verb%list_mk_comb(%}$t${\small\verb%,[%}$t_1${\small\verb%, %}$\ldots${\small\verb% ,%}$t_n${\small\verb%])%} \\ \hline
{\small\verb%\%}$x_1\cdots x_n${\small\verb%.%}$t$ &
{\small\verb%\%}$x_1${\small\verb%. %}$\cdots${\small\verb% \%}$x_n${\small\verb%.%}$t$ &
{\small\verb%list_mk_abs([%}$x_1${\small\verb%, %}$\ldots${\small\verb% ,%}$x_n${\small\verb%],%}$t${\small\verb%)%}
\\ \hline
{\small\verb%!%}$x_1\cdots x_n${\small\verb%.%}$t$ &
{\small\verb%!%}$x_1${\small\verb%. %}$\cdots${\small\verb% !%}$x_n${\small\verb%.%}$t$ &
{\small\verb%list_mk_forall([%}$x_1${\small\verb%, %}$\ldots${\small\verb% ,%}$x_n${\small\verb%],%}$t${\small\verb%)%}
\\ \hline
{\small\verb%?%}$x_1\cdots x_n${\small\verb%.%}$t$ &
{\small\verb%?%}$x_1${\small\verb%. %}$\cdots${\small\verb% ?%}$x_n${\small\verb%.%}$t$ &
{\small\verb%list_mk_exists([%}$x_1${\small\verb%, %}$\ldots${\small\verb% ,%}$x_n${\small\verb%],%}$t${\small\verb%)%} \\
\hline
\end{tabular}
\end{center}

\noindent There are also constructors
\ml{list\_mk\_conj}\index{list_mk_conj@\ml{list\_mk\_conj}},
\ml{list\_mk\_disj}\index{list_mk_disj@\ml{list\_mk\_disj}},
\ml{list\_mk\_imp}\index{list_mk_imp@\ml{list\_mk\_imp}} and
\ml{list\_mk\_pair}\index{list_mk_pair@\ml{list\_mk\_pair}}
for conjunctions, disjunctions, implications and tuples respectively.
The corresponding destructor functions are called \ml{strip\_comb}, \etc,
\index{term constructors, in HOL logic@term constructors, in \HOL\ logic|)}
\index{terms, in HOL logic@terms, in \HOL\ logic!constructors for|)}


\section{Theorems}
\label{avra_theorems}
% I have added this section in a hurry 9 Nov 89.  Was missing!

In Chapter~\ref{logic}, the notion of deduction was introduced in terms
of {\it sequents\/}\index{sequents!in natural deduction}, where a sequent
is a pair whose second component is a formula being
asserted (a conclusion)\index{conclusions!of sequents},
and whose first component is a set of formulas (hypotheses)\index{hypotheses!of sequents}.
Based on this was the notion of a {\it deductive system\/}\index{natural deduction}\index{deductive systems}: a set of pairs,
whose second component is a sequent, and
whose first component is a sequent list\footnote{Note that these sequents
form a list, not a set; that is, are ordered.}.
The concept of a sequent {\it following from\/}\index{follows from, in natural deduction}
a set of sequents via a
deductive system was then defined: a sequent follows from a set of sequents if
the sequent
is the last element of some chain of sequents, each of whose
elements is either in the set, or itself follows from the set along with
earlier elements of the chain, via the deductive system.

A notation for `follows from' was then introduced.
That a
sequent $(\{t_1,\ldots,t_n\},\ t)$ follows from
a set of sequents $\Delta$, via a deductive system ${\cal D}$, is
denoted\index{turnstile notation|(} by: $t_1,\ldots,t_n\vdash_{{\cal D},\Delta} t$.
(It was noted that
where either ${\cal D}$ or $\Delta$ were clear by context, their mention
could be omitted; and where the set of hypotheses was empty,
its mention could be omitted.)

A sequent that follows from the empty set of sequents via
a deductive system is called a {\it theorem\/} of that deductive system.
That is, a theorem\index{theorems, in natural deduction} is the last element of a {\it proof\/}\index{proof!in natural deduction} (in the sense
of Chapter~\ref{logic}) from the empty
set of sequents. When a pair $(L,(\Gamma,t))$ belongs to a deductive system,
and the list $L$ is empty,
then the sequent $(\Gamma,t)$ is called an {\it axiom\/}\index{axioms!in
natural deduction}.
Any pair $(L,(\Gamma,t))$ belonging to
a deductive system is called a {\it primitive inference\/}\index{inference, in natural deduction}\index{primitive inference, in natural deduction}
of the system, with hypotheses\footnote{Note that
`hypotheses' and `conclusion' are also used for the components
of sequents.} $L$ and
conclusion $(\Gamma,t)$.

A formula\index{formulas as terms, in HOL logic@formulas as terms, in \HOL\ logic}
 in the abstract is represented concretely in \HOL\ by
a term whose \HOL\ type is {\small\verb%":bool"%}.
Therefore, a term\index{terms, in HOL logic@terms, in \HOL\ logic!as logical formulas} of type {\small\verb%":bool"%} is used to represent
a member of the set of hypotheses of a sequent;
and likewise to represent the
conclusion of a sequent.
Sets in this context
are represented by lists, so the set of hypotheses of a sequent\index{sequents!representation of, in HOL logic@representation of, in \HOL\ logic}
is represented by a list of {\small\verb%`:bool`%}-typed terms.

A theorem in the abstract is represented concretely in the \HOL\
system by a value with the \ML\ abstract type
{\small\verb%thm%}\index{thm@\ml{thm}}.
The type {\small\verb%thm%} has a primitive destructor function

\begin{boxed}
\index{dest_thm@\ml{dest\_thm}|pin}
\begin{verbatim}
   dest_thm : thm -> (term list * term)
\end{verbatim}\end{boxed}

\noindent which returns a pair consisting of the hypothesis\index{hypotheses!of theorems} list and
the conclusion\index{conclusions!of theorems}, respectively, of a theorem.
From this, two destructor\index{theorems, in HOL logic@theorems, in \HOL\ logic!destructors for} functions are derived


\begin{boxed}
\index{hyp@\ml{hyp}|pin}
\index{concl@\ml{concl}|pin}
\begin{verbatim}
   hyp   : thm -> term list
   concl : thm -> term
\end{verbatim}\end{boxed}

\noindent for extracting the hypothesis list and the conclusion, respectively,
of a theorem. The \ML\ type {\small\verb%thm%} does not have
a primitive constructor function.  In this way, the \ML\ type system protects
the \HOL\ logic
from the arbitrary and unrecorded construction
of theorems, which would compromise
the consistency\index{consistency, of HOL logic@consistency, of \HOL\ logic} of the logic. (Functions which return theorems as values,
\eg\ functions representing primitive inferences,
are discussed first in Section~\ref{rules}, and further in
Chapter\ref{derived-rules}.)

It was mentioned in Chapter~\ref{logic} that the deductive system of \HOL\
includes five axioms\footnote{This is
a simplification:
%each inference rule corresponds to an infinite family of elements
%of the deductive system, and
the axioms are an extension
of the basic logic. See Sections~\ref{boolthy} and \ref{ind}.}.
In that Chapter, the axioms were presented in abstract form.
The concrete representation of the axioms in \HOL\ is given
in Section~\ref{HOL-theory}.
% and of the inference rules, in
%Section~\ref{rules}.
To anticipate, the axiom \ml{BOOL\_CASES\_AX}
mentioned in Chapter~\ref{logic} is printed in \HOL\ as follows
(where \ml{T} and \ml{F}
are the \HOL\ logic's constants representing truth and
falsity, respectively):

\begin{hol}
\index{F@\ml{F}!axiom for}
\begin{verbatim}
   |- !t. (t = T) \/ (t = F) : thm
\end{verbatim}\end{hol}

\noindent Note the special print format\index{printing, in HOL logic@printing, in \HOL\ logic!of theorems},
 with the approximation
to the abstract $\vdash$ notation\index{theorem notation, in HOL logic@theorem notation, in \HOL\ logic|(}, \ml{|-}, used to indicate \ML\ type
{\small\verb%thm%} status;
as well as the absence of \HOL\ quotation marks\index{ theorem marker, in HOL logic@\ml{"|-} (theorem marker, in \HOL\ logic)}
 in the \ml{|-} context.
The session below illustrates the use of the destructor functions:

\setcounter{sessioncount}{1}
\begin{session}\begin{verbatim}
- val th = BOOL_CASES_AX;
> val th = |- !t. (t = T) \/ (t = F) : thm

- hyp th;
> val it = [] : term list

- concl th;
> val it = `!t. (t = T) \/ (t = F)` : term

- type_of it;
> val it = `:bool` : hol_type
\end{verbatim}\end{session}\index{turnstile notation|)}

\noindent In addition to the print conventions mentioned above,
the printing of theorems prints hypotheses\index{printing, in HOL logic@printing, in \HOL\ logic!of hypotheses of theorems}
 as periods (\ie\ full stops or
dots).  The flag \ml{show\_assums}\index{show_assums@\ml{show\_assums}} prints theorems with
hypotheses shown in full. These points are illustrated with a
theorem inferred, for example purposes, from another axiom mentioned
in Chapter~\ref{logic}: \ml{SELECT\_AX}.

\setcounter{sessioncount}{1}
\begin{session}\begin{verbatim}
- val th = UNDISCH (SPEC_ALL SELECT_AX);
> val th =  [.] |- P ($@ P) : thm

- show_assums := true;
> val it = () : unit

- th;
> val it =  [P x] |- P ($@ P) : thm
\end{verbatim}\end{session}\index{theorem notation, in HOL logic@theorem notation, in \HOL\ logic|)}

\section{Theories}\index{theories, in HOL logic@theories, in \HOL\ logic!representation of|(}
\label{theoryfns}

In Chapter~\ref{logic} a theory is described as a $4$-tuple

\[ {\cal T}\ =\ \langle{\sf Struc}_{\cal T},\
                {\sf Sig}_{\cal T},\
                {\sf Axioms}_{\cal T},\
                {\sf Theorems}_{\cal T}\rangle \]

\noindent where
\begin{myenumerate}
\item ${\sf Struc}_{\cal T}$ is
the type structure of ${\cal T}$;
\item ${\sf Sig}_{\cal T}$ is
the signature of ${\cal T}$;
\item ${\sf Axioms}_{\cal T}$ is
the set of axioms of ${\cal T}$;
\item ${\sf Theorems}_{\cal T}$ is the set of
theorems of ${\cal T}$.
\end{myenumerate}

Theories are structured hierarchically to represent sequences of
extensions called \emph{segments}\index{theory segments} of an initial
theory (see Section~\ref{extensions}) called
\ml{min}\index{min@\ml{min}}. A theory segment is not really a logical
concept, but rather a concept of the representation of theories in the
\HOL\ system. Each segment records some types, constants, axioms and
theorems, together with pointers to other segments called its {\it
parents\/}\index{parents, of HOL theories@parents, of \HOL\ theories}.
The theory represented by a segment is obtained by taking the
union of all the types, constants, axioms and theorems in the segment,
together with the types, constants, axioms and theorems in all the
segments reachable by following pointers to parents. This collection
of reachable segments is called the {\it ancestry\/}\index{ancestry,
of HOL system theories@ancestry, of \HOL\ system
theories}\index{theories, in HOL logic@theories, in \HOL\
logic!hierarchies of} of the segment.

A typical\index{HOL system@\HOL\ system!typical work in} piece of work
with the \HOL\ system consists in a number of sessions\index{sessions
with HOL system@sessions, with \HOL\ system}.  In the first of these, a
new theory, ${\cal T}$ say, is created by importing some existing theory
segments, making a number of definitions, and perhaps proving and
storing some theorems in the current segment. Then the current segment
(named $name$ say) is exported. The concrete result will be an \ML\
module $name$\ml{Theory} whose contents is the current theory segment
created during the session and whose ancestry represents the desired
logical theory ${\cal T}$. Subsequent work sessions can access the
definitions and theorems of ${\cal T}$ by importing $name$\ml{Theory};
this avoids having to load the tools and replay
the proofs that created $name$\ml{Theory} in the first place.

The naming of data in theories is based on the names given to segments.
Specifically an axiom, definition, specification or theorem is
accessed\index{theories, in HOL logic@theories, in \HOL\ logic!naming of}
by an \ML\ long identifier $thy${\small\verb+Theory.+}$name$, where
$thy$ is the name of the theory segment current when the item was
declared and $name$ is a specific name supplied by the user (see the
functions \ml{new\_axiom}, \ml{new\_definition}, below). Different items
can have the same specific name if the associated segment is different.
Thus each theory segment provides a separate namespace of ML bindings of
\HOL\ items.

Various additional pieces of information are stored in a theory
segment, including the parsing status of the constants (\eg\ whether
they are infixes or binders).

There is always a \emph{current theory} which is the theory
represented by the current theory segment together with its
ancestry. The name of the current theory segment is returned by the \ML\
function:

\begin{boxed}\index{current_theory@\ml{current\_theory}|pin}
\begin{verbatim}
   current_theory : unit -> string
\end{verbatim}\end{boxed}

On startup, the current theory segment of \HOL\ is named \ml{scratch},
which is an empty theory, having the theory {\small\verb+bool+} as its sole
parent. This is a very simple logical setting; for example, common types
such as numbers and pairs are not present. Typically, a user would begin
by loading whatever specific logical context is required.

\subsection{Primitive ML functions for creating theories}
\label{theoryprims}

The \ML\ functions for creating theories and manipulating
\index{theories, in HOL logic@theories, in \HOL\ logic!creation of|(}
are listed below.

\begin{boxed}
\index{new_theory@\ml{new\_theory}|pin}
\begin{verbatim}
   new_theory : string -> unit
\end{verbatim}\end{boxed}

\noindent One creates a new theory segment by a call to
\verb+new_theory+.  This allocates a new `area' where subsequent theory
operations take effect. If the current theory ($thy_1$ say) at the time
of a call to {\small\verb+new_theory +}$thy_2$ is non-empty, \ie, has
had an axiom, definition, or theorem stored in it, then $thy_1$ is
exported before $thy_2$ is allocated. Furthermore, $thy_2$ will obtain
$thy_1$ as a parent. If {\small\verb+new_theory +}$thy$ is called when
the current theory segment is already named $thy$, then that is
interpreted as a request merely to clear the current theory segment
(nothing will be exported).

A call to {\small\verb+new_theory "+}$name${\small\verb+"+} fails if:
\begin{itemize}

\item $name$ is not an alphanumeric starting with a letter.

\item there is a theory already named $name$ in the ancestry of the
current segment.

\item if it is necessary to export the current segment before creating
the new theory and the export attempt fails.

\end{itemize}

The current theory segment acts as a kind of scratchpad. Elements stored
in the current segment may be overwritten by subsequent additions, or
deleted outright. Any theory elements that were built from overwritten
or deleted elements are now held to be {\it out-of-date}, and will not
be included in the theory when it is finally exported.  Out-of-date
constants and types are detected by the \HOL\ printer, which will print
them surrounded by odd-looking syntax to alert the user.

In contrast to the current segment, (proper) ancestor segments may not
be altered.

Since \HOL\ theories are represented by \ML\ modules, one imports an
existing theory segment by simply importing the corresponding module.

\begin{boxed}
\index{load@\ml{load|pin}}
\begin{verbatim}
   load : string -> unit
\end{verbatim}\end{boxed}

Executing {\small\verb+load +}$name${\small\verb+Theory+} imports the
first file named $name${\small\verb+Theory.uo+} found along the
{\small\verb+loadPath+} into the session. Any unloaded ancestors of
$name$ will be loaded before loading of $name${\small\verb+Theory+}
continues.

\begin{boxed}
\index{new_type@\ml{new\_type}|pin}
\begin{verbatim}
   new_type : int -> string -> unit
\end{verbatim}\end{boxed}


\noindent Executing \ml{new\_type}$\ n\ \ml{"\ty{op}"}$ makes \ty{op}
a new $n$-ary type operator\index{type operators, in HOL logic@type
operators, in \HOL\ logic!declaration} in the current theory.
Failure if:
\begin{myenumerate}
\item there already exists a type operator named $\ty{op}$ in an ancestor
      theory segment.
\item \ty{op} is not an allowed name for a type.
\end{myenumerate}


\begin{boxed}
\index{new_constant@\ml{new\_constant}|pin}
\begin{verbatim}
   new_constant : (string * type) -> unit
\end{verbatim}\end{boxed}

\noindent Executing {\small\verb%new_constant("%}$c${\small\verb%",%}$\sigma${\small\verb%)%} makes
$c_{\sigma'}$ a new constant\index{constants, in HOL logic@constants, in \HOL\ logic!declaration of} of the current theory,
for all $c_{\sigma'}$ where $\sigma'$ is an instance of $\sigma$.
The type $\sigma$ is
called the {\it generic type\/}\index{generic types, in HOL logic@generic types, in \HOL\ logic} of $c$. Failure if:
\begin{myenumerate}
\item there already exists a constant named $c$ in an ancestor theory segment.
\end{myenumerate}

\begin{boxed}
\index{new_infix@\ml{new\_infix}|pin}
\begin{verbatim}
   new_infix : (string * type) -> unit
\end{verbatim}\end{boxed}


\noindent Executing \ml{new\_infix("}$ix$\ml{",}$\sigma$\ml{)}
declares $ix$ to be a new constant with generic type $\sigma$ and
infix status.
Failure if:
\begin{myenumerate}
\item there already exists a constant named $ix$ in an ancestor theory segment;
\item $\sigma$ not of the form \ml{$\sigma_1$->$\sigma_2$->$\sigma_3$}.
\end{myenumerate}


\begin{boxed}
\index{new_binder@\ml{new\_binder}|pin}
\begin{verbatim}
   new_binder : (string * type) -> unit
\end{verbatim}\end{boxed}


\noindent Executing \ml{new\_binder("}$b$\ml{",}$\sigma$\ml{)}\index{binders, in HOL logic@binders, in \HOL\ logic!declaration of}
declares $b$ to be a new constant with generic type $\sigma$ and
binder status.
Failure if:
\begin{myenumerate}
\item there already exists a constant named $b$ an ancestor theory segment;
\item $\sigma$ not of the form \ml{($\sigma_1$->$\sigma_2$)->$\sigma_3$}.
\end{myenumerate}

\begin{boxed}
\index{new_axiom@\ml{new\_axiom}|pin}
\begin{verbatim}
   new_axiom : (string * term) -> thm
\end{verbatim}\end{boxed}


\noindent Executing \ml{new\_axiom("}$name$\ml{",}$t$\ml{)} declares the
sequent
\ml{(\{\},$t$)} to be an axiom\index{axioms!declaration of, in HOL logic@declaration of, in \HOL\ logic} of the current theory with name $name$.
Failure if:
\begin{myenumerate}
\item $t$ contains out-of-date constants or types.
\end{myenumerate}


Once a theorem has been proved, it can be saved with the function

\begin{boxed}
\index{save_thm@\ml{save\_thm}|pin}
\begin{verbatim}
   save_thm : (string * thm) -> thm
\end{verbatim}\end{boxed}

\noindent Evaluating \ml{save\_thm("}$name$\ml{",}$th$\ml{)} will save
the theorem\index{theorems, in HOL logic@theorems, in \HOL\ logic!saving
of}\index{saving theorems} $th$ with name $name$ in the current theory
segment.

Once a theory segment has been constructed, it can be written out to a
file, which, after compilation, can be imported into future sessions.

\begin{boxed}
\index{export_theory@\ml{export\_theory}|pin}
\begin{verbatim}
    export_theory : unit -> unit
\end{verbatim}\end{boxed}

When {\small\verb+export_theory+} is called, all out-of-date entities
are removed from the current segment. Also, the parenthood of the theory
is computed. The current theory segment is written to file
$name${\small{\tt Theory.sml}} in the current working directory.  The
file $name${\small{\tt Theory.sig}}, which documents the contents of
$name$, is also written to the current working directory.  Notice that
the exported theory is not compiled by \HOL. That is left to an external
tool, {\small\verb+Holmake+}, which maintains dependencies among
collections of \HOL\ theory segments.

\subsection{Functions for creating definitional extensions}\index{extension, of HOL logic@extension, of \HOL\ logic!definitional}\index{definitional extension, of HOL logic@definitional extension, of \HOL\ logic}\index{theories, in HOL logic@theories, in \HOL\ logic!extension of|(}
\label{avra_definitional}

There are three kinds of definitional extensions:
constant definitions, constant specifications and type definitions.

\subsubsection{Constant definitions}

In Section~\ref{defs} a constant definition\index{extension, of HOL logic@extension, of \HOL\ logic!by constant definition}\index{constant definition extension, of HOL logic@constant definition extension, of \HOL\ logic!ML function for@\ML\ function for|(}
over a signature $\Sigma_{\Omega}$ is defined to be
an equation, \ie\ a formula of the form $c_{\sigma}=t_{\sigma}$,
such that:
\begin{myenumerate}
\item $c$ is not the name of any constant in $\Sigma_{\Omega}$;
\item $t_{\sigma}$ is a closed term in ${\sf Terms}_{\Sigma_{\Omega}}$;
\item all the type variables occurring in $t_{\sigma}$ occur in $\sigma$.
\end{myenumerate}

In \HOL, definitions can be slightly more general than this, in that
an equation:

\[ c\ v_1\ \cdots\ v_n\ =\ t \]

\noindent is  allowed  to  be a  definition where  $v_1$, $\dots$, $v_n$ are
variable structures (\ie\ tuples of distinct variables).   Such  an equation is
logically equivalent to:

\[ c\ =\ \lambda v_1\ \cdots\ v_n.\  t \]

\noindent which is a definition in the sense of  Section~\ref{defs} if (i),
(ii) and (iii) hold.

The following  \ML\ function  creates\index{defining mechanisms, for HOL logic@defining mechanisms, for \HOL\ logic} a  new definition in
the current theory.

\begin{boxed}
\index{new_definition@\ml{new\_definition}|pin}
\begin{verbatim}
   new_definition : (string * term) -> thm
\end{verbatim}\end{boxed}


\noindent Evaluating
 \ml{new\_definition("}$name$\ml{",\ }$c\ v_1\ \cdots\ v_n\ =\ t$\ml{)},
where $c$ is not already a constant, declares the sequent
\ml{(\{\},$\lambda v_1\ \cdots\ v_n.\  t$)} to be a constant definition\index{definitions, adding to HOL logic@definitions, adding to \HOL\ logic}
of the current theory. The name associated with the definition in
this theory is $name$.
Failure if:
\begin{myenumerate}
\item $c$ is already a constant in an ancestor current theory;
\item $t$ contains free variables that are not in any of
the variable structures $v_1$, $\dots$, $v_n$ (this is equivalent
to requiring $\lambda v_1\ \cdots\ v_n.\  t$ to be a closed term);
\item there is a type variable in  $v_1$, $\dots$, $v_n$ or $t$
that does not occur in the type of $c$.
\end{myenumerate}

\subsubsection{Constant specifications}
\label{conspec}

\index{specification of constants, in HOL logic@specification of constants, in \HOL\ logic|(}
\index{extension, of HOL logic@extension, of \HOL\ logic!by constant specification}
In Section~\ref{specs} a constant specification\index{constant specification extension, of HOL logic@constant specification extension, of \HOL\ logic!ML function for@\ML\ function for} for a theory ${\cal T}$
is defined to be a pair:

\[ \langle(c_1,\ldots,c_n),\ \lquant{{x_1}_{\sigma_1}
\cdots {x_n}_{\sigma_n}}t_{\ty{bool}}\rangle \]

\noindent such that:

\begin{myenumerate}
\item $c_1$, $\dots$, $c_n$ are distinct names.
\item $\lquant{{x_1}_{\sigma_1}
\cdots {x_n}_{\sigma_n}}t_{\ty{bool}}\ \in\ {\sf Terms}_{\cal T}$.
\item $tyvars(\lquant{{x_1}_{\sigma_1}
\cdots {x_n}_{\sigma_n}}t_{\ty{bool}})\ \subseteq\ tyvars(\sigma_i)$ for
$1\leq i\leq n$.
\item $\equant{{x_1}_{\sigma_1}\ \cdots\ {x_n}_{\sigma_n}}t
\ \in\ {\sf Theorems}_{\cal T}$.
\end{myenumerate}

The following \ML\ function is used to make constant specifications in
the \HOL\ system.

\begin{boxed}
\index{new_specification@\ml{new\_specification}|pin}
\begin{verbatim}
   new_specification : string -> ((string*string)list) -> thm -> thm
\end{verbatim}\end{boxed}

Evaluating:

\medskip

\begin{tabular}{l}
   \ml{new\_specification}\\
\ \ml{"}$name$\ml{"}\\
\ \ml{[}$flag_1$\ml{,"}$c_1$\ml{",\ }$\ldots$\ml{\ ,\ "}$flag_n$\ml{","}$c_n$\ml{"]}\\
\ \ml{|-\ ?}$x_1\ \cdots\ x_n$\ml{.}\  $t$\ml{[}$x_1$\ml{,}$\ \ldots\
$\ml{,}$x_n$\ml{]}\\
\end{tabular}

\medskip

\noindent simultaneously  introduces  new constants  named $c_1$, $\dots$,
$c_n$ satisfying the property:

\[ \ml{|- }t\ml{[}c_1\ml{,}\ \ldots\ \ml{,}c_n\ml{]} \]

\noindent If $flag_i$ is \ml{constant}
then $c_i$ is declared an ordinary constant, if it is
\ml{infixl}$\ n$ then $c_i$ is declared a left associative infix with
binding strength $n$, if it is
\ml{infixr}$\ n$ then $c_i$ is declared a right associative infix with
binding strength $n$, and if it is
\ml{binder}\index{binders, in HOL logic@binders, in \HOL\ logic} then $\ml{c}_i$ is declared
a binder.  This theorem is stored,
with name $name$, as a definition in the current theory segment. A call to
\ml{new\_specification} fails if:

\begin{myenumerate}
\item the theorem argument has a non-empty assumption list;
\item there are free variables in the theorem argument;
\item $c_1$, $\dots$, $c_n$ are not distinct variables;
\item some $c_i$ is already a constant in an ancestor theory;
\item some $c_i$ is not an allowed name for a constant;
\item some $flag_i$ is not either \ml{constant}, \ml{infix}
or \ml{binder};
\item the type of $c_i$ is not suitable for a constant with the syntactic
status specified by $flag_i$;
\item the type of some $c_i$ does not contain all the type
variables which occur in the term
{\small\verb%\%}$x_1\ \cdots\ x_n$\ml{.}\  $t$\ml{[}$x_1$\ml{,}$\ \ldots\
$\ml{,}$x_n$\ml{]}.
\end{myenumerate}

\subsubsection{Type definitions}\index{extension, of HOL logic@extension, of \HOL\ logic!by type definition|(}
\label{type-defs}\index{type definitions, in HOL logic@type definitions, in \HOL\ logic|(}

In Section~\ref{tydefs} it is explained that
defining\index{type definitions, in HOL logic@type definitions, in \HOL\ logic!introduction of}\index{type definition extension, in HOL logic@type definition extension, in \HOL\ logic!ML function for@\ML\ function for|(}
a new type $(\alpha_1,\ldots,\alpha_n)\ty{op}$ in a theory ${\cal T}$ consists
of introducing $\ty{op}$ as a new $n$-ary type operator and

\[\turn \equant{f_{(\alpha_1,\ldots,\alpha_n)\ty{op}\fun\sigma}}\TyDef\ p\ f\]

\noindent as a new axiom, where $p$ is a predicate
characterizing\index{characteristic predicate, of type definitions} a
non-empty subset of an existing type $\sigma$.  Formally, a type definition
for a theory ${\cal T}$ is a $3$-tuple

\[ \langle \sigma,\ (\alpha_1,\ldots,\alpha_n)\ty{op},
    \ p_{\sigma\fun\ty{bool}}\rangle \]

\noindent where:

\begin{myenumerate}
\item $\sigma\in{\sf Types}_{\cal T}$  and
$tyvars(\sigma)\in\{\alpha_1, \ldots , \alpha_n\}$.
\item \ty{op} is not the name of a type constant in ${\sf Struc}_{\cal T}$.
\item $p\in{\sf Terms}_{\cal T}$ is a closed term of
type $\sigma\fun\ty{bool}$  and
$tyvars(p)\subseteq\{\alpha_1, \ldots , \alpha_n\}$.
\item $\equant{x_{\sigma}}p\ x \ \subseteq\ {\sf Theorems}_{\cal T}$.
\end{myenumerate}

The following \ML\ function makes a type definition in the \HOL\ system.

\begin{boxed}
\index{new_type_definition@\ml{new\_type\_definition}|pin}
\begin{verbatim}
   new_type_definition : (string * term * thm) -> thm
\end{verbatim}\end{boxed}

\noindent If $t$ is a term of type
$\sigma$\ml{->bool} containing $n$ distinct type variables, then
evaluating:

{\def\op{{\normalsize\sl op}}
\begin{hol}\begin{alltt}
   new_type_definition("{\op}", \m{t}, |- ?\m{x}.\m{\:t \;x})
\end{alltt}\end{hol}}

\noindent results in \ty{op} being declared as a new $n$-ary type operator
characterized by the definitional\index{definitional axioms}\index{type operators, in HOL logic@type operators, in \HOL\ logic!definitional axioms for} axiom:

\begin{hol}\begin{alltt}
   |- ?rep. TYPE\_DEFINITION \m{t} rep
\end{alltt}\end{hol}

\noindent which is stored as a definition with the automatically
generated name
\ty{op}\ml{\_TY\_DEF}.\index{TY_DEF@$\ldots$\ml{\_TY\_DEF}}. The constant
\ml{TYPE\_DEFINITION}\index{TYPE_DEFINITION@\ml{TYPE\_DEFINITION}}
is defined in the theory \ml{bool} by:

\begin{hol}\begin{verbatim}
   |- TYPE_DEFINITION (P:*->bool) (rep:**->*) =
       (!x' x''. (rep x' = rep x'') ==> (x' = x'')) /\
       (!x. P x = (?x'. x = rep x'))
\end{verbatim}\end{hol}

\noindent Executing \ml{new\_type\_definition("\ty{op}",\ }$t$\ml{,\
|- ?}$x$\ml{.}\ $t\ x$\ml{)} fails if:
\begin{myenumerate}
\item $\ty{op}$ is already the name of a type or type operator
in an ancestor theory;
\item $t$ does not have a type of the form $\sigma$\ml{->bool}.
\end{myenumerate}
\index{extension, of HOL logic@extension, of \HOL\ logic!by type definition|)}
\index{theories, in HOL logic@theories, in \HOL\ logic!extension of|)}\index{type definition extension, in HOL logic@type definition extension, in \HOL\ logic!ML function for@\ML\ function for|)}\index{type definitions, in HOL logic@type definitions, in \HOL\ logic|)}

\subsubsection{Defining bijections}
\index{type definitions, in HOL logic@type definitions, in \HOL\ logic!defining bijections for|(}

The result of a type definition using \ml{new\_type\_definition} is a theorem
which asserts only the {\it existence\/} of a
bijection\index{bijection of types, in HOL logic@bijection of types, in \HOL\ logic}
from the type it defines to the corresponding subset of an existing type.  To
introduce constants that in fact denote such a bijection and its inverse, the
following \ML\ function is provided:

\begin{boxed}
\index{define_new_type_bijections@\ml{define\_new\_type\_bijections}|pin}
\begin{verbatim}
   define_new_type_bijections : string -> string -> string -> thm -> thm
\end{verbatim}\end{boxed}

\noindent This function takes three string arguments and a theorem argument.
The theorem argument must be a definitional axiom of the form returned by
\ml{new\_type\_definition}.  The first string argument is the name under which
the constant definition (a constant specification, in fact) made by
{\small\verb!define_new_type_bijections!} will be stored in the current theory
segment, and the second and third string arguments are user-specified names for
the two constants that are to be defined. These constants are defined so as to
denote mutually inverse bijections between the defined type, whose definition
is given by the supplied theorem, and the representing type of this defined
type.

Evaluating:

\medskip
{\def\op{{\normalsize\sl op}}
\begin{hol}\begin{alltt}
   define\_new\_type\_bijections "\m{name}" "\m{abs}" "\m{rep}"
           |- ?rep:newty->ty. TYPE\_DEFINITION \m{P} rep
\end{alltt}\end{hol}}

\medskip

\noindent automatically defines two new constants
\m{abs}{\small\verb!:ty->newty!} and \m{rep}{\small\verb!:ty->newty!}
such that:

{\def\bk{\char'134}
\begin{hol}\begin{alltt}
   |- (!a. \m{abs}(\m{rep} a) = a) /\bk (!r. \m{P} r = (\m{rep}(\m{abs} r) = r))
\end{alltt}\end{hol}}

\noindent This theorem, which is the defining property for the constants
\m{abs} and \m{rep}, is stored under the name "\m{name}" in the current theory
segment.  It is also the value returned by \ml{define\_new\_type\_bijections}.
The theorem states that \m{abs} is the left inverse of \m{rep} and---for
values satisfying \m{P}---that \m{rep} is the left inverse of \m{abs}.

A call to
\ml{define\_new\_type\_bijections \m{name} \m{abs} \m{rep} \m{th}}
fails if:

\begin{myenumerate}
\item either $abs$ or $rep$ is already the name of a constant in
an ancestor theory;
\item $th$ is not a theorem of the form returned by
\ml{new\_type\_definition}.
\end{myenumerate}%
\index{type definitions, in HOL logic@type definitions, in \HOL\ logic!defining bijections for|)}

\subsubsection{Properties of type bijections}
\index{type definitions, in HOL logic@type definitions, in \HOL\ logic!properties of bijections for|(}

The following \ML\ functions are provided for proving that the bijections
introduced by \ml{define\_new\_type\_isomorphisms} are injective (one-to-one)
and surjective (onto):

\begin{boxed}
\index{prove_rep_fn_one_one@\ml{prove\_rep\_fn\_one\_one}|pin}
\index{prove_rep_fn_onto@\ml{prove\_rep\_fn\_onto}|pin}
\index{prove_abs_fn_one_one@\ml{prove\_abs\_fn\_one\_one}|pin}
\index{prove_abs_fn_onto@\ml{prove\_abs\_fn\_onto}|pin}
\begin{verbatim}
   prove_rep_fn_one_one : thm -> thm
   prove_rep_fn_onto    : thm -> thm
   prove_abs_fn_one_one : thm -> thm
   prove_abs_fn_onto    : thm -> thm
\end{verbatim}\end{boxed}

\noindent The theorem argument to each of these functions must be a theorem
of the form returned by \ml{define\_new\_type\_bijections}:

{\def\bk{\char'134}
\begin{hol}\begin{alltt}
   |- (!a. \m{abs}(\m{rep} a) = a) /\bk (!r. \m{P} r = (\m{rep}(\m{abs} r) = r))
\end{alltt}\end{hol}}

\noindent If \m{th} is a theorem of this form, then evaluating
\ml{prove\_rep\_fn\_one\_one \m{th}} proves that the function \m{rep} is
one-to-one, and returns the theorem:

\begin{hol}\begin{alltt}
   |- !a a'. (\m{rep} a = \m{rep} a') = (a = a')
\end{alltt}\end{hol}

\noindent Likewise, \ml{prove\_rep\_fn\_onto \m{th}} proves that \m{rep} is
onto the set of values that satisfy \m{P}:

{\def\bk{\char'134}
\begin{hol}\begin{alltt}
   |- !r. \m{P} r = (?a. r = \m{rep} a)
\end{alltt}\end{hol}}

\noindent Evaluating \ml{prove\_abs\_fn\_one\_one \m{th}} proves that \m{abs}
is one-to-one for values that satisfy \m{P}, and returns the theorem:

{\def\bk{\char'134}
\begin{hol}\begin{alltt}
   |- !r r'. \m{P} r ==> \m{P} r' ==> ((\m{abs} r = \m{abs} r') = (r = r'))
\end{alltt}\end{hol}}

\noindent And evaluating \ml{prove\_abs\_fn\_onto \m{th}} proves that \m{abs}
is onto, returning the theorem:

{\def\bk{\char'134}
\begin{hol}\begin{alltt}
   |- !a. ?r. (a = \m{abs} r) /\bk \m{P} r
\end{alltt}\end{hol}}

\noindent All four functions will fail if applied to any theorem that does not
have the form of a theorem returned by \ml{define\_new\_type\_bijections}.
None of these functions saves anything in the current theory.

\index{type definitions, in HOL logic@type definitions, in \HOL\ logic!properties of bijections for|)}

\subsection{ML functions for accessing theories}

\index{theories, in HOL logic@theories, in \HOL\ logic!functions for accessing|(}
\index{axioms!retrieval of, in HOL system@retrieval of, in \HOL\ system|(}
The arguments of \ML\ type {\small\verb%string%} to {\small\verb%new_axiom%},
{\small\verb%new_definition%}
\etc\ are the names of the corresponding axioms and definitions. These
names are used when accessing theories with the functions
{\small\verb%axiom%}, {\small\verb%definition%}, \etc, described below.
%The various functions for setting up theories are illustrated in the
%example session in Section~\ref{example}.


The current theory\index{theories, in HOL logic@theories, in \HOL\ logic!hierarchies of}
can be extended by adding new parents, types,
constants, axioms and definitions. Theories that are in the ancestry of
the current theory cannot be extended in this way; they can be thought of as
\emph{frozen}.

There are various functions for loading the contents of theory files:

\begin{boxed}
\index{parents@\ml{parents}|pin}
\index{types@\ml{types}|pin}
\index{constants@\ml{constants}|pin}
\index{infixes@\ml{infixes}|pin}
\index{binders@\ml{binders}|pin}
\index{axioms@\ml{axioms}|pin}
\index{definitions@\ml{definitions}|pin}
\index{theorems@\ml{theorems}|pin}
\begin{verbatim}
   parents     : string -> string list
   types       : string -> (int * string) list
   constants   : string -> term list
   infixes     : string -> term list
   binders     : string -> term list
   axioms      : string -> (string * thm) list
   definitions : string -> (string * thm) list
   theorems    : string -> (string * thm) list
\end{verbatim}\end{boxed}

\noindent The first argument is the name of a theory (which must be in the
ancestry of the current theory segment); the result is a list of the
components of the theory. The name of the current theory can be abbreviated by
\ml{`-`}.\index{ abbreviation, of HOL theory part names@\ml{-}
(abbreviation, of \HOL\ theory part names)} For example, \ml{parents `-`} returns the parents of the current
theory.

In the case of \ml{types} a list of arity-name pairs is returned; in the
case of  \ml{axioms}, \ml{definitions} or \ml{theorems} a list
of string-theorem
pairs is returned, where the string is the name of the theorem representing the
axiom, definition or theorem that was supplied by the user. Note that constant
specifications and type definitions are both retrieved using the function
\ml{definitions}.


Individual axioms, definitions and theorems can be read from the current theory
using the following \ML\ functions:

\begin{boxed}
\index{axiom@\ml{axiom}|pin}
\index{definition@\ml{definition}|pin}
\index{theorem@\ml{theorem}|pin}
\begin{verbatim}
   axiom      : string -> thm
   definition : string -> thm
   theorem    : string -> thm
\end{verbatim}\end{boxed}

\noindent The  first  argument  is the user  supplied name  of the axiom,
definition or theorem in the current theory.

The contents of the current theory can be printed in a readable format using the function
{\small\verb%print_theory%}\index{printing, in HOL logic@printing, in \HOL\ logic!of theories}\index{print_theory@\ml{print\_theory}}.
\index{axioms!retrieval of, in HOL system@retrieval of, in \HOL\
system|)}\index{theories, in HOL logic@theories, in \HOL\
logic!functions for accessing|)}


%\subsection{Type abbreviations}\label{typeabbrev}\index{types, in HOL logic@types, in \HOL\ logic!abbreviation of}\index{type abbreviations!in HOL logic@in \HOL\ logic}\index{abbreviation of types, in HOL logic@abbreviation of types, in \HOL\ logic|(}
%It is possible to introduce an abbreviation for a monomorphic type using the
%function:
%
%\begin{boxed}\index{new_type_abbrev@\ml{new\_type\_abbrev}|pin}
%\begin{verbatim}
%   new_type_abbrev : (string * type) -> unit
%\end{verbatim}\end{boxed}
%
%\noindent Evaluating \ml{new\_type\_abbrev(`}$name$\ml{`,":}$\sigma$\ml{")}
%enables $name$ to be used in quotations instead of $\sigma$. The evaluation
%fails
%if $\sigma$ is polymorphic. Type abbreviations
%are recorded in theory files, so that
%when a theory is loaded, any type abbreviations made are
%activated. The list of currently active abbreviations in a theory
%is given by the function:
%
%\begin{boxed}\index{type_abbrevs@\ml{type\_abbrevs}|pin}
%\begin{verbatim}
%   type_abbrevs : string -> (string * type) list
%\end{verbatim}\end{boxed}
%
%
%Note that abbreviation can also be made using antiquotation\index{antiquotation, in HOL logic terms@antiquotation, in \HOL\ logic terms}, without the
%restriction to monomorphic types. Such \ML\ abbreviations are not, of course,
%stored in theory files and so do not persist beyond a single session.
%The following session illustrates various ways of
%abbreviating types:
%
%\setcounter{sessioncount}{1}
%\begin{session}\begin{verbatim}
%*new_theory `numpair`;;
%() : unit
%
%#new_type_abbrev(`numpair`, ":num*num");;
%() : unit
%
%#let t1 = "x:numpair";;
%t1 = "x" : term
%
%#type_of t1;;
%":num * num" : type
%
%#":numpair" = ":num*num";;
%true : bool
%\end{verbatim}\end{session}
%
%\noindent The alternative to introducing a type abbreviation is
%to give an \ML\ name to the type, and then to use this name via antiquotation.
%Continuing the session:\index{abbreviation of types, in HOL logic@abbreviation of types, in \HOL\ logic|)}
%
%\begin{session}\begin{verbatim}
%#let ty = ":num*num";;
%ty = ":num * num" : type
%
%#let t2 = "x:^ty";;
%t2 = "x" : term
%
%#t1 = t2;;
%true : bool
%\end{verbatim}\end{session}
%
%\pagebreak[2]
%
%\noindent The type abbreviation is stored in the theory file and so
%persists across sessions. This can be seen by the result of printing
%the theory \ml{numpair}:
%
%\begin{session}\begin{verbatim}
%#print_theory`numpair`;;
%The Theory numpair
%Parents --  HOL
%Type Abbreviations --  numpair ":num * num"
%******************** numpair ********************
%
%() : unit
%\end{verbatim}\end{session}
%
%\noindent If the session is then ended:
%
%\begin{session}\begin{verbatim}
%#close_theory();;
%() : unit
%
%#quit();;
%\end{verbatim}\end{session}
%
%\noindent and a new session is started in which the theory \ml{numpair} is
%loaded:
%
%\setcounter{sessioncount}{1}
%\begin{session}\begin{verbatim}
%#load_theory`numpair`;;
%Theory numpair loaded
%() : unit
%
%#"x:numpair";;
%"x" : term
%
%#type_abbrevs `-`;;
%[(`numpair`, ":num * num")] : (string * type) list
%\end{verbatim}\end{session}
%
%\noindent then the type abbreviation persists.
%
%Type abbreviations tend to be little used in practice; the antiquotation
%method is usually sufficient.


\section{The theory {\tt min}}\label{minTheory}

The theory \ml{min}\index{min, the HOL theory@\ml{min}, the \HOL\
theory|(} declares the type constant {\small\verb+bool+} of booleans,
the binary type operator {\small\verb+fun+} of functions, and the type
constant {\small\verb+ind+} of individuals.  Building on this, three
primitive constants\index{constants, in HOL
 logic@constants, in \HOL\ logic!primitive logical}\index{primitive
 constants, of HOL logic@primitive constants, of \HOL\ logic}
are declared in the theory {\small\verb%min%}: equality, implication, and a choice operator.
\index{ equality, in HOL logic@\ml{=} (equality, in
 \HOL\ logic)}\index{equality, in HOL logic@equality, in \HOL\ logic}

Equality ({\small\verb+$= : 'a -> 'a -> bool+}) parses as an infix with
low binding precedence (100).

Implication ({\small\verb+$==> : bool -> bool -> bool+}) parses as a
right-associative infix with binding precedence 200.

 Equality\index{equality, in HOL logic@equality, in \HOL\
 logic}\index{implication, in HOL logic@implication, in \HOL\ logic}
 and implication are standard predicate calculus notions, but choice is
 more exotic:
if $t$ is a term having type $\sigma${\small\verb%->bool%},
then {\small\verb%@x.%}$t${\small\verb% x%} (or, equivalently,
{\small\verb%$@%}$t$) denotes {\it some\/} member of the set whose
characteristic\index{characteristic predicate, of type definitions}
 function is $t$. If the set is empty, then
{\small\verb%@x.%}$t${\small\verb% x%} denotes an arbitrary member of the
set denoted by $\sigma$. The constant {\small\verb%@%} is a higher order
version of Hilbert's\index{Hilbert, D.}\index{epsilon operator}
 $\hilbert$-operator; it is related to the constant
$\iota$ in Church's formulation of higher order logic. For more details,
see Church's\index{Church, A.} original paper \cite{Church}, Leisenring's\index{Leisenring, A.} book
on Hilbert's $\hilbert$-symbol \cite{Leisenring}, or
Andrews' textbook on type theory \cite{Andrews}.

\section{Primitive rules of inference of the HOL Logic}
\label{rules}

\index{inference rules, of HOL logic@inference rules, of \HOL\ logic!primitive|(}
The primitive rules of inference of the logic were described abstractly
in Section~\ref{HOLrules}. The descriptions relied on meta-variables
$t$, $t_1$, $t_2$, and so on.
%In Section~\ref{avra_theorems}, a primitive inference was defined as
%a pair $(L,(\Gamma,t))$ belonging to
%a deductive system.
In the \HOL\ logic, infinite families of primitive
inferences are grouped together and thought of as single primitive inference
schemes.\index{families of inferences, in HOL logic@families of inferences, in \HOL\ logic}  Each family contains all the concrete instances of one
particular inference `pattern'. These can be produced, in
abstract form, by instantiating the meta-variables in Section~\ref{HOLrules}
to concrete terms.

In \HOL, primitive inference schemes are represented
by \ML\ functions that return theorems as values.
That is, for particular \HOL\ terms, the \ML\ functions return
the instance of the theorem at those terms. The \ML\ functions
are part of the \ML\ abstract type
 \ml{thm}\index{thm@\ml{thm}}:
although \ml{thm} has no primitive constructors, it has (eight)
operations which return theorems as values: \ml{ASSUME}, \ml{REFL},
\ml{BETA\_CONV}, \ml{SUBST}, \ml{ABS}, \ml{INST\_TYPE},
\ml{DISCH} and \ml{MP}.\index{inference schemes, in HOL logic@inference schemes, in \HOL\ logic}

The \ML\ functions that implement the primitive inference schemes in the
\HOL\ system are described below.  The same notation\index{notation!for
specification of rules}\index{inferences, in HOL logic@inferences, in
\HOL\ logic!notation for} is used here as in Section~\ref{HOLrules}:
hypotheses above a horizontal line and conclusion\index{conclusions!of
inference rules} beneath. The machine-readable {\small ASCII} notation
is used for the logical constants.

\subsection{Assumption introduction}\index{assumption introduction,
in HOL logic@assumption introduction, in \HOL\ logic!ML function
for@\ML\ function for}

\begin{boxed}
\index{ASSUME@\ml{ASSUME}|pin}
\begin{verbatim}
   ASSUME : term -> thm
\end{verbatim}\end{boxed}

\begin{center}
\begin{tabular}{c}
  \\ \hline
$t${\small\verb% |- %}$t$ \\
\end{tabular}
\end{center}

\noindent
{\small\verb%ASSUME %}$t${\small\verb%%} evaluates to $t${\small\verb%|- %}$t$.
Failure if $t$ is not of type \ml{bool}.

\bigskip

\subsection{Reflexivity}\index{reflexivity, in HOL logic@reflexivity, in \HOL\ logic!ML function for@\ML\ function for}

\begin{boxed}\index{REFL@\ml{REFL}|pin}
\begin{verbatim}
   REFL : term -> thm
\end{verbatim}\end{boxed}

\begin{center}
\begin{tabular}{c}
  \\ \hline
{\small\verb% |- %}$t${\small\verb% = %}$t$ \\
\end{tabular}
\end{center}

\noindent {\small\verb%REFL %}$t${\small\verb%%} evaluates to
{\small\verb%|- %}$t${\small\verb% = %}$t$. A call to \ml{REFL} never fails.

\bigskip

\subsection{Beta-conversion}\index{beta-conversion, in HOL logic@beta-conversion, in \HOL\ logic!ML function for@\ML\ function for}

\begin{boxed}\index{BETA_CONV@\ml{BETA\_CONV}|pin}
\begin{verbatim}
   BETA_CONV : term -> thm
\end{verbatim}\end{boxed}

\begin{center}
\begin{tabular}{c}
  \\ \hline
{\small\verb% |- (\%}$x${\small\verb%.%}$t_1${\small\verb%)%}$t_2${\small\verb% = %}$t_1[t_2/x]$
\end{tabular}
\end{center}

\begin{itemize}
\item where $t_1[t_2/x]$ denotes the result of substituting $t_2$ for $x$
in $t_1$, with suitable renaming of variables to prevent free variables
in $t_2$ becoming bound after substitution. The substitution
 $t_1[t_2/x]$ is always defined.
\end{itemize}


\noindent {\small\verb%BETA_CONV (\%}$x${\small\verb%.%}$t_1${\small\verb%)%}$t_2${\small\verb%%} evaluates to the
theorem {\small\verb%|- (\%}$x${\small\verb%.%}$t_1${\small\verb%)%}$t_2${\small\verb% = %}$t_1[t_2/x]$.
Failure if the argument to \ml{BETA\_CONV} is not a $\beta$-redex (\ie\ is not
of the form {\small\verb%(\%}$x${\small\verb%.%}$t_1${\small\verb%)%}$t_2${\small\verb%%}).

\bigskip

\subsection{Substitution}\index{substitution rule, in HOL logic@substitution rule, in \HOL\ logic!ML function for@\ML\ function for|(}\index{SUBST@\ml{SUBST}|(}

\begin{boxed}
\begin{verbatim}
   SUBST : (thm * term)list -> term -> thm -> thm
\end{verbatim}\end{boxed}

\begin{center}
\begin{tabular}{c}
$\Gamma_1${\small\verb% |- %} $t_1${\small\verb%=%}$t'_1$ {\small\verb%  %} $\cdots$ {\small\verb%  %}
$\Gamma_n${\small\verb% |- %} $t_n${\small\verb%=%}$t'_n$ {\small\verb%  %}
$\Gamma${\small\verb% |- %} $t[t_1,\ldots,t_n]$ \\ \hline
$\Gamma_1 \cup \cdots
\cup \Gamma_n \cup \Gamma${\small\verb% |- %} $t[t'_1,\ldots,t'_n]$ \\
\end{tabular}
\end{center}

\bigskip

\begin{itemize}
\item where $t[t_1,\ldots,t_n]$ denotes a term $t$ with some free
occurrences of the terms $t_1$, $\dots$, $t_n$ singled out and
$t[t'_1,\ldots,t'_n]$ denotes the result of simultaneously replacing each
such occurrences of $t_i$ by $t'_i$ (for $1{\leq}i {\leq} n$),
with suitable renaming of variables to prevent free variables
in $t_i'$ becoming bound after substitution.
\end{itemize}

\noindent
The first argument to {\small\verb%SUBST%} is a list
{\small\verb%[(|-%}$t_1${\small\verb%=%}$t'_1${\small\verb%, %}$x_1${\small\verb%);%}$\:\ldots\:${\small\verb%;(|-%}$t_n${\small\verb%=%}
$t'_n${\small\verb%, %}$x_n${\small\verb%)]%}.  The second argument is a
template term $t[x_1,\ldots,x_n]$ in which occurrences of the variable
$x_i$ (where $1 \leq i\leq n$) are used to mark the places where
substitutions with {\small\verb%|- %}$t_i${\small\verb%=%}$t'_i$ are to be
done. Thus

\bigskip

{\small\verb%SUBST [(|-%}$t_1${\small\verb%=%}$t'_1${\small\verb%, %}$x_1${\small\verb%);%}$\ldots${\small\verb%;(|-%}$t_n${\small\verb%=%}
$t'_n${\small\verb%, %}$x_n${\small\verb%)]  %}$t[x_1,\ldots,x_n]${\small\verb%  %}
$\Gamma${\small\verb% |- %}$t[t_1,\ldots,t_n]$

\bigskip

\noindent returns $\Gamma${\small\verb% |- %}$t[t'_1,\ldots,t'_n]$.
Failure if:
\begin{myenumerate}
\item any of the arguments are of the wrong form;
\item the type of $x_i$ is not equal to the type of $t_i$ for some
$1\leq i\leq n$.
\end{myenumerate}\index{SUBST@\ml{SUBST}|)}\index{substitution rule, in HOL logic@substitution rule, in \HOL\ logic!ML function for@\ML\ function for|)}

\subsection{Abstraction}\index{abstraction rule, in HOL logic@abstraction rule, in \HOL\ logic!ML function for@\ML\ function for}
\index{function abstraction, in HOL logic@function abstraction, in \HOL\ logic!inference rules for}


\begin{boxed}\index{ABS@\ml{ABS}|pin}
\begin{verbatim}
   ABS : term -> thm -> thm
\end{verbatim}\end{boxed}


\begin{center}
\begin{tabular}{c}
$\Gamma${\small\verb% |- %}$t_1${\small\verb% = %}$t_2$ \\ \hline
$\Gamma${\small\verb% |- (\%}$x${\small\verb%.%}$t_1${\small\verb%) = (\%}$x${\small\verb%.%}$t_2${\small\verb%)%} \\
\end{tabular}
\end{center}

\begin{itemize}
\item where $x$ is not free in $\Gamma$.
\end{itemize}

\noindent
{\small\verb%ABS %}$x${\small\verb% %}$\Gamma${\small\verb% |- %}$t_1${\small\verb%=%}$t_2$ returns the theorem
$\Gamma${\small\verb% |- (\%}$x${\small\verb%.%}$t_1${\small\verb%) = (\%}$x${\small\verb%.%}$t_2${\small\verb%)%}.
Failure if $x$ is not a variable, or $x$
 occurs free in any assumption in $\Gamma$.


\bigskip

\subsection{Type instantiation}\index{type instantiation, in HOL logic@type instantiation, in \HOL\ logic!ML function for@\ML\ function for}\index{types, in HOL logic@types, in \HOL\ logic!instantiation of}

\begin{boxed}\index{INST_TYPE@\ml{INST\_TYPE}|pin}
\begin{verbatim}
   INST_TYPE : (type*type) list -> thm -> thm
\end{verbatim}\end{boxed}

\begin{center}
\begin{tabular}{c}
$\Gamma${\small\verb% |- %}$t$ \\ \hline
$\Gamma${\small\verb% |- %}$t[\sigma_1,\ \ldots\ ,\sigma_n/\alpha_1,\ \ldots\ ,\alpha_n]$
\end{tabular}
\end{center}

\bigskip

\begin{itemize}
\item $t[\sigma_1,\ \ldots\ ,\sigma_n/\alpha_1,\ \ldots\ ,\alpha_n]$
denotes the result of substituting (in parallel) the types $\sigma_1$,
$\ldots$\ , $\sigma_n$ for the type variables $\alpha_1$, $\ldots$\ ,
$\alpha_n$ in $t$, with the restriction that none of $\alpha_1$, $\ldots$\
, $\alpha_n$ occur in $\Gamma$.
\end{itemize}

\noindent
{\small\verb%INST_TYPE[(%}$\sigma_1${\small\verb%,%}$\alpha_1${\small\verb%);%}$\ldots${\small\verb%;(%}$\sigma_n${\small\verb%,%}$\alpha_n${\small\verb%)] %}$th$
returns the result of instantiating each occurrence of $\alpha_i$ in the
theorem $th$ to $\sigma_i$ (for $1 \leq i \leq n$). Failure if:
\begin{myenumerate}
\item arguments of the wrong form (\eg\ an $\alpha_i$ is not a type variable);
\item $\alpha_i$
(for $1\leq i\leq n$) occurs in any assumption in $\Gamma$.
\end{myenumerate}

\bigskip

\subsection{Discharging an assumption}\index{discharging assumptions, in HOL logic@discharging assumptions, in \HOL\ logic!ML function for@\ML\ function for}


\begin{boxed}\index{DISCH@\ml{DISCH}|pin}
\begin{verbatim}
   DISCH : term -> thm -> thm
\end{verbatim}\end{boxed}

\begin{center}
\begin{tabular}{c}
$\Gamma${\small\verb% |- %} $t_2$ \\ \hline
$\Gamma{-}\{t_1\}${\small\verb% |- %} $t_1${\small\verb% ==> %}$t_2$
\end{tabular}
\end{center}

\begin{itemize}
\item  $\Gamma{-}\{t_1\}$ denotes the set obtained by removing $t_1$
from $\Gamma$ (note that $t_1$ need not occur in $\Gamma$; in this case
$\Gamma{-}\{t_1\} = \Gamma$).
\end{itemize}

\noindent
{\small\verb%DISCH %}$t_1${\small\verb% %}$\Gamma${\small\verb% |- %}$t_2$
evaluates to the theorem
$\Gamma{-}\{t_1\}${\small\verb% |- %}$t_1${\small\verb% ==> %}$t_2$.
\ml{DISCH} fails if the term given as its first argument is not of
type \ml{bool}.



\bigskip

\subsection{Modus Ponens}\index{Modus Ponens, in HOL logic@Modus Ponens, in \HOL\ logic!ML function for@\ML\ function for}


\begin{boxed}\index{MP@\ml{MP}|pin}
\begin{verbatim}
   MP : thm -> thm -> thm
\end{verbatim}\end{boxed}

\begin{center}
\begin{tabular}{c}
$\Gamma_1${\small\verb% |- %}$t_1${\small\verb% ==> %}$t_2$ {\small\verb%     %} $\Gamma_2${\small\verb% |- %}$t_1$ \\
\hline
$\Gamma_1 \cup \Gamma_2${\small\verb% |- %}$t_2$ \\
\end{tabular}
\end{center}

\noindent
{\small\verb%MP%} takes two theorems (in the order shown above) and returns
the result of applying Modus Ponens; it fails if the arguments are not of the
right form.
\index{inference rules, of HOL logic@inference rules, of \HOL\ logic!primitive|)}

\section{Oracles}

\holn{} extends the \LCF\ tradition by allowing the use of an \emph
{oracle} mechanism, enabling arbitrary formulas to become elements of
the \verb+thm+ type. By use of this mechanism, \holn{} can utilize the
results of arbitrary proof procedures. In spite of such liberalness, one
can still make strong assertions about the security of ML objects of
type \verb+thm+.

To avoid unsoundness, a \emph{tag} is attached to any theorem
coming from an oracle. This tag is propagated through every
inference that the theorem participates in (much as ordinary assumptions
are propagated in the inference rule {\small\verb+MP+}). If it happens
that falsity becomes derived, the offending oracle can be found by
examining the tags component of the theorem. A theorem proved without
use of any oracle will have an empty tag, and can thus be considered to
have been proved solely by deductive steps in the HOL logic.

A tagged theorem can be created via

\begin{boxed}
\index{mk_oracle_thm@\ml{mk\_oracle\_thm}!type of}
\begin{verbatim}
   mk_oracle_thm : tag -> term list * term -> thm
\end{verbatim}\end{boxed}

which directly creates the requested theorem and attaches the given tag to
it. Tags may be created with

\begin{boxed}
\index{Tag.read@\ml{Tag.read}!making tags}
\begin{verbatim}
   Tag.read : string -> tag.
\end{verbatim}\end{boxed}

As well as providing principled access to the results of external
reasoners, tags are used to implement some useful `system' operations on
theorems. For example, one can directly create a theorem via the function
\verb+mk_thm+. The tag \verb+MK_THM+ gets attached to each theorem
created with this call. This allows users to directly create useful
theorems, \eg, to use as test data for derived rules of inference.
Another tag is used to implement so-called `validity checking' for tactics.

The tags in a theorem can be viewed by setting \verb+Globals.show_tags+ to
true.

\setcounter{sessioncount}{1}
\begin{session}\begin{verbatim}
- Globals.show_tags := true;
> val it = () : unit

- mk_thm([], Term `F`);;
> val it = [oracles: MK_THM] [axioms: ] [] |- F : thm
\end{verbatim}\end{session}\index{mk_thm@mk_thm)}

There are three elements to the left of the turnstile in the fully printed
representation of a theorem: the first two\footnote{Tags are also used for
tracking the use of axioms in proofs.} comprise the tags component and the
third is the standard assumption list. The tag component of a theorem
can be extracted by

\begin{boxed} \begin{verbatim}
     Thm.tag : thm -> tag
\end{verbatim}\end{boxed}

\noindent and prettyprinted by

\begin{boxed} \begin{verbatim}
     Tag.pp : ppstream -> tag -> unit.
\end{verbatim}\end{boxed}

\section{The theory {\tt bool}}\label{boolfull}

\index{axioms!primitive, of HOL logic@primitive, of \HOL\ logic|(}
At start-up,  the  initial  theory  for  users  of  the \HOL\  system is called
\ml{bool}\index{HOL@\ml{HOL}}, which is constructed when the \HOL\
system is built. The theory {\small\verb%bool%}
contains the five axioms\index{axioms!in bool theory@in \ml{bool} theory}
for higher order logic. These axioms, together with the rules
of inference described in Section~\ref{rules}, constitute the core of the
\HOL\ logic.  Because of the way the \HOL\ system evolved from
\LCF,\index{LCF@\LCF}\footnote{To simplify the porting of the LCF
theorem-proving tools to the HOL system, the HOL logic was made as like
PP$\lambda$ (the logic built-in to LCF) as possible.} the particular
axiomatization\index{axioms!non-primitive, of HOL logic@non-primitive,
of \HOL\ logic} of higher order logic it uses differs from the classical
axiomatization due to Church\index{Church, A.} \cite{Church}.  The
biggest difference is that in Church's formulation type
variables\index{type variables, in HOL  logic@type variables, in \HOL\
logic!differences from classical} are in  the meta-language, whereas in
the \HOL\ logic they are part of the object language.

The logical constants\index{logical constants, in HOL logic@logical constants, in \HOL\ logic} {\small\verb%T%}\index{truth values, in HOL logic@truth values, in \HOL\ logic!constants for}\index{T@\ml{T}!defined in terms of primitives} (truth), {\small\verb%F%}\index{F@\ml{F}!defined in terms of primitives} (falsity),
{\small\verb%~%} (negation)\index{ negation, in HOL logic@{\small\verb+~+} (negation, in \HOL\ logic)}, {\small\verb%/\%} (conjunction)\index{ conjunction, in HOL logic@{\small\verb+/\+} (conjunction, in \HOL\ logic)}\index{conjunction, in HOL logic@conjunction, in \HOL\ logic!defined in terms of primitives},
{\small\verb%\/%} (disjunction)\index{ disjunction, in HOL logic@{\small\verb+\/+} (disjunction, in \HOL\ logic)}\index{disjunction, in HOL logic@disjunction, in \HOL\ logic!defined in terms of primitives}, {\small\verb%!%} (universal
quantification)\index{ universal quantifier, in HOL logic@{\small\verb+"!+} (universal quantifier, in \HOL\ logic)}\index{universal quantifier, in HOL logic@universal quantifier, in \HOL\ logic!defined in terms of primitives}, {\small\verb%?%} (existential quantification)\index{ existential quantifier, in HOL logic@{\small\verb+?+} (existential quantifier, in \HOL\ logic)}\index{existential quantifier, in HOL logic@existential quantifier, in \HOL\ logic!defined in terms of primitives}
and {\small\verb%?!%} (unique existence quantifier)\index{ exists unique, in HOL logic@{\small\verb+?"!+} (exists unique, in \HOL\ logic)}\index{exists unique, in HOL logic@exists unique, in \HOL\ logic!defined in terms of primitives}
 can all
be defined in terms of equality\index{equality, in HOL logic@equality, in \HOL\ logic}, implication and choice.  The definitions
listed below are fairly standard; each one is preceded by its \ML\ name.
(Later definitions sometimes use earlier ones.)


\begin{hol}
\index{truth values, in HOL logic@truth values, in \HOL\ logic!definition of}
\index{T_DEF@\ml{T\_DEF}}
\index{T@\ml{T}!definitional axiom for}
\index{disjunction, in HOL logic@disjunction, in \HOL\ logic!definitional axiom for}
\index{conjunction, in HOL logic@conjunction, in \HOL\ logic!definitional axiom for}
\index{iff, in HOL logic@iff, in \HOL\ logic!definitional axiom for}
\index{negation, in HOL logic@negation, in \HOL\ logic!definitional axiom for}
\index{exists unique, in HOL logic@exists unique, in \HOL\ logic}
\index{F@\ml{F}!axiom for}
\index{F@\ml{F}!definitional axiom for}
\index{ exists unique, in HOL logic@{\small\verb+?"!+} (exists unique, in \HOL\ logic)}
\index{T_DEF@\ml{T\_DEF}}
\index{FORALL_DEF@\ml{FORALL\_DEF}}
\index{EXISTS_DEF@\ml{EXISTS\_DEF}}
\index{AND_DEF@\ml{AND\_DEF}}
\index{OR_DEF@\ml{OR\_DEF}}
\index{F_DEF@\ml{F\_DEF}}
\index{NOT_DEF@\ml{NOT\_DEF}}
\index{EXISTS_UNIQUE_DEF@\ml{EXISTS\_UNIQUE\_DEF}}
\index{conjunction, in HOL logic@conjunction, in \HOL\ logic!definitional axiom for}
\index{disjunction, in HOL logic@disjunction, in \HOL\ logic!definitional axiom for}
\index{equality, in HOL logic@equality, in \HOL\ logic!primitive axiom for}
\index{existential quantifier, in HOL logic@existential quantifier, in \HOL\ logic!definitional axiom for}
\index{universal quantifier, in HOL logic@universal quantifier, in \HOL\ logic!definitional axiom for}
\index{exists unique, in HOL logic@exists unique, in \HOL\ logic!definitional axiom for}
\begin{verbatim}
   T_DEF              |- T   = ((\x:bool. x) = (\x. x))

   FORALL_DEF         |- $!  = \P:'a->bool. P = (\x. T)

   EXISTS_DEF         |- $?  = \P:'a->bool. P($@ P)

   AND_DEF            |- $/\ = \t1 t2. !t. (t1 ==> t2 ==> t) ==> t

   OR_DEF             |- $\/ = \t1 t2. !t. (t1 ==> t) ==> (t2 ==> t) ==> t

   F_DEF              |- F   = !t. t

   NOT_DEF            |- $~  = \t. t ==> F

   EXISTS_UNIQUE_DEF  |- $?! = (\P. $? P /\ (!x y. P x /\ P y ==> (x = y)))
\end{verbatim}\end{hol}


There are five
\index{universal quantifier, in HOL logic@universalquantifier,
       in \HOL\ logic!in four primitive axioms}
axioms in the theory {\small\verb%bool%}\index{bool, the HOL
theory@\ml{bool}, the \HOL\ theory}; the first four are the following:

\begin{hol}
\index{BOOL_CASES_AX@\ml{BOOL\_CASES\_AX}}
\index{IMP_ANTISYM_AX@\ml{IMP\_ANTISYM\_AX}}
\index{ETA_AX@\ml{ETA\_AX}}
\index{SELECT_AX@\ml{SELECT\_AX}}
\index{implication, in HOL logic@implication, in \HOL\ logic!primitive axiom for}
\index{ choice function, in HOL logic@{\small\verb+"@+} (choice function, in \HOL\ logic)}
\index{choice axiom}
\index{choice operator, in HOL logic@choice operator, in \HOL\ logic!primitive axiom for}
\begin{verbatim}
   BOOL_CASES_AX   |- !t. (t = T) \/ (t = F)

   IMP_ANTISYM_AX  |- !t1 t2. (t1 ==> t2) ==> (t2 ==> t1) ==> (t1 = t2)

   ETA_AX          |- !t. (\x. t x) = t

   SELECT_AX       |- !P:'a->bool x. P x ==> P($@ P)
\end{verbatim}\end{hol}

\noindent
The fifth and last axiom of the \HOL\ logic is the Axiom of
Infinity\index{axiom of infinity}. Its statement is phrased in terms of
the function properties {\small\verb%ONE_ONE%} and {\small\verb%ONTO%}. The
definitions are:

\begin{hol}
\index{ONE_ONE_DEF@\ml{ONE\_ONE\_DEF}}
\index{ONTO_DEF@\ml{ONTO\_DEF}}
\index{one-to-one predicate, in HOL logic@one-to-one predicate, in \HOL\ logic!definitional axiom for}
\index{onto predicate, in HOL logic@onto predicate, in \HOL\ logic!definitional axiom for}
\begin{verbatim}
   ONE_ONE_DEF |- ONE_ONE f = (!x1 x2. (f x1 = f x2) ==> (x1 = x2))

   ONTO_DEF    |- ONTO f    = (!y. ?x. y = f x)
\end{verbatim}\end{hol}

The Axiom of Infinity\index{axioms!in bool theory@in \ml{bool} theory} is

{\begin{hol}
\index{INFINITY_AX@\ml{INFINITY\_AX}}
\index{axiom of infinity}
\index{existential quantifier, in HOL logic@existential quantifier, in \HOL\ logic!in infinity axiom}
\begin{verbatim}
  INFINITY_AX  |- ?f:ind->ind. ONE_ONE f /\ ~(ONTO f)
\end{verbatim}\end{hol}}

\noindent
This asserts that there exists a one-to-one map from {\small\verb%ind%} to
itself that is not onto. This implies that the type {\small\verb%ind%}
denotes an infinite set.\index{axioms!primitive, of HOL logic@primitive, of \HOL\ logic|)}

The four other axioms of the theory {\small\verb%bool%}, the rules of
inference in Section~\ref{rules} and the Axiom of Infinity are,
together, sufficient for developing all of standard mathematics. Thus,
in principle, the user of the \HOL\ system should never need to make a
non-definitional\index{axioms!dispensibility of
adding}\index{definitional theories} theory. In practice, it is often
very tempting to take the risk of introducing new axioms because
deriving them from definitions can be tedious---proving that `axioms'
follow from definitions amounts to proving their consistency.

The theory {\small\verb%bool%} also supplies the definitions of a number of
useful constants.
\begin{hol}
\index{LET_DEF@\ml{LET\_DEF}}
\index{COND_DEF@\ml{COND\_DEF}}
\index{COND@\ml{COND}}
\index{LET@\ml{LET}}
\index{conditional predicate, in HOL logic@conditional predicate, in \HOL\ logic!definitional axiom for}
\index{conditionals, in HOL logic@conditionals, in \HOL\ logic}
\begin{verbatim}
   LET_DEF      |- LET    = \f x. f x

   COND_DEF     |- COND   = \t t1 t2.@x.((t=T)==>(x=t1))/\((t=F)==>(x=t2))

   ARB_DEF      |- ARB    = @x. T
\end{verbatim}\end{hol}

The constant {\small\verb%LET%}\index{let-terms, in HOL logic@\ml{let}-terms, in \HOL\ logic!constant for} is used in representing terms
containing local variable bindings (\ie\
{\small\verb%let%}-terms\index{let-terms, in HOL logic@\ml{let}-terms,
in \HOL\ logic!definitional axiom for}. For example, the concrete syntax
{\small\verb+let v = M in N+} is translated by the parser to the term
{\small\verb+LET (\v.N) M+}. For the full description of how
{\small\verb+let+} expressions are translated, see Section \ref{prod}.

The constant {\small\verb%COND%} is used in representing conditional
expressions. The concrete syntax \index{terms, in HOL logic@terms,
in \HOL\ logic!conditional}\index{conditional
predicate, in HOL logic@conditional predicate,
in \HOL\ logic}\index{conditionals, in HOL
logic@conditionals, in \HOL\ logic}
\ml{`if $t_1\ $then$\ t_2\ $else$\ t_3$`} abbreviates the application
\ml{COND\ $t_1\ t_2\ t_3$}. The syntax \ml{$t_1\;
$=>$\;t_2\;$|$\;t_3$} is also permitted. The system alway prints out
conditionals in the "if $t_1$ then $t_2$ else $t_3$" form.

The polymorphic constant {\small\verb+ARB+} is used to denote a fixed
but arbitrary element in a type, which is occasionally useful when
attempting to deal with the issue of partiality.

%\subsection{Conditionals}\label{conditionals}
%
%An iterated conditional
%
%\[
%t_{11}\ \ml{=>}\ t_{12}\ \ml{|}\
%t_{21}\ \ml{=>}\ t_{22}\ \ml{|}\
%\ \ldots\ \ml{|}\
%t_{n1}\ \ml{=>}\ t_{n2}\ \ml{|}\ t_{n3}
%\]
%
%\noindent translates\index{parsing, of HOL logic@parsing, of \HOL\ logic!of conditionals} to:
%
%\[
%t_{11}\ \ml{=>}\ t_{12}\ \ml{|}\
%(t_{21}\ \ml{=>}\ t_{22}\ \ml{|}\
%\ \ldots\ \ml{|}\
%(t_{n1}\ \ml{=>}\ t_{n2}\ \ml{|}\ t_{n3})\ \ldots\ )
%\]
%
%\noindent which, in turn, abbreviates:
%
%\[\ml{COND}\ t_{11}\ t_{12}\ \ml{(COND}\ t_{21}\ t_{22}\ \ldots\
%\ml{(COND}\ t_{n1}\ t_{n2}\ t_{n3}\ml{)}\ \ldots\ \ml{)}\]
%
%\noindent For example,
%
%\begin{session}\begin{verbatim}
%- Term `if b then if c then if d then e else f else g else h`;
%<<HOL message: inventing new type variable names: 'a.>>
%
%> val it =
%    `(if b then (if c then (if d then e else f) else g) else h)`
%    : term
%
%- Term `b => c => d => e | f | g | h`;
%<<HOL message: inventing new type variable names: 'a.>>
%
%> val it =
%    `(if b then (if c then (if d then e else f) else g) else h)`
%    : term
%
%\end{verbatim}\end{session}
%
%

A large number of theorems involving the logical constants are
pre-proved in the theory {\small\verb+bool+}. The following are only a
selection.

\begin{boxed}\begin{verbatim}
BOTH_EXISTS_AND_THM  |- !P Q. (?x. P /\ Q) = (?x. P) /\ ?x. Q

BOTH_EXISTS_IMP_THM  |- !P Q. (?x. P ==> Q) = (!x. P) ==> ?x. Q

BOTH_FORALL_IMP_THM  |- !P Q. (!x. P ==> Q) = (?x. P) ==> !x. Q

BOTH_FORALL_OR_THM   |- !P Q. (!x. P \/ Q) = (!x. P) \/ !x. Q

COND_ABS        |- !b f g. (\x. (if b then f x else g x)) = if b then f else g

COND_EXPAND     |- !b t1 t2. (if b then t1 else t2) = (~b \/ t1) /\ (b \/ t2)

COND_ID         |- !b t. (if b then t else t) = t

COND_RAND       |- !f b x y. f (if b then x else y) = if b then f x else f y

COND_RATOR      |- !b f g x. (if b then f else g) x = if b then f x else g x

DE_MORGAN_THM        |- !A B. (~(A /\ B) = ~A \/ ~B) /\ (~(A \/ B) = ~A /\ ~B)

ETA_THM              |- !M. (\x. M x) =  M

EXISTS_OR_THM        |- !P Q. (?x. P x \/ Q x) = (?x. P x) \/ ?x. Q x

FORALL_AND_THM       |- !P Q. (!x. P x /\ Q x) = (!x. P x) /\ !x. Q x

LEFT_AND_FORALL_THM  |- !P Q. (!x. P x) /\ Q = !x. P x /\ Q

LEFT_EXISTS_AND_THM  |- !P Q. (?x. P x /\ Q) = (?x. P x) /\ Q

LEFT_EXISTS_IMP_THM  |- !P Q. (?x. P x ==> Q) = (!x. P x) ==> Q

LEFT_FORALL_IMP_THM  |- !P Q. (!x. P x ==> Q) = (?x. P x) ==> Q

LEFT_FORALL_OR_THM   |- !Q P. (!x. P x \/ Q) = (!x. P x) \/ Q

LEFT_OR_EXISTS_THM   |- !P Q. (?x. P x) \/ Q = ?x. P x \/ Q

NOT_EXISTS_THM       |- !P. ~(?x. P x) = !x. ~P x

NOT_FORALL_THM       |- !P. ~(!x. P x) = ?x. ~P x
\end{verbatim}\end{boxed}

\begin{boxed}\begin{verbatim}
RIGHT_AND_FORALL_THM |- !P Q. P /\ (!x. Q x) = !x. P /\ Q x

RIGHT_AND_OVER_OR    |- !A B C. (B \/ C) /\ A = B /\ A \/ C /\ A

RIGHT_EXISTS_AND_THM |- !P Q. (?x. P /\ Q x) = P /\ ?x. Q x

RIGHT_EXISTS_IMP_THM |- !P Q. (?x. P ==> Q x) = P ==> ?x. Q x

RIGHT_FORALL_IMP_THM |- !P Q. (!x. P ==> Q x) = P ==> !x. Q x

RIGHT_FORALL_OR_THM  |- !P Q. (!x. P \/ Q x) = P \/ !x. Q x

RIGHT_OR_EXISTS_THM  |- !P Q. (?x. P ==> Q x) = P ==> ?x. Q x

RIGHT_FORALL_IMP_THM |- !P Q. (!x. P ==> Q x) = P ==> !x. Q x

RIGHT_FORALL_OR_THM  |- !P Q. (!x. P \/ Q x) = P \/ !x. Q x

RIGHT_OR_EXISTS_THM  |- !P Q. P \/ (?x. Q x) = ?x. P \/ Q x

SELECT_REFL          |- !x. (@y. y = x) = x

SELECT_UNIQUE        |- !P x. (!y. P y = y = x) ==> ($@ P = x)
\end{verbatim}\end{boxed}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "description"
%%% End:
