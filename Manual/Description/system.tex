\chapter{The HOL Logic in ML}\label{HOLsyschapter}

In this chapter, the concrete representation of the \HOL\ logic is
described.  This involves describing the \ML\ functions that comprise
the interface to the logic (up to and including
Section~\ref{avra_terms}); the quotation, parsing, and printing of
logical types and terms (Section~\ref{quotation}); the representation of
theorems (Section~\ref{sec:theorems-in-ml}); the representation of theories
(Section~\ref{theoryfns}); the fundamental \HOL\ theory \texttt{bool}
(Section~\ref{boolfull}); the primitive rules of inference
(Section~\ref{rules}); and the methods for extending theories
(throughout Section~\ref{theoryfns} and also later in
Section~\ref{sec:bossLib}).  It is assumed that the reader is familiar
with \ML.  If not, the introduction to \ML\ in {\sl Getting Started
with HOL\/} in \TUTORIAL\ should be read first.

The \HOL\ system provides the \ML\ types \ml{hol\_type} and \ml{term}
which implement the types and terms of the \HOL\ logic, as defined in
Sections~\ref{types} and \ref{terms}, respectively. It also provides
primitive \ML\ functions for creating and manipulating values of these
types. Upon this basis the \HOL{} logic is implemented. The key idea
of the \HOL\ system, due to Robin Milner\index{Milner, R.}, and
discussed in this chapter, is that theorems are represented as an
abstract \ML\ type whose only pre-defined values are axioms, and whose
only operations are rules of inference. This means that the only way
to construct theorems in \HOL\ is to apply rules of inference to
axioms or existing theorems; hence the consistency of the logic is
preserved.

The purpose of the meta-language \ML\ is to provide a programming
environment in which to build theorem proving tools to assist in the
construction of proofs.  When the \HOL\ system is built, a range of
useful theorems is pre-proved and a set of tools pre-defined. The basic
system thus offers a rich initial environment; users can further enrich
it by implementing their own application specific tools and building
their own application specific theories.


\section{Lexical matters}\label{HOL-lex}

\index{identifiers, in HOL logic@identifiers, in \HOL\ logic|(} The name
of a \HOL\ variable\index{variables, in HOL logic@variables, in \HOL\
logic!names of|(} can be any \ML\ string, but the quotation mechanism
will parse only names that are identifiers (see Section~\ref{ident}
below).  The use of non-identifiers as variable names is discouraged
except in special circumstances (for example, when writing derived rules
that generate variables with names that are guaranteed to be different
from existing names). The name of a type variable\index{type variables,
in HOL logic@type variables, in \HOL\ logic!names of} in the \HOL\ logic
is formed by a prime (\ml{'}) followed by an alphanumeric which itself
contains no prime (see Section~\ref{tyvars} for examples).  The name of
a type constant or a term constant in the \HOL\ logic can be any
identifier, although some names are treated specially by the HOL parser
and printer and should therefore be avoided.
\index{identifiers, in HOL logic@identifiers, in \HOL\ logic|)}

\subsubsection{Identifiers}\label{ident}

A \HOL\ identifier can be of two forms:
\begin{myenumerate}
\item A finite sequence of alphanumerics starting with a letter.
\item A \emph{symbolic} identifier, \ie, a finite sequence formed by any
combination of the following characters:
\begin{hol}
\begin{verbatim}
  #  ?  +  *  /  \  =  <  >  &  %  @  !  ,  :  ;  _  |  ~  -
\end{verbatim}\end{hol}
\end{myenumerate}
%
A letter is a member of the list:
%
\begin{hol}
\begin{verbatim}
   a b c d e f g h i j k l m n o p q r s t u v w x y z
   A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
\end{verbatim}
\end{hol}
%
\HOL\ is case-sensitive: upper and lower case letters are
considered to be different.

Alphanumerics are letters or digits or underscores (\ml{\_}) or primes
(\ml{'}).  A digit is one of
{\small\verb+0+}, {\small\verb+1+}, {\small\verb+2+}, {\small\verb+3+},
{\small\verb+4+}, {\small\verb+5+}, {\small\verb+6+}, {\small\verb+7+},
{\small\verb+8+}, or {\small\verb+9+}.
A {\it number\/} is a string of one or more digits. In order to
distinguish different kinds of numbers a single character suffix may
be used: for example \verb+3n+ is a natural number while \verb+3i+ is
an integer.

\paragraph{Separators}

The separators used by the \HOL\ lexical analyser are (with ascii codes in
brackets):

\bigskip

space (32), carriage return (13), line feed (10), tab ({\verb+^+}I, 9),
form feed ({\verb+^+}L, 12)


\paragraph{Special identifiers}

The following valid identifiers should not be used as the name of
a variable or a constant.
%
\begin{verbatim}
   let  in  and  \  ;  =>  |  :  :=  with  updated_by
\end{verbatim}

\paragraph {Type variable names}\label{tyvars}

The name of a type variable in the \HOL\ logic is a string
beginning with a prime (\ml{'}) followed by an alphanumeric which itself
contains no prime; for example all of the following are valid type
variable names except for the last:
%
\begin{hol}
\begin{verbatim}
   'a   'b   'cat   'A11   'g_a_p   'f'oo
\end{verbatim}
\end{hol}


\section{Types}\index{types, in HOL logic@types, in \HOL\ logic}

The allowed types\index{type constraint!in HOL logic@in \HOL\ logic}
depend on which type constants\index{type constants, in HOL logic@type
constants, in \HOL\ logic} have been declared in the
current theory. See Section~\ref{theoryfns} for details of how such
declarations are made. There are two primitive constructor
\index{types, in HOL logic@types, in \HOL\ logic!constructors for}
\index{type constructors!in HOL logic@in \HOL\ logic} 
functions for values of type \ml{hol\_type}:
%
\index{function types, in HOL logic@function types, in \HOL\ logic!constructors for}
\index{mk_vartype@\ml{mk\_vartype}|pin}
\index{mk_type@\ml{mk\_type}|pin}
\begin{boxed}
\begin{verbatim}
   mk_vartype : string -> hol_type
   mk_thy_type : {Tyop:string, Thy:string, Args:hol_type list} -> hol_type
\end{verbatim}
\end{boxed}
%
The function \ml{mk\_vartype}
 constructs a type variable\index{type variables, in HOL logic@type
 variables, in \HOL\ logic!constructor for} with a given name;
it gives a warning if the name is not an allowable type variable name (\ie\ not
a \ml{'} followed by an alphanumeric).

The function \ml{mk\_thy\_type} constructs a compound type
\index{compound types, in HOL logic@compound types, in \HOL\ logic!constructors for}
from a record {\small\verb+{Tyop,Thy,Args}+} where {\small\verb+Tyop+}
is a string representing the name of the type operator, 
{\small\verb+Thy+} is a string representing the theory that
{\small\verb+Tyop+} was declared in, and {\small\verb+Args+} is  a list of
types representing the arguments to the operator.  Function types
$\sigma_1\fun\sigma_2$ of the logic are represented in \ML\ as though
they were compound types $(\sigma_1,\sigma_2)$\ml{fun} (in
Section~\ref{types}, however, function types were not regarded as
compound types).

The evaluation of
$\mathtt{mk\_thy\_type}\{\mathtt{Tyop} = \mathit{name},\
\mathtt{Thy} = \mathit{thyname},\ 
\mathtt{Args} = [\sigma_1, \cdots ,\sigma_n]\}$
fails if
%
\begin{myenumerate}
\item $\mathit{name}$ is not a type operator of theory $\mathit{thyname}$
\item $\mathit{name}$ is a type operator of theory $\mathit{thyname}$,
but its arity is not $n$.
\end{myenumerate}
%
For example, \ml{mk\_thy\_type\{Tyop="bool", Thy="bool", Args=[]\}}
\index{truth values, in HOL logic@truth values, in \HOL\ logic}
\index{bool, the type in HOL logic@\ml{bool}, the type in \HOL\ logic}
evaluates to an \ML\ value of type \ml{term} representing the type
\ty{bool}.
%
%\paragraph{Support for constructing types}

Type constants may be
bound to \ML\ values and need not be repeatedly constructed: \eg, the type built by 
\ml{mk\_thy\_type\{Tyop="bool", Thy="bool", Args=[]\}} is abbreviated  
by the \ML\ value \ml{bool}. Similarly, function types may be constructed
with the infix \ML\ function \ml{-->}. A few common type variables
have been constructed and bound to \ML{} identifers, \eg, \ml{alpha}
is the type variable \ml{'a} and \ml{beta} is the type variable
\ml{'b}.  Thus the \ML\ code \ml{alpha --> bool} is equal to, but much more concise than
%
{\small
\begin{verbatim}
  mk_thy_type{Tyop="fun", Thy="min", 
              Args=[mk_vartype "'a", 
                    mk_thy_type{Tyop="bool", Thy="bool", Args=[]}}
\end{verbatim}
}

%\paragraph{Taking types apart}

\noindent There are two primitive destructor\index
{types, in HOL logic@types, in \HOL\ logic!destructors for}
\index{type destructors, in HOL logic@type destructors, in \HOL\ logic}
functions for values of type \ml{hol\_type}:
\begin{boxed}
\index{function types, in HOL logic@function types, in \HOL\ logic!destructors for}
\index{dest_vartype@\ml{dest\_vartype}|pin}
\index{dest_thy_type@\ml{dest\_thy\_type}|pin}
\begin{verbatim}
  dest_vartype : hol_type -> string
  dest_thy_type : hol_type -> {Tyop:string, Thy:string, Args:hol_type list}
\end{verbatim}\end{boxed}

\noindent The function \ml{dest\_vartype}
\index{type variables, in HOL logic@type variables, in \HOL\ logic!destructors for}
\index{compound types, in HOL logic@compound types, in \HOL\ logic!destructors for}
extracts the name of a type variable.
A compound type is destructed by the function \ml{dest\_thy\_type} into the  name
 of the type operator, the name of the theory it was declared in, and
 a  list  of  the  argument  types; 
 \ml{dest\_vartype}  and \ml{dest\_thy\_type} are  thus the  inverses of
 \ml{mk\_vartype} and \ml{mk\_thy\_type}, respectively.  The destructors fail
 on arguments of the wrong form.


\section{Terms}\label{avra_terms}

The four primitive kinds of terms of the logic are described in
Section~\ref{terms}.  The \ML\ functions for manipulating these are
described in this section. There are also \emph{derived} terms that
are described in Section~\ref{derived-terms}.

At any time, the terms that may be constructed depends on which
constants have been declared in the current theory. See
Section~\ref{theoryfns} for details of how such declarations are made.

There are four primitive constructor
\index{variables, in HOL logic@variables, in \HOL\ logic!constructor for}
\index{terms, in HOL logic@terms, in \HOL\ logic!constructors for}
\index{term constructors, in HOL logic@term constructors, in \HOL\ logic} 
functions for values of type \ml{term}:

\begin{boxed}
\index{mk_var@\ml{mk\_var}|pin}
\begin{verbatim}
   mk_var : (string * hol_type) -> term
\end{verbatim}
\end{boxed}

\noindent\ml{mk\_var(}$x$\ml{,}$\sigma$\ml{)} evaluates to a variable
with name $x$ and type $\sigma$; it always succeeds.

\begin{boxed}
\index{mk_thy_const@\ml{mk\_const}|pin}
\begin{verbatim}
   mk_thy_const : {Name:string, Thy:string, Ty:hol_type} -> term
\end{verbatim}
\end{boxed}

\noindent $\mathtt{mk\_thy\_const}\{\mathtt{Name} = \mathit{c},\
\mathtt{Thy} = \mathit{thyname},\ \mathtt{Ty} = \sigma\}$
 evaluates to a term representing the constant
\index{constants, in HOL logic@constants, in \HOL\ logic!constructor for} 
with name $c$ and type $\sigma$; it fails if:
\begin{myenumerate}
% \item $c$ is not an allowable constant name;
\item $c$ is not the name of a constant in the theory $\mathit{thyname}$;
\item $\sigma$ is not an instance of the generic type of $c$
(the generic type of a constant is established when the constant is defined;
see Section~\ref{theoryfns}).
\end{myenumerate}

\begin{boxed}\index{mk_comb@\ml{mk\_comb}|pin}
\begin{verbatim}
   mk_comb : (term * term) -> term
\end{verbatim}
\end{boxed}

\noindent\ml{mk\_comb(}$t_1$\ml{,}$t_2$\ml{)}\index{function application, in HOL logic@function application, in \HOL\ logic!constructor for} evaluates to a term
representing the combination\index{combinations, in HOL logic@combinations, in \HOL\ logic!constructor for}
$t_1\ t_2$. It fails if:
\begin{myenumerate}
\item the type of $t_1$ does not have the form \ml{$\sigma'$->$\sigma$};
\item the type of $t_1$ has the form \ml{$\sigma'$->$\sigma$}, but the
type of $t_2$ is not equal to $\sigma'$.
\end{myenumerate}

\begin{boxed}
\index{mk_abs@\ml{mk\_abs}|pin}
\begin{verbatim}
   mk_abs : (term * term) -> term
\end{verbatim}
\end{boxed}

\noindent\ml{mk\_abs(}$x$\ml{,}$t$\ml{)} evaluates to a term representing
the abstraction\index{function abstraction, in HOL logic@function abstraction, in \HOL\ logic!constructor for} $\lquant{x}t$; it fails if $x$ is not a variable.


There are four primitive destructor\index{term destructors, in HOL logic@term destructors, in \HOL\ logic}\index{variables, in HOL logic@variables, in \HOL\ logic!destructor for}\index{constants, in HOL logic@constants, in \HOL\ logic!destructor for}\index{combinations, in HOL logic@combinations, in \HOL\ logic!destructor for}\index{function abstraction, in HOL logic@function abstraction, in \HOL\ logic!destructor for}\index{function application, in HOL logic@function application, in \HOL\ logic!destructor for} functions on terms:

\begin{boxed}

\index{dest_var@\ml{dest\_var}|pin}
\index{dest_thy_const@\ml{dest\_thy\_const}|pin}
\index{dest_comb@\ml{dest\_comb}|pin}
\index{dest_abs@\ml{dest\_abs}|pin}
\begin{verbatim}
   dest_var   : term -> (string * hol_type)
   dest_thy_const : term -> {Name:string, Thy:string, Ty:hol_type}
   dest_comb  : term -> (term * term)
   dest_abs   : term -> (term * term)
\end{verbatim}
\end{boxed}

These are the inverses of \ml{mk\_var}, \ml{mk\_thy\_const},
\ml{mk\_comb} and \ml{mk\_abs}, respectively. They fail when applied
to terms of the wrong form. Other useful destructor functions are
\ml{rator}\index{rator@\ml{rator}},
\ml{rand}\index{rand@\ml{rand}},
\ml{bvar}\index{bvar@\ml{bvar}},
\ml{body}\index{body@\ml{body}},
\ml{lhs}\index{lhs@\ml{lhs}} and
\ml{rhs}\index{rhs@\ml{rhs}}.
See \REFERENCE\ for details.

The function

\begin{boxed}\index{type_of@\ml{type\_of}|pin}
\begin{verbatim}
   type_of : term -> hol_type
\end{verbatim}\end{boxed}

\noindent returns the type
\index{types, in HOL logic@types, in \HOL\ logic!determination of} 
of a term. The function

\begin{boxed}\index{aconv@\ml{aconv}|pin}
\begin{verbatim}
   aconv : term -> term -> bool
\end{verbatim}\end{boxed}

\noindent implements the $\alpha$-convertibility test for
$\lambda$-calculus terms.
\index{$\alpha$-convertibility, in HOL logic@$\alpha$-convertibility, in \HOL\ logic!determination of}  
From the point of view of the \HOL{} logic, $\alpha$-convertible terms
are identical. A variety of other functions are available for
performing substitution (\verb+subst+), type instantiation
(\verb+inst+), $\beta$-reduction (\verb+beta_conv+), $\eta$-reduction
(\verb+eta_conv+), computation of free variables (\verb+free_vars+)
and other common term operations.  See \REFERENCE{} for more details.


\section{Quotation}
\label{quotation}\label{gen-abs}\label{let}
\index{type checking, in HOL logic@type checking, in \HOL\ logic!of quotation syntax|(}
\index{quotation, in HOL logic@quotation, in \HOL\ logic|(}
\index{ type quotes, in ML@\ml{"":$\cdots$""} (type quotes, in \ML)|(}
\index{ term quotes, in ML@\ml{""$\cdots$""} (term quotes, in \ML)|(}

It would be tedious to always have to input types and terms
using the constructor functions. The \HOL\ system, adapting the
approach taken in \LCF\index{LCF@\LCF}, has special
quotation
\index{quotation, in HOL logic@quotation, in \HOL{} logic!parser for}
\index{parsing, of HOL logic@parsing, of \HOL{} logic!of quotation syntax} 
parsers for \HOL\ types and terms which enable types and terms
to be input using a fairly standard syntax. For example, the \ML{}
expression $\holquote{\ml{:bool -> bool}}$ denotes exactly the same
value (of \ML\ type \ml{hol\_type}) as 

\begin{hol}
\index{bool, the type in HOL logic@\ml{bool}, the type in \HOL\ logic}
\begin{verbatim}
  mk_thy_type{Tyop = "fun",Thy = "min",
              Args = [mk_thy_type{Tyop = "bool", Thy = "bool", Args = []}, 
                      mk_thy_type{Tyop = "bool", Thy = "bool", Args = []}]}
\end{verbatim}
\end{hol}

\noindent and the expression {\small\verb|\x. x + 1|}
%
\index{function abstraction, in HOL logic@function abstraction, in \HOL\ logic}
%
can be used instead of\footnote{In order to be processed successfully, this
quotation requires the theory of arithmetic to have already been loaded, which 
can be accomplished by {\tt load "arithmeticTheory"}.}

{\small\baselineskip\HOLSpacing
\begin{verbatim}
 let val numty = mk_thy_type{Tyop="num",Thy="num",Args=[]}
 in 
  mk_abs
   (mk_var("x",numty),
    mk_comb(mk_comb
     (mk_thy_const
       {Name="+",Thy="arithmetic",Ty=numty --> numty --> numty},
        mk_var("x", numty)),
      mk_comb(mk_thy_const{Name="NUMERAL",Thy="arithmetic",Ty=numty-->numty},
       mk_comb(mk_thy_const{Name="BIT1",Thy="arithmetic",Ty=numty-->numty},
               mk_thy_const{Name="ZERO",Thy="arithmetic",Ty=numty}))))
 end
\end{verbatim}
}

 The \HOL{} printer, which is integrated into the \ML{} toplevel loop,
also outputs types and terms using this syntax.
\index{printing, in HOL logic@printing, in \HOL{} logic!of quotation syntax}
Types are printed
\index{printing, in HOL logic@printing, in \HOL\ logic!of types} 
in the form $\holquote{:\mathit{type}}$. For example, the \ML\ value
of type \ml{hol\_type} representing 
$\alpha\fun(\ty{ind}\fun\ty{bool})$ would be printed out 
as $\holquote{: \ml{\ensuremath{{}^\prime\!} a -> ind -> bool}}$.
Similarly, terms are printed in the form $\holquote{\,\mathit{term}\,}$. 
Thus, the term representing $\holquote{\uquant{x\ y}x<y \imp\equant{z}x+z = y}$
would be printed as:
%
\[ \holquote{\ml{!x y. x < y ==> ?z. x + z = y}} \]
%
A leading colon is used to distinguish a type quotation from a term quotation:
the former have the form \ml{`:}$\ \cdots\ $\ml{`} and the latter have
the form \ml{`}$\ \cdots\ $\ml{`}.

\index{type inference!in HOL parser@in \HOL\ parser|(}

\paragraph {Type inference}
Notice that there is no explicit type information in
\verb!\x.x+1!.  The \HOL\ type checker knows that \ml{1} has
type \ml{num} and \ml{+} has type \ml{num->(num->num)}.  From this
information it can infer that both occurrences of \ml{x} in
\verb!\x.x+1! could have type \ml{num}.  This is not the only possible
type assignment; for example, the first occurrence of \ml{x} could
have type \ml{bool} and the second one have type \ml{num}.  In that
case there would be two \emph{different} variables with name
\ml{x}, namely \ml{x}$_{\tt bool}$ and
\ml{x}$_{\tt num}$, the second of which is free.  However, the only
way to construct a term with this second type 
assignment is by using constructors, since the type checker uses the
heuristic that all variables in a term with the same name have the
same type.  This is illustrated in the following session.
%
\setcounter{sessioncount}{1}
\begin{session}
\begin{verbatim}
   - ``x = (x = 1)``;
   Type inference failure: unable to infer a type for the application of

   $= (x :num)

   which has type

   :num -> bool

   to

   (x :num) = (1 :num)

   which has type

   :bool

   unification failure message: unify failed
\end{verbatim}
\end{session}

The desired value can be directly constructed by the primitive constructor
functions:

\begin{session}
\begin{verbatim}
   - mk_eq
      (mk_var("x",bool),
       mk_eq(mk_var("x",numty),
             mk_numeral (Arbnum.fromString "1")));
   > val it = ``x = x = 1`` : term
\end{verbatim}
\end{session}

The original quotation type checker was designed and implemented by
Robin Milner\index{Milner, R.}.  It employs heuristics like the one
above to infer a sensible type for all variables occurring in a term.

At times, the user may want to control the exact type of a subterm. To
support such functionality, types can be explicitly indicated by
following any subterm with a colon and then a type.  For example,
\ml{``f(x:num):bool``} will type check with \ml{f} and \ml{x}
getting types \ml{num->bool} and \ml{num} respectively. 
This treatment of types within quotations is inherited from
\LCF\index{LCF@\LCF}.  \index{type constraint!in HOL logic@in \HOL\
  logic|)} \index{ term quotes, in ML@\ml{`$\cdots$`} (term quotes, in
  \ML)|)}

\subsection{Antiquotation}

Within a quotation, expressions of the form {\small\verb+^(+}$t${\small\verb+)+}
%
\index{ antiquotation, in HOL logic@{\small\verb+^+} (antiquotation, in \HOL\ logic)}
%
(where $t$ is an \ML\ expression of type
%
\index{type checking, in HOL logic@type checking, in \HOL\ logic!antiquotation in}
%
{\small\verb+term+} or {\small\verb+type+}) are called {\it antiquotations\/}
%
\index{terms, in HOL logic@terms, in \HOL\ logic!antiquotation}\index{antiquotation, in HOL logic terms@antiquotation, in \HOL\ logic terms}.
%
An antiquotation {\small\verb+^(+}$t${\small\verb+)+} evaluates to the
\ML\ value of $t$. For example,{\small\verb+``x \/ ^(mk_conj(``y:bool``, ``z:bool``))``+}
evaluates to the same term as {\small\verb+``x \/ (y /\ z)``+}. The
most common use of antiquotation is when the term $t$ is bound to an \ML\
variable $x$. In this case {\small\verb+^(+}$x${\small\verb+)+} can be
abbreviated by {\small\verb+^+}$x$.

The following session illustrates antiquotation.

\setcounter{sessioncount}{1}
\begin{session}
\begin{verbatim}
- val y = ``x+1``;
> val y = ``x + 1`` : term

val z = ``y = ^y``;
> val z = ``y = x + 1`` : term

- ``!x:num.?y:num.^z``;
> val it = ``!x. ?y. y = x + 1`` : term
\end{verbatim}
\end{session}

\noindent Types may be antiquoted as well:

\setcounter{sessioncount}{1}
\begin{session}
\begin{verbatim}
- val pred = ``:'a -> bool``;
> val pred = ``:'a -> bool`` : hol_type

- ``:^pred -> bool``;
> val it = ``:('a -> bool) -> bool`` : hol_type
\end{verbatim}
\end{session}

\noindent Antiquoting a type into a term quotation requires the use of
{\verb+ty_antiq+}. For example, 

\begin{session}
\begin{verbatim}
- ``!P:^pred. P x ==> Q x``;

! Toplevel input:
! Term `!P:^pred. P x ==> Q x`;
!           ^^^^
! Type clash: expression of type
!   hol_type
! cannot have type
!   term

- ``!P:^(ty_antiq pred). P x ==> Q x``;
> val it = `!P. P x ==> Q x` : term
\end{verbatim}
\end{session}

\subsection{Viewing the grammar}

The behaviour of the \HOL{} quotation parser and printer is determined
by the current grammar. Thus, a familiarity with the basic
vocabulary of the standard collection of \HOL{} theories is important
if one is to use \HOL effectively. One can examine the current grammar used by the
parser with the functions \verb+type_grammar+ and \verb+term_grammar+.

For example, in the following session, we see that the type grammar
used in the startup context of \HOL{} has the type operators
\verb+fun+, \verb+sum+, \verb+prod+, \verb+list+, \verb+recspace+, 
\verb+num+, \verb+option+, \verb+one+, \verb+label+, \verb+ind+, and
\verb+bool+. 

\setcounter{sessioncount}{1}
\begin{session}
\begin{verbatim}
- type_grammar();
> val it = 
    Rules:
    (50)   TY  ::=  TY -> TY [fun] (R-associative)
    (60)   TY  ::=  TY + TY [sum] (R-associative)
    (70)   TY  ::=  TY # TY [prod] (R-associative)
    (100)  TY  ::=  TY list | TY recspace | num | (TY, TY)prod | TY option |
                    one | (TY, TY)sum | label | (TY, TY)fun | ind | bool
     : grammar
\end{verbatim}
\end{session}

Also, \verb+fun+, \verb+sum+, and \verb+prod+ have infix 
notation (\verb+->+), (\verb|+|), and (\verb+#+), respectively, with 
different binding strengths: \verb+#+ (with 70) binds stronger than
\verb|+| (60), which  binds stronger than \verb+->+ (50). All postfix
type operators (with 100) bind more strongly than the infixes.

The next session shows the (abbreviated) output from invoking
\verb+term_grammar+ in the startup \HOL{} environment. The deleted output
includes a listing of  all constants known to the system, 
including prefix operators, along with all overloadings currrently in
force. The portrayed grammar ranges from binding operators at very low (0) binding
strength, through to function application (2000) and record selection
(2500), which bind very tightly.


\begin{session}
\begin{verbatim}
- term_grammar();
> val it =
    (0)    TM  ::=  "LEAST" <..binders..>  "." TM |
                    "?!" <..binders..>  "." TM | "?" <..binders..>  "." TM |
                    "!" <..binders..>  "." TM | "@" <..binders..>  "." TM |
                    "\" <..binders..>  "." TM
    (2)    TM  ::=  "let" TM "in" TM  [let]
    (3)    TM  ::=  TM "=>" TM "|" TM  [COND]   (R-associative)
    (4)    TM  ::=  TM "::" TM (restricted quantification operator)
    (5)    TM  ::=  TM TM  (binder argument concatenation)
    (7)    TM  ::=  "case" TM "of" TM  [case__magic]
    (8)    TM  ::=  TM "||" TM  [case_split__magic]   (R-associative)
    (9)    TM  ::=  TM "and" TM   (L-associative)
    (10)   TM  ::=  TM "->" TM  [case_arrow__magic]   (R-associative)
    (50)   TM  ::=  TM "##" TM | TM "," TM   (R-associative)
    (70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
    (80)   TM  ::=  TM ":-" TM   (non-associative)
    (100)  TM  ::=  TM "=" TM   (non-associative)
    (200)  TM  ::=  TM "==>" TM   (R-associative)
    (300)  TM  ::=  TM "\/" TM   (R-associative)
    (400)  TM  ::=  TM "/\" TM   (R-associative)
    (425)  TM  ::=  TM "IN" TM   (non-associative)
    (440)  TM  ::=  TM "++" TM   (L-associative)
    (450)  TM  ::=  TM "::" TM  [CONS] | TM ">=;" TM | TM "<=" TM |
                    TM ">" TM | TM "<;" TM | TM ">=" TM | TM "<=" TM |
                    TM ">" TM | TM "<" TM | TM "LEX" TM | TM "RSUBSET" TM |
                    TM ":=" TM  [record field update] |
                    TM "updated_by" TM  [functional record update] |
                    TM "with" TM  [record update]
                    (R-associative)
    (500)  TM  ::=  TM "-" TM | TM "+" TM | TM "RUNION" TM   (L-associative)
    (600)  TM  ::=  TM "DIV" TM | TM "*" TM | TM "RINTER" TM
                    (L-associative)
    (650)  TM  ::=  TM "MOD" TM   (L-associative)
    (700)  TM  ::=  TM "**" TM | TM "EXP" TM   (R-associative)
    (800)  TM  ::=  TM "O" TM | TM "o" TM   (R-associative)
    (900)  TM  ::=  "~" TM
    (1000) TM  ::=  TM ":" TY  (type annotation)
    (2000) TM  ::=  TM TM  (function application) |    (L-associative)
    (2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
           TM  ::=  "[" ... "]"  (separator = ";") |
                    "<|" ... "|>"  (separator = ";")
           TM  ::=  "(" ")"  [one] |
                    "(" TM ")"  [just parentheses, no term produced]
    ... <further output omitted>
  : grammar
\end{verbatim}
\end{session}

\subsection{Namespace control}

In order to provide convenience, the parser deals with overloading and
ambiguity. Overloading of numeric literals is discussed in Section
\ref{arith-overloading}, although any symbol may be overloaded, not
just numerals. At times such flexibility is quite useful; however, it
can happen that one wishes to explicitly designate a particular
constant. In that case, the notation
$\mathit{thy}$\verb+$+$\mathit{const}$ may be used in the parser to
designate the constant $\mathit{const}$ declared in theory
$\mathit{thy}$. In the following example, the less-than operator is
explicitly specified.

\setcounter{sessioncount}{1}
\begin{session}
\begin{verbatim}
- ``x prim_rec$< y``
> val it = ``x < y`` : term
\end{verbatim}
\end{session}


\section{Ways to construct types and terms}

\index{type variables, in HOL logic@type variables, in \HOL\ logic!constructor for}
\index{type constructors!in HOL logic@in \HOL\ logic}
\index{term constructors, in HOL logic@term constructors, in \HOL\ logic|(}
\index{terms, in HOL logic@terms, in \HOL\ logic!constructors for|(}
The table below shows \ML\ expressions for various kinds of type
quotations\index{quotation, in HOL logic@quotation, in \HOL\ logic!of types}.
The expressions in the same row are equivalent.

\bigskip

\begin{center}
\index{compound types, in HOL logic@compound types, in \HOL\ logic!constructors for}
\index{ type variables, in HOL logic@\ml{'a,\,'b,\,}$\ldots$ (type variables, in \HOL\ logic)}
\index{types, in HOL logic@types, in \HOL\ logic!constructors for}
\index{ function type operator, in HOL logic@\ml{->} (function type operator, in \HOL\ logic)}
\index{mk_vartype@\ml{mk\_vartype}}
\index{mk_type@\ml{mk\_type}}
\begin{tabular}{|l|l|l|} \hline
\multicolumn{3}{|c|}{ } \\
\multicolumn{3}{|c|}{\bf Types} \\
\multicolumn{3}{|c|}{ } \\
{\it Kind of type} & {\it \ML\ quotation} & {\it Constructor expression}  \\ \hline
 & & \\
Type variable &
{\small\verb+: '+}{\small $alphanum$}  & {\small\verb+mk_vartype("'+$alphanum$\verb+")+}   \\ \hline
Type constant & $:op$ & {\small\verb+mk_type("+}$op${\small\verb+",[])+}   \\ \hline
 & $:\mathit{thy}$\verb+$+$\mathit{op}$ 
  & {\small\verb+mk_thy_type{Thy="+}$\mathit{thy}${\small\verb+",Tyop="+}$\mathit{op}${\small\verb+",Args=[]}+}   \\ \hline
Function type & $: \sigma_1$ {\small\verb+->+} $\sigma_2$ &
$\sigma_1$ {\small\verb+-->+} $\sigma_2$ \\ 
\hline
Compound type &
{\small\verb+:(+}$\sigma_1${\small\verb+,+} $\ldots$ {\small\verb+,+} $\sigma_n${\small\verb+)+}$op$ &
{\small\verb+mk_type("+}$op${\small\verb+", [+}
 $\sigma_1$ {\small\verb+,+} $\ldots$ {\small\verb+,+} $\sigma_n${\small\verb+])+}
\\ 
\hline
& {\small\verb+:(+}$\sigma_1${\small\verb+,+} $\ldots$ {\small\verb+,+} $\sigma_n${\small\verb+)+}$\mathit{thy}$\verb+$+$\mathit{op}$ 
& \begin{tabular}{l}
   {\small\verb+mk_thy_type{Thy="+}$\mathit{thy}${\small\verb+",+} \\
\quad \qquad {\small\verb+Tyop="+}$\mathit{op}${\small\verb+", Args=[+}
 $\sigma_1$ {\small\verb+,+} $\ldots$ {\small\verb+,+}
  $\sigma_n${\small\verb+]}+}
\end{tabular}
\\ \hline

\end{tabular}
\end{center}

\index{type quotes, in ML@\ml{`:$\cdots$`} (type quotes, in \ML)|)}

\index{terms, in HOL logic@terms, in \HOL\ logic!syntax of|(}

Equivalent ways of inputting the four primitive kinds of term are shown in
the next table.

\bigskip

\begin{center}
\index{combinations, in HOL logic@combinations, in \HOL\ logic!quotation of}
\index{terms, in HOL logic@terms, in \HOL\ logic!primitive}
\index{terms, in HOL logic@terms, in \HOL\ logic!constructors for}
\index{quotation, in HOL logic@quotation, in \HOL\ logic!of primitive terms}
\index{function abstraction, in HOL logic@function abstraction, in \HOL\ logic!symbol for}
\index{function application, in HOL logic@function application, in \HOL\ logic!constructor for}
\index{function application, in HOL logic@function application, in \HOL\ logic!syntax of}
\index{variables, in HOL logic@variables, in \HOL\ logic!constructor for}
\index{variables, in HOL logic@variables, in \HOL\ logic!syntax of}
\index{mk_var@\ml{mk\_var}}
\index{mk_const@\ml{mk\_const}}
\index{mk_comb@\ml{mk\_comb}}
\index{mk_abs@\ml{mk\_abs}}
\begin{tabular}{|l|l|l|} \hline
\multicolumn{3}{|c|}{ } \\
\multicolumn{3}{|c|}{\bf Primitive terms} \\
\multicolumn{3}{|c|}{ } \\
{\it Kind of term} & {\it \ML\ quotation} &
{\it Constructor expression}  \\ \hline
 & & \\
Variable & $var${\small\verb+:+}$\sigma$ &
{\small\verb+mk_var("+}$var${\small\verb+",+}$\sigma${\small\verb+)+} \\ \hline
Constant & $const${\small\verb+:+}$\sigma$ &
{\small\verb+mk_const("+}$const${\small\verb+",+}$\sigma${\small\verb+)+} \\ \hline
Constant & $\mathit{thy}$\verb+$+$\mathit{const}${\small\verb+:+}$\sigma$ &
{\small\verb+mk_thy_const{Name="+}$\mathit{const}${\small\verb+",Thy="+}$\mathit{thy}${\small\verb+",Ty=+}$\sigma${\small\verb+}+} \\ \hline
Combination & $t_1\ t_2$ &
{\small\verb+mk_comb(+}$t_1${\small\verb+, +}$t_2${\small\verb+)+} \\ \hline
Abstraction & {\small\verb+\+}$x${\small\verb+.+}$t$ &
{\small\verb+mk_abs(+}$x${\small\verb+, +}$t${\small\verb+)+} \\ \hline
\end{tabular}
\end{center}\index{type checking, in HOL logic@type checking, in \HOL\ logic!of quotation syntax|)}


In addition to the kinds of terms in the tables above,
the parser also supports the following syntactic abbreviations.


\begin{center}

\index{variables, in HOL logic@variables, in \HOL\ logic!multiple bound}
\index{list_mk_comb@\ml{list\_mk\_comb}|pin}
\index{list_mk_abs@\ml{list\_mk\_abs}|pin}
\index{list_mk_forall@\ml{list\_mk\_forall}|pin}
\index{list_mk_exists@\ml{list\_mk\_exists}|pin}
\index{combinations, in HOL logic@combinations, in \HOL\ logic!abbreviation for multiple}
\index{existential quantifier, in HOL logic@existential quantifier, in \HOL\ logic!abbreviation for multiple}
\index{universal quantifier, in HOL logic@universal quantifier, in \HOL\ logic!abbreviation for multiple}
\begin{tabular}{|l|l|l|} \hline
\multicolumn{3}{|c|}{ } \\
\multicolumn{3}{|c|}{\bf Syntactic abbreviations} \\
\multicolumn{3}{|c|}{ } \\
{\it Abbreviated term} & {\it Meaning} &
{\it Constructor expression} \\ \hline
 & &  \\
$t\ t_1 \cdots t_n$ &
{\small\verb+(+}$\cdots${\small\verb+(+}$t\ t_1${\small\verb+)+}$\cdots t_n${\small\verb+)+} &
{\small\verb+list_mk_comb(+}$t${\small\verb+,[+}$t_1${\small\verb+, +}$\ldots${\small\verb+ ,+}$t_n${\small\verb+])+} \\ \hline
{\small\verb+\+}$x_1\cdots x_n${\small\verb+.+}$t$ &
{\small\verb+\+}$x_1${\small\verb+. +}$\cdots${\small\verb+ \+}$x_n${\small\verb+.+}$t$ &
{\small\verb+list_mk_abs([+}$x_1${\small\verb+, +}$\ldots${\small\verb+ ,+}$x_n${\small\verb+],+}$t${\small\verb+)+}
\\ \hline
\end{tabular}
\end{center}


\section{Theorems}
\label{sec:theorems-in-ml}

In Chapter~\ref{logic}, the notion of deduction was introduced in
terms of \textit{sequents}\index{sequents!in natural deduction}, where
a sequent is a pair whose second component is a formula being asserted
(a conclusion)\index{conclusions!of sequents}, and whose first
component is a set of formulas (hypotheses)\index{hypotheses!of
  sequents}.  Based on this was the notion of a \textit{deductive
  system}\index{natural deduction}\index{deductive systems}: a set of
pairs, whose second component is a sequent, and whose first component
is a set of sequents.\footnote{Note that these sequents form a list,
  not a set; that is, are ordered.}  The concept of a sequent
\textit{following from}\index{follows from, in natural deduction} a
set of sequents via a deductive system was then defined: a sequent
follows from a set of sequents if the sequent is the last element of
some chain of sequents, each of whose elements is either in the set,
or itself follows from the set along with earlier elements of the
chain, via the deductive system.

\index{turnstile notation|(} A notation for `follows from' was then
introduced.  That a sequent $(\{t_1,\ldots,t_n\},\ t)$ follows from a
set of sequents $\Delta$, via a deductive system ${\cal D}$, is
denoted by: $t_1,\ldots,t_n\vdash_{{\cal D},\Delta} t$.  (It was noted
that where either ${\cal D}$ or $\Delta$ were clear by context, their
mention could be omitted; and where the set of hypotheses was empty,
its mention could be omitted.)

A sequent that follows from the empty set of sequents via a deductive
system is called a \textit{theorem} of that deductive system.  That
is, a theorem\index{theorems, in natural deduction} is the last
element of a \textit{proof}\index{proof!in natural deduction} (in the
sense of Chapter~\ref{logic}) from the empty set of sequents. When a
pair $(L,(\Gamma,t))$ belongs to a deductive system, and the list $L$
is empty, then the sequent $(\Gamma,t)$ is called an
\textit{axiom}\index{axioms!in natural deduction}.  Any pair
$(L,(\Gamma,t))$ belonging to a deductive system is called a
\textit{primitive inference}\index{inference, in natural
  deduction}\index{primitive inference, in natural deduction} of the
system, with hypotheses\footnote{Note that `hypotheses' and
  `conclusion' are also used for the components of sequents.} $L$ and
conclusion $(\Gamma,t)$.

A formula\index{formulas as terms, in HOL logic@formulas as terms, in
  \HOL\ logic} in the abstract is represented concretely in \HOL\ by a
term whose \HOL\ type is {\small\verb+:bool+}.  Therefore, a
term
\index{terms, in HOL logic@terms, in \HOL\ logic!as logical formulas} 
of type {\small\verb+:bool+} is used to represent a
member of the set of hypotheses of a sequent; and likewise to
represent the conclusion of a sequent.  Sets in this context are
represented by an implementation of the \ML{} signature \ml{HOLset}
supporting operations such as \ml{member} and
\ml{union}.
\index{sequents!representation of, in HOL logic@representation of, in \HOL\ logic}

A theorem in the abstract is represented concretely in the \HOL\
system by a value with the \ML\ abstract type
{\small\verb+thm+}
\index{thm@\ml{thm}}.
The type {\verb+thm+} has a destructor function

\begin{boxed}
\index{dest_thm@\ml{dest\_thm}|pin}
\begin{verbatim}
   dest_thm : thm -> (term list * term)
\end{verbatim}\end{boxed}

\noindent which returns a pair consisting of a list of the
hypotheses
\index{hypotheses!of theorems} 
and the conclusion
\index{conclusions!of theorems}, respectively, of a theorem.
The order of assumptions in the list should not be relied on.  A
theorem's hypotheses are also available in the set form with the
function

\begin{boxed}
\index{hyp_set@\ml{hyp\_set}}
\begin{verbatim}
   hyp_set : thm -> term HOLset.set
\end{verbatim}
\end{boxed}

Using \ml{dest\_thm}, two further destructor
\index{theorems, in HOL logic@theorems, in \HOL\ logic!destructors for} 
functions are derived

\begin{boxed}
\index{hyp@\ml{hyp}|pin}
\index{concl@\ml{concl}|pin}
\begin{verbatim}
   hyp   : thm -> term list
   concl : thm -> term
\end{verbatim}
\end{boxed}

\noindent for extracting the hypothesis list and the conclusion, respectively,
of a theorem. The \ML\ type {\small\verb+thm+} does not have
a primitive constructor function.  In this way, the \ML\ type system protects
the \HOL\ logic
from the arbitrary and unrecorded construction
of theorems, which would compromise
the consistency
\index{consistency, of HOL logic@consistency, of \HOL\ logic} of the logic.
(Functions which return theorems as values, \eg\ functions representing primitive inferences,
are discussed first in Section~\ref{rules}, and further in
Chapter\ref{derived-rules}.)

It was mentioned in Chapter~\ref{logic} that the deductive system of
\HOL\ includes four axioms.\footnote{This is a simplification: the
  axioms are an extension of the basic logic. See
  Sections~\ref{INIT}.}  In that Chapter, the axioms were presented in
abstract form.  Concretely, axioms are just theorem values that are
introduced through the use of the \ML{} function \ml{new\_axiom} (see
Section~\ref{theoryprims} below).  For example, the axiom
\ml{BOOL\_CASES\_AX} mentioned in Chapter~\ref{logic} is printed in
\HOL\ as follows (where \ml{T} and \ml{F} are the \HOL\ logic's
constants representing truth and falsity, respectively):

\begin{hol}
\index{F@\ml{F}!axiom for}
\begin{verbatim}
   |- !t. (t = T) \/ (t = F) : thm
\end{verbatim}
\end{hol}

\noindent Note the special print format\index{printing, in HOL logic@printing, in \HOL\ logic!of theorems},
 with the approximation
to the abstract $\vdash$ notation\index{theorem notation, in HOL logic@theorem notation, in \HOL\ logic|(}, \ml{|-}, used to indicate \ML\ type
{\small\verb+thm+} status;
as well as the absence of \HOL\ quotation marks\index{theorem marker, in HOL logic@\ml{"|-} (theorem marker, in \HOL\ logic)}
 in the \ml{|-} context.
The session below illustrates the use of the destructor functions:

\setcounter{sessioncount}{1}
\begin{session}
\begin{verbatim}
- val th = BOOL_CASES_AX;
> val th = |- !t. (t = T) \/ (t = F) : thm

- hyp th;
> val it = [] : term list

- concl th;
> val it = ``!t. (t = T) \/ (t = F)`` : term

- type_of it;
> val it = ``:bool`` : hol_type
\end{verbatim}
\end{session}
\index{turnstile notation|)}

\noindent In addition to the print conventions mentioned above, the
printing of theorems prints hypotheses
\index{printing, in HOL logic@printing, in \HOL\ logic!of hypotheses of theorems}
as periods (\ie\ full stops or dots).  The flag \ml{show\_assums}
\index{show_assums@\ml{show\_assums}} allows theorems
to be printed with hypotheses shown in full. These points are illustrated with a
theorem inferred, for example purposes, from another axiom mentioned
in Chapter~\ref{logic}: \ml{SELECT\_AX}.

\setcounter{sessioncount}{1}
\begin{session}
\begin{verbatim}
- val th = UNDISCH (SPEC_ALL SELECT_AX);
> val th =  [.] |- P ($@ P) : thm

- show_assums := true;
> val it = () : unit

- th;
> val it =  [P x] |- P ($@ P) : thm
\end{verbatim}
\end{session}
\index{theorem notation, in HOL logic@theorem notation, in \HOL\ logic|)}

\section{Primitive rules of inference of the HOL Logic}
\label{rules}

\index{inference rules, of HOL logic@inference rules, of \HOL{} logic!primitive|(}
The primitive rules of inference of the logic were described abstractly
in Section~\ref{HOLrules}. The descriptions relied on meta-variables
$t$, $t_1$, $t_2$, and so on.
In the \HOL\ logic, infinite families of primitive
inferences are grouped together and thought of as single primitive inference
schemes.\index{families of inferences, in HOL logic@families of inferences, in \HOL\ logic}  Each family contains all the concrete instances of one
particular inference `pattern'. These can be produced, in
abstract form, by instantiating the meta-variables in Section~\ref{HOLrules}
to concrete terms.

In \HOL, primitive inference schemes are represented
by \ML\ functions that return theorems as values.
That is, for particular \HOL\ terms, the \ML\ functions return
the instance of the theorem at those terms. The \ML\ functions
are part of the \ML\ abstract type
 \ml{thm}\index{thm@\ml{thm}}:
although \ml{thm} has no primitive constructors, it has (eight)
operations which return theorems as values: \ml{ASSUME}, \ml{REFL},
\ml{BETA\_CONV}, \ml{SUBST}, \ml{ABS}, \ml{INST\_TYPE},
\ml{DISCH} and \ml{MP}.\index{inference schemes, in HOL logic@inference schemes, in \HOL\ logic}

The \ML\ functions that implement the primitive inference schemes in the
\HOL\ system are described below.  The same notation\index{notation!for
specification of rules}\index{inferences, in HOL logic@inferences, in
\HOL\ logic!notation for} is used here as in Section~\ref{HOLrules}:
hypotheses above a horizontal line and conclusion\index{conclusions!of
inference rules} beneath. The machine-readable {\small ASCII} notation
is used for the logical constants.

\subsection{Assumption introduction}\index{assumption introduction,
in HOL logic@assumption introduction, in \HOL\ logic!ML function
for@\ML\ function for}

\begin{boxed}
\index{ASSUME@\ml{ASSUME}|pin}
\begin{verbatim}
   ASSUME : term -> thm
\end{verbatim}\end{boxed}

\begin{center}
\begin{tabular}{c}
  \\ \hline
$t${\small\verb+ |- +}$t$ \\
\end{tabular}
\end{center}

\noindent
{\small\verb+ASSUME +}$t${\small\verb++} evaluates to $t${\small\verb+|- +}$t$.
Failure if $t$ is not of type \ml{bool}.

\bigskip

\subsection{Reflexivity}\index{reflexivity, in HOL logic@reflexivity, in \HOL\ logic!ML function for@\ML\ function for}

\begin{boxed}\index{REFL@\ml{REFL}|pin}
\begin{verbatim}
   REFL : term -> thm
\end{verbatim}\end{boxed}

\begin{center}
\begin{tabular}{c}
  \\ \hline
{\small\verb+ |- +}$t${\small\verb+ = +}$t$ \\
\end{tabular}
\end{center}

\noindent {\small\verb+REFL +}$t${\small\verb++} evaluates to
{\small\verb+|- +}$t${\small\verb+ = +}$t$. A call to \ml{REFL} never fails.

\bigskip

\subsection{Beta-conversion}\index{beta-conversion, in HOL logic@beta-conversion, in \HOL\ logic!ML function for@\ML\ function for}

\begin{boxed}\index{BETA_CONV@\ml{BETA\_CONV}|pin}
\begin{verbatim}
   BETA_CONV : term -> thm
\end{verbatim}\end{boxed}

\begin{center}
\begin{tabular}{c}
  \\ \hline
{\small\verb+ |- (\+}$x${\small\verb+.+}$t_1${\small\verb+)+}$t_2${\small\verb+ = +}$t_1[t_2/x]$
\end{tabular}
\end{center}

\begin{itemize}
\item where $t_1[t_2/x]$ denotes the result of substituting $t_2$ for $x$
in $t_1$, with suitable renaming of variables to prevent free variables
in $t_2$ becoming bound after substitution. The substitution
 $t_1[t_2/x]$ is always defined.
\end{itemize}


\noindent {\small\verb+BETA_CONV (\+}$x${\small\verb+.+}$t_1${\small\verb+)+}$t_2${\small\verb++} evaluates to the
theorem {\small\verb+|- (\+}$x${\small\verb+.+}$t_1${\small\verb+)+}$t_2${\small\verb+ = +}$t_1[t_2/x]$.
Failure if the argument to \ml{BETA\_CONV} is not a $\beta$-redex (\ie\ is not
of the form {\small\verb+(\+}$x${\small\verb+.+}$t_1${\small\verb+)+}$t_2${\small\verb++}).

\bigskip

\subsection{Substitution}\index{substitution rule, in HOL logic@substitution rule, in \HOL\ logic!ML function for@\ML\ function for|(}\index{SUBST@\ml{SUBST}|(}

\begin{boxed}
\begin{verbatim}
   SUBST : (thm * term)list -> term -> thm -> thm
\end{verbatim}\end{boxed}

\begin{center}
\begin{tabular}{c}
$\Gamma_1${\small\verb+ |- +} $t_1${\small\verb+=+}$t'_1$ {\small\verb+  +} $\cdots$ {\small\verb+  +}
$\Gamma_n${\small\verb+ |- +} $t_n${\small\verb+=+}$t'_n$ {\small\verb+  +}
$\Gamma${\small\verb+ |- +} $t[t_1,\ldots,t_n]$ \\ \hline
$\Gamma_1 \cup \cdots
\cup \Gamma_n \cup \Gamma${\small\verb+ |- +} $t[t'_1,\ldots,t'_n]$ \\
\end{tabular}
\end{center}

\bigskip

\begin{itemize}
\item where $t[t_1,\ldots,t_n]$ denotes a term $t$ with some free
occurrences of the terms $t_1$, $\dots$, $t_n$ singled out and
$t[t'_1,\ldots,t'_n]$ denotes the result of simultaneously replacing each
such occurrences of $t_i$ by $t'_i$ (for $1{\leq}i {\leq} n$),
with suitable renaming of variables to prevent free variables
in $t_i'$ becoming bound after substitution.
\end{itemize}

\noindent
The first argument to {\small\verb+SUBST+} is a list
{\small\verb+[(|-+}$t_1${\small\verb+=+}$t'_1${\small\verb+, +}$x_1${\small\verb+);+}$\:\ldots\:${\small\verb+;(|-+}$t_n${\small\verb+=+}
$t'_n${\small\verb+, +}$x_n${\small\verb+)]+}.  The second argument is a
template term $t[x_1,\ldots,x_n]$ in which occurrences of the variable
$x_i$ (where $1 \leq i\leq n$) are used to mark the places where
substitutions with {\small\verb+|- +}$t_i${\small\verb+=+}$t'_i$ are to be
done. Thus

\bigskip

{\small\verb+SUBST [(|-+}$t_1${\small\verb+=+}$t'_1${\small\verb+, +}$x_1${\small\verb+);+}$\ldots${\small\verb+;(|-+}$t_n${\small\verb+=+}
$t'_n${\small\verb+, +}$x_n${\small\verb+)]  +}$t[x_1,\ldots,x_n]${\small\verb+  +}
$\Gamma${\small\verb+ |- +}$t[t_1,\ldots,t_n]$

\bigskip

\noindent returns $\Gamma${\small\verb+ |- +}$t[t'_1,\ldots,t'_n]$.
Failure if:
\begin{myenumerate}
\item any of the arguments are of the wrong form;
\item the type of $x_i$ is not equal to the type of $t_i$ for some
$1\leq i\leq n$.
\end{myenumerate}\index{SUBST@\ml{SUBST}|)}\index{substitution rule, in HOL logic@substitution rule, in \HOL\ logic!ML function for@\ML\ function for|)}

\subsection{Abstraction}\index{abstraction rule, in HOL logic@abstraction rule, in \HOL\ logic!ML function for@\ML\ function for}
\index{function abstraction, in HOL logic@function abstraction, in \HOL\ logic!inference rules for}


\begin{boxed}\index{ABS@\ml{ABS}|pin}
\begin{verbatim}
   ABS : term -> thm -> thm
\end{verbatim}\end{boxed}


\begin{center}
\begin{tabular}{c}
$\Gamma${\small\verb+ |- +}$t_1${\small\verb+ = +}$t_2$ \\ \hline
$\Gamma${\small\verb+ |- (\+}$x${\small\verb+.+}$t_1${\small\verb+) = (\+}$x${\small\verb+.+}$t_2${\small\verb+)+} \\
\end{tabular}
\end{center}

\begin{itemize}
\item where $x$ is not free in $\Gamma$.
\end{itemize}

\noindent
{\small\verb+ABS +}$x${\small\verb+ +}$\Gamma${\small\verb+ |- +}$t_1${\small\verb+=+}$t_2$ returns the theorem
$\Gamma${\small\verb+ |- (\+}$x${\small\verb+.+}$t_1${\small\verb+) = (\+}$x${\small\verb+.+}$t_2${\small\verb+)+}.
Failure if $x$ is not a variable, or $x$
 occurs free in any assumption in $\Gamma$.


\bigskip

\subsection{Type instantiation}\index{type instantiation, in HOL logic@type instantiation, in \HOL\ logic!ML function for@\ML\ function for}\index{types, in HOL logic@types, in \HOL\ logic!instantiation of}

\begin{boxed}\index{INST_TYPE@\ml{INST\_TYPE}|pin}
\begin{verbatim}
   INST_TYPE : (type*type) list -> thm -> thm
\end{verbatim}\end{boxed}

\begin{center}
\begin{tabular}{c}
$\Gamma${\small\verb+ |- +}$t$ \\ \hline
$\Gamma${\small\verb+ |- +}$t[\sigma_1,\ \ldots\ ,\sigma_n/\alpha_1,\ \ldots\ ,\alpha_n]$
\end{tabular}
\end{center}

\bigskip

\begin{itemize}
\item $t[\sigma_1,\ \ldots\ ,\sigma_n/\alpha_1,\ \ldots\ ,\alpha_n]$
denotes the result of substituting (in parallel) the types $\sigma_1$,
$\ldots$\ , $\sigma_n$ for the type variables $\alpha_1$, $\ldots$\ ,
$\alpha_n$ in $t$, with the restriction that none of $\alpha_1$, $\ldots$\
, $\alpha_n$ occur in $\Gamma$.
\end{itemize}

\noindent
{\small\verb+INST_TYPE[(+}$\sigma_1${\small\verb+,+}$\alpha_1${\small\verb+);+}$\ldots${\small\verb+;(+}$\sigma_n${\small\verb+,+}$\alpha_n${\small\verb+)] +}$th$
returns the result of instantiating each occurrence of $\alpha_i$ in the
theorem $th$ to $\sigma_i$ (for $1 \leq i \leq n$). Failure if:
\begin{myenumerate}
\item arguments of the wrong form (\eg\ an $\alpha_i$ is not a type variable);
\item $\alpha_i$
(for $1\leq i\leq n$) occurs in any assumption in $\Gamma$.
\end{myenumerate}

\bigskip

\subsection{Discharging an assumption}\index{discharging assumptions, in HOL logic@discharging assumptions, in \HOL\ logic!ML function for@\ML\ function for}


\begin{boxed}\index{DISCH@\ml{DISCH}|pin}
\begin{verbatim}
   DISCH : term -> thm -> thm
\end{verbatim}\end{boxed}

\begin{center}
\begin{tabular}{c}
$\Gamma${\small\verb+ |- +} $t_2$ \\ \hline
$\Gamma{-}\{t_1\}${\small\verb+ |- +} $t_1${\small\verb+ ==> +}$t_2$
\end{tabular}
\end{center}

\begin{itemize}
\item  $\Gamma{-}\{t_1\}$ denotes the set obtained by removing $t_1$
from $\Gamma$ (note that $t_1$ need not occur in $\Gamma$; in this case
$\Gamma{-}\{t_1\} = \Gamma$).
\end{itemize}

\noindent
{\small\verb+DISCH +}$t_1${\small\verb+ +}$\Gamma${\small\verb+ |- +}$t_2$
evaluates to the theorem
$\Gamma{-}\{t_1\}${\small\verb+ |- +}$t_1${\small\verb+ ==> +}$t_2$.
\ml{DISCH} fails if the term given as its first argument is not of
type \ml{bool}.



\bigskip

\subsection{Modus Ponens}\index{Modus Ponens, in HOL logic@Modus Ponens, in \HOL\ logic!ML function for@\ML\ function for}


\begin{boxed}\index{MP@\ml{MP}|pin}
\begin{verbatim}
   MP : thm -> thm -> thm
\end{verbatim}\end{boxed}

\begin{center}
\begin{tabular}{c}
$\Gamma_1${\small\verb+ |- +}$t_1${\small\verb+ ==> +}$t_2$ {\small\verb+     +} $\Gamma_2${\small\verb+ |- +}$t_1$ \\
\hline
$\Gamma_1 \cup \Gamma_2${\small\verb+ |- +}$t_2$ \\
\end{tabular}
\end{center}

\noindent
{\small\verb+MP+} takes two theorems (in the order shown above) and returns
the result of applying Modus Ponens; it fails if the arguments are not of the
right form.
\index{inference rules, of HOL logic@inference rules, of \HOL{} logic!primitive|)}

\section{Oracles}

\HOL{} extends the \LCF\ tradition by allowing the use of an \emph
{oracle} mechanism, enabling arbitrary formulas to become elements of
the \verb+thm+ type. By use of this mechanism, \HOL{} can utilize the
results of arbitrary proof procedures. In spite of such liberalness, one
can still make strong assertions about the security of ML objects of
type \verb+thm+.

To avoid unsoundness, a \emph{tag} is attached to any theorem
coming from an oracle. This tag is propagated through every
inference that the theorem participates in (much as ordinary assumptions
are propagated in the inference rule {\small\verb+MP+}). If it happens
that falsity becomes derived, the offending oracle can be found by
examining the tags component of the theorem. A theorem proved without
use of any oracle will have an empty tag, and can thus be considered to
have been proved solely by deductive steps in the HOL logic.

A tagged theorem can be created via

\begin{boxed}
\index{mk_oracle_thm@\ml{mk\_oracle\_thm}!type of}
\begin{verbatim}
   mk_oracle_thm : tag -> term list * term -> thm
\end{verbatim}\end{boxed}

which directly creates the requested theorem and attaches the given tag to
it. Tags may be created with

\begin{boxed}
\index{Tag.read@\ml{Tag.read}!making tags}
\begin{verbatim}
   Tag.read : string -> tag.
\end{verbatim}\end{boxed}

As well as providing principled access to the results of external
reasoners, tags are used to implement some useful `system' operations on
theorems. For example, one can directly create a theorem via the function
\verb+mk_thm+. The tag \verb+MK_THM+ gets attached to each theorem
created with this call. This allows users to directly create useful
theorems, \eg, to use as test data for derived rules of inference.
Another tag is used to implement so-called `validity checking' for tactics.

The tags in a theorem can be viewed by setting \verb+Globals.show_tags+ to
true.

\setcounter{sessioncount}{1}
\begin{session}\begin{verbatim}
- Globals.show_tags := true;
> val it = () : unit

- mk_thm([], Term `F`);;
> val it = [oracles: MK_THM] [axioms: ] [] |- F : thm
\end{verbatim}\end{session}\index{mk_thm@\ml{mk\_thm}}

There are three elements to the left of the turnstile in the fully printed
representation of a theorem: the first two\footnote{Tags are also used for
tracking the use of axioms in proofs.} comprise the tags component and the
third is the standard assumption list. The tag component of a theorem
can be extracted by

\begin{boxed} \begin{verbatim}
     Thm.tag : thm -> tag
\end{verbatim}\end{boxed}

\noindent and prettyprinted by

\begin{boxed} \begin{verbatim}
     Tag.pp : ppstream -> tag -> unit.
\end{verbatim}\end{boxed}


\section{Theories}
\index{theories, in HOL logic@theories, in \HOL\ logic!representation of|(}
\label{theoryfns}

In Chapter~\ref{logic} a theory is described as a $4$-tuple

\[ {\cal T}\ =\ \langle{\sf Struc}_{\cal T},\
                {\sf Sig}_{\cal T},\
                {\sf Axioms}_{\cal T},\
                {\sf Theorems}_{\cal T}\rangle \]

\noindent where
\begin{myenumerate}
\item ${\sf Struc}_{\cal T}$ is
the type structure of ${\cal T}$;
\item ${\sf Sig}_{\cal T}$ is
the signature of ${\cal T}$;
\item ${\sf Axioms}_{\cal T}$ is
the set of axioms of ${\cal T}$;
\item ${\sf Theorems}_{\cal T}$ is the set of
theorems of ${\cal T}$.
\end{myenumerate}

In the implementation of \HOL, theories are structured hierarchically
to represent sequences of extensions called
\emph{segments}
\index{theory segments} 
of an initial theory (see Section~\ref{extensions}) called
\ml{min}\index{min@\ml{min}}. A theory segment is not really a logical
concept, but rather a means of representating theories in the
\HOL\ system. Each segment records some types, constants, axioms and
theorems, together with pointers to other segments called its 
\emph{parents}
\index{parents, of HOL theories@parents, of \HOL\ theories}.
The theory represented by a segment is obtained by taking the
union of all the types, constants, axioms and theorems in the segment,
together with the types, constants, axioms and theorems in all the
segments reachable by following pointers to parents. This collection
of reachable segments is called the \emph{ancestry}
\index{ancestry, of HOL system theories@ancestry, of \HOL\ system theories}
\index{theories, in HOL logic@theories, in \HOL\ logic!hierarchies of}
of the segment.

\subsection{ML functions for theory operations}
\label{theoryprims}

A typical\index{HOL system@\HOL\ system!typical work in} piece of work
with the \HOL\ system consists in a number of sessions\index{sessions
with HOL system@sessions, with \HOL\ system}.  In the first of these, a
new theory, ${\cal T}$ say, is created by importing some existing theory
segments, making a number of definitions, and perhaps proving and
storing some theorems in the current segment. Then the current segment
(named $name$ say) is exported. The concrete result will be an \ML\
module $name$\ml{Theory} whose contents is the current theory segment
created during the session and whose ancestry represents the desired
logical theory ${\cal T}$. Subsequent work sessions can access the
definitions and theorems of ${\cal T}$ by importing $name$\ml{Theory};
this avoids having to load the tools and replay
the proofs that created $name$\ml{Theory} in the first place.

The naming of data in theories is based on the names given to segments.
Specifically an axiom, definition, specification or theorem is
accessed\index{theories, in HOL logic@theories, in \HOL\ logic!naming of}
by an \ML\ long identifier $thy${\small\verb+Theory.+}$name$, where
$thy$ is the name of the theory segment current when the item was
declared and $name$ is a specific name supplied by the user (see the
functions \ml{new\_axiom}, \ml{new\_definition}, below). Different items
can have the same specific name if the associated segment is different.
Thus each theory segment provides a separate namespace of ML bindings of
\HOL\ items.

Various additional pieces of information are stored in a theory
segment, including the parsing status of the constants (\eg\ whether
they are infixes or binders).

\paragraph {Determining the context}

There is always a \emph{current theory} which is the theory
represented by the current theory segment together with its
ancestry. The name of the current theory segment is returned by the \ML\
function:

\begin{boxed}\index{current_theory@\ml{current\_theory}|pin}
\begin{verbatim}
   current_theory : unit -> string
\end{verbatim}\end{boxed}

  When an interactive \HOL{} session begins, some theories will
  already be in the logical context. The exact set of theories in
  context will vary.  If the executable used is \texttt{hol.bare},
  then only \theoryimp{min} and \theoryimp{bool} will be loaded.  When
  the \texttt{hol} executable is used, a richer context is loaded.

The exact set of theories loaded can be determined with the
\ml{ancestry} command.
%
\begin{boxed}
\index{ancestry@\ml{ancestry}|pin}
\begin{verbatim}
  ancestry : string -> string list
\end{verbatim}\end{boxed}

This function provides a general mechanism for examining the structure
of the theory hierarchy.  The argument is the name of a theory (or
\texttt{"-"} as an abbreviation for the current theory), to which
\texttt{ancestry} will respondwith a list of the argument's ancestors
in the theory hierarchy.

\begin{boxed}
{\small
\begin{verbatim}
 ancestry "-";
 > val it =
    ["num", "prim_rec", "normalForms", "relation", "pair",
      "arithmetic", "while", "numeral", "label", "combin", "sum", "min",
      "bool", "marker", "one", "option", "ind_type", "list"] : string list
\end{verbatim}}
\end{boxed}


\paragraph{Creating a theory segment}

\index{theories, in HOL logic@theories, in \HOL\ logic!creation of|(}

One creates a new theory segment by a call to \verb+new_theory+. 
%
\begin{boxed}
\index{new_theory@\ml{new\_theory}|pin}
\begin{verbatim}
   new_theory : string -> unit
\end{verbatim}\end{boxed}
%
This allocates a new `area' where subsequent theory
operations take effect. If the current theory ($thy_1$ say) at the time
of a call to {\small\verb+new_theory +}$thy_2$ is non-empty, \ie, has
had an axiom, definition, or theorem stored in it, then $thy_1$ is
exported before $thy_2$ is allocated. Furthermore, $thy_2$ will obtain
$thy_1$ as a parent. If {\small\verb+new_theory +}$thy$ is called when
the current theory segment is already named $thy$, then that is
interpreted as a request merely to clear the current theory segment
(nothing will be exported).

A call to {\small\verb+new_theory "+}$name${\small\verb+"+} fails if:
\begin{itemize}

\item $name$ is not an alphanumeric starting with a letter.

\item there is a theory already named $name$ in the ancestry of the
current segment.

\item if it is necessary to export the current segment before creating
the new theory and the export attempt fails.
\end{itemize}

On startup, the current theory segment of \HOL\ is named \ml{scratch},
which is an empty theory, having a useful collection of theories in
its ancestry. Typically, a user would begin by loading whatever extra
logical context is required for the work at hand.

The current theory segment acts as a kind of scratchpad. Elements stored
in the current segment may be overwritten by subsequent additions, or
deleted outright. Any theory elements that were built from overwritten
or deleted elements would then be held to be {\it out-of-date}, and would not
be included in the theory when it is finally exported.  Out-of-date
constants and types are detected by the \HOL\ printer, which will print
them surrounded by odd-looking syntax to alert the user.

In contrast to the current segment, (proper) ancestor segments may not
be altered.

\paragraph{Loading prebuilt theories}

Since \HOL\ theories are represented by \ML\ modules, one imports an
existing theory segment by simply importing the corresponding module.

\begin{boxed}
\index{load@\ml{load}|pin}
\begin{verbatim}
   load : string -> unit
\end{verbatim}\end{boxed}

\noindent
Executing {\small\verb+load +}$name${\small\verb+Theory+} imports the
first file named $name${\small\verb+Theory.uo+} found along the
{\small\verb+loadPath+} into the session. Any unloaded ancestors of
$name$ will be loaded before loading of $name${\small\verb+Theory+}
continues.  Note that {\small\verb+load+} can not be used in ML files
that are to be compiled; it can only be used in the interactive
system.

\paragraph{Adding to the current theory}

The following \ML{} functions add types and terms to the current
theory segment. In typical usage, these functions will not be 
needed since higher-level definition facilities will invoke these as 
necessary. However, these functions can be useful for those writing
proof tools and derived definition principles.

\begin{boxed}
\index{new_type@\ml{new\_type}|pin}
\begin{verbatim}
   new_type : int -> string -> unit
\end{verbatim}\end{boxed}


\noindent Executing \ml{new\_type}$\ n\ \ml{"\ty{op}"}$ makes \ty{op}
a new $n$-ary type operator\index{type operators, in HOL logic@type
operators, in \HOL\ logic!declaration} in the current theory. If 
\ty{op} is not an allowed name for a type, a warning will be issued.


\begin{boxed}
\index{new_constant@\ml{new\_constant}|pin}
\begin{verbatim}
   new_constant : (string * type) -> unit
\end{verbatim}\end{boxed}

\noindent Executing {\small\verb+new_constant("+}$c${\small\verb+",+}$\sigma${\small\verb+)+} makes
$c_{\sigma'}$ a new constant\index{constants, in HOL logic@constants, in \HOL\ logic!declaration of} of the current theory,
for all $c_{\sigma'}$ where $\sigma'$ is an instance of $\sigma$.
The type $\sigma$ is
called the {\it generic type\/}\index{generic types, in HOL
  logic@generic types, in \HOL\ logic} of $c$. 
If $c$ is not an allowed name for a constant, a warning will be issued.

\begin{boxed}
\index{new_axiom@\ml{new\_axiom}|pin}
\begin{verbatim}
   new_axiom : (string * term) -> thm
\end{verbatim}\end{boxed}

\noindent Executing \ml{new\_axiom("}$name$\ml{",}$t$\ml{)} declares the
sequent
\ml{(\{\},$t$)} to be an axiom\index{axioms!declaration of, in HOL logic@declaration of, in \HOL\ logic} of the current theory with name $name$.
Failure if:
\begin{myenumerate}
\item the type of $t$ is not \verb+bool+.

\item $t$ contains out-of-date constants or types, \ie, constants or
  types that have been re-declared after $t$ was built.
\end{myenumerate}

Once a theorem has been proved, it can be saved with the function

\begin{boxed}
\index{save_thm@\ml{save\_thm}|pin}
\begin{verbatim}
   save_thm : (string * thm) -> thm
\end{verbatim}\end{boxed}

\noindent Evaluating \ml{save\_thm("}$name$\ml{",}$th$\ml{)} will save
the theorem\index{theorems, in HOL logic@theorems, in \HOL\ logic!saving
of}\index{saving theorems} $th$ with name $name$ in the current theory
segment.

\paragraph{Exporting a theory}

Once a theory segment has been constructed, it can be written out to a
file, which, after compilation, can be imported into future sessions.

\begin{boxed}
\index{export_theory@\ml{export\_theory}|pin}
\begin{verbatim}
    export_theory : unit -> unit
\end{verbatim}\end{boxed}

When {\small\verb+export_theory+} is called, all out-of-date entities
are removed from the current segment. Also, the parenthood of the
theory is computed. The current theory segment is written to file
$name${\small{\tt Theory.sml}} in the current working directory.  The
file $name${\small{\tt Theory.sig}}, which documents the contents of
$name$, is also written to the current working directory.  Notice that
the exported theory is not compiled by \HOL. That is left to an
external tool, \holmake{} (see section~\ref{Holmake}), which maintains
dependencies among collections of \HOL\ theory segments.


\subsection{ML functions for accessing theories}

\index{theories, in HOL logic@theories, in \HOL\ logic!functions for
  accessing|(} \index{axioms!retrieval of, in HOL system@retrieval of,
  in \HOL\ system|(} The arguments of \ML{} type \ml{string} to
\ml{new\_axiom}, \ml{new\_definition} \etc\ are the names of the
corresponding axioms and definitions. These names are used when
accessing theories with the functions \ml{axiom}, \ml{definition},
\etc, described below.

The current theory\index{theories, in HOL logic@theories, in \HOL\
  logic!hierarchies of} can be extended by adding new parents, types,
constants, axioms and definitions. Theories that are in the ancestry
of the current theory cannot be extended in this way; they can be
thought of as \emph{frozen}.

There are various functions for loading the contents of theory files:

\begin{boxed}
\index{parents@\ml{parents}|pin}
\index{types@\ml{types}|pin}
\index{constants@\ml{constants}|pin}
\begin{verbatim}
   parents     : string -> string list
   types       : string -> (int * string) list
   constants   : string -> term list
\end{verbatim}\end{boxed}

\noindent The first argument is the name of a theory (which must be in the
ancestry of the current theory segment); the result is a list of the
components of the theory. The name of the current theory can be
abbreviated by \ml{"-"}.\index{ abbreviation, of HOL theory part
  names@\ml{-} (abbreviation, of \HOL\ theory part names)} For
example, \ml{parents "-"} returns the parents of the current theory.

In the case of \ml{types} a list of arity-name pairs is returned.
Individual axioms, definitions and theorems can be read from the
current theory using the following \ML\ functions:

\begin{boxed}
\index{axiom@\ml{axiom}|pin}
\index{definition@\ml{definition}|pin}
\index{theorem@\ml{theorem}|pin}
\begin{verbatim}
   axiom      : string -> thm
   definition : string -> thm
   theorem    : string -> thm
\end{verbatim}\end{boxed}

\noindent The first argument is the user supplied name of the axiom,
definition or theorem in the current theory.  Further, a list of all
of a theory's axioms, definitions and theorems can be retreived with
the \ML{} functions:

\begin{boxed}
\index{axioms@\ml{axioms}|pin}
\index{theorems@\ml{theorems}|pin}
\index{definitions@\ml{definitions}|pin}
\begin{verbatim}
   axioms      : string -> (string * thm) list
   definitions : string -> (string * thm) list
   theorems    : string -> (string * thm) list
\end{verbatim}\end{boxed}

The contents of the current theory can be printed in a readable format using the function
{\small\verb+print_theory+}\index{printing, in HOL logic@printing, in \HOL\ logic!of theories}\index{print_theory@\ml{print\_theory}}.
\index{axioms!retrieval of, in HOL system@retrieval of, in \HOL\
system|)}\index{theories, in HOL logic@theories, in \HOL\
logic!functions for accessing|)}

\subsection{Functions for creating definitional extensions}\index{extension, of HOL logic@extension, of \HOL\ logic!definitional}\index{definitional extension, of HOL logic@definitional extension, of \HOL\ logic}\index{theories, in HOL logic@theories, in \HOL\ logic!extension of|(}
\label{avra_definitional}

There are three kinds of definitional extensions:
constant definitions, constant specifications and type definitions.

\subsubsection{Constant definitions}
\label{sec:constant-definitions}

In Section~\ref{defs} a constant definition\index{extension, of HOL logic@extension, of \HOL\ logic!by constant definition}\index{constant definition extension, of HOL logic@constant definition extension, of \HOL\ logic!ML function for@\ML\ function for|(}
over a signature $\Sigma_{\Omega}$ is defined to be
an equation, \ie\ a formula of the form $c_{\sigma}=t_{\sigma}$,
such that:
\begin{myenumerate}
\item $c$ is not the name of any constant in $\Sigma_{\Omega}$;
\item $t_{\sigma}$ is a closed term in ${\sf Terms}_{\Sigma_{\Omega}}$;
\item all the type variables occurring in $t_{\sigma}$ occur in $\sigma$.
\end{myenumerate}

In \HOL, definitions can be slightly more general than this, in that
an equation:

\[ c\ v_1\ \cdots\ v_n\ =\ t \]

\noindent is  allowed  to  be a  definition where  $v_1$, $\dots$, $v_n$ are
variable structures (\ie\ tuples of distinct variables).   Such  an equation is
logically equivalent to:

\[ c\ =\ \lambda v_1\ \cdots\ v_n.\  t \]

\noindent which is a definition in the sense of  Section~\ref{defs} if (i),
(ii) and (iii) hold.

The following  \ML\ function  creates\index{defining mechanisms, for HOL logic@defining mechanisms, for \HOL\ logic} a  new definition in
the current theory.

\begin{boxed}
\index{new_definition@\ml{new\_definition}|pin}
\begin{verbatim}
   new_definition : (string * term) -> thm
\end{verbatim}\end{boxed}


\noindent Evaluating
 \ml{new\_definition("}$name$\ml{",\ }$c\ v_1\ \cdots\ v_n\ =\ t$\ml{)},
declares the sequent
\ml{(\{\},$\lambda v_1\ \cdots\ v_n.\  t$)} to be a constant definition
\index{definitions, adding to HOL logic@definitions, adding to \HOL\ logic}
of the current theory. The name associated with the definition in
this theory is $name$.
Failure if:
\begin{myenumerate}
\item $t$ contains free variables that are not in any of
the variable structures $v_1$, $\dots$, $v_n$ (this is equivalent
to requiring $\lambda v_1\ \cdots\ v_n.\  t$ to be a closed term);
\item there is a type variable in  $v_1$, $\dots$, $v_n$ or $t$
that does not occur in the type of $c$.
\end{myenumerate}

\subsubsection{Constant specifications}
\label{conspec}

\index{specification of constants, in HOL logic@specification of constants, in \HOL\ logic|(}
\index{extension, of HOL logic@extension, of \HOL\ logic!by constant specification}
In Section~\ref{specs} a constant specification\index{constant specification extension, of HOL logic@constant specification extension, of \HOL\ logic!ML function for@\ML\ function for} for a theory ${\cal T}$
is defined to be a pair:

\[ \langle(c_1,\ldots,c_n),\ \lquant{{x_1}_{\sigma_1}
\cdots {x_n}_{\sigma_n}}t_{\ty{bool}}\rangle \]

\noindent such that:

\begin{myenumerate}
\item $c_1$, $\dots$, $c_n$ are distinct names.
\item $\lquant{{x_1}_{\sigma_1}
\cdots {x_n}_{\sigma_n}}t_{\ty{bool}}\ \in\ {\sf Terms}_{\cal T}$.
\item $tyvars(\lquant{{x_1}_{\sigma_1}
\cdots {x_n}_{\sigma_n}}t_{\ty{bool}})\ \subseteq\ tyvars(\sigma_i)$ for
$1\leq i\leq n$.
\item $\equant{{x_1}_{\sigma_1}\ \cdots\ {x_n}_{\sigma_n}}t
\ \in\ {\sf Theorems}_{\cal T}$.
\end{myenumerate}

The following \ML\ function is used to make constant specifications in
the \HOL\ system.

\begin{boxed}
\index{new_specification@\ml{new\_specification}|pin}
\begin{verbatim}
   new_specification : string -> string list -> thm -> thm
\end{verbatim}\end{boxed}

Evaluating:

\medskip

\begin{tabular}{l}
   \ml{new\_specification}\\
\ \ml{"}$name$\ml{"}\\
\ \ml{[}\ml{"}$c_1$\ml{"\ }$\ldots$\ml{\ ,}\ml{"}$c_n$\ml{"]}\\
\ \ml{|-\ ?}$x_1\ \cdots\ x_n$\ml{.}\  $t$\ml{[}$x_1$\ml{,}$\ \ldots\
$\ml{,}$x_n$\ml{]}\\
\end{tabular}

\medskip

\noindent simultaneously  introduces  new constants  named $c_1$, $\dots$,
$c_n$ satisfying the property:

\[ \ml{|- }t\ml{[}c_1\ml{,}\ \ldots\ \ml{,}c_n\ml{]} \]

\noindent This theorem is stored,
with name $name$, as a definition in the current theory segment. A call to
\ml{new\_specification} fails if:

\begin{myenumerate}
\item the theorem argument has a non-empty assumption list;
\item there are free variables in the theorem argument;
\item $c_1$, $\dots$, $c_n$ are not distinct variables;
\item the type of some $c_i$ does not contain all the type
variables which occur in the term
{\small\verb+\+}$x_1\ \cdots\ x_n$\ml{.}\  $t$\ml{[}$x_1$\ml{,}$\ \ldots\
$\ml{,}$x_n$\ml{]}.
\end{myenumerate}

\subsubsection{Type definitions}\index{extension, of HOL logic@extension, of \HOL\ logic!by type definition|(}
\label{type-defs}\index{type definitions, in HOL logic@type definitions, in \HOL\ logic|(}

In Section~\ref{tydefs} it is explained that
defining\index{type definitions, in HOL logic@type definitions, in \HOL\ logic!introduction of}\index{type definition extension, in HOL logic@type definition extension, in \HOL\ logic!ML function for@\ML\ function for|(}
a new type $(\alpha_1,\ldots,\alpha_n)\ty{op}$ in a theory ${\cal T}$ consists
of introducing $\ty{op}$ as a new $n$-ary type operator and

\[\turn \equant{f_{(\alpha_1,\ldots,\alpha_n)\ty{op}\fun\sigma}}\TyDef\ p\ f\]

\noindent as a new axiom, where $p$ is a predicate
characterizing\index{characteristic predicate, of type definitions} a
non-empty subset of an existing type $\sigma$.  Formally, a type definition
for a theory ${\cal T}$ is a $3$-tuple

\[ \langle \sigma,\ (\alpha_1,\ldots,\alpha_n)\ty{op},
    \ p_{\sigma\fun\ty{bool}}\rangle \]

\noindent where:

\begin{myenumerate}
\item $\sigma\in{\sf Types}_{\cal T}$  and
$tyvars(\sigma)\in\{\alpha_1, \ldots , \alpha_n\}$.
\item \ty{op} is not the name of a type constant in ${\sf Struc}_{\cal T}$.
\item $p\in{\sf Terms}_{\cal T}$ is a closed term of
type $\sigma\fun\ty{bool}$  and
$tyvars(p)\subseteq\{\alpha_1, \ldots , \alpha_n\}$.
\item $\equant{x_{\sigma}}p\ x \ \subseteq\ {\sf Theorems}_{\cal T}$.
\end{myenumerate}

The following \ML\ function makes a type definition in the \HOL\ system.

\begin{boxed}
\index{new_type_definition@\ml{new\_type\_definition}|pin}
\begin{verbatim}
   new_type_definition : (string * term * thm) -> thm
\end{verbatim}\end{boxed}

\noindent If $t$ is a term of type
$\sigma$\ml{->bool} containing $n$ distinct type variables, then
evaluating:

{\def\op{{\normalsize\sl op}}
\begin{hol}\begin{alltt}
   new_type_definition("{\op}", \m{t}, |- ?\m{x}.\m{\:t \;x})
\end{alltt}\end{hol}}

\noindent results in \ty{op} being declared as a new $n$-ary type operator
characterized by the definitional
\index{definitional axioms}\index{type operators, in HOL logic@type operators, in \HOL\ logic!definitional axioms for} axiom:

\begin{hol}\begin{alltt}
   |- ?rep. TYPE\_DEFINITION \m{t} rep
\end{alltt}\end{hol}

\noindent which is stored as a definition with the automatically
generated name
\ty{op}\ml{\_TY\_DEF}.\index{TY_DEF@$\ldots$\ml{\_TY\_DEF}}. The constant
\ml{TYPE\_DEFINITION}\index{TYPE_DEFINITION@\ml{TYPE\_DEFINITION}}
is defined in the theory \ml{bool} by:

\begin{hol}\begin{verbatim}
   |- TYPE_DEFINITION (P:'a->bool) (rep:'b->'a) =
       (!x' x''. (rep x' = rep x'') ==> (x' = x'')) /\
       (!x. P x = (?x'. x = rep x'))
\end{verbatim}\end{hol}

\noindent Executing \ml{new\_type\_definition("\ty{op}",\ }$t$\ml{,\
|- ?}$x$\ml{.}\ $t\ x$\ml{)} fails if:
\begin{myenumerate}
\item $t$ does not have a type of the form $\sigma$\ml{->bool}.
\end{myenumerate}
\index{extension, of HOL logic@extension, of \HOL\ logic!by type definition|)}
\index{theories, in HOL logic@theories, in \HOL\ logic!extension of|)}\index{type definition extension, in HOL logic@type definition extension, in \HOL\ logic!ML function for@\ML\ function for|)}\index{type definitions, in HOL logic@type definitions, in \HOL\ logic|)}

\paragraph{Defining bijections}
\index{type definitions, in HOL logic@type definitions, in \HOL\ logic!defining bijections for|(}

The result of a type definition using \ml{new\_type\_definition} is a theorem
which asserts only the {\it existence\/} of a
bijection\index{bijection of types, in HOL logic@bijection of types, in \HOL\ logic}
from the type it defines to the corresponding subset of an existing type.  To
introduce constants that in fact denote such a bijection and its inverse, the
following \ML\ function is provided:

\begin{boxed}
\index{define_new_type_bijections@\ml{define\_new\_type\_bijections}|pin}
\begin{verbatim}
   define_new_type_bijections 
      : {name:string, ABS:string, REP:string, tyax:thm} -> thm
\end{verbatim}\end{boxed}

\noindent This function takes a record {\small\verb+{ABS, REP, name, tyax}+}
The {\verb+tyax+} argument must be a definitional axiom of the form returned by
\ml{new\_type\_definition}.  The {\verb+name+} argument is the name under which
the constant definition (a constant specification, in fact) made by
{\small\verb!define_new_type_bijections!} will be stored in the current theory
segment, and the {\small\verb+ABS+} and {\small\verb+REP+} arguments
are user-specified names for the two constants that are to be
defined. These constants are defined so as to denote mutually inverse 
bijections between the defined type, whose definition is given by the
supplied theorem, and the representing type of this defined 
type.

Evaluating:

\medskip
{\def\op{{\normalsize\sl op}}
\begin{hol}\begin{alltt}
  define\_new\_type\_bijections 
       \{name="\m{name}", ABS="\m{abs}", REP="\m{rep}",
         tyax = |- ?rep:newty->ty. TYPE\_DEFINITION \m{P} rep \}
\end{alltt}\end{hol}}

\medskip

\noindent automatically defines two new constants
\m{abs}{\small\verb!:ty->newty!} and \m{rep}{\small\verb!:ty->newty!}
such that:

{\def\bk{\char'134}
\begin{hol}\begin{alltt}
   |- (!a. \m{abs}(\m{rep} a) = a) /\bk (!r. \m{P} r = (\m{rep}(\m{abs} r) = r))
\end{alltt}\end{hol}}

\noindent This theorem, which is the defining property for the constants
\m{abs} and \m{rep}, is stored under the name "\m{name}" in the current theory
segment.  It is also the value returned by \ml{define\_new\_type\_bijections}.
The theorem states that \m{abs} is the left inverse of \m{rep} and---for
values satisfying \m{P}---that \m{rep} is the left inverse of \m{abs}.

A call to
\ml{define\_new\_type\_bijections \m{name} \m{abs} \m{rep} \m{th}}
fails if:

\begin{myenumerate}
\item $th$ is not a theorem of the form returned by
\ml{new\_type\_definition}.
\end{myenumerate}%
\index{type definitions, in HOL logic@type definitions, in \HOL\ logic!defining bijections for|)}

\paragraph{Properties of type bijections}

\index{type definitions, in HOL logic@type definitions, in \HOL\ logic!properties of bijections for|(}

The following \ML\ functions are provided for proving that the bijections
introduced by \ml{define\_new\_type\_bijections} are injective (one-to-one)
and surjective (onto):

\begin{boxed}
\index{prove_rep_fn_one_one@\ml{prove\_rep\_fn\_one\_one}|pin}
\index{prove_rep_fn_onto@\ml{prove\_rep\_fn\_onto}|pin}
\index{prove_abs_fn_one_one@\ml{prove\_abs\_fn\_one\_one}|pin}
\index{prove_abs_fn_onto@\ml{prove\_abs\_fn\_onto}|pin}
\begin{verbatim}
   prove_rep_fn_one_one : thm -> thm
   prove_rep_fn_onto    : thm -> thm
   prove_abs_fn_one_one : thm -> thm
   prove_abs_fn_onto    : thm -> thm
\end{verbatim}\end{boxed}

\noindent The theorem argument to each of these functions must be a theorem
of the form returned by \ml{define\_new\_type\_bijections}:

{\def\bk{\char'134}
\begin{hol}\begin{alltt}
   |- (!a. \m{abs}(\m{rep} a) = a) /\bk (!r. \m{P} r = (\m{rep}(\m{abs} r) = r))
\end{alltt}\end{hol}}

\noindent If \m{th} is a theorem of this form, then evaluating
\ml{prove\_rep\_fn\_one\_one \m{th}} proves that the function \m{rep} is
one-to-one, and returns the theorem:

\begin{hol}\begin{alltt}
   |- !a a'. (\m{rep} a = \m{rep} a') = (a = a')
\end{alltt}\end{hol}

\noindent Likewise, \ml{prove\_rep\_fn\_onto \m{th}} proves that \m{rep} is
onto the set of values that satisfy \m{P}:

{\def\bk{\char'134}
\begin{hol}\begin{alltt}
   |- !r. \m{P} r = (?a. r = \m{rep} a)
\end{alltt}\end{hol}}

\noindent Evaluating \ml{prove\_abs\_fn\_one\_one \m{th}} proves that \m{abs}
is one-to-one for values that satisfy \m{P}, and returns the theorem:

{\def\bk{\char'134}
\begin{hol}\begin{alltt}
   |- !r r'. \m{P} r ==> \m{P} r' ==> ((\m{abs} r = \m{abs} r') = (r = r'))
\end{alltt}\end{hol}}

\noindent And evaluating \ml{prove\_abs\_fn\_onto \m{th}} proves that \m{abs}
is onto, returning the theorem:

{\def\bk{\char'134}
\begin{hol}\begin{alltt}
   |- !a. ?r. (a = \m{abs} r) /\bk \m{P} r
\end{alltt}\end{hol}}

\noindent All four functions will fail if applied to any theorem that does not
have the form of a theorem returned by \ml{define\_new\_type\_bijections}.
None of these functions saves anything in the current theory.

\index{type definitions, in HOL logic@type definitions, in \HOL\ logic!properties of bijections for|)}


%\subsection{Type abbreviations}\label{typeabbrev}\index{types, in HOL logic@types, in \HOL\ logic!abbreviation of}\index{type abbreviations!in HOL logic@in \HOL\ logic}\index{abbreviation of types, in HOL logic@abbreviation of types, in \HOL\ logic|(}
%It is possible to introduce an abbreviation for a monomorphic type using the
%function:
%
%\begin{boxed}\index{new_type_abbrev@\ml{new\_type\_abbrev}|pin}
%\begin{verbatim}
%   new_type_abbrev : (string * type) -> unit
%\end{verbatim}\end{boxed}
%
%\noindent Evaluating \ml{new\_type\_abbrev(`}$name$\ml{`,":}$\sigma$\ml{")}
%enables $name$ to be used in quotations instead of $\sigma$. The evaluation
%fails
%if $\sigma$ is polymorphic. Type abbreviations
%are recorded in theory files, so that
%when a theory is loaded, any type abbreviations made are
%activated. The list of currently active abbreviations in a theory
%is given by the function:
%
%\begin{boxed}\index{type_abbrevs@\ml{type\_abbrevs}|pin}
%\begin{verbatim}
%   type_abbrevs : string -> (string * type) list
%\end{verbatim}\end{boxed}
%
%
%Note that abbreviation can also be made using antiquotation\index{antiquotation, in HOL logic terms@antiquotation, in \HOL\ logic terms}, without the
%restriction to monomorphic types. Such \ML\ abbreviations are not, of course,
%stored in theory files and so do not persist beyond a single session.
%The following session illustrates various ways of
%abbreviating types:
%
%\setcounter{sessioncount}{1}
%\begin{session}\begin{verbatim}
%*new_theory `numpair`;;
%() : unit
%
%#new_type_abbrev(`numpair`, ":num*num");;
%() : unit
%
%#let t1 = "x:numpair";;
%t1 = "x" : term
%
%#type_of t1;;
%":num * num" : type
%
%#":numpair" = ":num*num";;
%true : bool
%\end{verbatim}\end{session}
%
%\noindent The alternative to introducing a type abbreviation is
%to give an \ML\ name to the type, and then to use this name via antiquotation.
%Continuing the session:\index{abbreviation of types, in HOL logic@abbreviation of types, in \HOL\ logic|)}
%
%\begin{session}\begin{verbatim}
%#let ty = ":num*num";;
%ty = ":num * num" : type
%
%#let t2 = "x:^ty";;
%t2 = "x" : term
%
%#t1 = t2;;
%true : bool
%\end{verbatim}\end{session}
%
%\pagebreak[2]
%
%\noindent The type abbreviation is stored in the theory file and so
%persists across sessions. This can be seen by the result of printing
%the theory \ml{numpair}:
%
%\begin{session}\begin{verbatim}
%#print_theory`numpair`;;
%The Theory numpair
%Parents --  HOL
%Type Abbreviations --  numpair ":num * num"
%******************** numpair ********************
%
%() : unit
%\end{verbatim}\end{session}
%
%\noindent If the session is then ended:
%
%\begin{session}\begin{verbatim}
%#close_theory();;
%() : unit
%
%#quit();;
%\end{verbatim}\end{session}
%
%\noindent and a new session is started in which the theory \ml{numpair} is
%loaded:
%
%\setcounter{sessioncount}{1}
%\begin{session}\begin{verbatim}
%#load_theory`numpair`;;
%Theory numpair loaded
%() : unit
%
%#"x:numpair";;
%"x" : term
%
%#type_abbrevs `-`;;
%[(`numpair`, ":num * num")] : (string * type) list
%\end{verbatim}\end{session}
%
%\noindent then the type abbreviation persists.
%
%Type abbreviations tend to be little used in practice; the antiquotation
%method is usually sufficient.

