\chapter{Miscellaneous Features}\label{avramisc}

\newcommand\holmake{\texttt{Holmake}}

This section describes some of the features
that exist for managing the interface\index{HOL system@\HOL\
system!adjustment of user interface of} to the \HOL\ system.

\begin{itemize}
\item A help system.
\item A theorem database.
\item A datatype database.
\item A tool for dependency maintenance in large developments.
\item Flags for controlling the parsing and printing of terms.
\item A function for adjusting the maximum depth to which terms and
theorems are printed by the pretty printer (the default is 500).
\item Functions for counting the number of primitive inferences done in
an evaluation, and timing it.
\item A version of the system which allows the implicit invocation of
the parsers for \HOL\ types and terms.
\end{itemize}

\section{Help}

 There are several kinds of help available in \holn{}, all accessible
 through the same incantation:
 \begin{verbatim}
     help <string>;
 \end{verbatim}

 The kinds of help available are:

 \begin{description}

 \item [MoscowML help.] This is uniformly excellent. Information for
   library routines is available, whether the library is loaded or not
   via \verb+help "Lib"+.

\item [HOL overview.] This is a short summary of important information
  about \holn{}.

\item [HOL help.] This is the on-line help from Hol88 and Hol90, and
  is intended to document all HOL-specific functions available to the
  user. It is very detailed and often accurate; however, it can be
  out-of-date, refer to HOL90 or HOL88, or even be missing!

\item [HOL structure information.]  For most structures in the \holn{}
  source, one can get a listing of the entrypoints found in the
  accompanying signature. This is helpful for locating functions and
  is automatically derived from the system sources, so it is alway
  up-to-date.

\item [Theory facts.] These are automatically derived from theory
  files, so they are always up-to-date. The signature of each theory
  is available (since theories are represented by structures in
  \holn{}). Also, each axiom, definition, and theorem in the theory can
  be accessed by name in the help system; the theorem itself is given.
 \end{description}

 Therefore the following example queries can be made:

 \begin{table}[h]
\begin{center}
 \begin{tabular}{|l|l|} \hline
  \verb+help "installPP"+ & Moscow ML help \\
  \verb+help "hol"+ &  \holn{} overview \\
  \verb+help "aconv"+ &  on-line HOL help \\
  \verb+help "Tactic"+ & HOL source structure information \\
  \verb+help "boolTheory"+ &  theory structure signature \\
  \verb+help "list_Axiom"+ & theory structure signature and theorem
 statement \\ \hline
 \end{tabular}
\end{center}
 \end{table}

\section{\holmake---a tool for maintaining \HOL\ formalizations}
\label{Holmake}

The purpose of \holmake\footnote{{\tt Holmake} was first written by
  Ken Larsen and then extended by Michael Norrish.} is to maintain
dependencies in a \holn{} source directory. A single invocation of
\holmake{} will compute dependencies between files, (re-)compile plain
ML code, (re-)compile and execute theory scripts, and (re-)compile the
resulting theory modules. \holmake{} does not require the user to
provide any dependency information,\eg, a Makefile. \holmake{} can
be very convenient to use, but there are some conventions and
restrictions on it that must be followed, which we will describe in
the sequel.

\holmake{} can be accessed through
\begin{verbatim}
   <hol-dir>/bin/Holmake.
\end{verbatim}

The development model that \holmake{} is designed to support is that
there are two modes of work: theory construction and system revision.
In `theory construction' mode, the user builds up a theory by
interacting with HOL, perhaps over many sessions. In `system rebuild'
mode, a component that others depend on has been altered, so all modules
dependent on it have to be brought up to date. System rebuild mode is
simpler so we deal with it first.

\subsection{System Rebuild}

A system rebuild happens when an existing theory has been improved in
some way (augmented with a new theorem, a change to a definition, etc.),
or perhaps some support ML code has been modified or added to the
formalization under development. The user needs to find and recompile
just those modules affected by the change. This is what an invocation of
\holmake{} does, by identifying the out-of-date modules and
re-compiling and re-executing them.


\subsection{Theory construction}

To start a theory construction, some context (semantic, and also proof
support) is established, typically by loading parent theories and
useful libraries. In the course of building the theory, the user keeps
track of the ML---which, for example, establishes context, makes
definitions, builds and invokes tactics, and saves theorems---in a
text file. This file is used to achieve inter-session persistence of
the theory being constructed, i.e., the text file resulting from
session $n$ is ``\verb+use+''d to start session $n+1$; after that,
theory construction resumes.

Once the user finishes the perhaps long and arduous task of constructing
a theory, the user should
\begin{enumerate}
\item make the script separately compilable;
\item invoke \holmake{}. This will (a) compile and execute the
  script file; and (b) compile the resulting theory file. After this,
  the theory file is available for use.
\end{enumerate}

\subsection{Making the script separately compilable}

First, the invocation
\begin{verbatim}
    val _ = export_theory();
\end{verbatim}
should be added at the end of the file. When the script is finally
executed, this call writes the theory to disk.

Second, we address a crucial environmental issue: if a theory script
has been constructed using\verb+ <holdir>/bin/hol+, then it has been
developed in an environment where some commonly used structures, \eg,
\verb+Tactic+, have already been loaded and opened for the user's
convenience. When we wish to apply \holmake{} to a script developed
in this way, we have to take some extra steps to ensure that the
compilation environment also provides these structures.  In the common
case, this is simple; one must only add, at the head of the theory
script, the following ``boilerplate'':
\begin{verbatim}
    open HolKernel Parse basicHol90Lib;
    infix THEN THENL THENC ORELSE ORELSEC THEN_TCL ORELSE_TCL ## |->;
    infixr -->;
\end{verbatim}
This will duplicate the starting environment that one obtains with
\verb+<holdir>/bin/hol+ and \verb+<holdir>/bin/hol.unquote+.

Now the script should be separately compilable. Invoke \holmake{}
to check; MoscowML will flag any unaccounted-for identifiers it finds.
The user has to resolve these, either by using the `dot' notation to
locate the identifier for the compiler, or by \verb+open+ing the
relevant module. This ``compile/resolve-identifier'' loop should
continue until \holmake{} succeeds in compiling the module.

The following notes may be of some further help.

\begin{enumerate}
\item The filenames of theory scripts must follow the following
  convention: a HOL theory script for theory ``x'' should be named
  \texttt{xScript.sml}.  When \verb+export_theory+ is called during an
  invocation of \verb+Holmake+, the files \texttt{xTheory.sig} and
  \texttt{xTheory.sml} will be generated and then compiled.

\item In the MoscowML batch compiler, modules are not allowed to have
  unbound top-level expressions. Hence, something like the following
  is not allowed:
\begin{verbatim}
    new_theory "ted";
\end{verbatim}
To make Moscow ML happy, one must instead write something like
\begin{verbatim}
    val _ = new_theory "ted";
\end{verbatim}

\item In the interactive system, one has to explicitly \verb+load+
  modules; on the other hand, the batch compiler will load modules
  automatically.  For example, in order to execute \verb+open Foo+ (or
  refer to values in \verb+Foo+) in the interactive system, one must
  first have executed \verb+load "Foo"+. Contrarily, the batch
  compiler will reject files having occurrences of \verb+load+, since
  \verb+load+ is only defined for the interactive system.

\item Take care not to have the string "Theory" embedded in the name
  of any of your files. \holn{} generates files containing this
  string, and when it cleans up after itself, it removes such files
  using a regular expression. This will also remove other files with
  names containing "Theory". For example, if, in your development
  directory, you had a file of ML code named \texttt{MyTheory.sml} and
  you also were managing a \holn{} development there with {\tt
    Holmake}, then MyTheory.sml would get deleted if {\tt Holmake
    clean} was invoked.

\item We can see that some users may not wish to use (some of) the
  support provided by \verb+basicHol90Lib+, since it is becoming
  dated. In that case, the same general principle set out above will
  apply: the user must ensure that the compilation environment for a
  theory script is the same as the interactive environment it was
  developed in.

\end{enumerate}

\subsection{Summary}

A complete theory construction is performed by the following steps:
\begin{itemize}
\item Construct theory script, perhaps over many sessions;
\item Transform script into separately compilable form;
\item Invoke \holmake{} to generate the theory and compile it.
\end{itemize}

After that, the theory is usable as an ML module.

\subsection{What \holmake{} doesn't do}

\holmake{} only works properly on the current directory.  \holmake{}
will rebuild files in the current directory if something it depends on
from another directory is fresher than it is, but it will not do any
analysis on files in other directories.  If one is developing a system
over more than one directory, one should write a master Makefile (or
shell script) that invokes \holmake{} in the subsidiary
directories, in the correct order, \ie., such that there never is an
out-of-date dependence leading outside of the current directory. This
should always be achievable, simply by ordering the directories in the
order that one would have to ``\verb+use+'' files in them.

\subsection{\holmake{}'s command-line arguments}

Like {\tt make}, \holmake{} takes command-line arguments
corresponding to the targets that the user desires to build.  If there
are none, then \holmake{} will attempt to build all ML modules and
HOL theories it can detect in the current directory.  In addition,
there are three special targets that can be used:
\begin{description}
\item[{\tt clean}] Removes all compiled files.
\item [{\tt cleanDeps}] Removes all of the pre-computed dependency
  files.  This can be an important thing to do if, for example, you
  have introduced a new {\tt .sig} file on top of an existing {\tt
  .sml} file.
\item [{\tt cleanAll}] Removes all compiled files as well as all of
  the hidden dependency information.
\end{description}

\noindent Finally, the user can directly affect the workings of \verb+Holmake+
with the following command-line options:
\begin{description}
\item[\tt -I <directory>] Look in specified directory for additional
  MoscowML object files, including other HOL theories.  This option
  can be repeated, with multiple {\tt -I}'s to allow for multiple
  directories to be referenced.
\item[\tt -d <file>] Ignore the given file and don't try to build it.
  The file may be rebuilt anyway if other files you have specified
  depend on it.  This is useful to stop Holmake from attempting to
  compile files that are interactive scripts (include use of {\tt
  load} or {\tt use}, for example).
\item[\texttt{-f <theory>}] Toggles whether or not a theory should be
  built in ``fast'' mode.  Fast building causes tactic proofs
  (invocations of \texttt{prove} and \texttt{store\_thm}) to
  automatically succeed.  This lack of soundness is marked by the
  \texttt{fast\_proof} oracle tag.  This tag will appear on all
  theorems proved in this way and all subsequent theorems that depend
  on such theorems.  \holmake's default is not to build in fast mode.
\item[\texttt{--fast}] Makes \holmake's default be to build in fast
  mode (see above).
\item[{\tt --help} or {\tt -h}] Prints out a useful option summary and
  exits.
\item[\tt --holdir <directory>] Associate this build with the given
  HOL directory, rather than the one this version of \holmake{} was
  configured to use by default.
\item[\texttt{--no\_sigobj}] Do not link against HOL system's
  directory of HOL system files.  Use of this option goes some way
  towards turning
  \holmake{} into a general MoscowML \textsf{make} system.  However,
  it will still attempt to do ``HOL things'' with files whose names
  end in \texttt{Script} and \texttt{Theory}.
\item[\texttt{--qof}] Standing for ``quit on failure'', if a tactic
  fails to prove a theorem, quit the build.  The default is to use
  \texttt{mk\_thm} to assert that the failed goal is true so that the
  build can continue and other theorems proved.
\item[{\tt --rebuild\_deps} or {\tt -r}] Forces \holmake{} to
  always rebuild the dependency information, whether or not it thinks
  it needs to.
\item[{\tt --version} or {\tt -v}] Show some brief version
  information.  As of this writing, \holmake{} is at version 2.1.1.
\end{description}

\noindent \holmake{} should never exit with the MoscowML message ``Uncaught
exception''.  Such behaviour is a bug, please report it!



\section{Flags for the HOL logic}
\label{HOLflags}

\index{HOL system@\HOL\ system!adjustment of user interface of|(} The
subset of flags\index{HOL system@\HOL\ system!flags in}\index{flags,
  in ML@flags, in \ML} that control aspects of \HOL\ relating to the
logic is summarized in the table below.


\begin{center}
\index{counting inferences, in HOL proofs@counting inferences, in \HOL\ proofs}
\index{inferences, in HOL logic@inferences, in \HOL\ logic!counting of}
\index{printing, in HOL logic@printing, in \HOL\ logic!of types}
\index{types, in HOL logic@types, in \HOL\ logic!printing of}
\index{types, in HOL logic@types, in \HOL\ logic!default}
\index{theory files!pretty printing of}
\index{pretty printing!flags for, in HOL system@flags for, in \HOL\ system}
\index{type checking, in HOL logic@type checking, in \HOL\ logic!verbose errors in}
\index{interface maps}
\index{printing, in HOL logic@printing, in \HOL\ logic!of quantification}
\index{let-terms, in HOL logic@\ml{let}-terms, in \HOL\ logic!pretty printing of}
\index{infixes, in HOL logic@infixes, in \HOL\ logic!pretty printing of}
\index{printing, in HOL logic@printing, in \HOL\ logic!pretty printing}
%\index{printing, in HOL logic@printing, in \HOL\ logic!undischarging
%IS_ASSUMPTION_OFs in@undischarging \ml{IS\_ASSUMPTION\_OF}s in}
%\index{IS_ASSUMPTION_OF@\ml{IS\_ASSUMPTION\_OF}}
\index{timing@\ml{timing}}
\index{show_types@\ml{show\_types}}
\index{sticky@\ml{sticky}}
\index{theory_pp@\ml{theory\_pp}}
\index{type_error@\ml{type\_error}}
\index{interface_print@\ml{interface\_print}}
\index{print_cond@\ml{print\_cond}}
\index{print_quant@\ml{print\_quant}}
\index{print_let@\ml{print\_let}}
\index{print_list@\ml{print\_list}}
\index{print_uncurry@\ml{print\_uncurry}}
\index{print_infix@\ml{print\_infix}}
\index{function abstraction, in HOL logic@function abstraction, in \HOL\ logic!paired}
\index{function abstraction, in HOL logic@function abstraction, in \HOL\ logic!pretty printing, of paired}
\begin{tabular}{|l|l|l|} \hline
\multicolumn{3}{|c|}{ } \\
\multicolumn{3}{|c|}{\bf Settable system flags} \\
\multicolumn{3}{|c|}{ } \\
{\it Flag} & {\it Function} &
{\it Default value} \\ \hline
 & &  \\
\ml{timing} &    Print number of theorems proved& \ml{false}\\ \hline

\ml{show\_types} &    Prints types in quotations   &    \ml{false}\\ \hline

\ml{sticky}     &         Activates sticky types   &        \ml{false}\\ \hline


\ml{theory\_pp} & Pretty printing of theory files &   \ml{false} \\ \hline

\ml{type\_error} & Verbose type checking errors in quotations& \ml{true} \\ \hline

\ml{interface\_print}  &   Causes inverse of interface map &     \ml{true}\\[-1mm]
 &                       to be used when printing & \\ \hline

\ml{print\_cond} & Pretty print \HOL\ conditionals  &      \ml{true}\\ \hline

\ml{print\_quant} &   Pretty print \HOL\ quantifications &     \ml{true}\\ \hline

\ml{print\_let} &   Pretty print \HOL\ \ml{let}-expressions   &\ml{true}\\ \hline

\ml{print\_list}   &       Pretty print \HOL\ lists &           \ml{true}\\ \hline

\ml{print\_uncurry} & Pretty print \HOL\ paired abstractions & \ml{true}\\ \hline

\ml{print\_infix} &    Pretty print \HOL\ infixes & \ml{true}\\ \hline
\end{tabular}
\end{center}


\section{Hiding constants}
\label{hidden}

\index{parsing, of HOL logic@parsing, of \HOL\ logic!hiding constant status in|(}
\index{HOL system@\HOL\ system!hiding constants in|(}
The following function can be used to hide\index{constants, in HOL logic@constants, in \HOL\ logic!hiding status of|(} the constant  status of  a name from
the quotation parser.

\begin{boxed}
\index{hide_constant@\ml{hide\_constant}|pin}
\begin{verbatim}
   hide_constant : string -> void
\end{verbatim}\end{boxed}


\noindent Evaluating \ml{hide\_constant\ `}$x$\ml{`}
makes the quotation parser treat $x$ as a variable (lexical
rules permitting), even if $x$ is the name of a constant in the current theory
(constants and variables can have the same name).
This is useful if one wants to use variables\index{variables, in HOL logic@variables, in \HOL\ logic!with constant names}  with the same names
as previously declared (or built-in) constants (\eg\ \ml{o}, \ml{I}, \ml{S}
\etc).
The name $x$ is still a
constant for the constructors, theories, etc; \ml{hide\_constant}
affects only  parsing.

Hiding a constant and then attempting to declare it as a new
constant will fail (as it must, if the system is to remain sound).\index{soundness!of HOL logic@of \HOL\ logic}\index{constants, in HOL logic@constants, in \HOL\ logic!hiding status of|)}

The function

\begin{boxed}
\index{unhide_constant@\ml{unhide\_constant}|pin}
\begin{verbatim}
   unhide_constant : string -> void
\end{verbatim}\end{boxed}

\noindent undoes the hiding; it fails if its argument is not a previously
hidden constant.

The function:

\begin{boxed}
\index{is_hidden@\ml{is\_hidden}|pin}
\begin{verbatim}
   is_hidden : string -> bool
\end{verbatim}\end{boxed}

\noindent tests whether a string is the name of a hidden constant.
\index{HOL system@\HOL\ system!adjustment of user interface of|)}
\index{HOL system@\HOL\ system!hiding constants in|)}
\index{parsing, of HOL logic@parsing, of \HOL\ logic!hiding constant status in|)}

\section{Adjusting the pretty-print depth}

\index{ML@\ML!pretty printer for|(}
The following \ML\ function  can be used to adjust the maximum depth of
printing\index{printing, in HOL logic@printing, in \HOL\ logic!structural depth adjustment in}.

\begin{boxed}
\index{max_print_depth@\ml{max\_print\_depth}|pin}
\begin{verbatim}
   max_print_depth : int -> int
\end{verbatim}\end{boxed}

\noindent The default print depth\index{default print depth, for HOL logic@default print depth, for \HOL\ logic|(} is $500$. Evaluating
\ml{max\_print\_depth}$\ n$ sets the maximum to $n$ and returns
the previous value
of the maximum. Subterms nested more deeply than
the maximum print depth are printed as
{\small\verb%&%}. For example:

\setcounter{sessioncount}{1}
\begin{session}\begin{verbatim}
#ADD_CLAUSES;;
Theorem ADD_CLAUSES autoloaded from theory `arithmetic`.
ADD_CLAUSES =
|- (0 + m = m) /\
   (m + 0 = m) /\
   ((SUC m) + n = SUC(m + n)) /\
   (m + (SUC n) = SUC(m + n))

|- (0 + m = m) /\
   (m + 0 = m) /\
   ((SUC m) + n = SUC(m + n)) /\
   (m + (SUC n) = SUC(m + n))

#max_print_depth 7;;
500 : int

#ADD_CLAUSES;;
|- (& + & = m) /\ (& + & = m) /\ ((& + & = &(&) /\ (& + (& = &(&)

#max_print_depth 5;;
7 : int

#ADD_CLAUSES;;
|- (& /\ (& /\ (& /\ (&

#max_print_depth 3;;
5 : int

#ADD_CLAUSES;;
|- &
\end{verbatim}\end{session}
\index{default print depth, for HOL logic@default print depth, for \HOL\ logic|)}

\section{Timing and counting theorems}

Whenever \HOL\  performs  a  primitive  inference  (or  accepts   an  axiom  or
definition) a counter\index{inferences, in HOL logic@inferences, in \HOL\ logic!counting of}\index{timing of HOL evaluations@timing of \HOL\ evaluations}\index{HOL system@\HOL\ system!timing and counting inferences in}  is incremented.  The value of this counter is returned by
the function:

\begin{boxed}
\index{thm_count@\ml{thm\_count}|pin}
\index{counting inferences, in HOL proofs@counting inferences, in \HOL\ proofs}
\begin{verbatim}
   thm_count : void -> int
\end{verbatim}\end{boxed}

\noindent This counter can be reset with the function:

\begin{boxed}
\index{set_thm_count@\ml{set\_thm\_count}|pin}
\begin{verbatim}
   set_thm_count : int -> int
\end{verbatim}\end{boxed}

\noindent The previous value of the counter is returned.

The following function is used to switch \ML\ into a  mode in  which the number
of primitive inferences done during each top-level interaction is  shown.
Run-time and garbage collection time are also shown.

\begin{boxed}
\index{timer@\ml{timer}|pin}
\begin{verbatim}
   timer : bool -> bool
\end{verbatim}\end{boxed}

\noindent Executing \ml{timer true} causes  the number  of primitive inferences
and timings to be  printed; \ml{timer  false} switches  the printing  off.  The
previous setting  is
returned.    Executing  \ml{timer}$\ b$  is equivalent to
setting the flag \ml{timing} to the value $b$.


\section{Quotation preprocessing}

A person usually works with \holn{} by interacting with the ML top level
loop in order to build formalizations and perform proofs. In this
setting, the user often needs to enter expressions of the HOL logic to
ML, and interpret the resulting responses. Since the ML representations
of the types, terms, and theorems of the HOL logic are quite unreadable
in their `raw' form, so-called {\it prettyprinters\/} for HOL logic
expressions are automatically invoked by the ML top level when printing
output.

Similarly, types and terms often have to be constructed by the user,
\eg, in order to make definitions, state goals to prove, provide
existential witnesses, \etc\ Since it would be unbearable to make a type
or term of any size `by hand', the system comes equipped with parsers
for type and term expressions. The parser for types is called
\verb+Type+, and the parser for terms is called \verb+Term+. These
parsers take {\it quotations\/}.  A quotation {\tt `}$\ldots$ {\tt `} is
much like an SML string, except that it can span several lines without
requiring awkward backslashes, as an ML string
would.\footnote{Quotations were a feature in the original LCF
system. See the MoscowML User's Manual for more information.}

For added convenience, the \HOL\ system distribution supplies a version
of \holn{} that features a {\it combined parser\/} that accepts both types
and terms. Enclosing some object language concrete syntax between
occurrences of \verb+``+ will result in the correct parser being
invoked. For example

\begin{verbatim}
    ``x /\ y /\ z ==> ?p. p``
\end{verbatim}

\noindent will parse as a term while

\begin{verbatim}
    ``:'a -> ('b -> 'h) -> bool``
\end{verbatim}

\noindent parses as an HOL type. Note that the concrete syntax given in
the quotation for a type needs to provide a hint: the type parser will
only be called if the first character after the leading {\tt ``} is a
colon (\verb+:+).

Knowledgable ML programmers will notice that the idiom {\tt ``}$\ldots$ {\tt
  ``} is not ML-typable; for that reason, it is implemented as a
  pre-processor to ML, thanks to work by Richard Boulton. Users who wish
  to use the pre-processor should invoke {\tt
  <hol-dir>/bin/hol.unquote}. {\small\verb+Holmake+} will accept
  source files having occurrences of \verb+``+.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "description"
%%% End:
