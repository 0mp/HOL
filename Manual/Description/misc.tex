\chapter{Miscellaneous Features}\label{avramisc}

This section describes some of the features
that exist for managing the interface\index{HOL system@\HOL\
system!adjustment of user interface of} to the \HOL\ system.

\begin{itemize}
\item A help system.
\item A theorem database.
\item A datatype database.
\item A tool for dependency maintenance in large developments.
\item Flags for controlling the parsing and printing of terms.
\item A function for adjusting the maximum depth to which terms and
theorems are printed by the pretty printer (the default is 500).
\item Functions for counting the number of primitive inferences done in
an evaluation, and timing it.
\item A version of the system which allows the implicit invocation of
the parsers for \HOL\ types and terms.
\end{itemize}

\section{Help}

 There are several kinds of help available in \HOL{}, all accessible
 through the same incantation:
 \begin{verbatim}
     help <string>;
 \end{verbatim}

 The kinds of help available are:

 \begin{description}

 \item [MoscowML help.] This is uniformly excellent. Information for
   library routines is available, whether the library is loaded or not
   via \verb+help "Lib"+.

\item [\HOL{} overview.] This is a short summary of important information
  about \HOL{}.

\item [\HOL{} help.] This on-line help is intended to document all
  HOL-specific functions available to the user. It is very detailed
  and often accurate; however, it can be out-of-date, refer to earlier
  versions of the system, or even be missing!

\item [\HOL{} structure information.]  For most structures in the
  \HOL{} source, one can get a listing of the entrypoints found in the
  accompanying signature. This is helpful for locating functions and
  is automatically derived from the system sources, so it is alway
  up-to-date.

\item [Theory facts.] These are automatically derived from theory
  files, so they are always up-to-date. The signature of each theory
  is available (since theories are represented by structures in
  \HOL{}). Also, each axiom, definition, and theorem in the theory can
  be accessed by name in the help system; the theorem itself is given.
 \end{description}

 Therefore the following example queries can be made:

 \begin{table}[h]
\begin{center}
 \begin{tabular}{|l|l|} \hline
  \verb+help "installPP"+ & Moscow ML help \\
  \verb+help "hol"+ &  \HOL{} overview \\
  \verb+help "aconv"+ &  on-line \HOL{} help \\
  \verb+help "Tactic"+ & \HOL{} source structure information \\
  \verb+help "boolTheory"+ &  theory structure signature \\
  \verb+help "list_Axiom"+ & theory structure signature and theorem
 statement \\ \hline
 \end{tabular}
\end{center}
 \end{table}

 \section{\holmake---a tool for maintaining \HOL{} formalizations}
\label{Holmake}

The purpose of \holmake\footnote{\holmake{} was first written by Ken
  Larsen and then extended by Michael Norrish.} is to maintain
dependencies in a \HOL{} source directory. A single invocation of
\holmake{} will compute dependencies between files, (re)compile plain
ML code, (re)compile and execute theory scripts, and (re)compile the
resulting theory modules. \holmake{} does not require the user to
provide any dependency information,\eg, a Makefile. \holmake{} can be
very convenient to use, but there are some conventions and
restrictions on it that must be followed, which we will describe in
the sequel.




\holmake{} can be accessed through
\begin{verbatim}
   <hol-dir>/bin/Holmake.
\end{verbatim}

The development model that \holmake{} is designed to support is that
there are two modes of work: theory construction and system revision.
In `theory construction' mode, the user builds up a theory by
interacting with HOL, perhaps over many sessions. In `system rebuild'
mode, a component that others depend on has been altered, so all modules
dependent on it have to be brought up to date. System rebuild mode is
simpler so we deal with it first.

\subsection{System Rebuild}

A system rebuild happens when an existing theory has been improved in
some way (augmented with a new theorem, a change to a definition,
etc.), or perhaps some support ML code has been modified or added to
the formalization under development. The user needs to find and
recompile just those modules affected by the change. This is what an
invocation of \holmake{} does, by identifying the out-of-date modules
and re-compiling and re-executing them.


\subsection{Theory construction}

To start a theory construction, some context (semantic, and also proof
support) is established, typically by loading parent theories and
useful libraries. In the course of building the theory, the user keeps
track of the ML---which, for example, establishes context, makes
definitions, builds and invokes tactics, and saves theorems---in a
text file. This file is used to achieve inter-session persistence of
the theory being constructed, i.e., the text file resulting from
session $n$ is ``\verb+use+''d to start session $n+1$; after that,
theory construction resumes.

Once the user finishes the perhaps long and arduous task of constructing
a theory, the user should
\begin{enumerate}
\item make the script separately compilable;
\item invoke \holmake{}. This will (a) compile and execute the
  script file; and (b) compile the resulting theory file. After this,
  the theory file is available for use.
\end{enumerate}

\subsection{Making the script separately compilable}

First, the invocation
\begin{verbatim}
    val _ = export_theory();
\end{verbatim}
should be added at the end of the file. When the script is finally
executed, this call writes the theory to disk.

Second, we address a crucial environmental issue: if a theory script
has been constructed using\verb+ <holdir>/bin/hol+, then it has been
developed in an environment where some commonly used structures, \eg,
\verb+Tactic+, have already been loaded and opened for the user's
convenience. When we wish to apply \holmake{} to a script developed
in this way, we have to take some extra steps to ensure that the
compilation environment also provides these structures.  In the common
case, this is simple; one must only add, at the head of the theory
script, the following ``boilerplate'':
\begin{verbatim}
    open HolKernel Parse boolLib;
\end{verbatim}
This will duplicate the starting environment that one obtains with
\verb+<holdir>/bin/hol.bare+ and
\verb+<holdir>/bin/hol.bare.unquote+.  If the script was developed
interactively with \texttt{hol} or \texttt{hol.unquote}, then one must
also add
\begin{verbatim}
    open bossLib
\end{verbatim}
Now the script should be separately compilable. Invoke \holmake{}
to check; MoscowML will flag any unaccounted-for identifiers it finds.
The user has to resolve these, either by using the `dot' notation to
locate the identifier for the compiler, or by \verb+open+ing the
relevant module. This ``compile/resolve-identifier'' loop should
continue until \holmake{} succeeds in compiling the module.

The following notes may be of some further help.

\begin{enumerate}
\item The filenames of theory scripts must follow the following
  convention: a HOL theory script for theory ``x'' should be named
  \texttt{xScript.sml}.  When \verb+export_theory+ is called during an
  invocation of \holmake, the files \texttt{xTheory.sig} and
  \texttt{xTheory.sml} will be generated and then compiled.

\item In the MoscowML batch compiler, modules are not allowed to have
  unbound top-level expressions. Hence, something like the following
  is not allowed:
\begin{verbatim}
    new_theory "ted";
\end{verbatim}
To make Moscow ML happy, one must instead write something like
\begin{verbatim}
    val _ = new_theory "ted";
\end{verbatim}
\noindent This is because the script file is required to be an ML
structure, and the contents of a structure must be
\emph{declarations}, not expressions.

\item In the interactive system, one has to explicitly \verb+load+
  modules; on the other hand, the batch compiler will load modules
  automatically.  For example, in order to execute \verb+open Foo+ (or
  refer to values in \verb+Foo+) in the interactive system, one must
  first have executed \verb+load "Foo"+. Contrarily, the batch
  compiler will reject files having occurrences of \verb+load+, since
  \verb+load+ is only defined for the interactive system.

\item Take care not to have the string "Theory" embedded in the name
  of any of your files. \HOL{} generates files containing this string,
  and when it cleans up after itself, it removes such files using a
  regular expression. This will also remove other files with names
  containing "Theory". For example, if, in your development directory,
  you had a file of ML code named \texttt{MyTheory.sml} and you also
  were managing a \HOL{} development there with \holmake, then
  \texttt{MyTheory.sml} would get deleted if \texttt{Holmake~clean}
  was invoked.

\end{enumerate}

\subsection{Summary}

A complete theory construction is performed by the following steps:
\begin{itemize}
\item Construct theory script, perhaps over many sessions;
\item Transform script into separately compilable form;
\item Invoke \holmake{} to generate the theory and compile it.
\end{itemize}

After that, the theory is usable as an ML module.

\subsection{What \holmake{} doesn't do}

\holmake{} only works properly on the current directory.  \holmake{}
will rebuild files in the current directory if something it depends on
from another directory is fresher than it is, but it will not do any
analysis on files in other directories.  If one is developing a system
over more than one directory, one should write a master Makefile (or
shell script) that invokes \holmake{} in the subsidiary directories,
in the correct order, \ie., such that there never is an out-of-date
dependence leading outside of the current directory. This should
always be achievable, simply by ordering the directories in the order
that one would have to ``\verb+use+'' files in them.

\subsection{\holmake{}'s command-line arguments}

Like {\tt make}, \holmake{} takes command-line arguments corresponding
to the targets that the user desires to build.  If there are none,
then \holmake{} will attempt to build all ML modules and HOL theories
it can detect in the current directory.  In addition, there are three
special targets that can be used:
\begin{description}
\item[{\tt clean}] Removes all compiled files (unless over-ridden by a
  make-file target of the same name, see
  section~\ref{sec:using-Holmakefiles} below).
\item [{\tt cleanDeps}] Removes all of the pre-computed dependency
  files.  This can be an important thing to do if, for example, you
  have introduced a new {\tt .sig} file on top of an existing {\tt
    .sml} file.
\item [{\tt cleanAll}] Removes all compiled files as well as all of
  the hidden dependency information.
\end{description}

\noindent Finally, the user can directly affect the workings of \holmake{}
with the following command-line options:
\begin{description}
\item[\tt -I <directory>] Look in specified directory for additional
  MoscowML object files, including other HOL theories.  This option
  can be repeated, with multiple {\tt -I}'s to allow for multiple
  directories to be referenced.
\item[\tt -d <file>] Ignore the given file and don't try to build it.
  The file may be rebuilt anyway if other files you have specified
  depend on it.  This is useful to stop Holmake from attempting to
  compile files that are interactive scripts (include use of {\tt
  load} or {\tt use}, for example).
\item[\texttt{-f <theory>}] Toggles whether or not a theory should be
  built in ``fast'' mode.  Fast building causes tactic proofs
  (invocations of \texttt{prove} and \texttt{store\_thm}) to
  automatically succeed.  This lack of soundness is marked by the
  \texttt{fast\_proof} oracle tag.  This tag will appear on all
  theorems proved in this way and all subsequent theorems that depend
  on such theorems.  \holmake's default is not to build in fast mode.
\item[\texttt{--fast}] Makes \holmake's default be to build in fast
  mode (see above).
\item[{\tt --help} or {\tt -h}] Prints out a useful option summary and
  exits.
\item[\tt --holdir <directory>] Associate this build with the given
  HOL directory, rather than the one this version of \holmake{} was
  configured to use by default.
\item[\tt --holmakefile <file>] Use the given file as a make-file.
  See section~\ref{sec:using-Holmakefiles} below for more on this.
\item[\texttt{--interactive} or \texttt{-i}] Causes the HOL code that
  runs when a theory building file is executed to have the flag
  \texttt{Globals.interactive} set to true.  This will alter the diagnostic
  output of a number of functions within the system.
\item[\texttt{-k} or \texttt{--keep-going}] Causes \holmake{} to try
  to build all specified targets, rather than stopping as soon as one
  fails to build.
\item[\texttt{--logging}] Causes \holmake{} to record the times taken
  to build any theory files it encounters.  The times are logged in a
  file in the current directory.  The name of this file includes the
  time when \holmake{} completed, and when on a Unix system, the name
  of the machine where the job was run.  If \holmake{} exits
  unsuccessfully, the filename is preceded by the string
  ``\texttt{bad-}''. Each line in the log-file is of the form
  \textit{theory-name time-taken}, with the time recorded in seconds.
\item[\texttt{--no\_holmakefile}]  Do not use a make-file, even if a file
  called \texttt{Holmakefile} is present in the current directory.
\item[\texttt{--no\_overlay}] Do not use an overlay file.  All HOL
  builds require the presence of a special overlay file from the
  kernel when compiling scripts and libraries.  This is not
  apppropriate for compiling code that has no connection to HOL, so
  this option makes the compilation not use the overlay file.  This
  option is also used in building the kernel before the overlay itself
  has been compiled.
\item[\texttt{--no\_sigobj}] Do not link against HOL system's
  directory of HOL system files.  Use of this option goes some way
  towards turning
  \holmake{} into a general MoscowML \textsf{make} system.  However,
  it will still attempt to do ``HOL things'' with files whose names
  end in \texttt{Script} and \texttt{Theory}.  This option implies
  \texttt{--no\_overlay}.
\item[\texttt{--overlay <file>}] Use the given file as the overlay
  rather than the default.
\item[\texttt{--qof}] Standing for ``quit on failure''.  If a tactic
  fails to prove a theorem, quit the build.  The default is to use
  \texttt{mk\_thm} to assert that the failed goal is true so that the
  build can continue and other theorems proved.
\item[\texttt{--quiet}] Minimise the amount of output produced by
  \holmake{}.  Fatal error messages will still be written to the
  standard error stream.  Other programs called by \holmake{} will not
  be affected.
\item[{\tt --rebuild\_deps} or {\tt -r}] Forces \holmake{} to
  always rebuild the dependency information, whether or not it thinks
  it needs to.
\end{description}

\noindent \holmake{} should never exit with the MoscowML message ``Uncaught
exception''.  Such behaviour is a bug, please report it!


\subsection{Using a make-file with \holmake}
\label{sec:using-Holmakefiles}

\holmake{} will use a make-file to augment its behaviour if one is
present in the current directory.  By default it will look for a file
called \texttt{Holmakefile}, but it can be made to look at any file at
all with the \texttt{--holmakefile} command-line option.  The
combination of \holmake{} and a make-file is supposed to behave as
much as possible like a standard implementation of \textsf{make}.

A make-file consists of two types of entries, variable definitions and
rules.  Outside of these entries, white-space is insignificant, but
newline and \texttt{TAB} characters are very significant within them.
Comments can be started with hash (\texttt{\#}) characters and last
until the end of the line.  Quoting is generally done with use of the
back-slash (\verb+\+) character.  In particular, a backslash-newline
pair always allows a line to be continued as if the newline wasn't
present at all.

A variable definition is of the form
\[
\textsl{Ident} \texttt{ = } \textsl{text}  \texttt{ <NEWLINE> }
\]
and a rule is of the form
\[
\textsl{text } \texttt{:} \textsl{ text} \texttt{ <NEWLINE>}
(\texttt{<TAB>}\textsl{text}\texttt{ <NEWLINE>})^*
\]
Henceforth, the text following a \texttt{TAB} character in a rule will
be referred to as the \emph{command text}.  Text elsewhere will be
referred to as \emph{normal text}.  Normal text has comments stripped
from it, so hash characters there must be escaped with a back-slash
character.  An \textsl{Ident} is any non-empty sequence of
alpha-numeric characters, including the underscore (\texttt{\_}).

In some contexts, normal text is interpreted as a list of words.
These lists use white-space as element separators.  If a word needs to
include white-space itself, those white-space characters should be
escaped with back-slashes.

\newcommand{\varref}[1]{\texttt{\$(#1)}}
\paragraph{Variable definitions} The text on the RHS of a variable
definition can be substituted into any other context by using a
\emph{variable reference}, of the form \varref{VARNAME}.  References
are evaluated \emph{late}, not at time of definition, so it is quite
permissible to have forward references.  On the other hand, this makes
it impossible to write things like \[ \texttt{VAR = \varref{VAR}
something\_new}
\] because the evaluation of \varref{VAR} would lead to an infinite
loop. GNU \textsf{make}'s facility for immediate
definition of variables with \texttt{:=} is not supported.

Note also that white-space around the equals-sign in a variable
definition is stripped.  This means that
\[
\texttt{VAR =<whitespace><NEWLINE>}
\] gives \texttt{VAR} the empty string as its value.\footnote{It is
  possible to give a variable a value of pure whitespace by writing \[
\begin{array}{l}
\texttt{NOTHING =}\\
\texttt{ONE\_SPACE = \varref{NOTHING}\textvisiblespace\hspace{1mm}\varref{NOTHING}}\\
\end{array}\]}

\paragraph{Rules}
Make-file rules are interpreted in the same way as by traditional
\textsf{make}.  The files specified after the colon (if any) are those
files that each target (the files before the colon) is said to
``depend'' on.  If any of these are newer than a target, then
\holmake{} rebuilds that target according to the commands.  If there
are no dependencies, then the commands are executed iff the
target doesn't exist.  If there are no commands, and the target is not
of a type that \holmake{} already knows how to build, then it will
just make sure that the the dependencies are up to date (this may or
may not create the target).  If there are no commands attached to a
rule, and the target is one that \holmake{} does know how to build,
then the rule's extra dependencies are added to those that \holmake{}
has managed to infer for itself, and \holmake{} will build the target
using its built-in rule.  If commands are provided for a type of file
that \holmake{} knows how to build itself, then the make-file's
commands and dependencies take precedence, and only they will be
executed.

If a command-line is preceded by a hyphen (\verb!-!) character, then
the rest of the line is executed, but its error-code is ignored.
(Normally, a command-line raising an error will cause \holmake{} to
conclude that the target can not be built.)  If a command-line is
preceded by an at-sign (\verb!@!), then that command-line will not be
echoed to the screen when it is run.  These two options can be
combined in either order at the start of a command-line.

Command text is interpreted only minimally by \holmake.  Double
back-slashes are turned into single back-slashes, and
backslash-newline pairs do extend lines.  Otherwise, command text is
passed as is to the underlying command interpreter (\texttt{/bin/sh}
say, on Unix, or \texttt{COMMAND.COM} on Windows).  In particular,
this means that hash-characters do \emph{not} start coments on
command-lines, and such ``comments'' will be passed to the shell,
which may or may not treat them as comments when it sees them.

\paragraph{Functions}
\holmake{} supports some simple functions for manipulating text.  All
functions are written with the general form
\texttt{\$(\textsl{function-name}\textvisiblespace{}\hspace{1mm}\textsl{arg}${}_1$,\textsl{arg}${}_2$\dots,\textsl{arg}${}_n$)}.
Arguments can not include commas (use variable references to variables
whose value are commas instead), but can otherwise be arbitrary text.
\begin{description}

\item[\texttt{\$(if arg1,arg2,arg3)}] examines \texttt{arg1}.  If it
  is the empty string, then the value of the whole is equal to the
  value of \texttt{arg3}.  Otherwise, the value is that of \texttt{arg2}.
\item[\texttt{\$(patsubst arg1,arg2,text)}] splits \texttt{text} into component
  words, and then transforms each word by attempting to see if it
  matches the pattern in \texttt{arg1}.  If so, it replaces that word
  with \texttt{arg2} (suitably instantiated).  If not, the word is
  left alone.  The modified words are then reassembled into a
  white-space separated list and returned as the value.

  A pattern is any piece of text including no more than one occurrence
  of the percent~(\texttt{\%}) character.  The percent character
  matches any non-empty string.  All other characters must be matched
  literally.  The instantiation for \texttt{\%} is remembered when the
  replacement is constructed.  Thus, \[
    \texttt{\$(patsubst \%.sml,\%.uo,\$(SMLFILES))}
   \] turns a list of files with suffixes \texttt{.sml} into the same
  list with the suffixes replaced with \texttt{.uo}.
\item[\texttt{\$(subst arg1,arg2,text)}] replaces every occurrence
  of \texttt{arg1} in \texttt{text} with \texttt{arg2}.
\item[\texttt{\$(protect arg)}] wraps \texttt{arg} in appropriate
  quote characters to ensure that it will pass through the operating
  system's command shell unscathed.  This is important in the presence
  of file-names that include spaces.  Those make-file variables that
  point directly at executables (\texttt{MOSMLC}, \texttt{MOSMLLEX}
  etc) are automatically protected in this way.  Others, which might
  be used in concatenation with other elements, are not so protected.
  Thus, if \texttt{DIR} might include spaces, one should write
  \texttt{\$(protect \$(DIR)/subdirectory/program)}.
\end{description}

\paragraph{Special and pre-defined variables}

If defined, the \texttt{INCLUDES} variable is used by to add
directories to the list of directories consulted when files are
compiled and linked.  The effect is as if the directories specified
had all been included on the command-line with \texttt{-I} options.
The \texttt{PRE\_INCLUDES} variable works similarly, but the
directories specified here are placed before the \mbox{\texttt{-I
<holdir>}} option that is used in invocations of the Moscow ML
compiler.  This option gives the user a way of over-riding code in
the core distribution if they choose as the compiler will find their
own code before the distribution's.

The \texttt{OPTIONS} variable is used for the specification of
options.  There are currently just three possible (others are
ignored): \texttt{NO\_SIGOBJ}, \texttt{NO\_OVERLAY}, and
\texttt{QUIT\_ON\_FAILURE}.  These have the same effect as the
corresponding command-line options. The \texttt{EXTRA\_CLEANS}
variable is used to specify the name of additional files that should
be deleted when a \texttt{Holmake clean} command is issued.

Within a command, the variable \texttt{\$<} is used to stand for the
name of the first dependency of the rule.  The variable \texttt{\$@} is
used to stand for the target of the rule.

Finally there are variables that are some useful abbreviations for
commonly used programs.  These are:
\begin{description}
\item[\texttt{CP}] This variable is replaced by an operating-system
  appropriate program to perform a file copy.  The file to be copied
  is the first argument, the second is the place to copy to.  The
  second argument can be a directory.  (Under Unix, \texttt{CP}
  expands to \texttt{cp}; under Windows, it expands to \texttt{copy}.)
\item[\texttt{HOLMOSMLC}] This variable is replaced by an invocation
  of the Moscow ML compiler along with the \texttt{-q} flag (necessary
  for handling quotations), and the usual \texttt{-I} include
  specifications (pre-includes, the hol-directory include, and the
  normal includes).
\item[\texttt{HOLMOSMLC-C}] This variable is the same as
  \texttt{HOLMOSMLC} except that it finishes with a closing
  \texttt{-c} option (hence the name) followed by the name of the
  system's overlay file.  This is needed for compilation of HOL source
  files, but not for linking of HOL object code, which can be done
  with \texttt{HOLMOSMLC}.
\item[\texttt{MOSMLC}] This is replaced by an invocation of the
  compiler along with just the normal includes.
\item[\texttt{MOSMLLEX}] This is replaced by an invocation of the
  \texttt{mosmllex} program that comes with the Moscow ML
  distribution.
\item[\texttt{MOSMLYAC}] This is replaced by an invocation of the
  \texttt{mosmlyac} program that comes with the Moscow ML
  distribution.
\item[\texttt{MV}] This variable is replaced by an operating-system
  appropriate program to perform a file movement.  The file to be
  moved is the first argument, the second is the place to move to.
  The second argument can be a directory.  (Under Unix, \texttt{MV}
  expands to \texttt{mv}; under Windows, it expands to \texttt{rename}.)


\end{description}
The \texttt{MOSMLLEX} and \texttt{MOSMLYAC} abbreviations are really
only useful if the originals aren't necessarily going to be on the
user's ``path''.  For backwards compatibility, the five variables
above including the sub-string ``\texttt{MOSML}'' in their names can
also be used by simply writing their names directly (i.e., without the
enclosing \varref{\dots}), as long as these references occur first on
a command-line.

Other pre-defined variables are given in
Figure~\ref{fig:predefined-holmake-vars}.  If a reference is made to
an otherwise undefined string, then it is treated as a reference to an
environment variable.  If there is no such variable in the
environment, then the variable is silently given the empty string as
its value.


\begin{figure}[htbp]
\begin{tabular}{ll}
\texttt{HOLDIR} & the root of the HOL distribution\\
\texttt{SIGOBJ} & \varref{HOLDIR}\texttt{/sigobj}, where HOL object
code is stored\\
\texttt{MOSMLDIR} & the root of the MoscowML distribution\\
\texttt{MOSMLCOMP} & \varref{MOSMLDIR}\texttt{/bin/mosmlc}\\
\texttt{UNQUOTE} & the location of the quotation-filter executable\\
\end{tabular}
\caption{Pre-defined variables provided in \holmake}
\label{fig:predefined-holmake-vars}
\end{figure}

\section{Hiding constants}
\label{hidden}

\index{parsing, of HOL logic@parsing, of \HOL{} logic!hiding constant status in|(}
\index{HOL system@\HOL\ system!hiding constants in|(}
The following function can be used to hide\index{constants, in HOL logic@constants, in \HOL\ logic!hiding status of|(} the constant  status of  a name from
the quotation parser.

\begin{boxed}
\index{hide@\ml{hide}|pin}
\begin{verbatim}
  val hide   : string -> ({Name : string, Thy : string} list *
                          {Name : string, Thy : string} list)
\end{verbatim}\end{boxed}

\noindent Evaluating \ml{hide "}$x$\ml{"}
makes the quotation parser treat $x$ as a variable (lexical
rules permitting), even if $x$ is the name of a constant in the current theory
(constants and variables can have the same name).
This is useful if one wants to use variables\index{variables, in HOL logic@variables, in \HOL\ logic!with constant names}  with the same names
as previously declared (or built-in) constants (\eg\ \ml{o}, \ml{I}, \ml{S}
\etc).
The name $x$ is still a
constant for the constructors, theories, etc; \ml{hide}
affects only  parsing.  See the \REFERENCE{} entry for \ml{hide} for
more details, including an explanation of the return type.

The function

\begin{boxed}
\index{reveal@\ml{reveal}|pin}
\begin{verbatim}
   reveal : string -> unit
\end{verbatim}\end{boxed}

\noindent undoes hiding.

The function

\begin{boxed}
\index{hidden@\ml{hidden}|pin}
\begin{verbatim}
   hidden : string -> bool
\end{verbatim}\end{boxed}

\noindent tests whether a string is the name of a hidden constant.
\index{HOL system@\HOL{} system!adjustment of user interface of|)}
\index{HOL system@\HOL{} system!hiding constants in|)}
\index{parsing, of HOL logic@parsing, of \HOL{} logic!hiding constant status in|)}

\section{Adjusting the pretty-print depth}

\index{ML@\ML!pretty printer for|(}
The following \ML\ reference  can be used to adjust the maximum depth of
printing\index{printing, in HOL logic@printing, in \HOL\ logic!structural depth adjustment in}.

\begin{boxed}
\index{max_print_depth@\ml{max\_print\_depth}|pin}
\begin{verbatim}
   max_print_depth : int ref
\end{verbatim}\end{boxed}

\index{default print depth, for HOL logic@default print depth, for \HOL{} logic|(}
\noindent The default print depth is $-1$, which is interpreted as
meaning no maximum.  Subterms nested more deeply than the maximum
print depth are printed as {\small\verb%...%}. For example:

\setcounter{sessioncount}{1}
\begin{session}\begin{verbatim}
- ADD_CLAUSES;
> val it =
    |- (0 + m = m) /\ (m + 0 = m) /\ (SUC m + n = SUC (m + n)) /\
       (m + SUC n = SUC (m + n)) : thm

- max_print_depth := 3;
> val it = () : unit
- ADD_CLAUSES;
> val it = |- (... + ... = m) /\ (... = ...) /\ ... /\ ... : thm
\end{verbatim}\end{session}
\index{default print depth, for HOL logic@default print depth, for \HOL{} logic|)}

\section{Timing and counting theorems}

\index{counting inferences, in HOL proofs@counting inferences, in \HOL\ proofs|(}
\index{inferences, in HOL logic@inferences, in \HOL\ logic!counting of|(}
\index{timing of HOL evaluations@timing of \HOL\ evaluations|(}


\HOL{} can be made to record its use of primitive
inferences, axioms, definitions and use of oracles.  Such recording is
enabled with the function

\begin{boxed}
\index{thm_counting@\ml{thm\_counting}|pin}
\begin{verbatim}
  val thm_counting : bool -> unit
\end{verbatim}
\end{boxed}

\noindent (This function as with all the others in this section is
found in the \texttt{Count} structure.)

Calling \verb+thm_counting true+ enables counting, and
\verb+thm_counting false+ disables it.  The default is for counting to
be disabled.  If it is enabled, whenever \HOL\ performs a primitive
inference (or accepts an axiom or definition) a
counter is incremented.  A total count as well as counts per
primitive inference are maintained.  The value of this counter is
returned by the function:

\begin{boxed}
\index{thm_count@\ml{thm\_count}|pin}
\begin{verbatim}
  val thm_count : unit ->
   {ASSUME : int, REFL : int, BETA_CONV : int, SUBST : int,
    ABS : int, DISCH : int, MP : int, INST_TYPE : int, MK_COMB : int,
    AP_TERM : int, AP_THM : int, ALPHA : int, ETA_CONV : int,
    SYM : int, TRANS : int, EQ_MP : int, EQ_IMP_RULE : int,
    INST : int, SPEC : int, GEN : int, EXISTS : int, CHOOSE : int,
    CONJ : int, CONJUNCT1 : int, CONJUNCT2 : int, DISJ1 : int,
    DISJ2 : int, DISJ_CASES : int, NOT_INTRO : int, NOT_ELIM : int,
    CCONTR : int, GEN_ABS : int, definition : int, axiom : int,
    from_disk : int, oracle :int, total :int }
\end{verbatim}\end{boxed}

\noindent This counter can be reset with the function:

\begin{boxed}
\index{reset_thm_count@\ml{reset\_thm\_count}|pin}
\begin{verbatim}
   val reset_thm_count : unit -> unit
\end{verbatim}\end{boxed}

Finally, the \texttt{Count} structure also includes another function
which easily enables the number of inferences performed by an \ML{}
procedure to be assessed:

\begin{boxed}
\index{Count.apply@\ml{Count.apply}|pin}
\begin{verbatim}
   val apply : ('a -> 'b) -> 'a -> 'b
\end{verbatim}
\end{boxed}

An invocation, \ml{Count.apply f x}, applies the function \ml{f} to
the argument \ml{x} and performs a count of inferences during this
time.  This function also records the total time taken in the
execution of the application.

For example, timing the action of \ml{numLib}'s \ml{ARITH\_CONV}:

\setcounter{sessioncount}{1}
\begin{session}
\begin{verbatim}
- Count.apply numLib.ARITH_CONV ``x > y ==> 2 * x > y``;
runtime: 0.010s,    gctime: 0.000s,     systime: 0.000s.
Axioms asserted: 0.
Definitions made: 0.
Oracle invocations: 0.
Theorems loaded from disk: 0.
HOL primitive inference steps: 165.
Total: 165.
> val it = |- x > y ==> 2 * x > y = T : thm
\end{verbatim}
\end{session}

\index{counting inferences, in HOL proofs@counting inferences, in \HOL\ proofs|)}
\index{inferences, in HOL logic@inferences, in \HOL\ logic!counting of|)}
\index{timing of HOL evaluations@timing of \HOL\ evaluations|)}


\section{Quotation preprocessing}

A person usually works with \HOL{} by interacting with the ML top level
loop in order to build formalizations and perform proofs. In this
setting, the user often needs to enter expressions of the HOL logic to
ML, and interpret the resulting responses. Since the ML representations
of the types, terms, and theorems of the HOL logic are quite unreadable
in their `raw' form, so-called {\it prettyprinters\/} for HOL logic
expressions are automatically invoked by the ML top level when printing
output.

Similarly, types and terms often have to be constructed by the user,
\eg, in order to make definitions, state goals to prove, provide
existential witnesses, \etc\ Since it would be unbearable to make a type
or term of any size `by hand', the system comes equipped with parsers
for type and term expressions. The parser for types is called
\verb+Type+, and the parser for terms is called \verb+Term+. These
parsers take {\it quotations\/}.  A quotation \mbox{{\tt `}$\ldots${\tt `}} is
much like an SML string, except that it can span several lines without
requiring awkward backslashes, as an ML string
would.\footnote{Quotations were a feature in the original LCF
system. See the MoscowML User's Manual for more information.}

For added convenience, the \HOL\ system distribution includes an
executable that features a {\it combined parser\/} that accepts both
types and terms. Enclosing some object language concrete syntax
between occurrences of \verb+``+ will result in the correct parser
being invoked. For example

\begin{verbatim}
    ``x /\ y /\ z ==> ?p. p``
\end{verbatim}

\noindent will parse as a term while

\begin{verbatim}
    ``:'a -> ('b -> 'h) -> bool``
\end{verbatim}

\noindent parses as an HOL type. Note that the concrete syntax given in
the quotation for a type needs to provide a hint: the type parser will
only be called if the first character after the leading {\tt ``} is a
colon (\verb+:+).

Knowledgable ML programmers will notice that the idiom {\tt
  ``}$\ldots$ {\tt ``} is not ML-typable; for that reason, it is
implemented as a pre-processor to ML, thanks to work by Richard
Boulton. Users who wish to use the pre-processor should invoke
\texttt{hol.unquote} in the distributions \texttt{bin} directory.
\holmake{} will accept source files having occurrences of \verb+``+.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "description"
%%% End:
