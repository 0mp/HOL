\chapter{Commonly-used Theories}\label{HOLtheories}

\index{theories, in HOL logic@theories, in \HOL{} logic!hierarchies of}
A useful subset of the collection of theories distributed with the
\HOL{} system is listed in Table~\ref{CommonTheories}.  In the rest of
this section, each of these theories is briefly described.  A complete
list of all the definitions and theorems in each theory is not given
here; the sections that follow provide only an overview of the
contents of each theory.  For a complete list of all the built-in
axioms, definitions and theorems in \HOL, see \REFERENCE.


\begin{table}
\begin{center}
\begin{tabular}{|l|l|}
\hline
min         & the origin theory \\
bool        & definitions of logical operators and basic axioms \\
combin      & combinators \\
pair        & theory of pairs \\
sum         & disjoint sums \\
relation    & transitive closure and wellfoundedness \\
one         & the singleton type \\
option      & the {\tt option} type \\
num         & Peano's axioms derived from the axiom of infinity \\
prim\_rec   & the primitive recursion theorem \\
arithmetic  & Peano arithmetic development \\
numeral     & numerals \\
integer     & integers \\
pred\_set   & sets as predicates (includes finite sets) \\
bag         & bags (also known as \emph{multisets})\\
list        & lists \\
rich\_list  & extended theory of lists \\
llist       & possibly infinite sequences (``lazy lists'')\\
path        & labelled paths/transition sequences\\
finite\_map & finite functions \\
ltree       & polymorphic finitely branching trees \\
res\_quan   & restricted quantifier support \\
ascii       & ascii \\
string      & strings \\
word        & (\emph{plus several others}) theory of bitstrings \\
real        & (\emph{plus several others}) real numbers and analysis \\
\hline
\end{tabular}
\caption{Commonly-used Theories}\label{CommonTheories}
\end{center}
\end{table}

\section{Combinators and the theory \theoryimp{combin}}

\index{function composition, in HOL logic@function composition, in \HOL\
logic|(}

The theory
\theoryimp{combin}
\index{combin@\theoryimp{combin}}
\index{combinators, in HOL logic@combinators, in \HOL{} logic}
contains the definitions of function composition (infixed \ml{o})
\index{ function composition operator, in HOL logic@\ml{o} (function composition operator), in \HOL{} logic|(}
and the combinators \ml{S},
\index{S, constant in HOL logic@\ml{S}, constant in \HOL{} logic}
\ml{K}
\index{K, constant in HOL logic@\ml{K}, constant in \HOL{} logic}
and
\ml{I}.
\index{I, constant in HOL logic@\ml{I}, constant in \HOL{} logic}


\begin{hol} \index{K_DEF@\ml{K\_DEF}} \index{S_DEF@\ml{S\_DEF}}
\index{I_DEF@\ml{I\_DEF}}
\begin{verbatim}
   o_DEF |- f o g = (\x. f(g x))

   K_DEF |- K = (\x y. x)

   S_DEF |- S = (\f g x. f x(g x))

   I_DEF |- I = S K K

   W_DEF |- W = (\f x. f x x)

   C_DEF |- C = (\f x y. f y x)
\end{verbatim}
\end{hol}


\noindent The following elementary properties are pre-proved in the theory
\ml{combin}:

\begin{hol} \index{K_THM@\ml{K\_THM}} \index{S_THM@\ml{S\_THM}}
\index{I_THM@\ml{I\_THM}} \index{I_o_ID@\ml{I\_o\_ID}} %
\begin{verbatim}
   o_THM |- !f g x. (f o g)x = f(g x)

   o_ASSOC |- !f g h. f o (g o h) = (f o g) o h

   K_THM |- !x y. K x y = x

   S_THM |- !f g x. S f g x = f x (g x)

   I_THM |- !x. I x = x

   I_o_ID |- !f. (I o f = f) /\ (f o I = f)

   K_o_THM |- (!f v. K v o f = K v) /\ (!f v. f o K v = K (f v))
\end{verbatim}
\end{hol}

Having the symbols \ml{o}, \ml{S}, \ml{K} and \ml{I} as built-in
constants
\index{variables, in HOL logic@variables, in \HOL{} logic!with constant names}
is sometimes inconvenient because they are often wanted
as mnemonic names for variables (\eg\ \ml{S} to range over sets and
\ml{o} to range over outputs).  Variables (though not constants) with
these names can be used in the current system if \ml{o}, \ml{S}, \ml{K}
and \ml{I} are first hidden (see Section~\ref{hidden}).
\index{function composition operator, in HOL logic@\ml{o} (function composition operator), in \HOL{} logic|)}
\index{function composition, in HOL logic@function composition, in \HOL{} logic|)}

\section{The theory \theoryimp{relation}}\label{relation}

Mathematical relations can be represented in \HOL{} by the type
{\small\verb+:'a -> 'b -> bool+}. The theory {\small\verb+relation+}
is intended to suppport this view of relations, but does not as yet
provide a well-rounded collection of definitions; indeed, it is common
to treat relations directly. For example, $R_1 \subseteq R_2$ can be
phrased as {\small\verb+!x y. R1 x y ==> R2 x y+}. The theory
\theoryimp{relation} currently provides definitions and theorems about
the reflexive, transitive and symmetric closures of a relation, for
wellfounded relations, and for some obvious extensions of these
properties.  For example, the constant {\small\verb+RTC+} takes the
reflexive and transitive closure of a relation, while the predicate
{\small\verb+WFP+} is true of a relation and an element if the
relation is well-founded at that element.

\begin{hol}
\begin{verbatim}
   RC_DEF |- !R x y. RC R x y = (x = y) \/ R x y
   SC_DEF |- !R x y. SC R x y = R x y \/ R y x
   TC_DEF |- !R a b.
               TC R a b =
                 !P.
                   (!x y. R x y ==> P x y) /\
                   (!x y z. P x y /\ P y z ==> P x z)
                   ==>
                     P a b

   WF_DEF |- !R. WF R = !B. (?w. B w) ==> ?min. B min /\ !b. R b min ==> ~B b
\end{verbatim}
\end{hol}

Wellfoundedness is used to justify the principle of wellfounded
induction and also a general recursion theorem. The statement of the
recursion theorem requires that the notion of a function restriction be
defined as well.

\begin{hol}
\begin{verbatim}
   WF_INDUCTION_THM
   |- !R:'a->'a->bool.
          WF R
            ==> !P. (!x. (!y. R y x ==> P y) ==> P x)
            ==> !x. P x

   RESTRICT_DEF |- !f R x. RESTRICT f R x = \y. if R y x then f y else ARB

   WFREC_COROLLARY
   |- !M R f. (f = WFREC R M) ==> WF R ==> !x. f x = M (RESTRICT f R x) x

   WF_RECURSION_THM |- !R. WF R ==> !M. ?!f. !x. f x = M (RESTRICT f R x) x
\end{verbatim}
\end{hol}

\noindent The theorems \ml{WF\_INDUCTION\_THM} and
\ml{WFREC\_COROLLARY} are used to automate recursive definitions. A
few basic combinators for wellfounded relations are also provided in
this theory.

\begin{hol}
\begin{verbatim}
   Empty_def      |- !x y. Empty x y = F

   inv_image_def  |- !R f. inv_image R f = \x y. R (f x) (f y)

   WF_Empty       |- WF Empty

   WF_SUBSET      |- !R P. WF R /\ (!x y. P x y ==> R x y) ==> WF P

   WF_TC          |- !R. WF R ==> WF (TC R)

   WF_inv_image   |- !R f. WF R ==> WF (inv_image R f)
\end{verbatim}
\end{hol}

\section{Pairs and the type {\tt prod}}\label{prod}

\index{representing types, in HOL logic@representing types, in \HOL{} logic!pair example of|(}
\index{pairs, in HOL logic@pairs, in \HOL{} logic|(}
\index{product types!in HOL logic@in \HOL{} logic|(}
The Cartesian  product  type  operator
\index{type operators, in HOL logic@type operators, in \HOL{} logic!for pairs}
\ml{prod}\index{prod@\ml{prod}} is  defined  in  the  theory \ml{pair}.
Values of type
{\small\verb%(%}$\sigma_1${\small\verb%,%}$\sigma_2${\small\verb%)prod%} are
ordered pairs  whose  first  component  has  type  $\sigma_1$  and whose second
component has type $\sigma_2$.  The \HOL{} parser\index{parsing, of HOL logic@parsing, of \HOL{} logic!of pairs}
converts type expressions of the
form \ml{`:}$\sigma_1${\small\verb%#%}$\sigma_2$\ml{`}\index{ product type operator, in HOL logic@{\small\verb+#+} (product
type operator, in \HOL{} logic)} into
\ml{(}$\sigma_1$\ml{,}$\sigma_2$\ml{)prod}\index{ pair constructor, in HOL
logic@\ml{,} (pair constructor, in \HOL{} logic)}, and   the   printer
inverts  this transformation. Pairs\index{pairing constructor, in HOL
logic@pairing constructor, in \HOL{} logic} are constructed with an infixed
comma symbol


\begin{hol}
\begin{verbatim}
   $, : 'a -> 'b -> 'a # 'b
\end{verbatim}
\end{hol}

\noindent so, for example, if $t_1$ and $t_2$ have types $\sigma_1$ and
$\sigma_2$
respectively, then $t_1$\ml{,}$t_2$ is a term with type
$\sigma_1${\small\verb%#%}$\sigma_2$. It is usual, but not necessary, to write
pairs within brackets:
\ml{(}$t_1$\ml{,}$t_2$\ml{)}. The comma symbol associates\index{pairing
constructor, in HOL logic@pairing constructor, in \HOL\
logic!associativity of} to the right, so  that
\ml{(}$t_1$\ml{,}$t_2$\ml{,}$\ldots$\ml{,}$t_n$\ml{)}
means
\ml{(}$t_1$\ml{,(}$t_2$\ml{,}$\ldots$\ml{,}$t_n$\ml{))}.

Cartesian products are defined by representing a pair
{\small\verb%(%}$t_1${\small\verb%,%}$t_2${\small\verb%)%} by the function

\begin{hol}
\begin{alltt}
   \bs{}a b. (a=\m{t\sb{1}}) /\verb!\! (b=\m{t\sb{2}})
\end{alltt}
\end{hol}

\noindent The
representing type of $\sigma_1${\small\verb%#%}$\sigma_2$ is thus
$\sigma_1${\small\verb%->%}$\sigma_2${\small\verb%->bool%}.  To define
pairs this way, the constants \ml{MK\_PAIR} and
\ml{IS\_PAIR}\index{IS_PAIR@\ml{IS\_PAIR}} are first defined.


\begin{hol}
\index{MK_PAIR_DEF@\ml{MK\_PAIR\_DEF}}
\index{IS_PAIR_DEF@\ml{IS\_PAIR\_DEF}}
\begin{verbatim}
   MK_PAIR_DEF   |- !x y. MK_PAIR x y = (\a b. (a = x) /\ (b = y))

   IS_PAIR_DEF   |- !p. IS_PAIR p = (?x y. p = MK_PAIR x y)
\end{verbatim}
\end{hol}

\noindent From these two definitions it is easy to prove that:

\begin{hol}
\begin{verbatim}
   |- ?p:'a->'b->bool. IS_PAIR p
\end{verbatim}
\end{hol}

\noindent since {\small\verb%|- IS_PAIR(MK_PAIR x y)%} follows  easily from the
definition of  \ml{IS\_PAIR}.    The  existence  theorem shown  above is called
{\small\verb%PAIR_EXISTS%}\index{PAIR_EXISTS@\ml{PAIR\_EXISTS}}.
 Given this theorem, the type operator
{\small\verb%prod%} is defined by evaluating:

\begin{hol}
\begin{verbatim}
   new_type_definition(`prod`, "IS_PAIR:(*->**->bool)->bool", PAIR_EXISTS)
\end{verbatim}
\end{hol}

\noindent which results in the definitional
axiom\index{axioms!non-primitive, of HOL logic@non-primitive, of \HOL\
  logic}\index{axioms!in bool theory@in \ml{bool} theory}
\ml{prod\_TY\_DEF} shown below being asserted in the theory \ml{bool}.

\begin{hol}
\begin{verbatim}
   prod_TY_DEF  |- ?rep. TYPE_DEFINITION IS_PAIR rep
\end{verbatim}
\end{hol}

Next, a new constant {\small\verb%REP_prod%} is defined, which
maps a pair to its representation as a function:

\begin{hol}
\index{REP_prod@\ml{REP\_prod}}
\begin{verbatim}
   REP_prod    |- REP_prod =
                  (@rep : 'a # 'b -> 'a -> 'b -> bool.
                    (!p' p''. (rep p' = rep p'') ==> (p' = p'')) /\
                    (!p. IS_PAIR p = (?p'. p = rep p')))
\end{verbatim}
\end{hol}

The infix constructor `{\small\verb%,%}'
and the selectors
{\small\verb+FST:'a#'b->'a+} and {\small\verb+SND:'a#'b->'b+} are then
defined by the equations shown below.


\begin{hol}\index{COMMA_DEF@\ml{COMMA\_DEF}}
\index{FST_DEF@\ml{FST\_DEF}}
\index{SND_DEF@\ml{SND\_DEF}}
\index{pairing constructor, in HOL logic@pairing constructor, in \HOL{} logic!definition of}
\index{FST, the constant in HOL logic@\ml{FST}, the constant in \HOL{} logic!definition of}
\index{selectors, in HOL logic@selectors, in \HOL{} logic}
\begin{verbatim}
   COMMA_DEF  |- !x y. x,y = (@p. REP_prod p = MK_PAIR x y)

   FST_DEF    |- !p. FST p = (@x. ?y. MK_PAIR x y = REP_prod p)

   SND_DEF    |- !p. SND p = (@y. ?x. MK_PAIR x y = REP_prod p)
\end{verbatim}
\end{hol}

The following standard theorems about pairs follow easily from these
definitions and the axiom \ml{prod\_TY\_DEF}.

\begin{hol}
\index{PAIR@\ml{PAIR}}
\index{FST, the axiom in HOL logic@\ml{FST}, the axiom in \HOL{} logic}
\index{SND, the axiom in HOL logic@\ml{SND}, the axiom in \HOL{} logic}
\index{PAIR_EQ@\ml{PAIR\_EQ}}
\begin{verbatim}
   PAIR     |- !x. (FST x,SND x) = x

   FST      |- !x y. FST(x,y) = x

   SND      |- !x y. SND(x,y) = y

   PAIR_EQ  |- (x,y = a,b)  =  (x = a) /\ (y = b)
\end{verbatim}
\end{hol}
\index{pairs, in HOL logic@pairs, in \HOL{} logic|)}
\index{product types!in HOL logic@in \HOL{} logic|)}
\index{representing types, in HOL logic@representing types, in \HOL{} logic!pair example of|)}
\index{bool, the HOL theory@\ml{bool}, the \HOL{} theory|)}


\subsection{Paired abstractions}
\label{HOL-varstruct}
\index{pairs, in HOL logic@pairs, in \HOL{} logic!in abstractions|(}
\index{UNCURRY@\ml{UNCURRY}|(}

\index{terms, in HOL logic@terms, in \HOL{} logic!pair|(}
\index{parsing, of HOL logic@parsing, of \HOL{} logic!of quotation syntax|(}
\index{function abstraction, in HOL logic@function abstraction, in \HOL{} logic!paired|(}
\index{function abstraction, in HOL logic@function abstraction, in \HOL{} logic!uncurrying, in paired|(}
The quotation parser
\index{parsing, of HOL logic@parsing, of \HOL{} logic!of function abstractions}
\index{function abstraction, in HOL logic@function abstraction, in \HOL{} logic!abbreviation for multiple}
\index{terms, in HOL logic@terms, in \HOL{} logic!function abstraction}
will convert\footnote{Only when the theory of pairs is loaded.}
{\small\bs\texttt{(}}$x_1${\small\verb%,%}$x_2${\small\verb%).%}$t$
to {\small\verb%UNCURRY(%\bs}$x_1\ x_2${\small\verb%.%}$t${\small\verb%)%},
where the constant {\small\verb%UNCURRY%}
is defined by:

\begin{hol}
\begin{verbatim}
   UNCURRY f (x,y)  =  f x y
\end{verbatim}
\end{hol}

\noindent The transformation is done recursively so that, for example,

\begin{hol}
\begin{alltt}
   \bs(\m{x\sb{1}},\m{x\sb{2}},\m{x\sb{3}}).\m{t}
\end{alltt}
\end{hol}

\noindent is converted to

\begin{hol}
\begin{alltt}
  UNCURRY \bs\m{x\sb{1}}.UNCURRY(\bs\m{x\sb{2}},\m{x\sb{3}}.\m{t}))
\end{alltt}
\end{hol}

\noindent More generally, the quotation parser repeatedly applies the
transformation:

\begin{hol}
\begin{alltt}
   \bs(\m{v\sb{1}},\m{v\sb{2}}).\m{t}\m{\quad \leadsto\quad}UNCURRY(\bs\m{v\sb{1}}.\verb%\%\m{v\sb{2}}.\m{t})
\end{alltt}
\end{hol}

\noindent until no more variable structures remain. For example:

\vspace{1ex}
\begin{tabular}{ll}
\texttt{\bs($x$,$y$).$t$} &
  $\leadsto$ \texttt{UNCURRY(\bs$x\,y$.$t$)}\\
%
\texttt{\bs($x_1$,$x_2$,$\ldots$,$x_n$).$t$} &
  $\leadsto$ \texttt{UNCURRY(\bs$x_1$.\bs($x_2$,$\ldots$,$x_n$).$t$)}\\
%
\texttt{\bs(($x_1$,$\ldots$,$x_n$),$y_1$,$\ldots$,$y_m$).$t$} &
  $\leadsto$
  \texttt{UNCURRY(\bs($x_1$,$\ldots$,$x_n$).\bs($y_1$,$\ldots$,$y_m$).$t$)}\\
\end{tabular}

\vspace{1ex}
Note that a variable structure like \ml{(x,y)} in
\ml{\bs(x,y).x+y}
is not a subterm of the abstraction
\index{function abstraction, in HOL logic@function abstraction, in \HOL{} logic!subterms of}
in which it occurs; it disappears on parsing.
\index{binders, in HOL logic@binders, in \HOL{} logic!parsing of}
\index{parsing, of HOL logic@parsing, of \HOL{} logic!of binders}
This can lead to unexpected errors (accompanied by obscure error
messages).  For example:

\begin{session}
\begin{verbatim}
- Term `\(x,y).x+y`;
> val it = `\(x,y). x + y` : term

- val p = Term `(x:num,y:num)`;
> val p = `(x,y)` : term

- Lib.try Term `\^p.x+y`;

Exception raised at Term.dest_var:
not a var
! Uncaught exception:
! HOL_ERR <poly>
\end{verbatim}
\end{session}

If $b$ is a binder, then \ml{$b$($x_1$,$x_2$).$t$} is parsed as
\ml{$b$(\bs($x_1$,$x_2$).$t$)}, and hence transformed as above.  For
example, \ml{!(x,y).x>y} parses to \ml{\$!(UNCURRY(\bs{}x.\bs{}y.\$> x
  y))} (where {\small{\tt >}} is an infixed constant of the theory
\theoryimp{arithmetic} meaning `is greater than').
\index{function abstraction, in HOL logic@function abstraction, in \HOL{} logic!paired|)}
\index{function abstraction, in HOL logic@function abstraction, in \HOL{} logic!uncurrying, in paired|)}
\index{pairs, in HOL logic@pairs, in \HOL{} logic!in abstractions|)}
\index{terms, in HOL logic@terms, in \HOL{} logic!pair|)}\index{UNCURRY@\ml{UNCURRY}|)}

Applications of paired abstraction to tuples can be $\beta$-reduced using
\ml{PAIRED\_BETA\_CONV} (see Section~\ref{genbeta}).


\subsection{{\tt let}-terms}
\label{let-exp}


The quotation parser\index{parsing, of HOL logic@parsing, of \HOL{} logic!of let-terms@of \ml{let}-terms}
 accepts \ml{let}-terms\index{terms, in HOL logic@terms, in \HOL{} logic!let-@\ml{let}-}\index{let-terms, in HOL logic@\ml{let}-terms, in \HOL{} logic!as abbreviations} superficially similar to those in
\ML. For example, the following terms are allowed:

\begin{hol}
\begin{verbatim}
   let x = 1 and y = 2 in x+y

   let f(x,y) = (x*x)+(y*y) and a = 20*20 and b = 50*49 in f(a,b)
\end{verbatim}
\end{hol}

\ml{let}-terms are actually abbreviations for ordinary  terms which are
specially supported by the parser and pretty printer.
The constant \ml{LET}\index{LET@\ml{LET}} is defined (in the theory \ml{bool}) by:

\begin{hol}\index{function abstraction, in HOL logic@function abstraction, in \HOL{} logic!relation to let-terms@relation to \ml{let}-terms}
\begin{verbatim}
   LET = (\f x. f x)
\end{verbatim}
\end{hol}

\noindent and is used to encode \ml{let}-terms in the logic. The parser
repeatedly applies the transformations:

\bigskip

{\small\begin{tabular}{ll}
\texttt{let~$f\,v_1\,\ldots\,v_n$~=~$t_1$~in~$t_2$} &
$\leadsto$~~\texttt{LET(\bs$f$.$t_2$)(\bs$v_1\,\ldots\,v_n$.$t_1$)}\\
%
\texttt{let~($v_1$,$\ldots$,$v_n$)~=~$t_1$~in~$t_2$} &
$\leadsto$~~\texttt{LET(\bs($v_1$,$\ldots$,$v_n$).$t_2$)$t_1$}\\
%
\texttt{let~$v_1$=$t_1$~and~$\ldots$~and~$v_n$=$t_n$~in~$t$} &
$\leadsto$~~\texttt{LET($\ldots$(LET(LET(\bs$v_1\ldots v_n$.$t$)$t_1$)$t_2$)$\ldots$)$t_n$}\\
\end{tabular}}

\bigskip


\noindent The underlying structure of the term can be seen by applying
destrucor operations.  For example:

\setcounter{sessioncount}{1}
\begin{session}
\begin{verbatim}
- Term `let x = 1 and y = 2 in x+y`;
> val it = `let x = 1 and y = 2 in x + y` : term

- dest_comb it;
> val it = (`LET (LET (\x y. x + y) 1)`, `2`) : term * term

- Term `let (x,y) = (1,2) in x+y`;
> val it = `let (x,y) = (1,2) in x + y` : Term.term

- dest_comb it;
> val it = (`LET (\(x,y). x + y)`, `(1,2)`) : Term.term * Term.term
\end{verbatim}
\end{session}

The reader is recommended to convince himself or herself that the
translations of \ml{let}-terms represent the intuitive meaning suggested by
the surface syntax.
\index{quotation, in HOL logic@quotation, in \HOL{} logic|)}
\index{quotation, in HOL logic@quotation, in \HOL{} logic!of non-primitive terms|)}
\index{terms, in HOL logic@terms, in \HOL{} logic!syntax of|)}
\index{type checking, in HOL logic@type checking, in \HOL{} logic!special forms in|)}

\ml{let}-terms can be simplified with \ml{let\_CONV}; see
Section~\ref{let-terms}.

\section{Disjoint sums}\label{sum}

The theory \ml{sum}\index{sum@\ml{sum}} defines the binary  disjoint
union\index{disjoint union theory, in HOL
logic@disjoint union theory, in \HOL{} logic|(}  type operator \ml{sum}.
A type  {\small\verb%(%}$\sigma_1${\small\verb%,%}$\sigma_2${\small\verb%)sum%}
denotes the  disjoint  union  of  types  $\sigma_1$  and $\sigma_2$.   The type
operator {\small\verb%sum%} can be defined just as {\small\verb%prod%} was, but
the details are omitted here.\footnote{The definition of disjoint  unions in
the HOL system is due to Tom Melham. The technical details of this definition can
be found in~\cite{Melham-banff}.}  The \HOL{} parser\index{parsing, of HOL logic@parsing, of \HOL{} logic!of sum types}
converts
\ml{":}$\sigma_1${\small\verb%+%}$\sigma_2$\ml{"}\index{ disjoint union
type operator, in HOL logic@\ml{+} (disjoint union
type operator, in HOL logic)} into
\ml{(}$\sigma_1$\ml{,}$\sigma_2$\ml{)sum}, and the printer inverts this.

The standard operations on sums are:


\begin{hol}
\index{disjoint union theory, in HOL logic@disjoint union theory, in \HOL{} logic|)}
\index{INL, the constant in HOL logic@\ml{INL}, the constant in \HOL{} logic}
\index{INR, the constant in HOL logic@\ml{INR}, the constant in \HOL{} logic}
\index{ISL, the constant in HOL logic@\ml{ISL}, the constant in \HOL{} logic}
\index{ISR, the constant in HOL logic@\ml{ISR}, the constant in \HOL{} logic}
\index{OUTL, the constant in HOL logic@\ml{OUTL}, the constant in \HOL{} logic}
\index{OUTR, the constant in HOL logic@\ml{OUTR}, the constant in \HOL{} logic}
\begin{verbatim}
   INL  : 'a      -> 'a + 'b
   INR  : 'b     -> 'a + 'b
   ISL  : 'a + 'b -> bool
   ISR  : 'a + 'b -> bool
   OUTL : 'a + 'b -> 'a
   OUTR : 'a + 'b -> 'b
\end{verbatim}\end{hol}

\noindent These are all defined as constants in the theory \ml{sum}.  The
constants \ml{INL} and \ml{INR} inject into the left and right summands,
respectively. The constants \ml{ISL} and \ml{ISR} test for membership of the
left and right summands, respectively. The constants \ml{OUTL} and \ml{OUTR}
project from a sum to the left and right summands, respectively.

The following two theorems, which are minor variants of each other, are
pre-proved in the built-in theory \ml{sum}. Each one, on its own, provides a
complete and abstract characterization of the disjoint sum type.

\begin{hol}
\index{sum_Axiom@\ml{sum\_Axiom}}
\index{sum_axiom@\ml{sum\_axiom}}
\begin{verbatim}
   sum_axiom   |- !f g. ?! h. (h o INL = f) /\ (h o INR = g)

   sum_Axiom = |- !f g. ?! h. (!x. h(INL x) = f x) /\ (!x. h(INR x) = g x)
\end{verbatim}
\end{hol}

\noindent Also provided as built-in, are the following theorems having to
do with the discriminator functions \ml{ISL} and \ml{ISR}:

\begin{hol}
\index{ISL, the theorem in HOL logic@\ml{ISL}, the theorem in \HOL{} logic}
\index{ISR, the theorem in HOL logic@\ml{ISR}, the theorem in \HOL{} logic}
\index{ISL_OR_ISR@\ml{ISL\_OR\_ISR}}
\begin{verbatim}
   ISL         |- (!x. ISL(INL x)) /\ (!y. ~ISL(INR y))

   ISR         |- (!x. ISR(INR x)) /\ (!y. ~ISR(INL y))

   ISL_OR_ISR  |- !x. ISL x \/ ISR x
\end{verbatim}
\end{hol}

\noindent The \ml{sum} theory also provides the following built-in theorems:

\begin{hol}
\index{OUTL, the theorem in HOL logic@\ml{OUTL}, the theorem in \HOL{} logic}
\index{OUTR, the theorem in HOL logic@\ml{OUTR}, the theorem in \HOL{} logic}
\index{INL, the theorem in HOL logic@\ml{INL}, the theorem in \HOL{} logic}
\index{INR, the theorem in HOL logic@\ml{INR}, the theorem in \HOL{} logic}
\begin{verbatim}
   OUTL        |- !x. OUTL(INL x) = x

   OUTR        |- !x. OUTR(INR x) = x

   INL         |- !x. ISL x ==> (INL(OUTL x) = x)

   INR         |- !x. ISR x ==> (INR(OUTR x) = x)
\end{verbatim}
\end{hol}

\noindent which describe the projection functions \ml{OUTL} and \ml{OUTR}.

\section{The theory \theoryimp{one}}%
\index{one, the HOL theory@\ml{one}, the \HOL{} theory}%
\index{one, the HOL type@\ml{one}, the \HOL{} type}%

The theory \ml{one} defines  the type  \ml{one} which  contains one element.
The constant  \ml{one}  is specified  to denote  this element.   The pre-proved
theorems in the theory \ml{one} are:

\begin{hol}
\index{one_axiom@\ml{one\_axiom}}
\index{one, the HOL theorem@\ml{one}, the \HOL{} theorem}
\index{one_Axiom@\ml{one\_Axiom}}
\begin{verbatim}
   one_axiom   |- !(f:'a->one) (g:'a -> one). f = g
   one         |- !(v:one). v = one
   one_Axiom   |- !(e:'a). ?!(fn:one->'a). fn one = e
\end{verbatim}
\end{hol}

\noindent These three theorems are equivalent characterizations of the type
with only one value. The theory \ml{one} is typically used in
constructing more elaborate types.  The one value of the type
\ml{one}, can also be written as \ml{()} by analogy with the unit
value in \ML.  This is also the default way in which this value is
printed by the system pretty-printer.

\section{The theory \theoryimp{option}}
\index{option, the HOL theory@\ml{option}, the \HOL{} theory}

The theory \theoryimp{option} defines a type operator \texttt{option}
that ``lifts'' its argument type, creating a type with all of the
values of the argument and one other, specially distinguished value.
The constructors of this type are
\begin{verbatim}
   NONE : 'a option
   SOME : 'a -> 'a option
\end{verbatim}
Options can be used to model partial functions.  If a function of type
$\alpha\rightarrow\beta$ does not have useful $\beta$ values for all
$\alpha$ inputs, then this distinction can be marked by making the
range of the function $\beta\texttt{ option}$, and mapping the
undefined $\alpha$ values to \texttt{NONE}.

An inductive type, options have a recursion theorem supporting the
definition of primitive recursive functions over option values.  Its
name is \texttt{option\_Axiom}:
\begin{verbatim}
  !e : 'b. !f : 'a -> 'b
     ?h. 'a option -> 'b.
        (!x. h (SOME x) = f x) /\
        (h NONE = e)
\end{verbatim}

The \theoryimp{option} theory also defines a case constant that allows
one to inspect option values in a ``pattern-matching'' style.
\begin{verbatim}
   case e of
      NONE -> v
   || SOME a -> f a
\end{verbatim}
The constant underlying this syntactic sugar is \texttt{option\_case},
with definition
\begin{verbatim}
   option_case_def |- (option_case u f NONE = u) /\
                      (option_case u f (SOME x) = f x)
\end{verbatim}
One other useful function in the \theoryimp{option} theory is
\texttt{OPTION\_MAP}:
\begin{verbatim}
   OPTION_MAP_DEF  |- (OPTION_MAP f NONE = NONE) /\
                      (OPTION_MAP f (SOME x) = SOME (f x))
\end{verbatim}

Finally, the \texttt{THE} function takes a \texttt{SOME} value to that
constructor's argument, and is unspecified on \texttt{NONE}:
\begin{verbatim}
   THE_DEF         |- THE (SOME x) = x
\end{verbatim}


\section{Natural numbers}

The natural numbers are developed in a series of theories. First, the
type of numbers is defined from the Axiom of Infinity, and Peano's
axioms are derived. Then the primitive recursion theorem is
proved. Based on that, a large theory treating the standard arithmetic
operations is developed. Lastly, a theory of numerals is provided.

\subsection{The theory \theoryimp{num}}

The theory \theoryimp{num}
\index{num, the theory in HOL logic@\ml{num}, the theory in \HOL{} logic}
defines the type \ml{num} of natural numbers to be
isomorphic to a countable subset of the primitive type \ml{ind}.  In this
theory, the constants \ml{0}
\index{ zero, in HOL logic@\ml{0} (zero, in \HOL{} logic)}
and \ml{SUC} (the successor function) are defined
and Peano's axioms
\index{axioms!in num theory@in \ml{num} theory}
\index{Peano's axioms}
\index{axioms!non-primitive, of HOL logic@non-primitive, of \HOL{} logic}
pre-proved in the form:

\begin{hol}
\index{NOT_SUC@\ml{NOT\_SUC}}
\index{INV_SUC@\ml{INV\_SUC}}
\index{INDUCTION@\ml{INDUCTION}}
\begin{verbatim}
   NOT_SUC    |- !n. ~(SUC n = 0)
   INV_SUC    |- !m n. (SUC m = SUC n) ==> (m = n)
   INDUCTION  |- !P. P 0 /\ (!n. P n ==> P(SUC n)) ==> (!n. P n)
\end{verbatim}
\end{hol}

In higher order logic, Peano's axioms are sufficient for developing number
theory because addition and multiplication can be defined. In first order
logic these must be taken as primitive.  Note also that
{\small\verb%INDUCTION%}\index{induction rule!for numbers, in HOL logic@for numbers, in \HOL{} logic} could not be stated as a single axiom in
first order logic because predicates (\eg\ {\small\verb%P%}) cannot be
quantified.

Uses of the theorem \ml{INDUCTION} are supported by the tactics
\ml{numLib.INDUCT\_TAC}\index{INDUCT_TAC@\ml{INDUCT\_TAC}} (see the
documentation in \REFERENCE\ for details), and
\ml{Induct}\index{Induct@\ml{Induct}} (see
Section~\ref{sec:high-level-proof-steps}).

\subsection{The theory \theoryimp{prim\_rec}}\label{prim_rec}

\index{primitive recursive definitions, in HOL logic@primitive recursive definitions, in \HOL{} logic!automated|(}
\index{primitive recursion theorem!for numbers|(}
\index{prim_rec@\ml{prim\_rec}|(}
In classical logic, unlike domain theory logics such as \PPL\index{PPlambda (same as PPLAMBDA), of LCF system@\ml{PP}$\lambda$ (same as \ml{PPLAMBDA}), of \ml{LCF} system},
arbitrary recursive definitions\index{recursive definitions, in classical logics} are not allowed. For example, there is no
function $f$ (of type \ml{num->num}) such that

\begin{hol}
{\small\verb%   !%}$x${\small\verb%. %}$f$ $x${\small\verb%  =  (%}$f$ $x${\small\verb%) + 1%}
\end{hol}

\noindent Certain restricted forms of recursive\index{primitive recursive
functions} definition do, however, uniquely
define functions. An important example are the {\it primitive recursive\/}
functions.\footnote{In higher order logic, primitive recursion
is much more powerful than in first order logic;
for example, Ackermann's function can be defined
by primitive recursion in higher order logic.} For
any $x$ and $f$ the {\it primitive
recursion theorem\/} tells us that there is a unique function
{\small\verb%fn%} such that:

\begin{hol}
{\small\verb%   (%}\ml{fn}{\small\verb% 0 = %}$x${\small\verb%) /\ (!%}$n${\small\verb%.%}\ml{fn}{\small\verb%(%}\ml{SUC} $n${\small\verb%) = %}$f${\small\verb% (%}\ml{fn} $n${\small\verb%)%} $n${\small\verb%)%}
\end{hol}

The primitive recursion theorem follows from Peano's\index{Peano's axioms}
 axioms. When the \HOL{} system is built, the following theorem is proved
 and stored in the theory {\small\verb%prim_rec%}:


\begin{hol}\index{num_Axiom@\ml{num\_Axiom}}
\index{characterizing theorem!for numbers}
\begin{verbatim}
   num_Axiom   |- !x f. ?fn. (fn 0 = x) /\ (!n. fn(SUC n) = f n (fn n))
\end{verbatim}
\end{hol}

\noindent The theorem states the validity of primitive recursive
definitions on the natural numbers: for any \ml{x} and \ml{f} there exists a
corresponding total function \ml{fn} which satisfies
the primitive recursive definition whose form is determined by \ml{x} and
\ml{f}.

\subsubsection{Primitive recursive definitions}\label{num-prim-rec}

\index{type definitions, in HOL logic@type definitions, in \HOL{} logic!primitive recursive|(}
\index{recursive definitions, in HOL logic@recursive definitions, in \HOL{} logic!automated, for numbers|(}
\index{primitive recursion theorem!automated use of, in HOL system@automated use of, in \HOL{} system|(}
The primitive
\index{primitive recursive definitions, in HOL logic@primitive recursive definitions, in \HOL{} logic!justification of}
recursion theorem can be used to justify any definition of a function
on the natural numbers by primitive recursion.  For example, a
primitive recursive definition in higher order logic of the form

\begin{hol}
\begin{alltt}
   fun 0       x\(\sb{1}\) \m{\dots} x\(\sb{i}\) = \m{f\sb{1}[}x\(\sb{1}\)\m{,\ldots,\,} x\(\sb{i}]\)
   fun (SUC n) x\(\sb{1}\) \m{\dots} x\(\sb{i}\) = \m{f\sb{2}[}fun n \m{t\sb{1} \dots t\sb{i},} n\m{,} x\(\sb{1}\)\m{,\ldots,\,}x\(\sb{i}]\)
\end{alltt}
\end{hol}

\noindent where all the free variables in the  terms $t_1$,
\dots, $t_i$ are contained in $\{$\ml{n}, $\ml{x}_1$, \dots, $\ml{x}_i\}$,
is logically equivalent to:

\begin{hol}
\begin{alltt}
   fun 0       = \verb!\!x\(\sb{1}\) \m{\dots} x\(\sb{i}\).\m{f\sb{1}[}x\(\sb{1}\)\m{,\ldots,\,}x\(\sb{i}]\)
   fun (SUC n) = \verb!\!x\(\sb{1}\) \m{\dots} x\(\sb{i}\).\m{f\sb{2}[}fun n \m{t\sb{1} \dots t\sb{i},} n\m{,}x\(\sb{1}\)\m{,\ldots,\,}x\(\sb{i}]\)
               = (\verb!\!f n x\(\sb{1}\) \m{\dots} x\(\sb{i}\).\m{f\sb{2}[}f \m{t\sb{1} \dots t\sb{i},} n\m{,} x\(\sb{1}\)\m{,\ldots,\,}x\(\sb{i}]\)) (fun n) n
\end{alltt}
\end{hol}

The existence  of  a  recursive  function  \ml{fun} which  satisfies these two
equations follows directly from the primitive recursion theorem
\ml{num\_Axiom} shown above.   Specializing the  quantified variables \verb!x!
and \verb!f!  in  a suitably  type-instantiated version  of \ml{num\_Axiom} so
that

\begin{hol}
\begin{alltt}
   x\m{=}\verb!\!x\(\sb{1}\) \(\dots\) x\(\sb{i}\).\m{f\sb{1}[}x\(\sb{1}\)\(,\ldots,\,\)x\(\sb{i}]\)  {\rm and}  f\(=\)\verb!\!f n x\(\sb{1}\) \(\dots\) x\(\sb{i}\).\m{f\sb{2}[}f \m{t\sb{1} \dots t\sb{i},} n\(,\) x\(\sb{1}\)\(,\ldots,\,\)x\(\sb{i}]\))
\end{alltt}
\end{hol}

\noindent yields the existence theorem shown below:

\begin{hol}
\begin{alltt}
   |- ?fn. fn 0       = \verb!\!x\(\sb{1}\) \(\dots\) x\(\sb{i}\).\m{f\sb{1}[}x\(\sb{1}\)\(,\ldots,\,\)x\(\sb{i}]\) /\verb!\!
           fn (SUC n) = (\verb!\!f n x\(\sb{1}\) \(\dots\) x\(\sb{i}\).\m{f\sb{2}[}f \m{t\sb{1} \dots t\sb{i},} n\(,\) x\(\sb{1}\)\(,\ldots,\,\)x\(\sb{i}]\)) (fn n) n
\end{alltt}
\end{hol}

\noindent This theorem allows a constant \ml{fun} to be introduced (via the
definitional mechanism of constant specifications---see Section~\ref{conspec})
to denote the recursive function that satisfies the two equations in the body
of the theorem. Introducing a constant \ml{fun} to name the function asserted
to exist by the theorem shown above, and simplifying using $\beta$-reduction,
yields the following theorem:

\begin{hol}
\begin{alltt}
   |- fun 0       = \verb!\!x\(\sb{1}\) \(\dots\) x\(\sb{i}\).\m{f\sb{1}[}x\(\sb{1}\)\(,\ldots,\,\)x\(\sb{i}]\) /\verb!\!
      fun (SUC n) = \verb!\!x\(\sb{1}\) \(\dots\) x\(\sb{i}\).\m{f\sb{2}[}fun n \m{t\sb{1} \dots t\sb{i},} n\(,\) x\(\sb{1}\)\(,\ldots,\,\)x\(\sb{i}]\)
\end{alltt}
\end{hol}

\noindent It follows immediately from this theorem that the constant \ml{fun}
satisfies the primitive recursive defining equations given by the theorem shown
below:

\begin{hol}
\begin{alltt}
   |- fun 0 x\(\sb{1}\) \(\dots\) x\(\sb{i}\) = \m{f\sb{1}[}x\(\sb{1}\)\(,\ldots,\,\)x\(\sb{i}]\)
      fun (SUC n) x\(\sb{1}\) \(\dots\) x\(\sb{i}\) = \m{f\sb{2}[}fun n \m{t\sb{1} \dots t\sb{i},} n\(,\) x\(\sb{1}\)\(,\ldots,\,\)x\(\sb{i}]\)
\end{alltt}
\end{hol}

To automate the use of the primitive recursion theorem in deriving
recursive definitions of this kind, the \HOL{} system provides a function
which automatically proves the existence of primitive recursive
functions and then makes a constant specification to introduce the constant
that denotes such a function:

\begin{boxed}
\index{new_recursive_definition@\ml{new\_recursive\_definition}|pin}
\begin{verbatim}
   new_recursive_definition : thm -> string -> term -> thm
\end{verbatim}
\end{boxed}

\noindent In fact, {\small\verb+new_recursive_definition+} handles
primitive recursive definitions over a range of types, not just the
natural numbers. For details, see the \REFERENCE\ documentation.  More
conveniently still, the \texttt{Define} function (see
Section~\ref{sec:high-level-proof-steps}) supports primitive
recursion, among other styles of definition, and does not require the
user to quote the primitive recursion axiom.

\subsubsection{The less-than relation}

The less-than relation `{\small{\tt\verb+<+}}'\index{less than, in HOL
  logic@\ml{<} (less than, in \HOL{} logic)} is most naturally defined by
  primitive recursion. However, it is needed for the proof of the
  primitive recursion theorem, so it must be defined before definition
  by primitive recursion is available. The theory \theoryimp{prim\_rec}
  therefore contains the following non-recursive definition\index{less
  than, in HOL logic@less than, in \HOL{} logic} of \ml{<}:

\begin{hol}
\index{LESS@\ml{LESS}}
\begin{verbatim}
   LESS  |- !m n. m < n = (?P. (!n. P(SUC n) ==> P n) /\ P m /\ ~P n)
\end{verbatim}
\end{hol}

\noindent
This definition says that {\small\verb%m < n%} if there exists a set (with
characteristic function {\small\verb%P%}) that is downward
closed\footnote{A set of numbers is \textit{downward closed} if whenever it
contains the successor of a number, it also contains the number.} and
contains {\small\verb%m%} but not {\small\verb%n%}.

\subsubsection{Consequences of primitive recursion}

Once the primitive recursion theorem is available, other useful
theorems can be proved. The theory \theoryimp{prim\_rec} supplies the
Axiom of Dependent Choice, which is a theorem in \HOL{} because it
follows from {\small\verb+SELECT_AX+}:

\begin{hol}
\index{Axiom of Dependent Choice@\ml{DC}}
\begin{verbatim}
   DC  |- !P R a.
            P a /\ (!x. P x ==> ?y. P y /\ R x y)
             ==>
           ?f. (f 0 = a) /\ !n. P (f n) /\ R (f n) (f (SUC n))
\end{verbatim}
\end{hol}

The theorem {\small\verb+DC+} is useful when one wishes to build a
function having a certain property from a relational
characterization. For example, an alternate characterization of
wellfoundedness is the absence of infinite decreasing $R$ chains. By use
of {\small\verb+DC+}, this can be proved to be equal to the the notion
of wellfoundedness (namely, that every set has an $R$-minimal element)
defined in the theory {\small\verb+relation+}.

\begin{hol}
\index{wellfounded@\ml{wellfounded}}
\begin{verbatim}
   wellfounded_def    |- wellfounded (R:'a->'a->bool)
                            =
                         ~?f. !n. R (f (SUC n)) (f n)

   WF_IFF_WELLFOUNDED |- !R. WF R = wellfounded R
\end{verbatim}
\end{hol}

The theory \ml{prim\_rec} also provides theorems asserting the
wellfoundedness of the predecessor relation and the less-than relation,
as well as the wellfoundedness of measure functions.

\begin{hol}
\index{WF_PRED@\ml{WF\_PRED}}
\index{WF_LESS@\ml{WF\_LESS}}
\index{measure_def@\ml{measure\_def}}
\index{WF_measure@\ml{WF\_measure}}
\begin{verbatim}
   WF_PRED     |- WF (\x y. y = SUC x)

   WF_LESS     |- WF $<

   measure_def |- measure = inv_image $<

   WF_measure  |- !m. WF (measure m)
\end{verbatim}
\end{hol}


\subsection{The theory \theoryimp{arithmetic}}

The built-in theory {\small\verb%arithmetic%}\index{number theory, in HOL logic@number theory, in \HOL{} logic}
\index{arithmetic@\ml{arithmetic}} contains primitive recursive
definitions of following standard arithmetic operators.

\begin{hol}
\index{ADD@\ml{ADD}}
\index{SUB@\ml{SUB}}
\index{MULT@\ml{MULT}}
\index{EXP@\ml{EXP}}
\index{ subtraction, in HOL logic@\ml{-} (subtraction, in \HOL{} logic)}
\index{ multiplication, in HOL logic@\ml{*} (multiplication, in \HOL{} logic)}
\begin{verbatim}
   ADD            |- (!n. 0 + n = n) /\
                     (!m n. (SUC m) + n = SUC(m + n))

   SUB            |- (!m. 0 - m = 0) /\
                     (!m n. (SUC m) - n = (m < n => 0 | SUC(m - n)))

   MULT           |- (!n. 0 * n = 0) /\
                     (!m n. (SUC m) * n = (m * n) + n)

   EXP            |- (!m. m EXP 0 = 1) /\
                     (!m n. m EXP (SUC n) = m * (m EXP n))
\end{verbatim}
\end{hol}

\noindent It also contains the following non-recursive definitions.

\begin{hol}
\index{arithmetic, in HOL logic@arithmetic, in \HOL{} logic}
\index{ greater than, in HOL logic@\ml{>} (greater than, in \HOL{} logic)}
\index{ less or equal, in HOL logic@\ml{<=} (less or equal, in \HOL{} logic)}
\index{ greater or equal, in HOL logic@\ml{>=} (greater or equal, in \HOL{} logic)}
\index{MOD@\ml{MOD}}
\index{DIV@\ml{DIV}}
\begin{verbatim}
   GREATER        |- !m n. m > n = n < m

   LESS_OR_EQ     |- !m n. m <= n = m < n \/ (m = n)

   GREATER_OR_EQ  |- !m n. m >= n = m > n \/ (m = n)

   DIVISION       |- !n. 0 < n ==> (!k. (k = ((k DIV n) * n) + (k MOD n)) /\
                                        (k MOD n) < n)
\end{verbatim}
\end{hol}


An \adhoc\ but useful collection of over a hundred elementary theorems of
arithmetic are pre-proved when \HOL{} is built and stored in the theory
{\small\verb%arithmetic%}.  For a complete list of available
theorems, see \REFERENCE.

The following table gives the parsing status of the arithmetic
constants.

\begin{center}
{\small
\begin{tabular}{@{}ccc}
Operator & Strength & Associativity \\ \hline
{\small\verb+>=+} & 450 & right \\
{\small\verb+<=+} & 450 & right \\
{\small\verb+>+} & 450 & right \\
{\small\verb+<+} & 450 & right \\
{\small\verb%+%} & 500 & left \\
{\small\verb%-%} & 500 & left \\
{\small\verb%*%} & 600& left \\
{\small\verb%DIV%} & 600 & left \\
{\small\verb%MOD%} & 650 & left \\
{\small\verb%EXP%} & 700 & right \\
\end{tabular}}
\end{center}

\subsection{The theory \theoryimp{numeral}}\label{numeral}\index{numeral,
the construction of in HOL logic@\ml{numeral}, the construction of in \HOL{} logic}

The type \ml{num}\index{num, the type in \HOL\
  logic@\ml{num}, the type in \HOL{} logic}, is usually thought of as
  being supplied with an infinite collection of numerals: \ml{1},
  \ml{2}, \ml{3}, \etc.  However, the \HOL{} logic has no way to define
  such infinite families of constants; instead all numerals other
  than $0$ are actually built up from the constants introduced by
  the following definitions:
\begin{verbatim}
   NUMERAL_DEF    |- !x. NUMERAL x = x

   BIT1           |- !x. BIT1 n = n + (n + SUC 0)

   BIT2           |- !x. BIT2 n = n + (n + SUC(SUC 0))

   ALT_ZERO       |- ALT_ZERO = 0
\end{verbatim}

\noindent For example, the numeral $5$ is represented by the term
\[
   \ml{NUMERAL}(\ml{BIT1}(\ml{BIT2}(\ml{ALT\_ZERO})))
\]
but the \HOL{} parser and pretty-printer make such terms appear as
numerals. This binary representation for numerals allows for
asymptotically efficient calculation. Theorems supporting arithmetic
calculations on numerals can be found in the \theoryimp{numeral}
theory; these are mechanized by the \texttt{reduce} library. Numerals
may of course be built using \ml{mk\_comb}, and taken apart with
\ml{dest\_comb}. A more convenient interface to this functionality is
provided by \ml{mk\_numeral}, \ml{dest\_numeral}, and
\ml{is\_numeral}. These functions (all themselves in the structure
\ml{numSyntax}) make use of an \ML{} structure \ml{Arbnum} which
implements arbitrary precision numbers.

\setcounter{sessioncount}{0}
\begin{session}
\begin{verbatim}
- numSyntax.mk_numeral (Arbnum.fromString "3432432423423423234");
> val it = ``3432432423423423234`` : term

- numSyntax.dest_numeral it;
> val it = 3432432423423423234 : num

- Arbnum.+(it,it);
> val it = 6864864846846846468 : num

- numSyntax.mk_numeral it;
> val it = ``6864864846846846468`` : term
\end{verbatim}
\end{session}

Numerals are related to numbers via the derived inference rule
\ml{num\_CONV}, found in the \ml{numLib} library.

\begin{boxed}
\index{num_CONV@\ml{num\_CONV}|pin}
\begin{verbatim}
   numLib.num_CONV : term -> thm
\end{verbatim}
\end{boxed}

\noindent \ml{num\_CONV} can be used to generate the ``\ml{SUC}''
equation for any non-zero numeral.  For example:

\setcounter{sessioncount}{0}
\begin{session}
\begin{verbatim}
- load "numLib"; open numLib;

- num_CONV ``1``;
> val it = |- 1 = SUC 0 : thm

- num_CONV ``2``;
> val it = |- 2 = SUC 1 : thm

- num_CONV ``3141592653``;
> val it = |- 3141592653 = SUC 3141592652 : thm
\end{verbatim}
\end{session}

\noindent The \ml{num\_CONV} function works purely by inference, using
the definitions provided above.\footnote{In previous versions of \HOL,
\ml{num\_CONV} would not prove its result, which was not in keeping with
the \LCF\ approach, and which moreover made \ml{num\_CONV} dependent on
the underlying implementation of numbers. This made \ml{num\_CONV}
incomplete on \ML\ systems without arbitrary-sized numbers.}

When other numeric theories are loaded (such as those for the reals or
integers), numerals are overloaded so that the numeral {\small\verb+1+} can
actually stand for a natural number, an integer or a real value.  In
order to precisely specify the desired type, the user can use single
character suffixes (`\ml{n}' for the natural numbers, and `\ml{i}' for
the integers):

\begin{session}
\begin{verbatim}
- load "integerTheory";
> val it = () : unit

- Term`2`;
<<HOL message: more than one resolution of overloading was possible.>>
> val it = `2` : term

- type_of it;
> val it = `:int` : hol_type

- Term`2n`;
> val it = `2` : term

- type_of it;
> val it = `:num` : hol_type

- type_of (Term `42i`);
> val it = `:int` : hol_type
\end{verbatim}
\end{session}

A numeric literal such as $42i$ is represented by the application of an
\emph{injection} function of type {\small\verb+num -> ty+} to a
numeral. The injection function is different for each type
{\small\verb+ty+}. See Section \ref{integers} for further discussion.

The functions {\small\verb+mk_numeral+},
{\small\verb+dest_numeral+}, and {\small\verb+is_numeral+} only work for
numerals, and not for numeric literals with character suffixes other
than {\small\verb+n+}. For information on how to install new character
suffixes, consult the {\small\verb+add_numeral_info+} entry in
\REFERENCE.

\section{Integers}\label{integers}

There is an extensive theory of integers in \HOL. The type of integers
is constructed as a quotient on pairs of natural numbers. A standard
collection of operators are defined. These are overloaded with
similar operations on the natural numbers, and on the real numbers.
The constants defined in the integer theory include those found in the
following table.

\begin{center}
{\small
\begin{tabular}{@{}cccc}
Constant & Overloaded symbol & Strength & Associativity \\ \hline
{\small\verb+int_ge+} &{\small\verb+>=+} & 450 & right \\
{\small\verb+int_le+} &{\small\verb+<=+} & 450 & right \\
{\small\verb+int_gt+} &{\small\verb+>+}  & 450 & right \\
{\small\verb+int_lt+} &{\small\verb+<+}  & 450 & right \\
{\small\verb+int_add+} &{\small\verb%+%} & 500 & left \\
{\small\verb+int_sub+} &{\small\verb%-%} & 500 & left \\
{\small\verb+int_neg+} &{\small\verb%~%} & 900 & trueprefix \\
{\small\verb+int_mul+} &{\small\verb%*%} & 600 & left \\
{\small\verb%/%} & & 600 & left \\
{\small\verb+%+} & & 650 & left \\
{\small\verb+int_exp+} &{\small\verb%**%} & 700 & right \\
{\small\verb+int_of_num+} &{\small\verb%&%} & & prefix \\
\end{tabular}}
\end{center}

The overloaded symbol {\small\verb+& : num -> int+} denotes the
injection function from natural numbers to integers. The following
session illustrates how overloading and integers literals are treated.

\begin{session}
\begin{verbatim}
Term `1i = &(1n + 0n)`;
> val it = `1 = & (1 + 0)` : term

- show_numeral_types := true;
> val it = () : unit

- Term `&1 = &(1n + 0n)`;
<<HOL message: more than one resolution of overloading was possible.>>
> val it = `1i = & (1n + 0n)` : Term.term
\end{verbatim}
\end{session}


\section{Real numbers and analysis}

There is an extensive collection of theories that make up the
development of real numbers and analysis in HOL,
due to John Harrison \cite{jrh:thesis}. We will only give an overview of
the development; the interested reader should consult \REFERENCE\ and
Harrison's thesis.

The axioms for the real numbers are derived from the `half reals' which
are constructed from the `half rationals'. This part of the development
is recorded in {\small\verb+hratTheory+} and
{\small\verb+hrealTheory+}, but is not used once the reals have been
constructed. The real axioms are derived in the theory
{\small\verb+realaxTheory+}. A standard collection of operators on the
reals, and theorems about them, is found in {\small\verb+realaxTheory+}
and {\small\verb+realTheory+}. The operators and their parse status are
listed in the following table.

\begin{center}
{\small
\begin{tabular}{@{}cccc}
Constant & Overloaded symbol & Strength & Associativity \\ \hline
{\small\verb+real_ge+} &{\small\verb+>=+} & 450 & right \\
{\small\verb+real_lte+} &{\small\verb+<=+} & 450 & right \\
{\small\verb+real_gt+} &{\small\verb+>+}  & 450 & right \\
{\small\verb+real_lt+} &{\small\verb+<+}  & 450 & right \\
{\small\verb+real_add+} &{\small\verb%+%} & 500 & left \\
{\small\verb+real_sub+} &{\small\verb%-%} & 500 & left \\
{\small\verb+real_neg+} &{\small\verb%~%} & 900 & trueprefix \\
{\small\verb+real_mul+} &{\small\verb%*%} & 600 & left \\
{\small\verb+real_div+} & {\small\verb%/%} & 600 & left \\
{\small\verb+pow+} & &700 & right \\
{\small\verb+real_of_num+} &{\small\verb%&%} & & prefix \\
\end{tabular}}
\end{center}

On the basis of {\small\verb+realTheory+}, the following  sequence of
theories is constructed:

\begin{description}
\item [topologyTheory] Topologies and metric spaces, including metric on
the real line.
\item [netsTheory] Moore-Smith covergence nets, and special cases like
sequences.
\item [seqTheory] Sequences and series of real numbers.
\item [limTheory] Limits, continuity and differentiation.
\item [powserTheory] Power series.
\item [transcTheory] Transcendental functions, \emph{e.g.}, exp, sin,
cos, ln, root, sqrt, pi, tan, asn, acs, atn. Also the Kurzweil-Henstock
gauge integral and the fundamental theorem of calculus, McLaurin's
theorem.

\end{description}

A separate development that depends only on {\small\verb+realTheory+} is
a theory of polynomials, found in {\small\verb+polyTheory+}. A standard
collection of operations on polynomials, and theorems about them, are
also derived.

\section{Theories of sequences}
\subsection{The theory {\tt list}}\label{avra_list}
\index{list, the type operator in HOL logic@\ml{list}, the type operator in \HOL{} logic}
\index{recursive definitions, in HOL logic@recursive definitions, in \HOL{} logic!automated for lists|(}
\index{types, in HOL logic@types, in \HOL{} logic!tools for construction of}
\index{lists, in HOL logic@lists, in \HOL{} logic|(}
\index{list theory, in HOL logic@\ml{list} theory, in \HOL{} logic|(}
\index{lists, in HOL logic@\ml{[} $\cdots$ \ml{;} $\cdots$ \ml{]} (lists, in \HOL{} logic)|(}
The theory \ml{list} introduces the unary type operator
\ml{list} by a type definition. The standard list processing functions
are then defined on this type:

\begin{hol}
\index{NIL@\ml{NIL}}
\index{CONS@\ml{CONS}}
\index{HD, the constant in HOL logic@\ml{HD}, the constant in \HOL{} logic}
\index{TL, the constant in HOL logic@\ml{TL}, the constant in \HOL{} logic}
\index{NULL, the constant in HOL logic@\ml{NULL}, the constant in \HOL{} logic}
\begin{verbatim}
   NIL  : 'a list
   CONS : 'a -> 'a list -> 'a list
   HD   : 'a list -> 'a
   TL   : 'a list -> 'a list
   NULL : 'a list -> bool
\end{verbatim}\end{hol}

The \HOL{} parser\index{parsing, of HOL logic@parsing, of \HOL{} logic!of
list expressions} has been specially  modified to  parse the expression
{\small\verb%[]%} into {\small\verb%NIL%}, to parse the expression
{\small\verb%h :: t%} into {\small\verb%CONS h t%}, and to parse the expression
{\small\verb%[%}$t_1${\small\verb%;%}$t_2${\small\verb%;%}$\ldots${\small\verb%;%}$t_n${\small\verb%]%}
into {\small\verb%CONS %}$t_1${\small\verb% (CONS %}$t_2 \cdots\
${\small\verb%(CONS %}$t_n${\small\verb%  NIL)%}$\  \cdots\ ${\small\verb%)%}.
The \HOL{} printer\index{printing, in HOL logic@printing, in \HOL{} logic!of list expressions}
reverses these transformations.

The functions \ml{NIL} and \ml{CONS} are defined in terms of the representing
type of lists. From their definitions, the following fundamental theorems about
lists
\index{list theorems, in HOL logic@list theorems, in \HOL{} logic|(}
are proved and stored in the theory \ml{list}.

\begin{hol}
\index{list_Axiom@\ml{list\_Axiom}}
\index{axioms!non-primitive, of HOL logic@non-primitive, of \HOL{} logic}
\index{axioms!in list theory@in \ml{list} theory}
\index{list_INDUCT@\ml{list\_INDUCT}}
\index{list_CASES@\ml{list\_CASES}}
\index{CONS_11@\ml{CONS\_{11}}}
\index{NOT_NIL_CONS@\ml{NOT\_NIL\_CONS}}
\index{NOT_CONS_NIL@\ml{NOT\_CONS\_NIL}}
\index{characterizing theorem!for lists}
\begin{verbatim}
   list_Axiom    |- !x f. ?!fn.(fn[] = x) /\ (!h t. fn(h::t) = f(fn t)h t)

   list_INDUCT   |- !P. P[] /\ (!t. P t ==> (!h. P(h::t))) ==> (!l. P l)

   list_CASES    |- !l. (l = []) \/ (?t h. l = h::t)

   CONS_11       |- !h t h' t'. (h::t = h'::t') = (h = h') /\ (t = t')

   NOT_NIL_CONS  |- !h t. ~([] = h::t)

   NOT_CONS_NIL  |- !h t. ~(h::t = [])
\end{verbatim}
\end{hol}

The theorem  \ml{list\_Axiom}  shown  above  is  analogous   to  the  primitive
recursion theorem\index{primitive recursion theorem!for lists} on the
natural numbers discussed above in Section~\ref{num-prim-rec}.  It
states  the  validity  of  primitive recursive definitions on lists, and
can be used to justify any such definition.  The \ML\
function {\small\verb+new_recursive_definition+}
uses this theorem to do automatic
\index{primitive recursion theorem!automated use of, in HOL system@automated use of, in \HOL{} system|)}  proofs of the existence of primitive
recursive functions on lists and then make constant specifications to introduce
constants that  denote  such  functions.  For example, the \HOL{} system defines
a length function, \ml{LENGTH}, on lists by the primitive recursive
definition on lists shown below:

\begin{hol}
\begin{verbatim}
   new_recursive_definition Prefix list_Axiom "LENGTH"
      (Term `(LENGTH NIL = 0) /\
             (!h t. LENGTH (h::t) = SUC (LENGTH t))`)
\end{verbatim}
\end{hol}

\noindent When this \ML\
expression is evaluated, \HOL{} uses \ml{list\_Axiom} to prove existence
of a function that satisfies the given primitive recursive definition,
introduces a constant to name this function using a constant specification, and
stores the resulting theorem:

\begin{hol}
\begin{verbatim}
    LENGTH   |- (LENGTH [] = 0) /\ (!h t. LENGTH(h::t) = SUC(LENGTH t))
\end{verbatim}
\end{hol}

\noindent in the current theory (in this case, the theory \ml{list}).

The predicate \ml{NULL}  and  the
selectors \ml{HD} and  \ml{TL} are  defined\index{list definitions, in HOL logic@list definitions, in \HOL{} logic}
 in  the theory  \ml{list} by the
specifications:

\begin{hol}
\index{NULL, the definition in HOL logic@\ml{NULL}, the definition in \HOL{} logic}
\index{HD, the definition in HOL logic@\ml{HD}, the definition in \HOL{} logic}
\index{TL, the definition in HOL logic@\ml{TL}, the definition in \HOL{} logic}
\begin{verbatim}
   NULL |- NULL[] /\ (!h t. ~NULL(h::t))

   HD   |- !h t. HD(h::t) = h

   TL   |- !h t. TL(h::t) = t
\end{verbatim}
\end{hol}

\noindent The following primitive recursive definitions of functions on lists
are also made in the theory \ml{list}:


\begin{hol}
\index{SUM, the theorem in HOL logic@\ml{SUM}, the theorem in \HOL{} logic}
\index{APPEND, the theorem in HOL logic@\ml{APPEND}, the theorem in \HOL{} logic}
\index{concatenation, of lists!in HOL logic@in \HOL{} logic}
\index{FLAT, the theorem in HOL logic@\ml{FLAT}, the theorem in \HOL{} logic}
\index{LENGTH, the theorem in HOL logic@\ml{LENGTH}, the theorem in \HOL{} logic}
\index{MAP, the theorem in HOL logic@\ml{MAP}, the theorem in \HOL{} logic}
\index{EL, the theorem in HOL logic@\ml{EL}, the theorem in \HOL{} logic}

\index{SUM, the constant in HOL logic@\ml{SUM}, the constant in \HOL{} logic}
\index{APPEND, the constant in HOL logic@\ml{APPEND}, the constant in \HOL{} logic}
\index{FLAT, the constant in HOL logic@\ml{FLAT}, the constant in \HOL{} logic}
\index{LENGTH, the constant in HOL logic@\ml{LENGTH}, the constant in \HOL{} logic}
\index{MAP, the constant in HOL logic@\ml{MAP}, the constant in \HOL{} logic}
\index{EL, the constant in HOL logic@\ml{EL}, the constant in \HOL{} logic}
\index{EVERY, the HOL constant@\ml{EVERY}, the \HOL{} constant}
\index{EVERY_DEF@\ml{EVERY\_DEF}}
\index{EVERY, the HOL constant@\ml{EVERY}, the \HOL{} constant}
\index{EXISTS_DEF@\ml{EXISTS\_DEF}}
\index{EXISTS, the HOL constant@\ml{EXISTS}, the \HOL{} constant}
\index{FILTER@\ml{FILTER}}
\index{FILTER, the HOL constant@\ml{FILTER}, the \HOL{} constant}
\index{FOLDL@\ml{FOLDL}}
\index{FOLDL, the HOL constant@\ml{FOLDL}, the \HOL{} constant}
\index{FOLDR@\ml{FOLDR}}
\index{FOLDR, the HOL constant@\ml{FOLDR}, the \HOL{} constant}
\index{MEM@\ml{MEM}}
\index{MEM, the HOL constant@\ml{MEM}, the \HOL{} constant}
\begin{verbatim}
   SUM        |- (SUM [] = 0) /\ (!h t. SUM(h::t) = h + SUM t)

   APPEND     |- (!l. APPEND [] l = l) /\
                 (!l1 l2 h. APPEND (h::l1) l2 = h::APPEND l1 l2)

   FLAT       |- (FLAT[] = []) /\ (!h t. FLAT(h::t) = APPEND h (FLAT t))

   LENGTH     |- (LENGTH [] = 0) /\ (!h t. LENGTH (h::t) = SUC(LENGTH t))

   MAP        |- (!f. MAP f [] = []) /\
                 (!f h t. MAP f (h::t) = f h::MAP f t)

   EL         |- (!l. EL 0 l = HD l) /\ (!l n. EL (SUC n)l = EL n (TL l))

   EVERY_DEF  |- (!P. EVERY P [] = T) /\
                 (!P h t. EVERY P (h::t) = P h /\ EVERY P t)

   EXISTS_DEF |- (!P. EXISTS P [] = F) /\
                 (!P h t. EXISTS P (h::t) = P h \/ EXISTS P t)

   FILTER     |- (!P. FILTER P [] = []) /\
                 (!P h t. FILTER P (h::t)
                           = if P h then h::FILTER P t else FILTER P t)

   FOLDL      |- (!f e. FOLDL f e [] = e) /\
                 (!f e x l. FOLDL f e (x::l) = FOLDL f (f e x) l)

   FOLDR      |- (!f e. FOLDR f e [] = e) /\
                 (!f e x l. FOLDR f e (x::l) = f x (FOLDR f e l))

   MEM        |- (!x. MEM x [] = F) /\
                 (!x h t. MEM x (h::t) = (x = h) \/ MEM x t)
\end{verbatim}
\end{hol}

\noindent For a complete list of available theorems in
{\small\verb+listTheory+}, see \REFERENCE.  The theory
{\small\verb+list+} is relatively compact, largely because of
how the \HOL{} system has evolved. A more extensive theory of lists can
be found in {\small\verb+rich_listTheory+}.

\index{list theorems, in HOL logic@list theorems, in \HOL{} logic|)}
\index{lists, in HOL logic@\ml{[} $\cdots$ \ml{;} $\cdots$ \ml{]} (lists, in \HOL{} logic)|)}
\index{list theory, in HOL logic@\ml{list} theory, in \HOL{} logic|)}
\index{lists, in HOL logic@lists, in \HOL{} logic|)}
\index{recursive definitions, in HOL logic@recursive definitions, in \HOL{} logic!automated for lists|)}

\subsection{Possibly infinite sequences (\theoryimp{llist})}

\index{lazy lists@``lazy'' lists!\HOL{} theory of|(}
The theory \theoryimp{llist} contains the definition of a type of
possibly infinite sequences.  This type is similar to the ``lazy
lists'' of programming languages like Haskell, hence the name of the
theory.  The \theoryimp{llist} theory has a number of constants that
are analogous to constants in the theory of (necessarily finite)
lists.  The \theoryimp{llist} versions of these constants have the
same names, but with a capital `L' prepended.  Thus, some of the core
constants in this theory are:

\begin{verbatim}
   LNIL  : 'a llist
   LCONS : 'a -> 'a llist -> 'a llist
   LHD   : 'a llist -> 'a option
   LTL   : 'a llist -> 'a llist option
\end{verbatim}

The \ml{LHD} and \ml{LTL} constants return \ml{NONE} when applied to
the empty sequence, \ml{LNIL}.  This use of an option type is another
way of modelling the essential partiality of these constants.  (In the
theory of lists, the analogous \ml{HD} and \ml{TL} functions are
simply have unspecified values when applied to empty lists.)

The type \ml{llist} is not inductive, and there is no primitive
recursion theorem supporting the definition of functions that have
domains of type \ml{llist}.  Rather, \ml{llist} is a coinductive type,
and has an axiom that justifies the definition of (co-)recursive
functions that map into the \ml{llist} type.  This axiom has the name
\ml{llist\_Axiom}, and states
\begin{verbatim}
   !f : 'a -> ('a # 'b) option.
      ?g : 'a -> 'b llist.
         (!x. LHD (g x) = OPTION_MAP SND (f x)) /\
         (!x. LTL (g x) = OPTION_MAP (g o FST) (f x))
\end{verbatim}
An equivalent form of the above is
\begin{verbatim}
   !f. ?g.
      !x. g x = case f x of
                   NONE -> LNIL
                || SOME (x',y) -> LCONS y (g x')
\end{verbatim}
Other constants in the theory \theoryimp{llist} include \texttt{LTAKE},
\texttt{LDROP}, \texttt{LMAP}, \texttt{LFINITE} and
\texttt{LFILTER}. Their types are
\begin{verbatim}
   LTAKE   : num -> 'a llist -> 'a list
   LDROP   : num -> 'a llist -> 'a llist
   LMAP    : ('a -> 'b) -> 'a llist -> 'b llist
   LFINITE : 'a llist -> bool
   LFILTER : ('a -> bool) -> 'a llist -> 'a llist
\end{verbatim}
They are characterised by the following theorems
\begin{verbatim}
   LTAKE_THM
      |- (LTAKE 0 l = SOME []) /\
         (LTAKE (SUC n) LNIL = NONE) /\
         (LTAKE (SUC n) (LCONS h t) = OPTION_MAP (CONS h) (LTAKE n t)

   LDROP_THM
      |- (LDROP 0 ll = SOME ll) /\
         (LDROP (SUC n) ll = NONE) /\
         (LDROP (SUC n) (LCONS h t) = LDROP n t)

   LMAP
      |- (LMAP f LNIL = LNIL) /\
         (LMAP f (LCONS h t) = LCONS (f h) (LMAP f t))

   LFINITE_THM
      |- (LFINITE LNIL = T) /\
         (LFINITE (LCONS h t) = LFINITE t)

   LFILTER_THM
      |- (LFILTER P LNIL = LNIL) /\
         (LFILTER P (LCONS h t) = if P h then LCONS h (LFILTER P t)
                                  else LFILTER P t)
\end{verbatim}

Finally, there are two very important proof principles for proving
that two \texttt{llist} values are equal.  The first states that two
sequences are equal if they return the same prefixes of length $n$ for
all possible values of $n$:
\begin{verbatim}
   LTAKE_EQ |- (ll1 = ll2) = (!n. LTAKE n ll1 = LTAKE n ll2)
\end{verbatim}
This theorem is subsequently used to derive the bisimulation
principle:
\begin{verbatim}
   LLIST_BISIMULATION
            |- (ll1 = ll2) =
               ?R. R ll1 ll2 /\
                   !ll3 ll4. R ll3 ll4 ==>
                             (ll3 = LNIL) /\ (ll4 = LNIL) \/
                             (LHD ll3 = LHD ll4) /\
                             R (THE (LTL ll3)) (THE (LTL ll4))
\end{verbatim}
The principle of bisimulation states that two \ml{llist} values $l_1$
and $l_2$ are equal if (and only if) it is possible to find a
relation $R$ such that
\begin{itemize}
\item $R$ relates the two values, i.e., $R\;l_1\;l_2$; and
\item if $R$ holds of any two values $l_3$ and $l_4$, then either
  \begin{itemize}
  \item both $l_3$ and $l_4$ are empty; or
  \item the head elements of $l_3$ and $l_4$ are the same, and the
    tails of those two values are again related by $R$
  \end{itemize}
\end{itemize}
Of course, a possible $R$ would be equality itself, but the strength
of this theorem is that other, more convenient relations can also be
used.
\index{lazy lists@``lazy'' lists!\HOL{} theory of|)}

\subsection{Labelled paths (\theoryimp{path})}

The theory \theoryimp{path} defines a binary type operator
$(\alpha,\beta)\texttt{path}$, which stands for possibly infinite
paths of the following form\[
  \alpha_1 \stackrel{\beta_1}{\longrightarrow}
  \alpha_2 \stackrel{\beta_2}{\longrightarrow}
  \alpha_3 \stackrel{\beta_3}{\longrightarrow} \cdots
  \alpha_n \stackrel{\beta_n}{\longrightarrow}
  \alpha_{n+1} \stackrel{\beta_{n+1}}{\longrightarrow}  \cdots
  \]
The \texttt{path} type is thus an appropriate model for reduction
sequences, where the $\alpha$ parameter corresponds to ``states'', and
the $\beta$ parameter corresponds to the labels on the arrows.

The model of $(\alpha,\beta)\texttt{path}$ is $\alpha \times
((\alpha\times\beta)\texttt{llist})$.  The type of paths has two
constructors:
\begin{verbatim}
   stopped_at : 'a -> ('a,'b) path
   pcons      : 'a -> 'b -> ('a,'b) path -> ('a,'b) path
\end{verbatim}
The \ml{stopped\_at} constructor returns a path containing just one
state, and no transitions.  (Thus, the reduction sequence has
``stopped at'' this state.)  The \ml{pcons} constructor takes a state,
a label, and a path, and returns a path which is now headed by the
state argument, and which moves from that state via the label argument
to the path.  Graphically, $\texttt{pcons}\;x\;l\;p$ is equal to
\[
x \stackrel{l}{\longrightarrow}
\underbrace{p_1 \stackrel{l_1}{\longrightarrow} p_2
  \stackrel{l_2}{\longrightarrow} \cdots\quad}_p
\]
Other constants defined in theory \theoryimp{path} include
\begin{verbatim}
   finite  : ('a,'b) path -> bool
   first   : ('a,'b) path -> 'a
   labels  : ('a,'b) path -> 'b llist
   last    : ('a,'b) path -> 'a
   length  : ('a,'b) path -> num option
   okpath  : ('a -> 'b -> 'a -> bool) -> ('a,'b) path -> bool
   pconcat : ('a,'b) path -> 'b -> ('a,'b) path -> ('a,'b) path
   pmap    : ('a -> 'c) -> ('b -> 'd) -> ('a,'b)path -> ('c,'d)path
\end{verbatim}

The \texttt{first} function returns the first element of a path.
There always is such an element, and the defining equations are
\begin{verbatim}
   first_thm  |- (first (stopped_at x) = x) /\
                 (first (pcons x l p) = x)
\end{verbatim}

On the other hand, the \texttt{last} function does not always have a
well-specified value, though it still has nice characterising
equations:
\begin{verbatim}
   last_thm   |- (last (stopped_at x) = x) /\
                 (last (pcons x l p) = last p)
\end{verbatim}

The theorem for \texttt{finite} has a similar feel, but has a definite
value (\texttt{F}, or \emph{false}) on infinite paths), whereas the
value of \texttt{last} on such paths is unspecified:
\begin{verbatim}
   finite_thm |- (finite (stopped_at x) = T) /\
                 (finite (pcons x l p) = finite p)
\end{verbatim}

The function \texttt{pconcat} concatenates two paths, linking them
with a provided label.  If the first path is infinite, then the result
is equal to that first path.  The defining equation


%\subsection{The theory {\tt rich\_list}}\label{rich_list}
%
%The theory {\small\verb+list+} is relatively compact, largely because of
%how the \HOL{} system has evolved. A more extensive theory of lists can be
%found in {\small\verb+rich_listTheory+}, in which the following
%list operations are defined:
%
%\begin{hol}
%\begin{verbatim}
%  [ALL_EL]
%  |- (!P. ALL_EL P [] = T) /\
%     !P x l. ALL_EL P (x::l) = P x /\ ALL_EL P l
%
%  [BUTFIRSTN]
%  |- (!l. BUTFIRSTN 0 l = l) /\
%     !n x l. BUTFIRSTN (SUC n) (x::l) = BUTFIRSTN n l
%
%  [BUTLASTN]
%  |- (!l. BUTLASTN 0 l = l) /\
%     !n x l. BUTLASTN (SUC n) (SNOC x l) = BUTLASTN n l
%
%  [BUTLAST_DEF] |- !l. BUTLAST l = SEG (PRE (LENGTH l)) 0 l
%
%  [ELL]
%  |- (!l. ELL 0 l = LAST l) /\
%     !n l. ELL (SUC n) l = ELL n (BUTLAST l)
%
%  [FIRSTN]
%  |- (!l. FIRSTN 0 l = []) /\
%     !n x l. FIRSTN (SUC n) (x::l) = x::FIRSTN n l
%
%  [GENLIST]
%  |- (!f. GENLIST f 0 = []) /\
%     !f n. GENLIST f (SUC n) = SNOC (f n) (GENLIST f n)
%
%  [IS_EL_DEF]
%  |- !x l. IS_EL x l = SOME_EL ($= x) l
%
%  [IS_PREFIX]
%  |- (!l. IS_PREFIX l [] = T) /\
%     (!x l. IS_PREFIX [] (x::l) = F) /\
%     !x1 l1 x2 l2. IS_PREFIX (x1::l1) (x2::l2) = (x1 = x2) /\ IS_PREFIX l1 l2
%
%  [IS_SUBLIST]
%  |- (!l. IS_SUBLIST l [] = T) /\
%     (!x l. IS_SUBLIST [] (x::l) = F) /\
%     !x1 l1 x2 l2.
%       IS_SUBLIST (x1::l1) (x2::l2) =
%       (x1 = x2) /\ IS_PREFIX l1 l2 \/ IS_SUBLIST l1 (x2::l2)
%
%  [IS_SUFFIX]
%  |- (!l. IS_SUFFIX l [] = T) /\
%     (!x l. IS_SUFFIX [] (SNOC x l) = F) /\
%     !x1 l1 x2 l2.
%       IS_SUFFIX (SNOC x1 l1) (SNOC x2 l2) = (x1 = x2) /\ IS_SUFFIX l1 l2
%
%  [LASTN]
%  |- (!l. LASTN 0 l = []) /\
%     !n x l. LASTN (SUC n) (SNOC x l) = SNOC x (LASTN n l)
%
%  [LAST_DEF]
%  |- !l. LAST l = HD (SEG 1 (PRE (LENGTH l)) l)
%
%  [OR_EL_DEF] |- OR_EL = SOME_EL I
%
%  [PREFIX_DEF] |- !P l. PREFIX P l = FST (SPLITP ($~ o P) l)
%
%  [REPLICATE]
%  |- (!x. REPLICATE 0 x = []) /\
%     !n x. REPLICATE (SUC n) x = x::REPLICATE n x
%
%  [REVERSE]
%  |- (REVERSE [] = []) /\
%     !x l. REVERSE (x::l) = SNOC x (REVERSE l)
%
%  [SCANL]
%  |- (!f e. SCANL f e [] = [e]) /\
%     !f e x l. SCANL f e (x::l) = e::SCANL f (f e x) l
%
%  [SCANR]
%  |- (!f e. SCANR f e [] = [e]) /\
%     !f e x l. SCANR f e (x::l) = f x (HD (SCANR f e l))::SCANR f e l
%
%  [SEG]
%  |- (!k l. SEG 0 k l = []) /\
%     (!m x l. SEG (SUC m) 0 (x::l) = x::SEG m 0 l) /\
%     !m k x l. SEG (SUC m) (SUC k) (x::l) = SEG (SUC m) k l
%
%  [SNOC]
%  |- (!x. SNOC x [] = [x]) /\
%     !x x' l. SNOC x (x'::l) = x'::SNOC x l
%
%  [SOME_EL]
%  |- (!P. SOME_EL P [] = F) /\
%     !P x l. SOME_EL P (x::l) = P x \/ SOME_EL P l
%
%  [SPLITP]
%  |- (!P. SPLITP P [] = ([],[])) /\
%     !P x l.
%       SPLITP P (x::l) =
%       (if P x then ([],x::l) else (x::FST (SPLITP P l),SND (SPLITP P l)))
%
%  [SUFFIX_DEF]
%  |- !P l. SUFFIX P l = FOLDL (\l' x. (if P x then SNOC x l' else [])) [] l
%
%  [UNZIP]
%  |- (UNZIP [] = ([],[])) /\
%     !x l. UNZIP (x::l) = (FST x::FST (UNZIP l),SND x::SND (UNZIP l))
%
%  [ZIP]
%   |- (ZIP ([],[]) = []) /\
%       !x1 l1 x2 l2. ZIP (x1::l1,x2::l2) = (x1,x2)::ZIP (l1,l2)
%\end{verbatim}\end{hol}
%
%A large number of theorems about these constants can be found in
%{\small\verb+rich_listTheory+}.



%\section{Partial functions and the {\tt option} type}


%\section{Finite maps}

%\section{Strings}
%\subsection{The theory {\tt ascii}}
%\subsection{The theory {\tt string}}

%\section{Sets}
%\subsection{The theory {\tt set}}
%\subsection{The theory {\tt pred\_set}}
%%\subsection{The theory {\tt finset}}
%
%\subsection{Syntax for sets}\index{set theory notation}
%
%The special purpose set-theoretic notations
%{\small\verb%"{%}$t_1,t_2,\ldots,t_n${\small\verb%}"%} and
%{\small\verb%"{%}$t${\small\verb%|%}$p${\small\verb%}"%} are available.
%The normal interpretation of the former is the finite set containing
%$t_1,t_2,\ldots, t_n$ and the normal interpretation of the latter
%is the set of all $t$s such that $p$.
%
%For example,
%\begin{hol}\begin{verbatim}
%   "{1,2,3,4}"
%\end{verbatim}\end{hol}
%
%\noindent parses to
%
%\begin{hol}\begin{verbatim}
%   "1 INSERT (2 INSERT (3 INSERT (4 INSERT EMPTY)))"
%\end{verbatim}\end{hol}
%
%\noindent Similarly, {\small\verb%"{%}$t${\small\verb%|%}$p${\small\verb%}"%}
%parses to:
%
%\medskip
%
%\noindent{\small
%{\verb%   `%}}{\small{\verb%GSPEC(\(%}$x_1${\verb%,%}$\ldots${\verb%,%}$x_n${\verb%).(%}$t${\verb%,%}$p${\verb%))"%}
%}
%
%\medskip
%
%\noindent where $x_1$, $\ldots$ , $x_n$ are the free variables occurring in both $t$
%and $p$.  If there are no such free variables then an error results.
%The order in which the variables are listed in the variable structure
%of the paired abstraction is an unspecified function of the structure
%of $t$ (it is approximately left to right).
%
%For example,
%
%\begin{hol}\begin{verbatim}
%   "{x+y | (x < y) /\ (y < z)}"
%\end{verbatim}\end{hol}
%
%\noindent parses to:
%
%\begin{hol}\begin{verbatim}
%   "GSPEC(\(x,y). ((x+y), (x < y) /\ (y < z)))"
%\end{verbatim}\end{hol}
%
%\noindent where \ml{GSPEC} is defined by:
%
%\begin{hol}\begin{verbatim}
%   |- !f. GSPEC f = SPEC(\x. ?y. x,T = f y)
%\end{verbatim}\end{hol}
%
%\noindent and \ml{SPEC} abstracts a predicate to a set (it is the abstraction
%bijection used in the definition of the type operator \ml{set}).
%Other examples are:
%
%\begin{hol}\begin{verbatim}
%   "{x+y+z | (x < y) /\ (y < z)}"
%\end{verbatim}\end{hol}
%
%\noindent will parse to:
%
%\begin{hol}\begin{verbatim}
%   "GSPEC(\(x,y,z). (x+(y+z), (x < y /\ y < z)))"
%\end{verbatim}\end{hol}
%
%\noindent and
%
%\begin{hol}\begin{verbatim}
%   "{x+y+w | (x < y) /\ (y < z)}"
%\end{verbatim}\end{hol}
%
%\noindent will parse to:
%
%\begin{hol}\begin{verbatim}
%   "GSPEC(\(x,y). (x+(y+w), (x < y /\ y < z)))"
%\end{verbatim}\end{hol}
%
%%\section{Multisets}
%
%\section{Restricted binders}\label{res-quant}
%
%\index{types, in HOL logic@types, in \HOL{} logic!dependent}
%\index{dependent types in HOL logic@dependent types in \HOL{} logic}
%\index{quantifiers!restricted}
%
%The theory \ml{res\_quan} contains the definitions of the constants
%{\small\verb!RES_FORALL!}, {\small\verb!RES_EXISTS!},
%{\small\verb!RES_SELECT!}, and {\small\verb!RES_ABSTRACT!},
%which are used to support restricted
%quantification\index{quantifiers!restricted} in the \HOL{} logic.  This
%implements a method of simulating subtypes and dependent types with
%predicates. The definitions are:
%
%\begin{hol}
%\index{RES_FORALL@\ml{RES\_FORALL}}
%\index{RES_EXISTS@\ml{RES\_EXISTS}}
%\index{RES_SELECT@\ml{RES\_SELECT}}
%\index{RES_ABSTRACT@\ml{RES\_ABSTRACT}}
%\index{ARB@\ml{ARB}}
%\begin{verbatim}
%   RES_FORALL   |- !P B. RES_FORALL P B = (!x. P x ==> B x)
%
%   RES_EXISTS   |- !P B. RES_EXISTS P B = (?x. P x /\ B x)
%
%   RES_SELECT   |- !P B. RES_SELECT P B = (@x. P x /\ B x)
%
%   RES_ABSTRACT |- !P B. RES_ABSTRACT P B = (\x. if P x then B x else ARB)
%\end{verbatim}\end{hol}
%
%
%The new syntax automatically translates as follows:
%
%\begin{hol}
%{\small\verb%   \%}$v${\small\verb%::%}$P${\small\verb%.%}$B${\small\verb%    <---->   RES_ABSTRACT %}$P${\small\verb% (\%}$v${\small\verb%.%}$B${\small\verb%)%}\\
%{\small\verb%   !%}$v${\small\verb%::%}$P${\small\verb%.%}$B${\small\verb%    <---->   RES_FORALL   %}$P${\small\verb% (\%}$v${\small\verb%.%}$B${\small\verb%)%}\\
%{\small\verb%   ?%}$v${\small\verb%::%}$P${\small\verb%.%}$B${\small\verb%    <---->   RES_EXISTS   %}$P${\small\verb% (\%}$v${\small\verb%.%}$B${\small\verb%)%}\\
%{\small\verb%   @%}$v${\small\verb%::%}$P${\small\verb%.%}$B${\small\verb%    <---->   RES_SELECT   %}$P${\small\verb% (\%}$v${\small\verb%.%}$B${\small\verb%)%}
%\end{hol}
%
%Anything can be written between the binder and `\ml{::}' that can be
%written between the binder and `\ml{.}`. See the examples below.
%
%Currently no derived rules are provided to support this notation, so
%any inferences will need to work on the underlying semantic
%representation.
%
%User-defined binders can also have restricted forms, which are set up
%with the function:
%
%\begin{boxed}\index{associate_restriction@\ml{associate\_restriction}|pin}
%\begin{verbatim}
%   associate_restriction : (string * string) -> *
%\end{verbatim}\end{boxed}
%
%
%\noindent If \m{c} is the name
%of a binder and \ml{RES\_}\m{c} is the name of a suitable constant (which
%must be explicitly defined), then executing:
%
%\begin{hol}
%{\small\verb%   associate_restriction(`%}$c${\small\verb%`, `RES_%}$c${\small\verb%`)%}
%\end{hol}
%
%\noindent will cause the parser and pretty-printer to support:
%
%\begin{hol}
%{\small\verb%   %}$c$ $v${\small\verb%::%}$P${\small\verb%. %}$B${\small\verb%    <---->   RES_%}$c$ $P${\small\verb% (\%}$v${\small\verb%. %}$B${\small\verb%)%}
%\end{hol}
%
%Here is an example session:
%
%\setcounter{sessioncount}{1}
%\begin{session}\begin{verbatim}
%#"!x y::P. x<y";;
%"!x y :: P. x < y" : term
%
%#set_flag(`print_restrict`, false);;
%true : bool
%
%#"!x y::P. x<y";;
%"RES_FORALL P(\x. RES_FORALL P(\y. x < y))" : term
%
%#"?(x,y) p::(\(m,n).m<n). p=(x,y)";;
%"RES_EXISTS
% (\(m,n). m < n)
% (\(x,y). RES_EXISTS(\(m,n). m < n)(\p. p = x,y))"
%: term
%
%#"\x y z::P.[0;x;y;z]";;
%"RES_ABSTRACT P(\x. RES_ABSTRACT P(\y. RES_ABSTRACT P(\z. [0;x;y;z])))"
%: term
%\end{verbatim}\end{session}
%
%A conversion that rewrites away the constants \ml{RES\_ABSTRACT},
%\ml{RES\_FORALL}, \ml{RES\_EXISTS} and \ml{RES\_SELECT} is:
%
%\begin{hol}\begin{verbatim}
%   let RESTRICT_CONV =
%        (PURE_REWRITE_CONV [definition `bool` `RES_ABSTRACT`;
%                            definition `bool` `RES_FORALL`;
%                            definition `bool` `RES_EXISTS`;
%                            definition `bool` `RES_SELECT`])
%        THENC (DEPTH_CONV BETA_CONV)
%\end{verbatim}\end{hol}
%
%\noindent This is a bit unsatisfactory, as is shown by the artificial
%example below:
%
%\setcounter{sessioncount}{1}
%\begin{session}\begin{verbatim}
%#let t = "!x y::P.?f:num->num::Q. f(@n::R.T) = (x+y)";;
%t = "!x y :: P. ?f :: Q. f(@n :: R. T) = x + y" : term
%
%#RESTRICT_CONV t;;
%|- (!x y :: P. ?f :: Q. f(@n :: R. T) = x + y) =
%   (!x. P x ==> (!x'. P x' ==> (?x. Q x /\ (x(@x. R x /\ T) = x + x'))))
%\end{verbatim}\end{session}
%
%The variable $x$ in the definitions of the constants
%\ml{RES\_ABSTRACT}, \ml{RES\_FORALL}, \ml{RES\_EXISTS} and
%\ml{RES\_SELECT} gets confused with the variable in the supplied term.
%This can be avoided by changing \ml{RESTRICT\_CONV} to perform
%explicit alpha-conversion. For example, by implementing a conversion:
%
%\begin{hol}
%{\small\verb%   RES_FORALL %}$P${\small\verb% (\%}$v$\ml{.}$B$\ml{[}$v$\ml{])  ---->  !}$v$\ml{. }$P$ $v$\ml{ ==> }$B$\ml{[}$v$\ml{]}
%\end{hol}
%
%\noindent Dealing with the case when
%$v$ is a variable structure is also desirable. For example:
%
%\begin{session}\begin{verbatim}
%#let t1 = "!(m,n)::P. m<n";;
%t1 = "!(m,n) :: P. m < n" : term
%
%#RESTRICT_CONV t1;;
%|- (!(m,n) :: P. m < n) = (!x. P x ==> (\(m,n). m < n)x)
%
%\end{verbatim}\end{session}
%
%\noindent If anyone writes the desired conversions please let us know!
%
%Here is an example of a user-defined restriction:
%
%\begin{session}\begin{verbatim}
%#new_binder_definition(`DURING`, "DURING(p:num#num->bool) = $!p");;
%|- !p. $DURING p = $! p
%
%#"DURING x::(m,n). p x";;
%no restriction constant associated with DURING
%skipping: x " ;; parse failed
%
%#new_definition
%# (`RES_DURING`, "RES_DURING(m,n)p = !x. m<=x /\ x<=n ==> p x");;
%|- !m n p. RES_DURING(m,n)p = (!x. m <= x /\ x <= n ==> p x)
%
%#associate_restriction(`DURING`,`RES_DURING`);;
%() : void
%
%#"DURING x::(m,n). p x";;
%"DURING x :: (m,n). p x" : term
%
%#set_flag(`print_restrict`,false);;
%true : bool
%
%#"DURING x::(m,n). p x";;
%"RES_DURING(m,n)(\x. p x)" : term
%\end{verbatim}\end{session}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "description"
%%% End:
