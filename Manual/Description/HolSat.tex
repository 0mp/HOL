%\documentclass[12pt]{article}

%\usepackage{alltt}
%\usepackage{epsfig}
%\usepackage{pstricks}
%\usepackage{xspace}
%\usepackage{url}
%\usepackage{makeidx}
%\usepackage{index}
%\usepackage{multind}


\renewcommand{\t}[1]{\mbox{\small\tt #1}}
%\newcommand{\prev}[1]{#1}

%\newcommand{\varord}[1]{#1}

%\newcommand{\ma}[1]{{{$#1$}}}
%\newcommand{\id}[1]{#1}

\newcommand\Hol{Hol98}

%\newcommand{\els}{\mid}
%\newcommand{\Imp}{\Rightarrow}

%\renewcommand{\prod}{\mbox{\tt{*}}}
%\newcommand{\SP}{~}
%\newcommand{\SPP}{~}

%\newcommand{\homedir}{\mbox{$\sim$}}

%\newcommand{\Turn}{\(\turn\)}
%\newcommand{\And}{\(\wedge\)}
%\newcommand{\Or}{\(\vee\)}
%\newcommand{\Not}{\(\neg\)}
%\newcommand{\Forall}{\(\forall\)}
%\newcommand{\Exists}{\(\exists\)}
%\newcommand{\Mapsto}{\(\mapsto\)}

%\input{../LaTeX/commands}

\setcounter{sessioncount}{0}

%\begin{document}
\index{HolSatLib|(}
\index{SAT solvers|see {HolSatLib}}

{\tt{HolSatLib}} provides a powerful propositional tautology prover {\tt SAT\_TAUT\_PROVE}, as well as a very simple harness for invoking SAT solvers on \HOL{} terms. Section~\ref{install} describes how to install the supported SAT solvers. Currently the following
solvers are supported:

\medskip

\begin{tabular}{lp{3.75in}}
{\bf Solver} & {\bf Home Page} \\ \hline
%SATO & {\small\url{http://www.cs.uiowa.edu/~hzhang/sato.html}}\\
%GRASP & {\small\url{http://sat.inesc.pt/~jpms/grasp}}\\
ZCHAFF & {\small\url{http://www.ee.princeton.edu/~chaff/zchaff.html}}\\
MINISAT & {\small\url{http://www.cs.chalmers.se/Cs/Research/FormalMethods/MiniSat/Main.html}}
\end{tabular}

\medskip

These solvers require input in the standard DIMACS format\footnote{\small\tt ftp://dimacs.rutgers.edu/pub/challenge/satisfiability/} for conjunctive normal form (CNF). It should be straightforward to add other DIMACS compatible SAT solvers.

The purpose of {\tt{HolSatLib}} is to provide a platform
for experimenting with combinations of theorem proving and
SAT. \HOL{} can be used to deductively manipulate terms into CNF as
required for SAT analysis, and then the results of the analysis
can be reimported into \HOL{} and either checked or just trusted.

{\tt HolSatLib} comes with MINISAT pre-installed. The special function {\tt SAT\_TAUT\_PROVE} 
is provided that attempts to prove propositional tautologies deductively, using
the proof logging feature of MINISAT.
 
Currently {\tt HolSatLib} has only been tested under Linux, though it should be
possible to run it under Windows.

The following example illustrates {\tt{HolSatLib}} in action.

\begin{session}\begin{verbatim}
- load "HolSatLib"; open HolSatLib;
(* output omitted *)
> val it = () : unit

- show_tags := true;
> val it = () : unit

- satOracle minisatp ``(x \/ ~y \/ z) /\ (~z \/ y)``;
> val it = [oracles: minisatp] [axioms: ] []
           |- ~z /\ ~y /\ ~x ==> (x \/ ~y \/ z) /\ (~z \/ y) : thm

- satProve minisatp ``(x \/ ~y \/ z) /\ (~z \/ y)``;
> val it = [oracles: DISK_THM ] [axioms: ] [] 
           |- ~z /\ ~y /\ ~x ==> (x \/ ~y \/ z) /\ (~z \/ y) : thm

- SAT_TAUT_PROVE ``(a ==> b) /\ (b ==> a) ==> (a=b)``;
> val it = [oracles: DISK_THM ] [axioms: ] [] 
           |- (a ==> b) /\ (b ==> a) ==> (a = b) : thm
\end{verbatim}
\end{session}

Setting \t{show\_tags} to \t{true} makes the \HOL{} top
level print theorem tags. The \t{DISK\_THM} oracle tag has nothing to do with \t{HolSatLib}. It just indicates the use of theorems from \HOL{} libraries read in from permanent storage. Note that \t{SAT\_TAUT\_PROVE} does not require the user to specify the solver.

The function \t{satOracle} \index{HolSatLib!satOracle@\ml{satOracle}} takes a supported SAT solver and a CNF term
$t$ and

\begin{enumerate}
\item writes a DIMACS format file corresponding to the term $t$
\item invokes the solver on the file to create an output file
\item parses the output file to extract the model found
\item creates a theorem, tagged with the name of the solver, that shows the model.
\end{enumerate}

The function \t{satProve} \index{HolSatLib!satProve@\ml{satProve}} performs steps 1--3 above, but then uses
\HOL{} to check that the model is really a model and then
returns an untagged theorem. Note that checking a model is
generally much quicker than finding it (one just `evaluates' the term
with the values supplied by the model).

Thus if one is prepared to trust the solver then use \t{satOracle},
but if one wants to verify the results (which could be time-consuming)
use \t{satProve}.


The next example illustrates what happens on unsatisfiable terms.

\begin{session}\begin{verbatim}

- satOracle minisatp ``(x \/ ~y \/ z) /\ ~z /\ y /\ ~x``;
> val it = [oracles: minisatp] [axioms: ] [] 
           |- ~((x \/ ~y \/ z) /\ ~z /\ y /\ ~x)

- satProve minisatp ``(x \/ ~y \/ z) /\ ~z /\ y /\ ~x``;
! Uncaught exception: 
! satProveError

\end{verbatim}\end{session}

If a term $t$ is unsatisfiable then \t{satOracle} will return {\small\verb+|- ~+}$t$,
tagged with the name of the SAT solver used. However, \t{satProve} will raise an exception. However, {\tt SAT\_TAUT\_PROVE} can deductively prove propositional tautologies. This can be used to prove unsatisfiability by passing it the negation of the unsatisfiable term.

\subsection{Installing ZChaff for {\tt HolSatLib}}\label{install}\index{HolSatLib!installing}

Download ZChaff into the directory {\tt hol98/src/HolSat/sat\_solvers/zchaff}. Create links of the same name as the directory name, to point to the executable, or rename the executable.

You should now be able to step through the examples in Section~\ref{sec:HolSatLib}. See the description of the {\tt SatSolvers} module below to see how to add support for other SAT solvers.

\subsection{{\tt HolSatLib} internals}

{\tt HolSatLib} currently comes with four modules

\medskip

\begin{tabular}{ll}
{\bf Module} & {\bf Description} \\ \hline
{\tt HolSatLib} & wrapper for commonly used functions\\
{\tt satTools} & functions for invoking SAT solvers\\
{\tt dimacsTools} & functions for term conversion to/from DIMACS files\\
{\tt SatSolvers} & specifications of the supported SAT solvers\\
\end{tabular}

There are several other modules used internally by \t{SAT\_TAUT\_PROVE}. We shall not cover them here.
\medskip

\subsubsection{Contents of {\tt HolSatLib} module}

The signature of {\tt HolSatLib} is shown below, followed
by a description of the components.

{\small\begin{verbatim}
signature HolSatLib = sig
  type sat_solver = SatSolvers.sat_solver 
  val tmp_name : string ref
  val prefix : string ref
  val zchaff  : sat_solver
  val minisatp : sat_solver
  val termToDimacsFile : string option -> int -> int -> Term.term array ->
			 string 
			 * (int * (Term.term, Term.term * int) Redblackmap.dict) 
			 * Term.term array
  val readDimacs :string -> Term.term 
  val satProve : sat_solver -> Term.term -> Thm.thm
  val satOracle : sat_solver -> Term.term -> Thm.thm
  exception Sat_counterexample of Thm.thm
  val SAT_TAUT_PROVE : Term.term -> Thm.thm
end
\end{verbatim}}

\paragraph{\tt sat\_solver}${}$\\

The datatype \t{sat\_solver} \index{HolSatLib!sat\_solver@\ml{sat\_solver}} is defined in the module {SatSolvers}.
The data in the record argument to the constructor \t{SatSolver}
is an ad-hoc list of what is needed to invoke a SAT program
and parse the results. One only needs to know what the fields
contain if one is adding another SAT prover. See the
source code {\tt SatSolvers.sml} for some information
in the comments. You may also find it useful to look at the SAT format file available from \url{www.satlib.org}\footnote{\url{http://www.satlib.org/Benchmarks/SAT/satformat.ps}}.

\paragraph{{\tt zchaff} and {\tt minisatp}}${}$\\

The ML identifiers \t{zchaff} and \t{minisatp} are bound
by module {\tt SatSolvers} to descriptions of the corresponding SAT solvers.
These descriptions are passed to \t{satOracle} and \t{satProve} to
select which SAT solver to invoke.

\paragraph{{\tt tmp\_name}, and {\tt prefix}}${}$\\

The reference \t{tmp\_name} contains the temporary file name used in
the last invocation of a SAT solver  by \t{satOracle} or \t{satProve}. This name
was generated using \t{FileSys.tmpName}.

The reference \t{prefix} contains the string that is concatenated to numbers
to get the \HOL{} variables used when reading a separately generated DIMACS file
with \t{readDimacs}. Default value is {\verb+"v"+}.

\paragraph{\tt satOracle}${}$\\
\index{HolSatLib!satOracle@\ml{satOracle}}
{\small{\tt satOracle}~{\it solver}~{\it term}}


\begin{enumerate}
\item writes a DIMACS format file corresponding to {\it term} (the input name is {\it tmp}{\tt{.cnf}}, where the string {\it tmp} is in the reference \t{tmp\_name})

\item invokes {\it solver} on the file and writes results to an output file

\begin{enumerate}
\item the default settings (time, verbosity etc.) supplied by {\it solver}
are used
\item the output file name is {\it tmp}{\tt{.}}{\it{name}}, where
the string {\it tmp} is in the reference \t{tmp\_name}
and {\it name} is the string given as the value of the field {\tt name} of {\it solver}
\end{enumerate}

\item parses the output file to see if a model was found and if so extracts it

\begin{enumerate}
\item the presence of the string given as the value of the
field \\ {\tt failure\_string} in {\it solver} is
assumed to indicate that {\it term} is unsatisfiable
\item if {\it term} is not unsatisfiable,
the model is assumed to be supplied as a list of integers in the output file 
{\it tmp}{\tt{.}}{\it{name}} between the strings
given as the values of the fields {\tt start\_string} and {\tt end\_string}
in {\it solver}
\item if the value of the field {\tt only\_true} is
\t{true} then it is assumed that only the positive literals
of the model are given and so
the negative literals are taken to be the negations of those variables
occurring in {\it term}, but not in the computed model
\end{enumerate}


\item creates a theorem, tagged with the name of {\it solver}, showing the result

\begin{enumerate}

\item if {\it term} is unsatisfiable the result is the tagged theorem $\turn \neg term$.
\item if a model is found the result is the tagged theorem $\turn model \Rightarrow term$,
where {\it model} is the conjunction of the literals extracted from the model.
\item the oracle tag is the name of {\it solver}.
\end{enumerate}
\end{enumerate}

\paragraph{\tt satProve}${}$\\
\index{HolSatLib!satProve@\ml{satProve}}
{\small{\tt satProve}~{\it solver}~{\it term}} goes through the same steps 1,2 and 3 
as {\tt satOracle}, but instead of step 4

\begin{enumerate}
\item  if a model is found, then proof in \HOL{} is used to first check the model
is really a model (by `evaluating' {\it term} using the model) and if it
is an untagged theorem $\turn model \Rightarrow term$ is returned.

\item if a model is found by {\it solver}, but the \HOL{} check fails, 
i.e.~the model is invalid, then the exception \t{satProveError} is raised.

\item if {\it term} is found to be unsatisfiable by {\it solver},
the exception \\ \t{satProveError} is raised.

\end{enumerate}

\paragraph{\tt SAT\_TAUT\_PROVE}${}$\\
\index{HolSatLib!SAT\_TAUT\_PROVE@\ml{SAT\_TAUT\_PROVE}}

Attempts to prove that the supplied term is a tautology by

\begin{enumerate}
\item Negating the input term
\item Converting that to definitional CNF
\item Passing it to MINISAT with proof logging turned on
\item If unsatisfiable, using the proof log to construct a ground refutation in HOL
\end{enumerate}

If MINISAT was not properly installed or fails for some other reason, \t{SAT\_TAUT\_PROVE} 
falls back to a much slower propositional tautology prover implemented in SML.

\paragraph{\tt readDimacs}${}$\\

{\small{\tt readDimacs}~{\it file}} reads a DIMACS format file and returns
a CNF \HOL{} term corresponding to the SAT problem in the file names {\it file}.
The integers in the file are prefixed with the string in the reference 
\t{prefix} (the default is {\small\verb+"v"+}).

%{\small{\tt readDimacs}} is mainly intended as a tool for getting CNF examples by reading in examples from the DIMACS problem set,which is distributed with {\tt HolSatLib} in the directory{\tt HolSatLib/doc/DIMACS} or is available from\\{\tt ftp://dimacs.rutgers.edu/pub/challenge/satisfiability/benchmarks/cnf/}.

\subsubsection{Contents of {\tt SatSolvers} module}
\index{HolSatLib!sat\_solver@\ml{sat\_solver}}
{\tt SatSolvers} contains the definition of the datatype \t{sat\_solver} for specifying SAT solvers.


The data that is supplied as an argument to the constructor \t{SatSolver}
has the following fields.

\medskip

\begin{tabular}{lp{4.75in}}
\t{name} & name of the SAT solver \\

\t{URL} & URL of the SAT executable for downloading\\

\t{executable} &
name of the SAT solver command\\

\t{notime\_run} &
evaluating \t{notime\_run}{\it~ex~(infile,outfile)} returns a string giving a command to execute to run the SAT solver from input {\it infile} and produce output {\it outfile}; the paramenter {\it ex} should be the full path name of the  SAT solver command all command options are the defaults (see solver documentation)\\

\t{time\_run} &
evaluating \t{time\_run}{\it~ex~((infile,outfile),time)} returns a string giving a command to execute to run the SAT solver for {\it time} units of time (the units are specified in the SAT solver's documentation) from input {\it infile} and produce output {\it outfile}; the paramenter {\it ex} should be the full path name of the  SAT solver command; all command options, besides the time, are the defaults (currently \t{time\_run} is not used)\\

\t{failure\_string} & string whose presence in the solver output indicated unsatisfiability\\


\t{start\_string} &
string indicating start of model \\


\t{end\_string} &
string indicating end of model \\

\end{tabular}

\medskip

Note that if a model is found, it is assumed to be bracketed
by \\ \t{start\_string} and \t{end\_string}. SAT solvers 
(like {\tt satz}\footnote{\url{http://www.laria.u-picardie.fr/~cli/EnglishPage.html}})
for which models are not bracketed by a fixed pair of strings cannot currently
be specified for use with {\tt HolSatLib}. If access to such solvers is needed, then
it will be necessary to extend the datatype \t{sat\_solver} to contain
additional parsing data (e.g.~regular expressions).

\subsubsection{Conversion to CNF}

\HOL{} provides several facilities for converting terms to CNF. The module {\tt defCNF} contains a  conversion  {\tt DEF\_CNF\_CONV : term -> thm},\index{HolSatLib!DEF\_CNF\_CONV@\ml{DEF\_CNF\_CONV}} from Joe Hurd, to convert \HOL{} terms to a form suitable for input to \t{satOracle} or \t{satProve} (note that {\tt SAT\_TAUT\_PROVE} does not require its argument to be in CNF). 

{\small\verb+DEF_CNF_CONV+}~$t$ returns a theorem $\turn t = t'$,
where $t'$ is in CNF. The conversion is {\it definitional} in that it may introduce extra variables not found in the original term. The advantage is that the conversion will take time linear in the size of the original term, unlike a normal CNF conversion. 

Note that {\tt DEF\_CNF\_CONV} is not a ``drop-in'' replacement for {\tt CNF\_CONV}, since the right-hand side of the CNF conversion theorem is existentially quantified over the freshly generated variables. A more efficient version of this is {\tt DEF\_CNF\_VECTOR\_CONV}, which replaces the definitional variables wit a single variable vector, thus requiring a single existential quantifier.

There are other tools for converting to various canonical forms. See the source code
{\small\verb+src/metis/normalForms.sml+} for details.

\index{HolSatLib|)}

%\end{document}
