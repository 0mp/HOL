\chapter{Principi Avanzati di Definizione}\label{HOLdefinitions}

\section{I Datatype}\label{sec:datatype}
\index{definizioni di tipo, nella logica HOL@definizioni di tipo, nella logica \HOL{}!tipi algebrici}
\index{Hol_datatype@\ml{Hol\_datatype}|(}
\index{tipi di dato algebrici|see{\ml{Hol\_datatype}}}
\index{tipi di dato!definizione in HOL@definizione in \HOL{}}
\index{tipi di dato!definizione in HOL@definizione in \HOL{}|seealso{\ml{Hol\_datatype}}}

Nonostante la logica \HOL{} fornisca principi primitivi di definizione 
che permettono di introdurre nuovi tipi, il livello di dettaglio è 
a grana molto fine. Lo stile delle definizioni di datatype nei linguaggi 
di programmazione funzionale fornisce una motivazione per un interfaccia di 
alto livello per definire datatype algebrici.

La funzione \verb+Hol_datatype+ supporta la definizione di tali 
tipi di dato; le specifiche dei tipi possono essere ricorsive, mutuamente 
ricorsive, ricorsive annidate, e coinvolgere record. La sintassi delle 
dichiarazioni che \verb+Hol_datatype+ accetta si trova nella Tabella
\ref{datatype}.

\newcommand{\itelse}[3]{\mbox{$\mathtt{if}\ {#1}\ \mathtt{then}\ {#2}\ \mathtt{else}\ {#3}$}}

\newcommand{\bk}{\char'134}
\newcommand{\ident}      {\mbox{\it ident}}
\newcommand{\clause}      {\mbox{\it clause}}
\newcommand{\type}       {\mbox{\it hol\_type}}
{
\newcommand{\binding} {\mbox{\it binding}}
\newcommand{\recdspec}  {\mbox{\it record-spec}}
\newcommand{\constr} {\mbox{\it constructor-spec}}

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|rcl|}
\hline
\multicolumn{3}{|l|}
{\texttt{Hol\_datatype `}[\binding\ \texttt{;}]* \binding\texttt{`}}\\
& &\\
\binding & \verb+::=+ & \ident\ \verb+=+ \constr\\
         & \verb+|+ & \ident\ \verb+=+ \recdspec\\
& & \\
\constr & \verb+::=+ & [\clause\ \verb+|+]* \clause \\
& & \\
\clause & \verb+::=+ & \ident \\
        & \verb+|+ & \ident\ \verb+of+\ [\type\ \verb+=>+]* \type\\
& & \\
\recdspec & \verb+::=+ & \verb+<|+ [\ident\ \verb+:+ \type\ \verb+;+]*
                                   \ident\ \verb+:+ \type\ \verb+|>+\\

\hline
\end{tabular}
\caption{Dichiarazione di Datatype}\label{datatype}
\end{center}
\end{table}
}


\index{definizioni di tipo, nella logica HOL@definizioni di tipo, nella logica \HOL{}!mantenimento della TypeBase@mantenimento della \ml{TypeBase}}
\index{TypeBase@\ml{TypeBase}}
%
\HOL{} mantiene un database sottostante di fatti datatype chiamata la 
\ml{TypeBase}. Questo database è usato per supportare vari strumenti 
di dimostrazione di alto livello (si veda la Sezione~\ref{sec:bossLib}), ed è aumentato ogni volta 
che si fa una dichiarazione \verb+Hol_datatype+. Quando un datatype è 
definito per mezzo di \verb+Hol_datatype+, la seguente informazione è derivata 
e archiviata nel database.

\begin{itemize}
\item teorema d'inizializzazione per il tipo 
\item iniettività dei costruttori 
\item distinzione dei costruttori
\item teorema d'induzione strutturale
\item teorema di analisi dei casi
\item definizione della costante `case' per il tipo 
\item teorema di congruenza per la costante case
\item definizione della `dimensione' del tipo
\end{itemize}

Quando il sistema \HOL{} 
si avvia, la \ml{TypeBase} contiene già le voci rilevanti per 
i tipi \holtxt{bool}, \holtxt{prod}, \holtxt{num}, \holtxt{option},
e \holtxt{list}.

\paragraph{Esempio: Alberi Binari}
La seguente dichiarazione ML di un tipo di dati di alberi binari
\begin{hol}
\begin{verbatim}
  datatype ('a,'b) btree = Leaf of 'a
                         | Node of ('a,'b) btree * 'b * ('a,'b) btree
\end{verbatim}
\end{hol}
\noindent sarebbe dichiarata in \HOL{} come 
\begin{hol}
\begin{verbatim}
   Hol_datatype `btree = Leaf of 'a
                       | Node of btree => 'b => btree`
\end{verbatim}
\end{hol}
\noindent La notazione \holtxt{=>} in una descrizione di datatype HOL 
è intesa sostituire \holtxt{*} in una descrizione di datatype ML, 
e evidenzia il fatto che, in HOL, i costruttori sono di default 
curried. Si noti anche che non è menzionato alcun parametro di tipo 
per il nuovo tipo: le variabili di tipo sono sempre in ordine alfabetivo.

Vale la pena ripetere questo punto delicato: il formato delle definizioni di datatype 
non ha abbastanza informazione per determinare sempre l'ordine degli 
argomenti per gli operatori di tipo introdotti. Così, quando si definisce un tipo 
che è polimorfico in più di un argomento, c'è la questione di 
quale sarà l'ordine degli argomenti del nuovo operatore. Per un altro 
esempio, se si definisce
%
\begin{hol}
\begin{verbatim}
   Hol_datatype `sum = Left of 'left | Right of 'right`;
\end{verbatim}
\end{hol}
%
e poi si scrive \ml{('a,'b)sum}, il valore \ml{'a} sarà sotto il 
costruttore \ml{Left} o \ml{Right}? Il sistema sceglie di far apparire 
gli argomenti corrispondenti alla variabili nell'ordine dato dall'ordine 
alfabetico dei nomi delle variabili. Così, nell'esempio 
dato, l'\ml{'a} di \ml{('a,'b)sum} sarà l'argomento \ml{Left} 
perché \ml{left} viene prima di \ml{right} nell'ordine alfabetico 
standard (ASCII).

\subsection{Ulteriori esempi}

Nel seguito, daremo una panoramica del genere di tipi che 
possono essere definiti per mezzo di \ml{Hol\_datatype}.

Per iniziare, i tipi enumerati possono essere definiti come nel seguente esempio:
\begin{hol}
\begin{verbatim}
  Hol_datatype
    `enum = A1  | A2  | A3  | A4  | A5
          | A6  | A7  | A8  | A9  | A10
          | A11 | A12 | A13 | A14 | A15
          | A16 | A17 | A18 | A19 | A20
          | A21 | A22 | A23 | A24 | A25
          | A26 | A27 | A28 | A29 | A30`
\end{verbatim}
\end{hol}
%
Altri tipi non ricorsivi possono essere definiti così:
\begin{hol}
\begin{verbatim}
  Hol_datatype
    `foo = N of num
         | B of bool
         | Fn of 'a -> 'b
         | Pr of 'a # 'b`
\end{verbatim}
\end{hol}
%
Spostandoci ai tipi ricorsivi, abbiamo già visto un tipo di alberi 
binari che hanno valori polimorfici presso i nodi interni. Questa volta, 
li dichiareremo in formato ``accoppiato''.
\begin{hol}
\begin{verbatim}
  Hol_datatype
    `tree = Leaf of 'a
          | Node of tree # 'b # tree`
\end{verbatim}
\end{hol}
%
Questa specifica sembra più vicina alla dichiarazione che si potrebbe fare 
in ML, ma può essere più difficile da gestire nella dimostrazione rispetto al 
formato curried usato di sopra.

La sintassi di base del lambda calcolo denominato è facile da descrivere:
%
\begin{hol}
\begin{verbatim}
  Hol_datatype
    `lambda = Var of string
            | Const of 'a
            | Comb of lambda => lambda
            | Abs of lambda => lambda`
\end{verbatim}
\end{hol}
%
La sintassi per i termini `de Bruijn' è più o meno simile:
%
\begin{hol}
\begin{verbatim}
  Hol_datatype
    `dB = Var of string
        | Const of 'a
        | Bound of num
        | Comb  of dB => dB
        | Abs   of dB`
\end{verbatim}
\end{hol}
%
Gli alberi arbitrariamente ramificanti possono essere definiti permettendo a un nodo di mantenere 
la lista dei suoi sotto-alberi. In un tale caso, i nodi foglia non hanno bisogno di essere 
dichiarati esplicitamente.
%
\begin{hol}
\begin{verbatim}
  Hol_datatype
    `ntree = Node of 'a => ntree list`
\end{verbatim}
\end{hol}
%
Un tipo di `termini del primo ordine' può essere dichiarato nel modo seguente:
%
\begin{hol}
\begin{verbatim}
  Hol_datatype
    `term = Var of string
          | Fnapp of string # term list`
\end{verbatim}
\end{hol}
%
Possono anche essere definiti tipi mutuamente ricorsivi. Il seguente, estratto 
da Elsa Gunter da Definition of Standard ML, cattura un sottoinsieme di 
Core ML.
%
\begin{hol}
\begin{verbatim}
  Hol_datatype
    `atexp = var_exp of string
           | let_exp of dec => exp ;

       exp = aexp    of atexp
           | app_exp of exp => atexp
           | fn_exp  of match ;

     match = match  of rule
           | matchl of rule => match ;

      rule = rule of pat => exp ;

       dec = val_dec   of valbind
           | local_dec of dec => dec
           | seq_dec   of dec => dec ;

   valbind = bind  of pat => exp
           | bindl of pat => exp => valbind
           | rec_bind of valbind ;

       pat = wild_pat
           | var_pat of string`
\end{verbatim}
\end{hol}
%
Tipi record semplici possono essere introdotti usando la notazione \holtxt{<| ... |>}.
%
\begin{hol}
\begin{verbatim}
  Hol_datatype
    `state = <| Reg1 : num; Reg2 : num; Waiting : bool |>`
\end{verbatim}
\end{hol}
%
L'uso di tipi record può essere ricorsivo. Per esempio, la seguente 
dichiarazione potrebbe essere usata per formalizzare un semplice file system.
%
\begin{hol}
\begin{verbatim}
  Hol_datatype
    `file = Text of string | Dir of directory
       ;
     directory = <| owner : string ;
                    files : (string # file) list |>`
\end{verbatim}
\end{hol}

\subsection{Definizioni di tipo che falliscono}

Ora ci rivolgiamo ad alcuni tipi che non possono essere dichiarati con \ml{Hol\_datatype}. 
In alcuni casi essi non possono esistere del tutto in HOL; in altri, il tipo 
può essere incorporato nella logica HOL, ma \ml{Hol\_datatype} non è in grado di rendere 
la definizione.

Per prima cosa, un tipo vuoto non è permesso in HOL, così il seguente tentativo 
è destinato a fallire.
%
\begin{hol}
\begin{verbatim}
  Hol_datatype
    `foo = A of foo`
\end{verbatim}
\end{hol}
%
I cosiddetti `tipi annidati', che occasionalmente sono piuttosto utili, non possono 
al momento essere costruiti con \ml{Hol\_datatype}:
%
\begin{hol}
\begin{verbatim}
  Hol_datatype
    `btree = Leaf of 'a
           | Node of  ('a # 'a) btree`
\end{verbatim}
\end{hol}
%
I tipi non possono eseguire la ricorsione su entrambi i lati delle frecce funzione. La ricorsione 
sulla destra è coerente (si veda la teoria \theoryimp{inftree}), ma 
\ml{Hol\_datatype} non è in grado di definire tipi algebrici che 
la richiedono. Così, esempi come il seguente falliranno:
%
\begin{hol}
\begin{verbatim}
  Hol_datatype
    `flist = Nil
           | Cons of 'a => ('b -> flist)`
\end{verbatim}
\end{hol}
%
La ricorsione sulla sinistra deve fallire per ragioni di cardinalità. Per 
esempio, HOL non permette il seguente tentativo di modellare il lambda 
calcolo non tipizzato come un insieme (si noti la \holtxt{->} nella clausola per il 
costruttore \holtxt{Abs}):
%
\begin{hol}
\begin{verbatim}
  Hol_datatype
    `lambda = Var of string
            | Const of 'a
            | Comb of lambda => lambda
            | Abs of lambda -> lambda`
\end{verbatim}
\end{hol}

\subsection{Teoremi che sorgono da una definizione di datatype}

Le conseguenze di un'invocazione di \ml{Hol\_datatype} sono archiviate nell'attuale segmento di teoria e nella \ml{TypeBase}. 
Le principali conseguenze di una definizione di datatype sono i teoremi di ricorsione primitiva e d'induzione. 
Questi forniscono la capacità di definire semplici funzioni sul tipo, e un principio d'induzione per il tipo.
\index{teoremi d'induzione, nella logica HOL@teoremi d'induzione, nella logica \HOL{}!per tipi di dato algenrico}
Così, per un tipo denominato \holtxt{ty}, il teorema di ricorsione primitiva è archiviato sono \ml{ty\_Axiom} e il teorema d'induzione è messo sotto \ml{ty\_induction}.
Altre conseguenze includono la distinzione dei costruttori (\ml{ty\_distinct}), e l'iniettività dei costruttori (\verb+ty_11+). 
Una versione `degenerata' di \ml{ty\_induction} è anche archiviata sotto \ml{ty\_nchotomy}: essa prevede ragionamenti per casi sulla costruzione degli elementi di \ml{ty}.
Infine, sono archiviati alcuni teoremi per scopi speciali: per esempio, \ml{ty\_case\_cong} mantiene un teorema di congruenza per enunciati ``case'' su elementi di \ml{ty}. 
Questi enunciati case sono definiti da \ml{ty\_case\_def}.
Inoltre, è aggiunta alla teoria attuale una definizione della ``dimensione'' del tipo, sotto il nome \ml{ty\_size\_def}.

Per esempio, l'invocazione 
%
\begin{hol}
\begin{verbatim}
  Hol_datatype
    `tree = Leaf of num
          | Node of tree => tree`
\end{verbatim}
\end{hol}
%
risulta nel fatto che le definizioni
%
\begin{hol}
\begin{verbatim}
  tree_case_def =
    |- (!f f1 a. case f f1 (Leaf a) = f a) /\
       !f f1 a0 a1. case f f1 (Node a0 a1) = f1 a0 a1

  tree_size_def
    |- (!a. tree_size (Leaf a) = 1 + a) /\
       !a0 a1. tree_size (Node a0 a1) = 1 + (tree_size a0 + tree_size a1)
\end{verbatim}
\end{hol}
%
sono aggiunte alla teoria attuale. I seguenti teoremi circa i datatype 
sono inoltre dimostrati e archiviati nella teoria attuale.
%
\begin{hol}
\begin{verbatim}
  tree_Axiom
    |- !f0 f1.
       ?fn. (!a. fn (Leaf a) = f0 a) /\
            !a0 a1. fn (Node a0 a1) = f1 a0 a1 (fn a0) (fn a1)
  tree_induction
    |- !P. (!n. P (Leaf n)) /\
           (!t t0. P t /\ P t0 ==> P (Node t t0)) ==> !t. P t
  tree_nchotomy
    |- !t. (?n. t = Leaf n) \/ ?t' t0. t = Node t' t0
  tree_11
    |- (!a a'. (Leaf a = Leaf a') = (a = a')) /\
       !a0 a1 a0' a1'. (Node a0 a1 = Node a0' a1') = (a0=a0') /\ (a1=a1')
  tree_distinct
    |- !a1 a0 a. ~(Leaf a = Node a0 a1)
  tree_case_cong
    |- !M M' f f1.
        (M = M') /\
        (!a. (M' = Leaf a) ==> (f a = f' a)) /\
        (!a0 a1. (M' = Node a0 a1) ==> (f1 a0 a1 = f1' a0 a1))
          ==>
        (tree_CASE M f f1 M = tree_CASE M' f' f1')
\end{verbatim}
\end{hol}
%
Quando è definito un tipo che coinvolge record, molte più definizioni sono 
fatte e aggiunte alla teoria attuale.

Una definizione di tipo mutuamente ricorsiva ha come risultato che i 
teoremi e le definizioni di sopra sono aggiunte per ognuno dei tipi definiti.

\section{Tipi Record}\label{sec:records}
\index{definizioni di tipo, nella logica HOL@definizioni di tipo, nella logica \HOL{}!tipi record}
\index{tipi record}

I tipi record sono dei modi convenienti d'impacchettare insieme un numero di 
tipi componenti, e di dare a questi componenti dei nomi così da facilitare 
l'accesso ad essi. I tipi record sono semanticamente equivalenti a grandi 
tipi coppia (prodotto), ma la possibilità di etichettare i campi con nomi di 
propria scelta è una grande comodità. I tipi record come 
implementati in \HOL{} sono analoghi ai tipi \texttt{struct} del C e ai 
record del Pascal.

Costruiti correttamente, i tipi record forniscono utili funzionalità di manutenibilità. 
Se si può sempre accedere al campo {\tt fieldn} di un tipo record 
semplicemente scrivendo {\tt record.fieldn}, allora dei cambiamenti al tipo che 
risultano nell'aggiunta o cancellazione di altri campi non invalideranno 
questo riferimento. Una mancanza nei tipi record dell'SML è che non 
permettono la stessa manutenibilità quando sono interessati degli aggiornamenti 
(funzionali) dei record. L'implementazione HOL permette di scrivere
\begin{hol}
\begin{verbatim}
  rec with fieldn := new_value
\end{verbatim}
\end{hol}
che sostituisce il vecchio valore di {\tt fieldn} nel record {\tt rec}
con {\tt new\_value}. Non sarà necessario cambiare questa espressione se 
un altro campo è aggiunto, modificato o cancellato dalla definizione originale 
del record.

\paragraph{Definire un tipo record}
I tipi record sono definiti con la funzione \texttt{Hol\_datatype}, come 
discusso in precedenza. Per esempio, per creare un tipo record chiamato 
{\tt person} con campi booleani, stringa e numero chiamati {\tt
  employed}, {\tt name} e {\tt age}, si inserirebbe:
\begin{hol}
\begin{verbatim}
  Hol_datatype
    `person = <| employed : bool ;
                 age : num ;
                 name : string |>`
\end{verbatim}
\end{hol}
L'ordine in cui i campi sono inseriti non è significativo. Oltre 
a definire il tipo (chiamato {\tt person}), la funzione di definizione 
di datatype definisce anche due altre insiemi di costanti. Queste sono le 
funzioni di accesso al campo e le funzioni di aggiornamento funzionale. Le funzioni 
di accesso al campo hanno nomi della forma 
   $\langle$\textsl{record-type\/}$\rangle$\verb|_|$\langle$\textsl{field\/}$\rangle$.
Queste funzioni possono essere usate direttamente, o si può usare la notazione standard 
di accesso ai campi per accedere ai valori del campo di un record. Così, 
si scriverebbe l'espressione: \holtxt{bob.employed} allo scopo 
di restituire il valore del campo {\tt employed} di {\tt bob}. 
L'alternativa, \holtxt{person\_employed bob}, funziona, ma sarebbe 
stampata usando la prima sintassi, con il punto.\index{tipi record!notazione di selezione dei campi}

Alle funzioni di aggiornamento funzionale sono dati i nomi 
\mbox{``$\langle$\textsl{record-type}$\rangle$\texttt{\_}$\langle$\textsl{field}$\rangle$\texttt{\_fupd}''} 
per ciascun campo nel 
tipo. Esse prendono due argomenti, una funzione e un record da 
aggiornare. Il parametro funzione è un endomorfismo sul tipo del campo, 
così che il record risultante è lo stesso dell'originale, eccetto per il fatto che 
il campo specificato ha avuto la funzione applicata ad esso per 
generare il nuovo valore per quel campo. Esse possono essere scritte con la 
parola chiave \texttt{with} e l'operatore \texttt{updated\_by}. Così che 
%
\begin{hol}
\begin{verbatim}
  bob with employed updated_by $~
	$
\end{verbatim}
\end{hol}\noindent
%
è un valore record identico a \texttt{bob} eccetto per il fatto che il 
valore booleano nel campo \texttt{employed} è stato invertito.

Inoltre, c'è un addolcimento sintattico disponibile per permettere di scrivere un 
record con uno dei suoi campi sostituito da un valore specifico. Questo è 
fatto usando l'operatore \holtxt{:=} al posto di
\holtxt{updated\_by}:
%
\begin{hol}
\begin{verbatim}
  bob with employed := T
\end{verbatim}
\end{hol}
%
Questo forma è tradotta al momento del parsing per essere un uso del corrispondente 
aggiornamento funzionale, insieme con un udo del combinatorio-\textsf{K} dalla 
teoria \texttt{combin}. Perciò, l'esempio di sopra è in realtà
%
\begin{hol}
\begin{verbatim}
  bob with employed updated_by (K T)
\end{verbatim}
\end{hol}
%
che a sua volta è una forma più carina di
%
\begin{hol}
\begin{verbatim}
  person_employed_fupd (K T) bob
\end{verbatim}
\end{hol}
%
Se si desidera una catena di aggiornamenti, allora gli aggiornamenti multipli possono essere 
specificati all'interno di coppie \holtxt{<|}-\holtxt{|>}, separati da 
punti-e-virgola, così:
%
\begin{hol}
\begin{verbatim}
  bob with <| age := 10; name := "Child labourer" |>
\end{verbatim}
\end{hol}
%
Entrambe le forme di aggiornamento (usando \texttt{updated\_by} e \texttt{:=}) possono essere 
usati in una catena di aggiornamenti.

\paragraph{Specificare letterali record}

Il parser accetta liste di specifiche di campo tra coppie 
\holtxt{<|}-\holtxt{|>} senza la parola chiave \holtxt{with}.
Queste sono tradotte in sequenze di aggiornamenti di un valore arbitrario 
(letteralmente, il valore HOL \holtxt{ARB}), e sono trattate come letterali.
Così,
%
\begin{hol}
\begin{verbatim}
  <| age := 21; employed := F; name := "Layabout" |>
\end{verbatim}
\end{hol}

\paragraph{Usare i teoremi prodotti da definizioni di record}

Oltre a definire il tipo e le funzioni descritti di sopra, una definizione 
di tipo record dimostra anche una suite di utili teoremi. Questi sono tutti 
salvati (usando {\tt save\_thm}) nel segmento attuale.  %
%
\index{TypeBase@\ml{TypeBase}}
%
Alcuni sono anche aggiunti alle semplificazioni della \ml{TypeBase} per il 
tipo, così saranno automaticamente applicati quando si semplifica con il 
simpset \ml{srw\_ss()}, o con le tattiche \ml{RW\_TAC} e
\ml{SRW\_TAC} (si veda la Sezione~\ref{sec:simpLib}).

Tutti i teoremi sono salvati sotto i nomi che cominciano con il nome del 
tipo. La lista di sotto è un esempio dei teoremi dimostrati. Le 
stringhe d'identificazione sono suffissi appesi al nome del tipo al 
fine di generare il nome finale del teorema.

\newcommand{\rewruse}{Questo teorema è installato nella \texttt{TypeBase}.}
\newcommand{\field}[1]{\mbox{\it field}_{#1}}
\newcommand{\update}{\mbox{\tt\_fupd}}

\begin{description}
\item[\texttt{\_accessors}] Le definizioni delle funzioni di accesso.
  \rewruse
\item[\texttt{\_fn\_updates}] Le definizioni delle funzioni di aggiornamento 
  funzionale.
\item[\texttt{\_accfupds}] Un teorema che stabilisce forme più semplici per 
	espressioni che sono della forma $\field{i}\, (\field{j}\update\;f\; r)$. Se 
	$i = j$, allora il lato destro è $f (\field{i}(r))$, se no, è $(\field{i}\;r)$.
  \rewruse
\item[\texttt{\_component\_equality}] Un teorema che stabilisce che $(r_1 =
  r_2) \equiv \bigwedge_i (\field{i}(r_1) = \field{i}(r_2))$.
\item[\texttt{\_fupdfupds}] Un teorema che stabilisce che $\field{i}\update
  \;f \,(\field{i}\update \;g\;r) = \field{i}\update\;(f \circ g)\;r$.
  \rewruse
\item[\texttt{\_fupdcanon}] Un teorema che stabilisce i risultati di commutatività 
	per tutte le possibili coppie di aggiornamenti di campo. Essi sono costruiti in 
	un modo tale che se usati come riscritture, renderanno canoniche 
	le sequenze di aggiornamenti. Così, per tutti gli $i < j$, è generato \[
	\field{j}\update\;f\;(\field{i}\update\;g\;r) =
  \field{i}\update\;g\;(\field{j}\update\;f\;r)
  \]
 \rewruse
\end{description}

\paragraph{Record grandi} La dimensione di certi teoremi dimostrati nel 
pacchetto tipi record cresce come il quadrato del numero di campi nel 
record. (In particolare, i teoremi di canonicalizzazione dell'aggiornamento e 
e i teoremi \texttt{acc\_fupd} hanno questa proprietà.) Per evitare inefficienza 
con record grandi, l'implementazione dei tipi record usa una 
rappresentazione sottostante più efficiente quando il numero dei campi cresce 
troppo. Il punto esatto in cui è applicata questa ottimizzazione è applicata è 
controllato dalla variabile reference 
\texttt{Datatype.big\_record\_size}. Questo valore è inizializzato a 20, 
ma gli utenti possono cambiarlo a scelta.

Sfortunatamente, la rappresentazione di record grandi ha lo svantaggio che 
ogni funzione di aggiornamento e di accesso ha due forme: termini differenti che 
sono stampati allo stesso modo. Una forma è una semplice costante, ed è la forma 
prodotta quando un termine è sottoposto al parsing. L'altra è un pò più complicata, ma 
ammette l'uso di teoremi più piccoli quando dei valori record sono 
semplificati. Di conseguenza, si raccomanda che i nuovi teoremi, dimostrati 
dall'utente che menzionano campi di record grandi o aggiornamenti di campi passino 
attraverso una fase di semplificazione (\texttt{SIMP\_RULE}), applicando le 
riscritture della \texttt{TypeBase}, prima di essere salvati.

Il pretty-printing di record grandi può essere controllato con il 
flag di trace \texttt{pp\_bigrecs}.
\index{Hol_datatype@\ml{Hol\_datatype}|)}


\section{Tipi Quoziente}\label{quotients}
\index{definizioni di tipo, nella logica HOL@definizioni di tipo, nella logica \HOL{}!quozienti|(}
\index{tipi quoziente, definizione di}

\HOL{} fornisce una libreria per definire nuovi tipi che sono quozienti 
di tipi esistenti, rispetto alle relazioni di equivalenza parziale. 
Questa libreria è descritta in {\it ``Higher Order Quotients in Higher
Order Logic''} [HOQ], da cui è presa la seguente descrizione.

Si accede alla libreria quotient aprendo {\tt quotientLib}, 
il che rende accessibili tutti i suoi strumenti e teoremi.

La definizione di nuovi tipi corrispondenti ai quozienti di 
tipi esistenti per relazioni di equivalenza è chiamata ``sollevare'' 
i tipi da un livello inferiore, più rappresentativo a uno superiore 
più alto. Entrambi i livelli descrivono oggetti simili, ma 
alcuni dettagli che sono evidenti al livello inferiore non sono più 
visibili al livello superiore. La logica è semplificata.

Simply forming a new type does not complete the quotient operation.
Rather, one wishes to recreate the
%significant parts of the
pre-existing logical environment at the new,
higher, and more abstract level.  This includes not only the new
types, but also new versions of the constants that form and
manipulate values of those types, and also new versions of the
theorems that describe properties of those constants.  All of these
%must be recreated at the higher level, in order to
form a logical layer, above which all the lower representational details
may be safely and forever forgotten.

This can be done in a single call of the
main tool of this package.

\begin{hol}
\begin{verbatim}
define_quotient_types :
        {types: {name: string,
                 equiv: thm} list,
         defs: {def_name: string,
                fname: string,
                func: Term.term,
                fixity: Parse.fixity} list,
         tyop_equivs : thm list,
         tyop_quotients : thm list,
         tyop_simps : thm list,
         respects : thm list,
         poly_preserves : thm list,
         poly_respects : thm list,
         old_thms : thm list} ->
        thm list
\end{verbatim}
\end{hol}
{\tt define\_quotient\_types} takes a single argument which is a
record with the following fields.

{\it types\/} is a list of records, each of which contains two fields:
{\it name}, which is the name of a new quotient type to be created, and
{\it equiv}, which is
either 1)
a theorem that a binary relation {\it R\/}
is an equivalence relation
(see [HOQ] \S 4)
of the form
$$
\mbox{\tt |-}\
\forall x\ y.\ R\ x\ y \ \Leftrightarrow \
                (R\ x = R\ y),
$$
or 2)
a theorem that {\it R\/} is a nonempty partial equivalence relation,
(see [HOQ] \S 5)
of the form
$$
\mbox{\tt |-}\
(\exists x.\ R\ x\ x) \ \wedge \
(\forall x\ y.\ R\ x\ y \ \Leftrightarrow \
                R\ x\ x \wedge R\ y\ y \wedge (R\ x = R\ y)).
$$
The process of forming the new quotient types is described
in [HOQ] \S 8.

{\it defs\/} is a list of records specifying the constants to be lifted.
Each record contains the following four fields:
{\it func\/} is an HOL term, which must be a single constant, which is the
constant to be lifted.
{\it fname\/} is the name of the new constant being defined as the lifted version of {\it func}.
{\it fixity\/} is the HOL fixity of the new constant being created,
as specified in the HOL structure {\tt Parse}.
{\it def\_name} is the name under which the new constant definition is to
be stored in the current theory.
The
process of defining lifted constants
is described in [HOQ] \S 9.

{\it tyop\_equivs\/} is a list of conditional equivalence theorems
for type operators (see [HOQ] \S 4.1).
These are used for bringing into regular form
theorems on new type operators, so that they can be lifted
(see [HOQ] \S 11 and \S 12).

{\it tyop\_quotients\/} is a list of conditional quotient theorems
for type operators (see [HOQ] \S 5.2).
These are used for lifting both constants and theorems.

{\it tyop\_simps\/} is a list of theorems used to simplify type operator
relations and map functions, e.g.,
for pairs,
{\tt |- (\$= \#\#\# \$=) = \$=} and
{\tt |- (I \#\# I) = I}.

The rest of the arguments refer to the general process of lifting theorems
over the quotients being defined,
as described in [HOQ] \S 10.

{\it respects\/} is a list of theorems about the respectfulness of the
constants being lifted.
These theorems are described in
[HOQ] \S 10.1.

{\it poly\_preserves\/} is a list of theorems about the preservation of
polymorphic constants in the HOL logic
across a quotient operation.
%as if they were definitions across the quotient operation.
In other words, they state that any quotient operation preserves these
constants as a homomorphism.
These theorems are described in
[HOQ] \S 10.2.

{\it poly\_respects\/} is a list of theorems showing the respectfulness
of the polymorphic constants mentioned in {\it poly\_preserves}.
These are
described in
[HOQ] \S 10.3.

{\it old\_thms\/} is a list of theorems concerning the lower, representative
types and contants, which are to be automatically lifted and proved at the
higher, more abstract quotient level.
These theorems are described in
[HOQ] \S 10.4.

{\tt define\_quotient\_types} returns a list of theorems, which are the
lifted versions of the {\it old\_thms}.

A similar function,
{\tt define\_quotient\_types\_rule}, takes a single argument which is a
record with the same fields as above except for {\it old\_thms},
and returns an SML function of type {\tt thm -> thm}.
This result, typically called {\tt LIFT\_RULE},
is then used to lift the old theorems individually, one at a time.

For backwards compatibility with
the excellent quotients package
{\tt EquivType}
created by
John Harrison
%to whom much credit is due, and
(which provided much inspiration),
the following function is also provided:

\begin{hol}
\begin{verbatim}
define_equivalence_type :
        {name: string,
         equiv: thm,
         defs: {def_name: string,
                fname: string,
                func: Term.term,
                fixity: Parse.fixity} list,
         welldefs : thm list,
         old_thms : thm list} ->
        thm list
\end{verbatim}
\end{hol}
\noindent
This function is limited to a single quotient type, but may be
more convenient when the generality of {\tt define\_quotient\_types}
is not needed.
This function is defined in terms of {\tt define\_quotient\_types} as

\begin{hol}
\begin{verbatim}
fun define_equivalence_type {name,equiv,defs,welldefs,old_thms} =
    define_quotient_types
     {types=[{name=name, equiv=equiv}], defs=defs, tyop_equivs=[],
      tyop_quotients=[FUN_QUOTIENT],
      tyop_simps=[FUN_REL_EQ,FUN_MAP_I], respects=welldefs,
      poly_preserves=[FORALL_PRS,EXISTS_PRS],
      poly_respects=[RES_FORALL_RSP,RES_EXISTS_RSP],
      old_thms=old_thms};
\end{verbatim}
\end{hol}
\index{type definitions, nella logica HOL@type definitions, nella logica \HOL{}!quotients|)}


\section{Case Expressions}\label{CaseExp}
\index{case expressions|(}

Within the HOL{} logic, case expressions provide a very compact and convenient notation for multi-way selection among the values of several expressions.
This is modeled on the case constructs in functional programming languages such as Standard ML.
Such case expressions can simplify the expression of complicated branches between different cases or combinations of cases.
The basic syntax (where the non-terminal $\mathit{term}$ stands for any \HOL{} term) is
\begin{eqnarray*}
\mathit{term} & ::= & \texttt{case}\;\mathit{term}\;\texttt{of}\;\mathit{cases}\\
\mathit{cases} &::= & \mathit{case}_1 \;\mathit{morecases}\\
\mathit{case}_1 & ::= & \texttt{\bfseries |}\;\mathit{case} \;\;\;|\;\;\;\mathit{case}\\
\mathit{morecases} & ::= & \varepsilon\;\;\;|\;\;\;\texttt{|}\;\mathit{case}\;\mathit{morecases}\\
\mathit{case} & ::= & \mathit{term} \;\texttt{=>}\; \mathit{term}
\end{eqnarray*}
The choice in the rule for the first case ($\mathit{case}_1$) allows the use of more uniform syntax, where every case is preceded by a vertical bar.
Omitting the bar, which is what the pretty-printer does when the syntax is printed, conforms with the syntax used by SML.

Based on the value of a test expression, a list of pattern expressions
are considered in sequence to see if they match the test expression.
The first pattern which successfully matches causes its associated result
expression to be evaluated and its value yielded as the value of the
entire case expression.  For example,
%
\begin{hol}
\begin{verbatim}
  case n of
     0 => "none"
   | 1 => "one"
   | 2 => "two"
   | _ => "many"
\end{verbatim}
\end{hol}
%

This could have been expressed using several ``if--then--else'' constructs,
but the case expression is much more compact and clean, with the
selection between various choices made clearly evident.

In addition to literals as patterns, as above, patterns may be
constructor expressions.  Many standard HOL{} types have constructors,
including \ml{num}, \ml{list}, and \ml{option}.
%
\begin{hol}
\begin{verbatim}
  case spouse(employee) of
   | NONE   => "single"
   | SOME s => "married to " ++ name_of s
\end{verbatim}
\end{hol}
(This example uses the optional bar in front of the first case.)

HOL{} supports a rich structure of case expressions using a single
notation.  The format is related to that of definitions of recursive
functions, as described in Section~\ref{TFL}.  In addition, case
expressions may contain literals as patterns, either singly or as
elements of deeply nested patterns.

Case expressions may test values of any type.  If the test expression
is a type with constructors, then the patterns may be expressed
using the constructors applied to arguments, as for example \ml{SOME s}
in the example above.  A free variable within the constructor pattern,
for example \ml{s} in the pattern \ml{SOME s}, becomes bound to the
corresponding value within the value of the test expression, and
can be used within the associated result expression for that pattern.

In addition to the constructors of standard types in HOL{},
constructor patterns may also be used for types created by use of the
datatype definition facility described in Section~\ref{sec:datatype},
including user-defined types.

Whether or not the test expression is a type with constructors,
the patterns may be expressed using the appropriate literals of that type,
if any such literals exist.
A complex pattern may contain either or both of literals and constructor
patterns nested within it.
However, literals and constructors may not be mixed as alternatives of
each other within the same case expression,
except insofar as a particular pattern may be both a literal
and also a (0-ary) constructor of its type, as for example \ml{0} (zero)
is both a literal and a constructor of the type \ml{num}.
Here is an example of this kind of improper mixture.
%
\begin{hol}
\begin{verbatim}
  case n of
     0 => "none"
   | 1 => "one"
   | 2 => "two"
   | SUC m => "many"
\end{verbatim}
\end{hol}
%
In this pattern, the constructor pattern \ml{SUC m} is given as
an alternative to the literal patterns \ml{1} and \ml{2}.
This makes this attempted case expression invalid.
Deleting either group of rows would resolve the conflict,
and make the expression valid.
Note that the pattern \ml{0} is acceptable to either group.

Patterns can be nested as well, as shown in the next example, where
the function \ml{parents} returns a pair containing the person's father
and/or mother, where each is represented by \ml{NONE} if deceased.
%
\begin{hol}
\begin{verbatim}
  case parents(john) of
     (NONE,NONE) => "orphan"
   | _ => "not an orphan"
\end{verbatim}
\end{hol}
%
This shows the nesting of option patterns within a pair pattern,
and also the use of a wildcard \ml{\_} to match the cases not given.

If the set of patterns is sparse, there may be several new rows generated
automatically to fill it out, and possibly some new variables or the
\ml{ARB} constant to properly represent the case expression.
%
\begin{hol}
\begin{verbatim}
- ``case a of
      (1, y, z) => y + z
    | (x, 2, z) => x - z
    | (x, y, 3) => x * y``;
> val it =
    ``case a of
        (1,2,3) => 2 + 3
      | (1,2,z) => 2 + z
      | (1,y,3) => y + 3
      | (1,y,z) => y + z
      | (x,2,3) => x - 3
      | (x,2,z') => x - z'
      | (x,y',3) => x * y'
      | (x,y',z') => ARB`` : term
\end{verbatim}
\end{hol}

This is just a brief description of some of the
expressive capabilities of the case expression with patterns.
Many more examples of patterns are provided in Section~\ref{TFL}
on the definition of recursive functions.

\index{case expressions|)}


\section{Recursive Functions}\label{TFL}

HOL{} provides a function definition mechanism based on the
wellfounded recursion theorem proved in \theoryimp{relationTheory},
discussed in Section~\ref{relation}.  \ml{Define} takes a high-level,
possibly recursive, specification of a function, and attempts to
define the function in the logic. \ml{Define} may be used to define
abbreviations, recursive functions, and mutually recursive
functions. An induction theorem may be generated as a by-product of
\ml{Define}'s activity. This induction theorem follows the recursion
structure of the function, and may be useful when proving properties
of the function. \ml{Define} is not always successful in attempting
to make the specified definition, usually because an automatic
termination proof fails; in that case, another entrypoint, \ml{Hol\_defn},
which defers the termination proof to the user, can be used.
The technology underlying \ml{Define} and \ml{Hol\_defn} is explained
in detail in Slind~\cite{slind-thesis}.


\index{Define@\ml{Define}}

 In particular, \ml{Define} takes as input a quotation representing a
conjunction of equations. The specified function(s) may be phrased
using ML-style pattern-matching. A call
\ml{Define `}\textit{spec}\ml{`} should conform with the grammar in Table
\ref{define:syntax}.
\begin{table}[htbp]
\begin{center}
$
\begin{array}{|rll|}
\hline
\mathit{spec} & ::= &  \mathit{eqn} \\
              & \mid  & (\mathit{eqn}) \land \mathit{spec} \\
  & & \\
\mathit{eqn} & ::= & \mathit{alphanumeric}\ \mathit{pat} \ldots \mathit{pat} = \mathit{term} \\
  & & \\
  & & \\
\mathit{pat} & ::= & \mathit{variable} \\
    & \mid   & \mathit{wildcard} \\
    & \mid   & \mathit{cname} \\
    & \mid   & (\mathit{cname}_n\ \mathit{pat}_1 \ldots \mathit{pat}_n) \\
  & & \\
\mathit{cname} & ::= & \mathit{alphanumeric} \mid \mathit{symbolic} \\
  & & \\
\mathit{wildcard} & ::=  & \_\!\_ \\
                  & \mid & \_\!\_ \mathit{wildcard} \\
  & & \\
\hline
\end{array}
$
\caption{Syntax of Function Declaration}\label{define:syntax}
\end{center}
\end{table}

\paragraph{Pattern Expansion}
In general, \ml{Define} attempts to derive exactly the specified
conjunction of equations. However, the rich syntax of patterns allows
some ambiguity. For example, the input
%
\begin{hol}
\begin{verbatim}
  Define `(f 0 _ = 1)
    /\    (f _ 0 = 2)`
\end{verbatim}
\end{hol}
%
is ambiguous at \holtxt{f 0 0}: should the result be \holtxt{1} or
\holtxt{2}?  This ambiguity is dealt with in the usual way for compilers and
interpreters for functional languages: namely, the conjunction of
equations is treated as being applied left-conjunct first, followed
by processing the right conjunct. Therefore, in the example above, the
value of \holtxt{f 0 0} is \holtxt{1}. In the implementation,
ambiguities arising from such overlapping patterns are systematically
translated away in a pre-processing step.

 Another case of ambiguity in patterns is shown above: the specification
is incomplete since it does not tell how \holtxt{f} should behave when
applied to two non-zero arguments: e.g., \holtxt{f (SUC m) (SUC n)}. In the
implementation, such missing clauses are filled in, and have the value
\holtxt{ARB}. This `pattern-completion` step is a way of turning descriptions
of partial functions into total functions suitable for HOL. However,
since the user has not completely specified the function, the system
takes that as a hint that the user is not interested in using the
function at the missing-but-filled-in clauses, and so such clauses are
dropped from the final theorem.

In summary, \ml{Define} will derive the unambiguous and complete
equations
%
\begin{hol}
\begin{verbatim}
  |- (f 0 (SUC v4) = 1) /\
     (f 0 0 = 1) /\
     (f (SUC v2) 0 = 2)
     (f (SUC v2) (SUC v4) = ARB)
\end{verbatim}
\end{hol}
%
from the above ambiguous and incomplete equations. The odd-looking
variable names are due to the pre-processing steps described above. The
above result is only an intermediate value: in the final result returned
by \ml{Define}, the last equation is droppped since it was not
specified by the original input.
\begin{hol}
\begin{verbatim}
  |- (f 0 (SUC v4) = 1) /\
     (f 0 0 = 1) /\
     (f (SUC v2) 0 = 2)
\end{verbatim}
\end{hol}

\paragraph{Termination}

When processing the specification of a recursive function, \ml{Define}
must perform a termination proof. It automatically constructs
termination conditions for the function, and invokes a termination
prover in an attempt to prove the termination conditions.  If the
function is primitive recursive, in the sense that it exactly follows
the recursion pattern of a previously declared HOL datatype, then this
proof always succeeds, and \ml{Define} stores the derived equations in
the current theory segment.
Otherwise, the function is not an
instance of primitive recursion, and the termination prover may
succeed or fail. If the termination proof fails, then \ml{Define} fails.
If it succeeds, then \ml{Define} stores the specified equations in the
current theory segment. An induction theorem customized for the defined
function is also stored in the current segment. Note, however, that an
induction theorem is not stored for primitive recursive functions, since
that theorem would be identical to the induction theorem resulting from
the declaration of the datatype.


\paragraph{Storing definitions in the theory segment}

 \ml{Define} automatically generates names with which to store the
definition and, (if it exists) the associated induction theorem, in
the current theory. The name for storing the definition is built by
concatenating the name of the function with the value of the reference
variable \ml{Defn.def\_suffix}. The name for storing the induction theorem
is built by concatenating the name of the function with the value of
the reference variable \ml{Defn.ind\_suffix}. For mutually recursive
functions, where there is a choice of names, the name of the function
in the first clause is taken.

 Since the names used to store elements in the current theory segment
are transformed into ML bindings after the theory is exported, it is
required that every invocation of \ml{Define} generate names that are
valid ML identifiers. For this reason, \ml{Define} requires
alphanumeric function names. If one wishes to define symbolic
identifiers, the ML function \ml{xDefine} should be used.

\index{xDefine@\ml{xDefine}}
\begin{hol}
\begin{verbatim}
  xDefine : string -> term quotation -> thm
\end{verbatim}
\end{hol}
The \ml{xDefine} function is identical to
\ml{Define} except that it takes an explicit name to use when
storing the definition in the current theory.

\subsection{Function definition examples}
 We will give a number of examples that display the range of functions
that may be defined with \ml{Define}. First, we have a recursive function
that uses ``destructors'' in the recursive call.

\begin{hol}
\begin{verbatim}
  Define
    `fact x = if x = 0 then 1 else x * fact(x-1)`;

  Equations stored under "fact_def".
  Induction stored under "fact_ind".
  > val it = |- fact x = (if x = 0 then 1 else x * fact (x - 1)) : thm
\end{verbatim}
\end{hol}
%
Since \holtxt{fact} is not
primitive recursive, an induction theorem for \holtxt{fact} is generated and
stored in the current theory.
%
\begin{hol}
\begin{verbatim}
  - DB.fetch "-" "fact_ind";

  > val it =
     |- !P. (!x. (~(x = 0) ==> P (x - 1)) ==> P x) ==> !v. P v : thm
\end{verbatim}
\end{hol}

Next we have a recursive function with relatively complex
pattern-matching. We omit to examine the generated induction
theorem.
%
\begin{hol}
\begin{verbatim}
  Define `(flatten  []           = [])
     /\   (flatten ([]::rst)     = flatten rst)
     /\   (flatten ((h::t)::rst) = h::flatten(t::rst))`;

  Equations stored under "flatten_def".
  Induction stored under "flatten_ind".

  > val it =
      |- (flatten [] = []) /\
         (flatten ([]::rst) = flatten rst) /\
         (flatten ((h::t)::rst) = h::flatten (t::rst)) : thm
\end{verbatim}
\end{hol}

Next we define a curried recursive function, which uses
wildcard expansion and pattern-matching pre-processing.
%
\begin{hol}
\begin{verbatim}
  Define `(min (SUC x) (SUC y) = min x y + 1)
     /\   (min  ____    ____   = 0)`;

  Equations stored under "min_def".
  Induction stored under "min_ind".

  > val it =
      |- (min (SUC x) (SUC y) = min x y + 1) /\
         (min (SUC v2) 0 = 0) /\
         (min 0 v1 = 0) : thm
\end{verbatim}
\end{hol}

 Next we make a primitive recursive definition. Note that no
induction theorem is generated in this case.
%
\begin{hol}
\begin{verbatim}
  Define `(filter P [] = [])
    /\    (filter P (h::t) = if P h then h::filter P t else filter P t)`;

  Definition has been stored under "filter_def".

  > val it =
     |- (!P. filter P [] = []) /\
        !P h t. filter P (h::t) =
                 (if P h then h::filter P t else filter P t) : thm
\end{verbatim}
\end{hol}

\ml{Define} may also be used to define mutually recursive functions.
For example, we can define a datatype of propositions and a function for
putting a proposition into negation normal form as follows.
First we define a datatype, named \ml{prop}, of boolean formulas:
%
\begin{hol}
\begin{verbatim}
  Hol_datatype
    `prop = VAR of 'a
          | NOT of prop
          | AND of prop => prop
          | OR  of prop => prop`;
\end{verbatim}
\end{hol}
%
Then two mutually recursive functions \holtxt{nnfpos} and \holtxt{nnfneg}
are defined:
%
\begin{hol}
\begin{verbatim}
  Define
     `(nnfpos (VAR x)   = VAR x)
   /\ (nnfpos (NOT p)   = nnfneg p)
   /\ (nnfpos (AND p q) = AND (nnfpos p) (nnfpos q))
   /\ (nnfpos (OR p q)  = OR  (nnfpos p) (nnfpos q))

   /\ (nnfneg (VAR x)   = NOT (VAR x))
   /\ (nnfneg (NOT p)   = nnfpos p)
   /\ (nnfneg (AND p q) = OR  (nnfneg p) (nnfneg q))
   /\ (nnfneg (OR p q)  = AND (nnfneg p) (nnfneg q))`
\end{verbatim}
\end{hol}
%
The system makes the definition and returns the theorem
%
\begin{hol}
\begin{verbatim}
  |- (nnfpos (VAR x) = VAR x) /\
     (nnfpos (NOT p) = nnfneg p) /\
     (nnfpos (AND p q) = AND (nnfpos p) (nnfpos q)) /\
     (nnfpos (OR p q) = OR (nnfpos p) (nnfpos q)) /\
     (nnfneg (VAR x) = NOT (VAR x)) /\
     (nnfneg (NOT p) = nnfpos p) /\
     (nnfneg (AND p q) = OR (nnfneg p) (nnfneg q)) /\
     (nnfneg (OR p q) = AND (nnfneg p) (nnfneg q)) : thm
\end{verbatim}
\end{hol}

\ml{Define} may also be used to define non-recursive functions.
%
\begin{hol}
\begin{verbatim}
  Define
    `f x (y,z) = (x + 1 = y DIV z)`;
\end{verbatim}
\end{hol}

\ml{Define} may also be used to define non-recursive functions
with complex pattern-matching. The pattern-matching pre-processing of
{Define} can be convenient for this purpose, but can also generate a
large number of equations. For example:
%
\begin{hol}
\begin{verbatim}
  Define
    `(g (0,_,_,_,_) = 1) /\
     (g (_,0,_,_,_) = 2) /\
     (g (_,_,0,_,_) = 3) /\
     (g (_,_,_,0,_) = 4) /\
     (g (_,_,_,_,0) = 5)`
\end{verbatim}
\end{hol}
%
yields a definition with thirty-one clauses.


\subsection{When termination is not automatically proved}

If the termination proof for a prospective definition
fails, the invocation of \ml{Define} (or \ml{xDefine}) fails. In such
situations, the \ML{} function \ml{Hol\_defn} should be used.
%
\index{Hol_defn@\ml{Hol\_defn}}

\begin{hol}
\begin{verbatim}
  Hol_defn : string -> term quotation -> Defn.defn
\end{verbatim}
\end{hol}

\ml{Hol\_defn} makes the requested definition, but defers the proof of
termination to the user. For setting up termination proofs, there are
several useful entrypoints, namely
\begin{hol}
\begin{verbatim}
  Defn.tgoal  : Defn.defn -> GoalstackPure.proofs
  Defn.tprove : Defn.defn * tactic -> thm * thm
\end{verbatim}
\end{hol}
\ml{Defn.tgoal} is analogous to \ml{set\_goal} and \ml{Defn.tprove} is
analogous to \ml{prove}. Thus, \ml{Defn.tgoal} is used to take the
result of \ml{Hol\_defn} and set up a goal for proving termination
of the definition.

\paragraph{Example.} An invocation of {\small\verb+Define+} on
the following equations for Quicksort will currently fail, since the
termination proof is currently beyond the capabilities of the naive termination
prover. Instead, we make an application of {\small\verb+Hol_defn+}:

\setcounter{sessioncount}{0}
\begin{session}
\begin{verbatim}
 val qsort_def =
  Hol_defn "qsort"
    `(qsort ord [] = []) /\
     (qsort ord (h::t) =
         qsort ord (FILTER (\x. ord x h) t)
         ++ [h] ++
         qsort ord (FILTER (\x. ~(ord x h)) t))`
\end{verbatim}
\end{session}
which returns the following value of type \ml{defn}, but does not try
to prove termination.
\begin{session}
\begin{verbatim}
  HOL function definition (recursive)

  Equation(s) :
   [...] |- qsort ord [] = []
   [...]
  |- qsort ord (h::t) =
     qsort ord (FILTER (\x. ord x h) t) ++ [h] ++
     qsort ord (FILTER (\x. ~ord x h) t)

  Induction :
   [...]
  |- !P.
       (!ord. P ord []) /\
       (!ord h t.
          P ord (FILTER (\x. ~ord x h) t) /\
          P ord (FILTER (\x. ord x h) t) ==>
          P ord (h::t)) ==>
       !v v1. P v v1

  Termination conditions :
    0. !t h ord. R (ord,FILTER (\x. ~ord x h) t) (ord,h::t)
    1. !t h ord. R (ord,FILTER (\x. ord x h) t) (ord,h::t)
    2. WF R
\end{verbatim}
\end{session}

The type \ml{defn} has a prettyprinter installed for it: the above
output is typical, showing the components of a \ml{defn} in an understandable
format. Although it is possible to directly work with elements of
type \ml{defn}, it is more convenient to invoke
\ml{Defn.tgoal}, which sets up a termination proof in a goalstack.
%
\begin{session}
\begin{verbatim}
  Defn.tgoal qsort_def;

  > val it =
    Proof manager status: 1 proof.
    1. Incomplete:
         Initial goal:
         ?R.
           (!t h ord. R (ord,FILTER (\x. ~ord x h) t) (ord,h::t)) /\
           (!t h ord. R (ord,FILTER (\x. ord x h) t) (ord,h::t)) /\ WF R
\end{verbatim}
\end{session}
%
The goal is to find a wellfounded relation on the arguments to \holtxt{qsort}
and show that the arguments to \holtxt{qsort} are in the relation.
The function \ml{WF\_REL\_TAC} is almost invariably used at this point to
initiate the termination proof. Clearly, \ml{qsort} terminates because the list
argument gets shorter. Invoking \ml{WF\_REL\_TAC} with the appropriate
measure function results in two subgoals, both of which are easy to
prove.

\begin{session}
\begin{verbatim}
  - e (WF_REL_TAC `measure (LENGTH o SND)`);
  OK..
  2 subgoals:
  > val it =
     !t h ord. LENGTH (FILTER (\x. ord x h) t) < LENGTH (h::t)

     !t h ord. LENGTH (FILTER (\x. ~ord x h) t) < LENGTH (h::t)
\end{verbatim}
\end{session}
%
Execution of \ml{WF\_REL\_TAC} has automatically proved the
wellfoundedness of the termination relation
\holtxt{measure (LENGTH o SND)}
and the remainder of the goal has been simplified into a
pair of easy goals. Once both goals are proved, we can encapsulate
the termination proof with \ml{tDefine}, which takes a quotation
(representing desired recursion equations) and a tactic $t$,
defines the specified function, calculates the termination conditions,
and applies $t$ to them. If the termination conditions are proved by
$t$ then the recursion equations and induction theorem are stored
in the current theory segment before the recursion equations are returned:

\begin{session}
\begin{verbatim}
  - val qsort_def =  tDefine "qsort"
     `(qsort ord [] = []) /\
      (qsort ord (h::t) =
          qsort ord (FILTER (\x. ord x h) t) ++ [h] ++
          qsort ord (FILTER (\x. ~(ord x h)) t))`
     (WF_REL_TAC `measure (LENGTH o SND)` THEN ...);

  > val qsort_def =
      |- (qsort ord [] = []) /\
         (qsort ord (h::t) =
            qsort ord (FILTER (\x. ord x h) t) ++ [h] ++
            qsort ord (FILTER (\x. ~ord x h) t)) : thm
\end{verbatim}
\end{session}

The custom induction theorem for a function can be obtained by using \holtxt{fetch},
which returns named elements in the specified theory.\footnote{In a call to \texttt{fetch}, the
first argument denotes a theory; the current theory may be specified by \texttt{"-"}.}
\begin{session}
\begin{verbatim}
  - fetch "-" "qsort_ind";
  >  val qsort_ind =
      |- !P.
           (!ord. P ord []) /\
           (!ord h t.
              P ord (FILTER (\x. ~ord x h) t) /\
              P ord (FILTER (\x. ord x h) t) ==> P ord (h::t))
            ==>
           !v v1. P v v1  : thm
\end{verbatim}
\end{session}

\noindent The induction theorem produced by \holtxt{Define} and \holtxt{tDefine} can
be applied by \ml{recInduct}. See Section \ref{sec:bossLib} for details.

\subsubsection{Techniques for proving termination}

There are two problems to deal with when trying to prove termination.
First, one has to understand, intuitively and then mathematically,
why the function under consideration terminates. Second, one must
be able to phrase this in \HOL. In the following, we shall give a few
examples of how this is done.

There are a number of basic and advanced means of specifying wellfounded
relations. The most common starting point for dealing with termination
problems for recursive functions is to find some function, known as a a
\emph{measure} under which the arguments of a function call are larger
than the arguments to any recursive calls that result.

For a very simple starter example, consider the following definition
of a function that computes the greatest common divisor of two
numbers:
%
\setcounter{sessioncount}{0}
\begin{session}
\begin{verbatim}
  - val gcd_defn =
      Hol_defn "gcd"
         `(gcd (0,n) = n) /\
          (gcd (m,n) = gcd (n MOD m, m))`;

  - Defn.tgoal gcd_defn;

  > val it =
      Proof manager status: 1 proof.
      1. Incomplete:
           Initial goal:
           ?R. WF R /\ !v2 n. R (n MOD SUC v2,SUC v2) (SUC v2,n)
\end{verbatim}
\end{session}
%
The invocation \holtxt{gcd(m,n)} recurses in its first argument, and
since we know that \holtxt{m} is not 0, it is the case that
\holtxt{n MOD m} is smaller than \holtxt{m}. The way to phrase the
termination of \holtxt{gcd} in HOL is to use a `measure` function
to map from the domain of \holtxt{gcd}---a pair of numbers---to a number.
The definition of {measure} in \HOL{} is equivalent to
%
\begin{hol}
\begin{verbatim}
  |- measure f x y = (f x < f y).
\end{verbatim}
\end{hol}
%
Now we must pick out the argument position to measure and
invoke \ml{WF\_REL\_TAC}:
\begin{session}
\begin{verbatim}
  - e (WF_REL_TAC `measure FST`);
  OK..
  1 subgoal:
  > val it =
     !v2 n. n MOD SUC v2 < SUC v2
\end{verbatim}
\end{session}
%
This goal is easy to prove with a few simple arithmetic facts.

\paragraph{Weighting Functions}

Sometimes one needs a measure function that is itself recursive.  For
example, consider a type of binary trees and a function that
linearizes trees. The algorithm works by rotating the tree until it
gets a \holtxt{Leaf} in the left branch, then it recurses into the right
branch. At the end of execution the tree has been linearized.
\setcounter{sessioncount}{0}
\begin{session}
\begin{verbatim}
  - Hol_datatype
      `btree = Leaf
             | Brh of btree => btree`;

  - val Unbal_defn =
      Hol_defn "Unbal"
        `(Unbal Leaf = Leaf)
     /\  (Unbal (Brh Leaf bt) = Brh Leaf (Unbal bt))
     /\  (Unbal (Brh (Brh bt1 bt2) bt) = Unbal (Brh bt1 (Brh bt2 bt)))`;

  - Defn.tgoal Unbal_defn;

  > val it =
      Proof manager status: 1 proof.
      1. Incomplete:
         Initial goal:
          ?R. WF R /\
              (!bt. R bt (Brh Leaf bt)) /\
              !bt bt2 bt1. R (Brh bt1 (Brh bt2 bt)) (Brh (Brh bt1 bt2) bt)
\end{verbatim}
\end{session}
%
Since the size of the tree is unchanged in the last clause in the
definition of \holtxt{Unbal}, a simple size measure will not work. Instead, we
can assign weights to nodes in the tree such that the recursive calls of
\holtxt{Unbal} decrease the total weight in every case. One such assignment is
%
\begin{session}
\begin{verbatim}
  Define
   `(Weight (Leaf) = 0) /\
    (Weight (Brh x y) = (2 * Weight x) + (Weight y) + 1)`
\end{verbatim}
\end{session}
%
Now we can invoke \ml{WF\_REL\_TAC}:
%
\begin{session}
\begin{verbatim}
  e (WF_REL_TAC `measure Weight`);
  OK..

  2 subgoals:
  > val it =
   !bt. Weight bt < Weight (Brh Leaf bt)

   !bt bt2 bt1.
      Weight (Brh bt1 (Brh bt2 bt)) < Weight (Brh (Brh bt1 bt2) bt)
\end{verbatim}
\end{session}
%
Both of these goals are quite easy to prove.
%
The technique of `weighting` nodes in a datatype in order to prove
termination also goes by the name of \emph{polynomial interpretation}. It
must be admitted that finding the correct weighting for a termination
proof is more an art than a science. Typically, one makes a guess and
then tries the termination proof to see if it works.

\paragraph{Lexicographic Combinations}

Occasionally, there's a combination of factors that complicate the
termination argument. For example, the following specification
describes a naive pattern matching algorithm on strings (represented
as lists here). The function takes four arguments: the first, $p$,
is the remainder of the pattern being matched. The second,
$\mathit{rst}$, is the remainder of the string being searched.  The third
argument, $p_0$, holds the original pattern to be matched.
The fourth argument, $s$, is the string being searched.
%
\setcounter{sessioncount}{0}
\begin{session}
\begin{verbatim}
  val match_defn =
    Hol_defn "match"
      `(match [] __ __ __ = T)  /\
       (match __ [] __ __ = F)  /\
       (match (a::pp) (b::ss) p0 s =
         if a=b then match pp ss p0 s
           else
         if NULL(s) then F
           else
         match p0 (TL s) p0 (TL s))`;

  - val Match = Define `Match pat str = match pat str pat str`;
\end{verbatim}
\end{session}
%
The first clause of the definition states that if $p$ becomes exhausted, then a match has
been found;  the function returns \holtxt{T}. The second clause represents the case
where $s$ becomes exhausted but $p$ is not, in which case the function returns
\holtxt{F}. The remaining case is when there's more searching to do; the function
checks if the head of the pattern $p$ is the same as the head of
$\mathit{rst}$. If yes, then the search proceeds recursively, using the
tail of $p$ and the tail of $\mathit{rst}$. If no, that means that $p$ has
failed to match, so the algorithm advances one character ahead in
$\mathit{s}$ and starts matching from the beginning of $p_0$. If
$\mathit{s}$ is empty, however, then we return \holtxt{F}. Note that
$\mathit{rst}$ and $s$ both represent the string being
searched: $\mathit{rst}$ is a `local` version of $s$: we recurse into
$\mathit{rst}$  as long as there are matches with the pattern $p$. However,
if the search eventually fails, then $s$, which `remembers` where the search
started from, is used to restart the search.

So much for the behaviour of the function. Why does it terminate? There
are two recursive calls. The first call reduces the size of $p$ and $\mathit{rst}$, and
leaves the other arguments unchanged. The second call can increase the
size of $p$ and $\mathit{rst}$, but reduces the size $s$. This is a classic situation
in which to use a  lexicographic ordering: some arguments to the function are reduced in
some recursive calls, and some others are reduced in other recursive calls.
Recall that \holtxt{LEX} is an infix operator, defined in \ml{pairTheory} as follows:
%
\begin{hol}
\begin{verbatim}
  |- LEX R1 R2 = \(x,y) (p,q). R1 x p \/ ((x=p) /\ R2 y q)
\end{verbatim}
\end{hol}
%
In the second recursive call, the length of \holtxt{s} is reduced, and in
the first it stays the same. This motivates having the length of the
$s$ be the first component of the lexicographic
combination, and the length of $\mathit{rst}$ as the second
component. Formally, we want to map from the four-tuple of
arguments into a lexicographic combination of relations.
This is enabled by \holtxt{inv\_image} from \ml{relationTheory}:
%
\begin{hol}
\begin{verbatim}
   |- inv_image R f = \x y. R (f x) (f y)
\end{verbatim}
\end{hol}
%
The desired relation maps from the four-tuple of arguments into a pair
of numbers $(m,n)$, where $m$ is the length of the fourth argument, and
$n$ is the length of the second argument. These lengths are then
compared lexicographically with respect to less-than ($<$).
\begin{session}
\begin{verbatim}
  Defn.tgoal match_defn;

  - e (WF_REL_TAC `inv_image($< LEX $<) (\(w,x,y,z). (LENGTH z,LENGTH x))`);
  OK..
  2 subgoals:
  > val it =
   !s ss a b.
     (a=b) ==> LENGTH s < LENGTH s \/ LENGTH ss < LENGTH (b::ss)

   !ss s a b.
     ~(a = b) /\ ~NULL s ==>
     LENGTH (TL s) < LENGTH s \/
     (LENGTH (TL s) = LENGTH s) /\ LENGTH (TL s) < LENGTH (b::ss)
\end{verbatim}
\end{session}
%
The first subgoal needs a case-split on \holtxt{s} before it is proved by
rewriting, and the second is also easy to prove by rewriting.

\subsubsection{How termination conditions are synthesized}

\index{congruence rules!in termination analysis|(}
It is occasionally important to understand, at least in part, how
\ml{Hol\_defn} constructs termination constraints. In some cases, it is
even necessary for users to influence this process in order to have correct
termination constraints extracted. The process is driven by so-called
\emph{congruence theorems} for particular \HOL{} constants.
For example, consider the following recursive definition of factorial:
%
\begin{hol}
\begin{verbatim}
  fact n = if n=0 then 1 else n * fact (n-1)
\end{verbatim}
\end{hol}
%
In the absence of knowledge of how the `if-then-else` construct
affects the \emph{context} of recursive calls, \ml{Hol\_defn} would
extract the termination constraints:
%
\begin{hol}
\begin{verbatim}
  0. WF R
  1. !n. R (n - 1) n
\end{verbatim}
\end{hol}
%
which are unprovable, because the \emph{context} of the recursive call has not
been taken account of. This example is in fact not a problem for HOL,
since the following congruence theorem is known to \ml{Hol\_defn}:
%
\begin{hol}
\begin{verbatim}
 |- !b b' x x' y y'.
      (b = b') /\
      (b' ==> (x = x')) /\
      (~b' ==> (y = y')) ==>
       ((if b then x else y) = (if b' then x' else y'))
\end{verbatim}
\end{hol}
%
This theorem is understood by \ml{Hol\_defn} as an ordered sequence
of instructions to follow when the termination condition extractor
hits an `if-then-else`. The theorem is read as follows: when an
instance `\texttt{if} $B$ \texttt{then} $X$ \texttt{else} $Y$` is
encountered while the extractor traverses the function definition,
do the following:
\begin{enumerate}

\item Traverse $B$ and extract termination conditions
     $\mathit{TCs}(B)$ from any recursive calls in it.
     This returns a theorem $\mathit{TCs}(B) \vdash B = B'$.

\item Assume $B'$ and extract termination conditions from any
  recursive calls in $X$. This returns a theorem
  $\mathit{TCs}(X) \vdash X = X'$.

\item Assume $\neg B'$ and extract termination conditions from any
   recursive calls in $Y$. This returns a theorem
   $\mathit{TCs}(Y) \vdash Y = Y'$.

\item  By equality reasoning with (1), (2), and (3), derive the theorem
\[\mathit{TCs}(B) \cup \mathit{TCs}(X) \cup \mathit{TCs}(Y)
  \vdash
  (\mathtt{if}\ B\ \mathtt{then}\ X\ \mathtt{else}\ Y) =
  (\mathtt{if}\ B'\ \mathtt{then}\ X'\ \mathtt{else}\ Y')
\]
\item Replace \texttt{if} $B$ \texttt{then} $X$ \texttt{else} $Y$ by
\texttt{if} $B'$ \texttt{then} $X'$ \texttt{else} $Y'$.

\end{enumerate}


The termination conditions are accumulated until the
extraction process finishes, and appear as hypotheses in the final
result. Thus the extracted termination conditions for \holtxt{fact} are
%
\begin{hol}
\begin{verbatim}
   0. WF R
   1. !n. ~(n = 0) ==> R (n - 1) n
\end{verbatim}
\end{hol}
%
and are easy to prove. The notion of \emph{context} of a recursive call
is defined by  the set of congruence rules used in extracting termination
conditions. This set can be obtained by invoking \holtxt{DefnBase.read\_congs},
and manipulated by \holtxt{DefnBase.add\_cong},
\holtxt{DefnBase.drop\_cong} and \holtxt{DefnBase.export\_cong}.
The `add' and `drop' functions only affect the current state of the congruence database; in contrast, the `export' function provides a way for theories to specify that a particular theorem should be added to the congruence database in all descendent theories.
\index{congruence rules!in termination analysis|)}



\paragraph{Higher Order Recursion and Congruence Rules}

A `higher-order` recursion is one in which a higher-order function is
used to apply the recursive function to arguments. In order for the
correct termination conditions to be proved for such a recursion,
congruence rules for the higher order function must be known to the
termination condition extraction mechanism. Congruence rules for
common higher-order functions, \eg, \holtxt{MAP}, \holtxt{EVERY}, and
\holtxt{EXISTS} for lists, are already known to the
mechanism. However, at times, one must manually prove and install a
congruence theorem for a new user-defined higher-order function.

For example, suppose we define a higher-order function \holtxt{SIGMA} for
summing the results of a function in a list.
%
\setcounter{sessioncount}{0}
\begin{session}
\begin{verbatim}
  Define `(SIGMA f [] = 0) /\
          (SIGMA f (h::t) = f h + SIGMA f t)`;
\end{verbatim}
\end{session}
%
We then use \holtxt{SIGMA} in the definition of a function for
summing the results of a function in a arbitrarily
(finitely) branching tree.
%
\begin{session}
\begin{verbatim}
  Hol_datatype `ltree = Node of 'a => ltree list`;

  Defn.Hol_defn
    "ltree_sigma"
    `ltree_sigma f (Node v tl) = f v + SIGMA (ltree_sigma f) tl`;
\end{verbatim}
\end{session}
%
In this definition, \holtxt{SIGMA} is applied to a partial application
\holtxt{(ltree\_sigma f)} of the function being defined. Such a situation
is called a \emph{higher-order recursion}. Since the recursive call of
\holtxt{ltree\_sigma} is not fully applied, special efforts have
to be made to extract the correct termination conditions. Otherwise,
the following unhappy situation results:
%
\begin{session}
\begin{verbatim}
  HOL function definition (recursive)

  Equation(s) :
    [..] |- ltree_sigma f (Node v tl)
              = f v + SIGMA (\a. ltree_sigma f a) tl

  Induction :
    [..] |- !P. (!f v tl. (!a. P f a) ==> P f (Node v tl)) ==> !v v1. P v v1

  Termination conditions :
    0. WF R
    1. !tl v f a. R (f,a) (f,Node v tl) : defn
\end{verbatim}
\end{session}
%
\index{congruence rules!in termination analysis}
The termination conditions for \holtxt{ltree\_sigma} seem to
require finding a wellfounded relation \holtxt{R} such that the pair
\holtxt{(f,a)} is \holtxt{R}-less than
\holtxt{(f, Node v tl)}. However, this is a hopeless task, since there is no
relation between \holtxt{a} and \holtxt{Node v tl}, besides the fact
that they are both \holtxt{ltree}s. The termination condition extractor
has not performed properly, because it didn't know a congruence rule
for \holtxt{SIGMA}. Such a congruence theorem is the following:
%
\begin{hol}
\begin{verbatim}
  SIGMA_CONG =
   |- !l1 l2 f g.
       (l1=l2) /\ (!x. MEM x l2 ==> (f x = g x)) ==>
       (SIGMA f l1 = SIGMA g l2)
\end{verbatim}
\end{hol}
%
Once \ml{Hol\_defn} has been told about this theorem, via \ml{DefnBase}'s \ml{add\_cong} or \ml{export\_cong} functions, the termination conditions extracted for the definition are now provable, since \holtxt{a} is a proper subterm of \holtxt{Node v tl}.
%
\begin{session}
\begin{verbatim}
  val _ = DefnBase.add_cong SIGMA_CONG;

  Defn.Hol_defn
    "ltree_sigma"
    `ltree_sigma f (Node v tl) = f v + SIGMA (ltree_sigma f) tl`;

  > val it =
      HOL function definition (recursive)

      Equation(s) :  ...  (* as before *)
      Induction :    ...  (* as before *)

      Termination conditions :
        0. WF R
        1. !v f tl a. MEM a tl ==> R (f,a) (f,Node v tl)
\end{verbatim}
\end{session}

\subsection{Recursion schemas}

In higher order logic, very general patterns of recursion, known as
\emph{recursion schemas} or sometimes \emph{program schemas}, can be
defined. One example is the following:
%
\[
  \konst{linRec} (x) =
    \itelse{d(x)}{e(x)}{f(\konst{linRec}(g\; x))}
\]
%
In this specification, the variables $d$, $e$, $f$, and $g$ are
functions, that, when instantiated in different ways, allow
\konst{linRec} to implement different recursive functions. In this,
\konst{linRec} is like many other higher order functions. However,
notice that if $d(x) = \konst{F}$, $f(x) = x+1$, and
$g(x) = x$, then the resulting instantiation of
\konst{linRec} could be used to obtain a contradiction:
%
\[
  \konst{linRec} (x) = \konst{linRec}(x) + 1
\]
%
This is not, however, derivable in \HOL{}, because recursion schemas
are defined by instantiating the wellfounded recursion theorem, and
therefore certain abstract termination constraints arise that
must be satisfied before recursion equations can be used in an
unfettered manner. The entrypoint for defining a schema is
\ml{TotalDefn.DefineSchema}. On the \konst{linRec} example it
behaves as follows (note that the schematic variables should
only occur on the right-hand side of the definition when making
the definition of a schema):
%
\setcounter{sessioncount}{0}
\begin{session}
\begin{verbatim}
  - TotalDefn.DefineSchema
      `linRec (x:'a) = if d(x) then e(x) else f(linRec(g x))`;

  <<HOL message: Definition is schematic in the following variables:
      "d", "e", "f", "g">>

  Equations stored under "linRec_def".
  Induction stored under "linRec_ind".
  > val it =
     [..]
    |- linRec d e f g x = if d x then e x else f (linRec d e f g (g x))
\end{verbatim}
\end{session}
%
The hypotheses of the returned theorem hold the abstract termination
constraints. A similarly constrained induction theorem is also
stored in the current theory segment.
%
\begin{session}
\begin{verbatim}
  hyp it;
  > val it = [``!x. ~d x ==> R (g x) x``, ``WF R``] : term list
\end{verbatim}
\end{session}
%
These constraints are abstract, since they place termination requirements
on variables that have not yet been instantiated. Once instantiations
for the variables are found, then the constraints may be eliminated
by finding a suitable wellfounded relation for \holtxt{R} and then
proving the other constraints.

\section{Inductive Relations}
\index{inductive relations|(}

\index{Hol_reln, defining inductive relations@\ml{Hol\_reln}, defining inductive relations}
\index{inductive relations!Hol_reln (ML function)@\ml{Hol\_reln} (ML function)}
Inductive definitions are made with the function \ml{Hol\_reln}, found
in the \ml{bossLib} structure, and the resulting definitions and
theorems are handled with functions defined in the library
\ml{IndDefLib}. The \ml{Hol\_reln} function takes a
term quotation as input and attempts to define the relations there
specified.  The input term quotation must parse to a term that
conforms to the following grammar:
\newcommand{\nonterm}[1]{\ensuremath{\langle\mathit{#1}\rangle}}
\begin{eqnarray*}
   \nonterm{inputFormat} &::=& \nonterm{clause} \;\holtxt{/\bk}\; \nonterm{inputFormat} \;\;|\;\; \nonterm{clause}\\
   \nonterm{clause}       &::=& (\holtxt{!}x_1 \dots
   x_n. \;\;\nonterm{hypothesis} \;\holtxt{==>}
   \;\nonterm{conclusion})\\
   &|& (\holtxt{!}x_1\dots x_n.\;\;\nonterm{conclusion})\\
   \nonterm{conclusion}   &::=& \nonterm{con} \;\mathit{sv_1}\; \mathit{sv_2} \dots\\
   \nonterm{hypothesis}   &::=& \mbox{any term}\\
   \nonterm{con}          &::=& \mbox{a new relation constant}
\end{eqnarray*}
The (optional) $\mathit{sv}_i$ terms that appear after a constant name
are so-called ``schematic variables''.  The same variables must always
follow all new constants throughout the definition.  These variables
and the names of the constants-to-be must not be quantified over in
each {\nonterm{clause}}.  A {\nonterm{clause}} should have no other
free variables.  Any that occur will be universally quantified as part
of the process of definition, and a warning message emitted.
(Universal quantifiers at the head of the clause can be used to bind
free variables, but it is also permissible to use existential
quantification in the hypotheses.  If a clause has no free variables,
it is permissible to have no universal quantification.)

A successful invocation of \ml{Hol\_reln} returns three theorems
$(\mathit{rules},\mathit{ind},\mathit{cases})$. Each is also stored in
the current theory segment.
\begin{itemize}
\item $\mathit{rules}$ is a conjunction of implications
that will be the same as the input term quotation; the theorem is
saved under the name \ml{<stem>\_rules}, where \ml{<stem>} is the name of the
first relation defined by the function.
\item $\mathit{ind}$ is the induction principle for the relations,
saved under the name \ml{<stem>\_ind}.
\item $\mathit{cases}$ is the so-called `cases' or `inversion' theorem
  for the relations, saved under the name \ml{<stem>\_cases}. A cases
  theorem is of the form
%
\begin{verbatim}
   (!a0 .. an.  R1 a0 .. an = <R1's first rule possibility> \/
                              <R1's second rule possibility> \/ ...)
                   /\
   (!a0 .. am.  R2 a0 .. am = <R2's first rule possibility> \/
                              <R2's second rule possibility> \/ ...)
                   /\
   ...
\end{verbatim}
%
and is used to decompose an element in the relation into the
possible ways of obtaining it by the rules.
\end{itemize}

\index{xHol_reln, defining inductive relations@\ml{xHol\_reln}, defining inductive relations}
\index{inductive relations!xHol_reln (ML function)@\ml{xHol\_reln} (ML function)}
If the ``stem'' of the first constant defined in a set of clauses is such that resulting \ML{} bindings in an exported theory file will result in illegal \ML{}, then the \ml{xHol\_reln} function should be used.
The \ml{xHol\_reln} function is analogous to the \ml{xDefine} function for defining recursive functions (see Section~\ref{TFL}).

\paragraph{Strong Induction Principles}
So called ``strong'' versions of induction principles (in which instances of the relation being defined appear as extra hypotheses), are automatically proved when a definition is made with \ml{Hol\_reln}. The strong induction principle for a relation is used when the \ml{Induct\_on} tactic is used.

\paragraph{Adding Monotone Operators}
\index{inductive relations!monotone operators for}
New constants may occur recursively throughout rules' hypotheses, as
long as it can be shown that the rules remain monotone with respect to
the new constants.  \ml{Hol\_reln} automatically attempts to prove such
monotonicity results, using a set of theorems held in a reference
\ml{IndDefLib.the\_monoset}.  Monotonicity theorems must be of the form
\[
\mathit{cond}_1 \land \cdots \land \mathit{cond}_m \Rightarrow
(\mathit{Op}\;\mathit{arg}_1 \dots \mathit{arg}_n \Rightarrow
\mathit{Op}\;\mathit{arg}'_1 \dots \mathit{arg}'_n)
\]
where each $\mathit{arg}$ and $\mathit{arg}'$ term must be a variable,
and where there must be as many $\mathit{cond}_i$ terms as there are
arguments to $\mathit{Op}$ that vary.  Each $\mathit{cond}_i$ must be
of the form \[ \forall \vec{v}. \;\mathit{arg}\;\vec{v} \Rightarrow
\mathit{arg}'\;\vec{v}
\]
where the vector of variables $\vec{v}$ may be empty, and where the
$\mathit{arg}$ and $\mathit{arg}'$ may actually be reversed (as in the
rule for negation).

For example, the monotonicity rule for conjunction is
\[
(P \Rightarrow P') \land (Q \Rightarrow Q') \Rightarrow (P \land Q
\Rightarrow P' \land Q')
\]
The monotonicity rule for the \holtxt{EVERY} operator in the theory of
lists (see Section~\ref{avra_list}), is
\[
(\forall x. \;P(x) \Rightarrow Q(x)) \Rightarrow
(\holtxt{EVERY}\;P\;\ell \Rightarrow \holtxt{EVERY}\;Q\;\ell)
\]
With a monotonicity result available for an operator such as
\holtxt{EVERY}, it is then possible to write inductive definitions
where hypotheses include mention of the new relation as arguments to
the given operators.

\index{export_mono (ML function)@\ml{export\_mono} (\ML{} function)}
Monotonicity results that the user derives may be stored in the global
\ml{the\_monoset} variable by using the \ml{export\_mono} function.
This function takes a string naming a theorem in the current theory
segment, and adds that theorem to the monotonicity theorems
immediately, and in such a way that this situation will also obtain when
the current theory is subsequently reloaded.

\paragraph{Examples}

A simple example of defining two mutually recursive relations is
the following:
%
\setcounter{sessioncount}{0}
\begin{session}
\begin{verbatim}
  Hol_reln
    `EVEN 0 /\
     (!n. ODD n ==> EVEN (n + 1)) /\
     (!n. EVEN n ==> ODD (n + 1))`;
\end{verbatim}
\end{session}
%
The result is three theorems
%
\begin{session}
\begin{verbatim}
  > val it =
    (|- EVEN 0 /\
        (!n. ODD n ==> EVEN (n + 1)) /\
        (!n. EVEN n ==> ODD (n + 1)),

     |- !EVEN' ODD'.
           EVEN' 0 /\
           (!n. ODD' n ==> EVEN' (n + 1)) /\
           (!n. EVEN' n ==> ODD' (n + 1))
           ==>
           (!a0. EVEN a0 ==> EVEN' a0) /\
           (!a1. ODD a1 ==> ODD' a1),

     |- (!a0. EVEN a0 = (a0 = 0) \/
                        ?n. (a0 = n + 1) /\ ODD n) /\
        (!a1. ODD a1 = ?n. (a1 = n + 1) /\ EVEN n)
    ) : thm * thm * thm
\end{verbatim}
\end{session}
%
The next example shows how to inductively define the reflexive and
transitive closure of relation $R$. Note that \holtxt{R}, as a
schematic variable, is not quantified in the rules. This is
appropriate because it is \holtxt{RTC R} that has the inductive
characterisation, not \holtxt{RTC} itself.
%
\begin{session}
\begin{verbatim}
  - Hol_reln `(!x. RTC R x x) /\
             (!x z. (?y. R x y /\ RTC R y z) ==> RTC R x z)`;

  > val it =
     (|- !R. (!x. RTC R x x) /\
             !x z. (?y. R x y /\ RTC R y z) ==> RTC R x z,

      |- !R RTC'.
           (!x. RTC' x x) /\
           (!x z. (?y. R x y /\ RTC' y z) ==> RTC' x z)
           ==>
           (!a0 a1. RTC R a0 a1 ==> RTC' a0 a1),

      |- !R a0 a1. RTC R a0 a1 = (a1 = a0) \/ ?y. R a0 y /\ RTC R y a1
     ) : thm * thm * thm
\end{verbatim}
\end{session}
%
The \ml{Hol\_reln} function may be used to define multiple relations,
as in the definition of \holtxt{EVEN} and \holtxt{ODD}.  The relations
may or may not be mutually recursive.  The clauses for each relation
need not be contiguous.

\subsection{Proofs with Inductive Relations}
\index{inductive relations!performing proofs}

The ``rules'' theorem of an inductive relation provides a straightforward way of proving arguments belong to a relation.
If confronted with a goal of the form \holtxt{R~x~y}, one might make progress by performing a \ml{MATCH\_MP\_TAC} (or perhaps, an \ml{HO\_MATCH\_MP\_TAC}) with one of the implications in the ``rules'' theorem.

The ``cases'' theorem can be used for the same purpose because it is an equality, of the general form \holtxt{R~x~y~$\iff$\dots}.
Because the right-hand side of this theorem will often include other occurrences of the relation, it is generally not safe to simply rewrite with it.
\index{SimpLHS@\ml{SimpLHS}}\index{SimpRHS@\ml{SimpRHS}}
\index{Once (controlling rewrite applications)@\ml{Once} (controlling rewrite applications)}
The rewriting-control directives \ml{Once}, \ml{SimpLHS} and \ml{SimpRHS} can be useful here.
\index{FULL_SIMP_TAC@\ml{FULL\_SIMP\_TAC}}
In addition, the ``cases'' theorem can be used as an ``elimination'' form: if one has an assumption of the form \holtxt{R~x~y}, rewriting this (perhaps with \ml{FULL\_SIMP\_TAC} if the term occurs in the goal's assumptions) into the possible ways it may have come about is often a good approach.

Inductive relations naturally also support proof by induction.
Because an inductive relation is the least relation satisfying the given rules, one can use induction to show goals of the form
\begin{alltt}
   \(\forall\)x y. R x y \(\Rightarrow\) P
\end{alltt}
where \holtxt{P} is an arbitrary predicate likely including references to variables \holtxt{x} and \holtxt{y}.

The low-level approach to goals of this form is to apply
\begin{verbatim}
   HO_MATCH_MP_TAC R_ind
\end{verbatim}
\index{Induct_on (ML induction tactic)@\ml{Induct\_on} (\ML{} induction tactic)}
A slightly more high-level approach is use the \ml{Induct\_on} tactic.
(This tactic is also used to perform structural inductions over algebraic data types; see Section~\ref{sec:bossLib}.)
When performing a rule induction, the quotation passed to \ml{Induct\_on} should be of the constant being used.
For the sake of aesthetics, the constant may also be applied to arguments.
Thus, one can write
\begin{verbatim}
   Induct_on `R`
\end{verbatim}
or
\begin{verbatim}
   Induct_on `R x y`
\end{verbatim}
and the effect will be the same.
\index{inductive relations|)}


%%% Local Variables:
%%% mode: latex
%%% mode: visual-line
%%% TeX-master: "description"
%%% End:
