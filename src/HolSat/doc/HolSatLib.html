  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd"><HTML>
<META NAME="GENERATOR" CONTENT="TtH 2.00">



<font size="+4"><tt>
<title>HolSatLib</title>
HolSatLib</tt> Documentation<br>
<font size="+2">Version 1.0<font face=symbol>b</font
></font>
</font>
<p>
 <HR>


 <font size="+2"><b>Mike Gordon</b></font>

<p>
 Jun  1, 2001


<p>
<img src="saturn.gif">

<H2>Preface</H2>

<p>
This document describes <tt>HolSatLib</tt>
as distributed with the <i>Kananaskis </i> release of Hol98. Section 2
describes how to install it with <i>Taupo</i> releases.

<p>
<tt>HolSatLib</tt> provides a very simple harness in Hol98 for
invoking SAT solvers on HOL terms. Currently the following
solvers are supported

<p>
<p><br>
<table>
<tr><td><b>Solver</b> </td><td><b>Home Page</b> </td>
<tr><td>SATO </td><td><font size="-1"><A HREF="http://www.cs.uiowa.edu/~hzhang/sato.html">
<tt>http://www.cs.uiowa.edu/~hzhang/sato.html</tt></A></font></td>
<tr><td>GRASP </td><td><font size="-1"><A HREF="http://sat.inesc.pt/~jpms/grasp">
<tt>http://sat.inesc.pt/~jpms/grasp</tt></A></font></td>
<tr><td>ZCHAFF </td><td><font size="-1"><A HREF="http://www.ee.princeton.edu/~chaff/zchaff.html">
<tt>http://www.ee.princeton.edu/~chaff/zchaff.html</tt></A></font>
</td></table>

<p>
<p><br>These solvers all require input in the standard 
<A HREF="ftp://dimacs.rutgers.edu/pub/challenge/satisfiability/doc/satformat.dvi">DIMACS  format</A>
for conjunctive normal form (CNF). It is intended to be straightforward to add other
DIMACS compatible SAT solvers.

<p>
The purpose of <tt>HolSatLib</tt> is to provide a platform
for experimenting with combinations of theorem proving and
SAT. Hol98 can be used to deductively manipulate terms into CNF as
required for SAT analysis, and then the results of the analysis
can be reimported into HOL and either checked or just trusted.

<p>
Currently <tt>
HolSatLib</tt> has only been tested under Linux, though it should be
possible to run it under Windows.

<p>

<div align=right>Mike Gordon<br>
Jun  1, 2001

</div>
<p>
        <H2><A NAME="tth_sEc1">
1</A>&nbsp;&nbsp;Introduction</H2>

<p>
The following examples illustrates <tt>HolSatLib</tt> in action.

<p>
 
<table>
<tr> <font size="-1">
<pre>

- load "HolSatLib"; open HolSatLib
[ output omitted ]
&#62; val it = () : unit

- show_tags := true;
&#62; val it = () : unit

- satOracle grasp ``(x \/ ~y \/ z) /\ (~z \/ y)``;
&#62; val it = [oracles: grasp] [axioms: ] [] 
           |- z /\ y ==&#62; (x \/ ~y \/ z) /\ (~z \/ y) : thm

- satProve grasp ``(x \/ ~y \/ z) /\ (~z \/ y)``;
&#62; val it = [oracles: ] [axioms: ] [] 
           |- z /\ y ==&#62; (x \/ ~y \/ z) /\ (~z \/ y) : thm

</pre></font></td></table>
</td>
 
<p>
Setting <font size="-1"><tt>show_tags</font></tt> to <font size="-1"><tt>true</font></tt> makes the Hol98 top
level print theorem tags.

<p>
The function <font size="-1"><tt>satOracle</font></tt> takes a SAT solver (currently either
<font size="-1"><tt>sato</font></tt>, <font size="-1"><tt>grasp</font></tt> or <font size="-1"><tt>zchaff</font></tt>, but more could be added) and a term
t and

<p>

<OL type="1">
<li> writes a DIMACS format file corresponding to the term t

<li> invokes the solver on the file to create an output file

<li> parses the output file to extract the model found

<li> creates a theorem, tagged with the name of the solver, that shows the model.
</OL>
<p>
The function <font size="-1"><tt>satProve</font></tt> performs steps 1-3 above, but then uses
Hol98 to check that the model is really a model and then
returns an untagged theorem. Note that checking a model is
generally much quicker than finding it (one just `evaluates' the term
with the values supplied by the model).

<p>
Thus if one is prepared to trust the solver then use <font size="-1"><tt>satOracle</font></tt>,
but if one wants to verify the results (which could be time-consuming)
use <font size="-1"><tt>satProve</font></tt>.

<p>
The next example illustrates what happens on unsatisfiable terms.

<p>
 
<table>
<tr> <font size="-1">
<pre>

- satOracle grasp ``(x \/ ~y \/ z) /\ ~z /\ y /\ ~x``;
&#62; val it = [oracles: grasp] [axioms: ] [] 
           |- ~((x \/ ~y \/ z) /\ ~z /\ y /\ ~x)

- satProve grasp ``(x \/ ~y \/ z) /\ ~z /\ y /\ ~x``;
! Uncaught exception: 
! satProveError

</pre></font></td></table>
</td>
 
<p>
If a term t is unsatisfiable then <font size="-1"><tt>satOracle</font></tt> will return <font size="-1"><tt>|- ~</tt></font>t,
tagged with the name of the SAT solver used. However, <font size="-1"><tt>satProve</font></tt> will raise an exception,
since there is no efficient way to check for unsatisfiability using pure Hol98 theorem proving.

<p>
A tautology checker that uses SAT can be easily programmed using
<font size="-1"><tt>CNF_CONV</font></tt>, which is supplied in the structure <font size="-1"><tt>canonTools</font></tt> that comes
with <font size="-1"><tt>HolSatLib</font></tt>. To check the validity of a term t

<p>

<blockquote>
<DL compact><dt><b><font size="-1"><tt>[th1]</font></tt></b></dt>
	<dd> use <font size="-1"><tt>CNF_CONV</font></tt> to prove <font size="-1"><tt>|- ~</tt></font>t&nbsp; = &nbsp;t', 
where t<font face=symbol>¢</font
> is in CNF;
<dt><b><font size="-1"><tt>[th2]</font></tt></b></dt>
	<dd> use SAT to prove  <font size="-1"><tt>|- ~</tt></font>t';
<dt><b><font size="-1"><tt>[th3]</font></tt></b></dt>
	<dd> by negating both sides of <font size="-1"><b><tt>th1</font></tt></b>, 
prove <font size="-1"><tt>|- ~~</tt></font>t&nbsp; = &nbsp;<font size="-1"><tt>~</tt></font>t';
<dt><b><font size="-1"><tt>[th4]</font></tt></b></dt>
	<dd> hence by combining <font size="-1"><b><tt>th2</font></tt></b> 
and <font size="-1"><b><tt>th3</font></tt></b> derive <font size="-1"><tt>|- ~~</tt></font>t.
<dt><b><font size="-1"><tt>[th5]</font></tt></b></dt>
	<dd> hence by the law of double negation conclude <font size="-1"><tt>|- </tt></font>t.
</DL>
<p>
</blockquote>Example Hol98 code to mechanise these steps is as follows:

<p>
 
<table>
<tr> <font size="-1">
<pre>

(* NOT_CLAUSES = |- (!t. ~~t = t) /\ (~T = F) /\ (~F = T)  *)
val NOT_NOT = CONJUNCT1 NOT_CLAUSES;

fun SAT_TAUT_CHECK sat_solver t =
 let val th1 = canonTools.CNF_CONV(mk_neg t)
     val th2 = satOracle sat_solver (rhs(concl th1))
     val th3 = AP_TERM ``$~`` th1
     val th4 = EQ_MP (SYM th3) th2
     val th5 = EQ_MP (SPEC t NOT_NOT) th4
 in
  th5
 end;

</pre></font></td></table>
</td>
 
<p>
        <H2><A NAME="tth_sEc2">
2</A>&nbsp;&nbsp;Installing <tt>HolSatLib</tt> under Linux</H2><A NAME="install">
</A>

<p>

<OL type="1">
<li> Visit 
<font size="-1">
<A HREF="http://www.cl.cam.ac.uk/~mjcg/HolSatLib"><tt>http://www.cl.cam.ac.uk/~mjcg/HolSatLib</tt></A>
</font> and
download the file 
<font size="-1">
<A HREF="http://www.cl.cam.ac.uk/~mjcg/HolSatLib/HolSatLib.tar.gz"><tt>HolSatLib.tar.gz</tt></A></font>

<p>

<li> place  <tt>HolSatLib.tar.gz</tt> in a directory <i>dir</i>
(where <i>dir</i> is an absolute path name)

<p>

<li> connect to <i>dir</i> and execute<br>
<font size="-1">
<pre>
   gunzip HolSatLib.tar.gz; tar -xf HolSatLib.tar
</pre></font>
 
<p>
this should result in a directory <i>dir</i><tt>/HolSatLib</tt> containing
 
<p>
<font size="-1">
<pre>
   Cnf.sml HolSatLib.sig HolSatLib.sml SatSolvers.sml doc sat_solvers
</pre></font>

<p>

<li> connect to <i>dir</i><tt>/HolSatLib</tt> and execute<br>
<font size="-1">
<pre>
   Holmake cleanAll; Holmake
</pre></font>
 
<p>
you should see
 
<p>
<font size="-1">
<pre>
   Analysing HolSatLib.sml
   Trying to create directory .HOLMK for dependency files
   Analysing HolSatLib.sig
   Compiling HolSatLib.sig
   Analysing SatSolvers.sml
   Compiling SatSolvers.sml
   Compiling HolSatLib.sml
   Analysing Cnf.sml
   Compiling Cnf.sml
</pre></font>

<p>

<li> download SATO, GRASP and ZCHAFF into the directories <tt>sato</tt>, <tt>grasp</tt>,
<tt>zchaff</tt>, respectively, in <i>dir</i><tt>/HolSatLib/sat_solvers</tt>
(versions may already be there)

<p>

<li> after starting Hol98 execute<br>

<font size="-1">
<pre>
   loadPath := "<i>dir</i>/HolSatLib" :: !loadPath;
</pre>
</font>
<p>

<li> you should now be able to execute<br>
<font size="-1">
<pre>
   load "HolSatLib"; open HolSatLib;
</pre></font>
</OL>
<p>
        <H2><A NAME="tth_sEc3">
3</A>&nbsp;&nbsp;<tt>HolSatLib</tt> Documentation</H2>

<p>
<tt>HolSatLib</tt> currently comes with three
modules

<p>
<p><br>
<table>
<tr><td><b>Module</b> </td><td><b>Description</b> </td>
<tr><td><tt>HolSatLib</tt> </td><td>functions for invoking SAT solvers</td>
<tr><td><tt>SatSolvers</tt> </td><td>specifications of <font size="-1"><tt>sato</font></tt>, <font size="-1"><tt>grasp</font></tt> and <font size="-1"><tt>zchaff</font></tt></td>
<tr><td><tt>Cnf</tt> </td><td>tool for converting HOL terms to CNF (from Joe Hurd)
</td></table>

<p>
<p><br>      <H3><A NAME="tth_sEc3.1">
3.1</A>&nbsp;&nbsp;Contents of <tt>HolSatLib</tt> module</H3>

<p>
The signature of <tt>HolSatLib</tt> is shown below, followed
by a description of the components.

<p>
<font size="-1">
<pre>
signature HolSatLib = sig
  datatype sat_solver = 
   SatSolver of {name           : string,
                 URL            : string,
                 executable     : string,    
                 notime_run     : string -&#62; string * string -&#62; string,    
                 time_run       : string -&#62; (string * string) * int -&#62; string,      
                 only_true      : bool,
                 failure_string : string,
                 start_string   : string,  
                 end_string     : string}
  val sato          : sat_solver
  val grasp         : sat_solver
  val zchaff        : sat_solver
  val tmp_name      : string ref
  val sat_command   : string ref
  val prefix        : string ref
  val showSatVarMap : unit -&#62; int * (string * int) list
  val satOracle     : sat_solver -&#62; Term.term -&#62; Thm.th
  val satProve      : sat_solver -&#62; Term.term -&#62; Thm.thm
  val readDimacs    : string -&#62; Term.term
</pre></font>

<p>
       <H4><A NAME="tth_sEc3.1.1">
3.1.1</A>&nbsp;&nbsp;<tt>sat_solver</tt></H4>

<p>
The datatype <font size="-1"><tt>sat_solver</font></tt> is defined in the module SatSolvers.
The data in the record argument to the constructor <font size="-1"><tt>SatSolver</font></tt>
is an ad-hoc list of what is needed to invoke a SAT program
and parse the results. One only needs to know what the fields
contain if one is adding another SAT prover. See the
source code <tt>SatSolvers.sml</tt> for some information
in the comments.

<p>
       <H4><A NAME="tth_sEc3.1.2">
3.1.2</A>&nbsp;&nbsp;<tt>sato</tt>, <tt>grasp</tt> and <tt>zchaff</tt></H4>

<p>
The ML identifiers <font size="-1"><tt>sato</font></tt>, <font size="-1"><tt>grasp</font></tt> and <font size="-1"><tt>zchaff</font></tt> are bound
by module <tt>SatSolvers</tt> to descriptions of the corresponding SAT solvers.
These descriptions are passed to <font size="-1"><tt>satOracle</font></tt> and <font size="-1"><tt>satProve</font></tt> to
select which SAT solver to invoke.

<p>
       <H4><A NAME="tth_sEc3.1.3">
3.1.3</A>&nbsp;&nbsp;<tt>tmp_name</tt>, <tt>sat_command</tt>, <tt>prefix</tt> and <tt>showSatVarMap</tt></H4>

<p>
The reference <font size="-1"><tt>tmp_name</font></tt> contains the temporary file name used in
the last invokation of a SAT solver  by <font size="-1"><tt>satOracle</font></tt> or <font size="-1"><tt>satProve</font></tt>. This name
was generated using <font size="-1"><tt>FileSys.tmpName</font></tt>.

<p>
The reference <font size="-1"><tt>sat_command</font></tt> contains the actual command executed
(using <font size="-1"><tt>Process.system</font></tt>) for
the last invokation of a SAT solver. This command reads from
an input file and writes to an output file. The file names are generated by extending <font size="-1"><tt>tmp_name</font></tt>
(the input file name extension is <font size="-1"><tt>cnf</font></tt> and the out extension is the name of the SAT solver used).

<p>
The reference <font size="-1"><tt>prefix</font></tt> contains the string that is concatenated to numbers
to get the HOL variables used when reading a separately generated DIMACS file
with <font size="-1"><tt>readDimacs</font></tt>. Default value is <tt>"v"</tt>.

<p>
The function <font size="-1"><tt>showSatVarMap</tt></font> returns a pair consisting of
the one plus the number of variables used (i.e. the first number not
currently used as a variable) and the mapping from variable names to
numbers for encoding a term in DIMACS format by
<font size="-1"><tt>satOracle</font></tt> or <font size="-1"><tt>satProve</font></tt>.

<p>
       <H4><A NAME="tth_sEc3.1.4">
3.1.4</A>&nbsp;&nbsp;<tt>satOracle</tt></H4>

<p>
<font size="-1"><tt>satOracle</tt>&nbsp;<i>solver</i>&nbsp;<i>term</i></font>

<p>

<OL type="1">
<li> writes a DIMACS format file corresponding to <i>term</i>

<OL type="a">
<p>

<li> the mapping from HOL variable names to integers can be seen using
<font size="-1"><tt>showSatVarMap</font></tt>

<li> the input file name is <i>tmp</i><tt>.cnf</tt>, where
the string <i>tmp</i> is in the reference <font size="-1"><tt>tmp_name</font></tt>
</OL>
<p>

<li> invokes <i>solver</i> on the file and writes results to an output file

<p>

<OL type="a">
<li> the default settings (time, verbosity etc.) supplied by <i>solver</i>
are used

<li> the output file name is <i>tmp</i><tt>.</tt><i>name</i>, where
the string <i>tmp</i> is in the reference <font size="-1"><tt>tmp_name</font></tt>
and <i>name</i> is the string given as the value of the field <tt>name</tt> of <i>solver</i>

<li> the actual command executed can be seen in the reference 
<font size="-1"><tt>sat_command</font></tt>
</OL>
<p>

<li> parses the output file to see if a model was found and if so extracts it

<p>

<OL type="a">
<li> the presence of the string given as the value of the
field <tt>failure_string</tt> in <i>solver</i> is
assumed to indicate that <i>term</i> is unsatisfiable

<li> if <i>term</i> is not unsatisfiable,
the model is assumed to be supplied as a list of integers in the output file 
<i>tmp</i><tt>.</tt><i>name</i> between the strings
given as the values of the fields <tt>start_string</tt> and <tt>end_string</tt>
in <i>solver</i>

<li> the mapping available via <font size="-1"><tt>showSatVarMap</font></tt> is used
to turn the extracted model into a HOL term

<li> if the value of the field <tt>only_true</tt> is
<font size="-1"><tt>true</font></tt> then it is assumed that only the positive literals
of the model are given (this is the case with SATO) and so
the negative literals are taken to be the negations of those variables
occurring in <i>term</i>, but not in the computed model
</OL>
<p>

<li> creates a theorem, tagged with the name of <i>solver</i>, showing the result

<p>

<OL type="a">
<li> if <i>term</i> is unsatisfiable the result is the tagged theorem <font size="-1"><tt>|- ~</tt></font><i>term</i>

<li> if a model is found the result is the tagged theorem 
<font size="-1"><tt>|- </tt></font><i>model</i><font size="-1"><tt> ==&#62; </tt></font><i>term</i>,
where <i>model</i> is the conjunction of the literals extracted from the model

<li> the oracle tag is the name of <i>solver</i>.
</OL>
<p>
</OL>       <H4><A NAME="tth_sEc3.1.5">
3.1.5</A>&nbsp;&nbsp;<tt>satProve</tt></H4>

<p>
<font size="-1"><tt>satProve</tt>&nbsp;<i>solver</i>&nbsp;<i>term</i></font> goes through the same steps 1,2 and 3 
as <tt>satOracle</tt>, but instead of step 4

<p>

<OL type="1">
<li>  if
a model is found, then proof in Hol98 is used to first check the model
is really a model (by `evaluating' <i>term</i> using the model) and if it
is an untagged theorem <font size="-1"><tt>|- </tt></font><i>model</i><font size="-1"><tt> ==&#62; </tt></font><i>term</i>
is returned

<p>

<li> if a model is found by <i>solver</i>, but the Hol98 check fails, 
i.e.&nbsp;the model is invalid, then the exception <font size="-1"><tt>satProveError</font></tt> is raised

<p>

<li> if <i>term</i> is found to be unsatisfiable by <i>solver</i>,
the exception <font size="-1"><tt>satProveError</font></tt> is raised

<p>
</OL>       <H4><A NAME="tth_sEc3.1.6">
3.1.6</A>&nbsp;&nbsp;<tt>readDimacs</tt></H4>

<p>
<font size="-1"><tt>readDimacs</tt>&nbsp;<i>file</i></font> reads a DIMACS format file and returns
an CNF HOL term corresponding the the SAT problem in the file names <i>file</i>.
The integers in the file are prefixed with the string in the reference 
<font size="-1"><tt>prefix</font></tt> (the default is <font size="-1"><tt>"v"</tt></font>).

<p>
<font size="-1"><tt>readDimacs</tt></font> is mainly intended as a tool for getting
CNF examples by reading in examples from the DIMACS problem set,
which is distributed with <tt>HolSatLib</tt> in the directory
<font size="-1"><tt>HolSatLib/doc/DIMACS</tt></font> or is available from<br>
<font size="-1"><A HREF="ftp://dimacs.rutgers.edu/pub/challenge/satisfiability/benchmarks/cnf/">
<tt>ftp://dimacs.rutgers.edu/pub/challenge/satisfiability/benchmarks/cnf/</tt></A></font>.

<p>
      <H3><A NAME="tth_sEc3.2">
3.2</A>&nbsp;&nbsp;Contents of <tt>SatSolvers</tt> module</H3>

<p>
<tt>SatSolvers</tt> contains the definition of the datatype
<font size="-1"><tt>sat_solver</font></tt> for specifying SAT solvers.

<p>
The record that is supplied as an argument to the constructor <font size="-1"><tt>SatSolver</font></tt>
has the following fields.

<p>
<p><br>
<table>
<tr><td><font size="-1"><tt>name</font></tt> </td><td>name of the SAT solver </td>
<tr><td><font size="-1"><tt>URL</font></tt> </td><td>URL of the SAT executable for downloading</td>
<tr><td><font size="-1"><tt>executable</font></tt> </td><td>name of the SAT solver command</td>
<tr><td><font size="-1"><tt>notime_run</font></tt> </td><td>evaluating <font size="-1"><tt>notime_run</font></tt><i>&nbsp;ex&nbsp;(infile,outfile)</i> returns a string</td>
<tr><td></td><td>giving a command to execute to run the SAT solver from input</td>
<tr><td></td><td><i>infile</i> and produce output <i>outfile</i>; the paramenter</td>
<tr><td></td><td><i>ex</i> should be the full path name of the  SAT solver command</td>
<tr><td></td><td>all command options are the defaults (see solver documentation)</td>
<tr><td><font size="-1"><tt>time_run</font></tt> </td><td>evaluating <font size="-1"><tt>time_run</font></tt><i>&nbsp;ex&nbsp;((infile,outfile),time)</i> returns a string</td>
<tr><td></td><td>giving a command to execute to run the SAT solver for <i>time</i> units</td>
<tr><td></td><td>of time (the units are specified in the SAT solver's documentation)</td>
<tr><td></td><td>from input <i>infile</i> and produce output <i>outfile</i>; the paramenter</td>
<tr><td></td><td><i>ex</i> should be the full path name of the  SAT solver command;</td>
<tr><td></td><td>all command options, besides the time, are the defaults</td>
<tr><td></td><td>(currently <font size="-1"><tt>time_run</font></tt> is not used)</td>
<tr><td><font size="-1"><tt>failure_string</font></tt> </td><td>string whose presence in the solver output indicated unsatisfiability</td>
<tr><td><font size="-1"><tt>start_string</font></tt> </td><td>string indicating start of model </td>
<tr><td><font size="-1"><tt>end_string</font></tt> </td><td>string indicating end of model </td></td></table>


<p>
<p><br>Note that if a model is found, it is assumed to be bracketed
by <font size="-1"><tt>start_string</font></tt> and <font size="-1"><tt>end_string</font></tt>. SAT solvers 
(like <A HREF="http://www.laria.u-picardie.fr/~cli/EnglishPage.html"><tt>satz</tt></A>)
for which models are not bracketed by a fixed pair of strings cannot currently
be specified for use with <tt>HolSatLib</tt>. If access to such solvers is needed, then
it will be necessary to extend the datatype <font size="-1"><tt>sat_solver</font></tt> to contain
additional parsing data (e.g.&nbsp;regular expressions).

<p>
      <H3><A NAME="tth_sEc3.3">
3.3</A>&nbsp;&nbsp;Contents of <tt>canonTools</tt> module</H3>

<p>
The module <tt>canonTools</tt> contains a simple conversion <font size="-1"><tt>CNF_CONV : term -&#62; thm</tt></font>, 
from Joe Hurd, to convert
HOL terms to a form suitable for inputting to <font size="-1"><tt>satOracle</font></tt> or <font size="-1"><tt>satProve</font></tt>.

<p>
<font size="-1"><tt>CNF_CONV</tt></font>&nbsp;t returns a theorem <font size="-1"><tt>|- </tt></font>t<font size="-1"><tt>&nbsp; = &nbsp;</font></tt>t<font face=symbol>¢</font
>,
where t<font face=symbol>¢</font
> is in CNF.

<p>

There are other tools for converting to various canonical forms. See the source code
<A HREF="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/hol/hol98/src/HolSat/">
<font size="-1"><tt>canonTools.sml</tt></font></A> for details.


<p><hr><small>File translated from T<sub><font size="-1">E</font></sub>X by <a href="http://hutchinson.belmont.ma.us/tth/">T<sub><font size="-1">T</font></sub>H</a>, version 2.00.<br>On  1 Jun 2001, 12:58.<br>
(then edited by Mike Gordon.)</small>
</HTML>
