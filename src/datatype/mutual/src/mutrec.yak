open Parse_support;
open DefTypeInfo;


fun HOL_PARSE_ERR{function,message} = 
 Exception.HOL_ERR{origin_structure = "mutual types grammar",
             origin_function = function,
             message = message};

(*---------------------------------------------------------------------------
 * Folding constant type specification subexpressions
 *---------------------------------------------------------------------------*)
local
fun dest_existing (existing ty) = ty
  | dest_existing _  = raise Match
in
fun fold_const (ty as type_op{Tyop,Args}) =
       let val Args' = map fold_const Args
       in
           existing (mk_type{Tyop = Tyop, Args = map dest_existing Args'})
           handle _ => type_op{Tyop = Tyop, Args = Args'}
       end
  | fold_const ty = ty
end
(* -------------------------------------------------------------- *)
(* If every argument in Args folds to (existing ty')              *)
(* and Tyop is fun or sum or prod (some known type operator,      *)
(* anything other than one being defined) then make it.           *)
(* Actually, try making it, and if it fails, revert.              *)
(* -------------------------------------------------------------- *)


type arg = (int,Type.hol_type) Lib.istream
%%
%term ident of string
    | symbolic_ident of string
    | qualified_ident of (string*string)
    | type_ident of string
    | qualified_type_ident of (string*string)
    | type_var_ident of string
    | binder of string
    | qualified_binder of (string*string)
    | aq of Term.term
    | lparen | rparen | type_lparen | type_rparen | lbracket | rbracket
    | lbrace | rbrace
    | type_comma | colon | dcolon | dot | semi_colon | eq_gt | eq
    | arrow | type_hash | type_plus | bar
    | let_ | and_ | in_ | of_
    | string_ of string
    | EOLEX
    | EOF 

(*
parse_mutual_types is
{type_name:string,constructors:{name:string,arg_info:type_info list} list} list
*)

%nonterm START     of {type_name:string,
                       constructors : {name:string,
                                       arg_info:type_info list} list} list

       (* Types *)
       | TYPE      of type_info
       | TYPE_ARG  of type_info list
       | TYPE_LIST of type_info list
       | BASIC     of type_info

       (* Mutual Recursive Datatype specs. *)
       | MUTYSPEC  of {type_name:string,
                       constructors : {name:string,
                                       arg_info:type_info list} list} list
       | MTYSPEC   of {type_name:string,
                       constructors : {name:string,
                                       arg_info:type_info list} list}
       | MTYID     of string
       | MCLAUSES  of {name:string, arg_info:type_info list} list
       | MCLAUSE   of {name:string, arg_info:type_info list}
       | MCARGS    of type_info list


%start START
%eop EOF EOLEX
%pos int
%header (functor MutrecLrValsFun (Token : TOKEN))
%name Mutrec
%noshift EOF
%pure
%verbose
%right arrow 
%right type_plus 
%right type_hash 
%arg (tyvars) : (int,Type.hol_type) Lib.istream
%%

START: colon MUTYSPEC (MUTYSPEC)


(*-----------------------TYPES-----------------------------------------------*)
TYPE : TYPE   arrow   TYPE  (type_op{Tyop = "fun", Args = [TYPE1,TYPE2]})
     | TYPE type_plus TYPE  (type_op{Tyop = "sum", Args = [TYPE1,TYPE2]})
     | TYPE type_hash TYPE  (type_op{Tyop = "prod",Args = [TYPE1,TYPE2]})
     | TYPE_ARG type_ident  (type_op{Tyop = type_ident, Args = TYPE_ARG})
     | BASIC                (BASIC)

TYPE_ARG : TYPE_ARG type_ident     ([type_op{Tyop=type_ident, Args=TYPE_ARG}])
         | type_lparen TYPE type_comma TYPE_LIST type_rparen (TYPE::TYPE_LIST)
         | BASIC                                                     ([BASIC])

BASIC : type_var_ident    (existing
                                (Preterm.Term.Type.mk_vartype type_var_ident))
      | type_ident        (existing (Preterm.Term.Type.mk_type{
                                       Tyop = type_ident, Args = []})
                           handle _ =>
                           being_defined type_ident)
      | aq                (existing (extract_type_antiq aq))
      | type_lparen TYPE type_rparen (TYPE)


TYPE_LIST : TYPE type_comma TYPE_LIST (TYPE::TYPE_LIST)    |   TYPE ([TYPE])


(*--------------MUTUAL RECURSIVE DATATYPE SPECIFICATIONS---------------------*)
MUTYSPEC : MTYSPEC                          ([MTYSPEC])
         | MTYSPEC semi_colon MUTYSPEC      (MTYSPEC::MUTYSPEC)

MTYSPEC : MTYID eq MCLAUSES   ({type_name=MTYID,constructors=MCLAUSES})
MTYID   : ident               (Globals.in_type_spec := SOME ident; ident)

MCLAUSES: MCLAUSE               ([MCLAUSE])
        | MCLAUSE bar MCLAUSES  (MCLAUSE::MCLAUSES)

MCLAUSE : string_                    ({name=string_ ,       arg_info=[]})
        | ident                      ({name=ident,          arg_info=[]})
        | symbolic_ident             ({name=symbolic_ident, arg_info=[]})
        | ident of_ MCARGS           ({name=ident,          arg_info=MCARGS})
        | symbolic_ident of_ MCARGS  ({name=symbolic_ident, arg_info=MCARGS})

MCARGS  : TYPE eq_gt MCARGS   ((fold_const TYPE)::MCARGS) 
        | TYPE                ([fold_const TYPE])
