(* ========================================================================= *)
(* Some (mutually, nested) recursive types from various sources, collected   *)
(* by jrh.                                                                   *)
(* ========================================================================= *)

load "mutualLib"; open mutualLib;
load "optionTheory";

fun basic_define_type n l q = 
 Define_type.define_type{name=n,type_spec=q,fixities = l};

time (define_type []) `Term = Var of 'A => 'B 
                            | App of bool => Termlist;
                   Termlist = Empty | Consp of Term => Termlist`;

time (basic_define_type "List" [Prefix,Prefix])
      `List = Nil 
            | Cons of 'A => List`;;

time (basic_define_type "Btree" [Prefix,Prefix])
    `Btree = Lf of 'A 
           | Nd of 'B => Btree => Btree`;;

time (define_type [])
    `Command = Assign of ind => Express
             | If of Express => Command
             | Ite of Express => Command => Command
             | While of Express => Command
             | Do of Command => Express;

     Express = Constant of num
             | Variable of ind
             | Summ of Express => Express
             | Product of Express => Express`;

time (define_type []) 
    `testa = empty_testa | cons_testa of testa => testb;
     testb = contentb of 'L => testc;
     testc = connection of 'M => testa`;;

time (define_type [])
    `atexp = Varb of ind 
           | Let of dec => exp;

       exp = Exp1 of atexp 
           | Exp2 of exp => atexp 
           | Exp3 of match;

     match = Match1 of rule 
           | Matches of rule => match;

     rule  = Rule of pat => exp;
       dec = Val of valbind 
           | Local of dec => dec 
           | Decs of dec => dec;

   valbind = Single of pat => exp 
           | Multi of pat => exp => valbind 
           | Rec of valbind;

       pat = Wild 
           | Varpat of ind`;;

time (basic_define_type "tri" [Prefix,Prefix,Prefix])
     define_type "tri = ONE | TWO | THREE";

(* ------------------------------------------------------------------------- *)
(* A couple from Steve Brackin's work.                                       *)
(* ------------------------------------------------------------------------- *)

time (basic_define_type "Steve1" 
  [Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,
   Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,
   Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,
   Prefix,Prefix,Prefix,Prefix])
      `Steve0 = X1 | X2 | X3 | X4 | X5 | X6 | X7 | X8 | X9 | X10 | X11 |
                X12 | X13 | X14 | X15 | X16 | X17 | X18 | X19 | X20 | X21 |
                X22 | X23 | X24 | X25 | X26 | X27 | X28 | X29 | X30 | X31 |
                X32 | X33 | X34`;;

time (define_type [])
    `TY1 = NoF__ 
         | Fk__ of 'A => TY2;

     TY2 = Ta__ of bool 
         | Td__ of bool 
         | Tf__ of TY1 
         | Tk__ of bool 
         | Tp__ of bool
         | App__ of 'A => TY1 => TY2 => TY3 
         | Pair__ of TY2 => TY2;

     TY3 = NoS__ 
         | Fresh__ of TY2 
         | Trustworthy__ of 'A
         | PrivateKey__ of 'A => 'B => 'C 
         | PublicKey__ of 'A => 'B => 'C
         | Conveyed__ of 'A => TY2 
         | Possesses__ of 'A => TY2 
         | Received__ of 'A => TY2 
         | Recognizes__ of 'A => TY2 
         | NeverMalFromSelf__ of 'A => 'B => TY2
         | Sends__ of 'A => TY2 => 'B 
         | SharedSecret__ of 'A => TY2 => 'B
         | Believes__ of 'A => TY3 
         | And__ of TY3 => TY3`;;

(* ------------------------------------------------------------------------- *)
(* Some with nesting of various kinds, plus required auxiliaries.            *)
(* ------------------------------------------------------------------------- *)

val def1 = time (define_type [listTheory.list_Axiom])
   `term = Vari of ind     (* ind was int *)
         | Fni of ind => term list`;

val def2 = time (define_type [pairTheory.pair_Axiom])
  `bintree = Leafb 
           | Branchb of bintree # bintree`;

val def3 = time (define_type [sumTheory.sum_Axiom])
  `etree = Terminal 
         | Nonterminal of num + etree`;

val def4 = time (define_type [optionTheory.option_Axiom])
  `ptree = Only of ptree option`;;

val def5 = time (define_type [])
  `mutual = Mutual of 'A => mutual => 'D => otherone 
          | Friend of 'D => otherone;
   otherone = Great of 'C 
            | Expectations of mutual => otherone`;;


local val mty = ty_antiq (Type`:('A,'D,'C)mutual`);
      val th1 = Q.SPECL [`f0`,`f1`,`f2`,`f3`] (#New_Ty_Uniqueness_Thm def5)
in
val mutual_ax = prove
(Term`!f0 f1 f2 f3.
  ?!fnm fno.
    (!x0 m x1 q. fnm (Mutual x0 m x1 q) = f0 (fnm m) (fno q) x0 x1 m q) /\
    (!x q.       fnm (Friend x q:^mty)  = f1 (fno q) x q) /\
    (!x.         fno (Great x)          = f2 x) /\
    (!m q.       fno (Expectations m q) = f3 (fnm m) (fno q) m q)`,
 REPEAT GEN_TAC 
  THEN CONV_TAC (DEPTH_CONV EXISTS_UNIQUE_CONV) THEN CONJ_TAC THENL
  [STRIP_ASSUME_TAC 
     (Q.SPECL [`f0`,`f1`,`f2`,`f3`] (#New_Ty_Existence_Thm def5))
    THEN Q.ID_EX_TAC THEN CONJ_TAC THENL
    [Q.ID_EX_TAC THEN ASM_REWRITE_TAC[],
     REPEAT (POP_ASSUM (K ALL_TAC)) THEN REPEAT GEN_TAC 
      THEN REPEAT STRIP_TAC THEN MATCH_MP_TAC 
          (REWRITE_RULE[] (Q.SPECL [`fnm`,`fno'`, `fnm`, `fno''`] th1))
      THEN REPEAT CONJ_TAC THEN FIRST_ASSUM MATCH_ACCEPT_TAC],
   REPEAT STRIP_TAC 
    THEN MP_TAC (REWRITE_RULE[] (Q.SPECL [`fnm`,`fno`, `fnm'`, `fno'`] th1))
    THEN ASM_REWRITE_TAC [] THEN STRIP_TAC])
end;


(* Need to prove rec'n thm for mutual first ... still doesn't work *)
val def6 = time (define_type [mutual_ax])
  `groof = Wu of bool
         | Wibble of ('A,groof,'L)mutual
         | Wobble of groof => groof`;

val def7 = time (define_type [listTheory.list_Axiom, sumTheory.sum_Axiom])
  `biterm = Variab of ind
          | Fnapp of biterm list + biterm list`;

val def8 = time (define_type [listTheory.list_Axiom, sumTheory.sum_Axiom])
  `triterm = Var0 of ind
          | Fun2 of triterm list + triterm list
          | Fun1 of triterm list`;;

val def9 = time (define_type [listTheory.list_Axiom])
    `xtree = Leafx of 'A
           | Branchx of xtree list`;;

(* Need to prove rec'n thm for xtree first *)
val def10 = time (define_type [xtree_Axiom])
  `simper = Leaves of 'A => 'B
          | Bough of simper xtree`;;

val def11 = time (basic_define_type "array" [Prefix])
  `array = Array of num => 'A list`;

(* Need to prove rec'n thms for xtree first *)
val def12 = time (define_type [listTheory.list_Axiom, xtree_Axiom, def11])
  `value = Integer of num
         | Boolean of bool
         | List of value list
         | Tree of value xtree
         | Array of value array`;;

val def13 = time (define_type [listTheory.list_Axiom,pairTheory.pair_Axiom])
  `command = Assignment of num list # expression list
           | Sequence of command list;
   expression = Numeral of num
              | Plus of expression # expression
              | Valof of command`;;

val def14 = time (define_type[mutual_Axiom,listTheory.list_Axiom,
                              pairTheory.pair_Axiom])
  `zonk = Stonk of ((zonk,pink,'A)mutual)list # expression
        | Tonk of zonk => pink list
        | Honk of num;
   pink = Floyd of zonk # pink
        | Purple of num
        | Rain of 'A # pink`;;

(* ------------------------------------------------------------------------- *)
(* Example from Konrad: 68000 instruction set.                               *)
(* ------------------------------------------------------------------------- *)

time (basic_define_type "SZ" [Prefix,Prefix,Prefix])
      `Size = Byte | Word | Long`;;

time (basic_define_type "DataRegister" 
  [Prefix,Prefix,Prefix,Prefix, Prefix,Prefix,Prefix,Prefix])
  `DataRegister = RegD0
                | RegD1
                | RegD2
                | RegD3
                | RegD4
                | RegD5
                | RegD6
                | RegD7`;

time (basic_define_type "AddressRegister" 
 [Prefix,Prefix,Prefix,Prefix, Prefix,Prefix,Prefix,Prefix])
  `AddressRegister = RegA0
                   | RegA1
                   | RegA2
                   | RegA3
                   | RegA4
                   | RegA5
                   | RegA6
                   | RegA7`;;

time (basic_define_type "DataOrAddressRegister" [Prefix,Prefix])
 `DataOrAddressRegister
              = data of DataRegister
              | address of AddressRegister`;

time (basic_define_type "Condition" 
[Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,
 Prefix,Prefix,Prefix,Prefix])
    `Condition = Hi
              | Ls
              | Cc
              | Cs
              | Ne
              | Eq
              | Vc
              | Vs
              | Pl
              | Mi
              | Ge
              | Lt
              | Gt
              | Le`;;

time (basic_define_type "AddressingMode" 
[Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix])
 `AddressingMode 
        = immediate of  num
        | direct of DataOrAddressRegister
        | indirect of AddressRegister
        | postinc of AddressRegister
        | predec of AddressRegister
        | indirectdisp of num => AddressRegister
        | indirectindex of num => AddressRegister => 
                           DataOrAddressRegister => Size
        | absolute of num
        | pcdisp of num
        | pcindex of num => DataOrAddressRegister => Size`;;


time (basic_define_type "M68kInstruction"
[Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,
 Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,
 Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,
 Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,
 Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,
 Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,
 Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,
 Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,
 Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,
 Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix,Prefix])
`M68kInstruction
    = ABCD of AddressingMode => AddressingMode
    | ADD of Size => AddressingMode => AddressingMode
    | ADDA of Size => AddressingMode => AddressRegister
    | ADDI of Size => num => AddressingMode
    | ADDQ of Size => num => AddressingMode
    | ADDX of Size => AddressingMode => AddressingMode
    | AND of Size => AddressingMode => AddressingMode
    | ANDI of Size => num => AddressingMode
    | ANDItoCCR of num
    | ANDItoSR of num
    | ASL of Size => AddressingMode => DataRegister
    | ASLW of AddressingMode
    | ASR of Size => AddressingMode => DataRegister
    | ASRW of AddressingMode
    | Bcc of Condition => Size => num
    | BTST of Size => AddressingMode => AddressingMode
    | BCHG of Size => AddressingMode => AddressingMode
    | BCLR of Size => AddressingMode => AddressingMode
    | BSET of Size => AddressingMode => AddressingMode
    | BRA of Size => num
    | BSR of Size => num
    | CHK of AddressingMode => DataRegister
    | CLR of Size => AddressingMode
    | CMP of Size => AddressingMode => DataRegister
    | CMPA of Size => AddressingMode => AddressRegister
    | CMPI of Size => num => AddressingMode
    | CMPM of Size => AddressRegister => AddressRegister
    | DBT of DataRegister num
    | DBF of DataRegister num
    | DBcc of Condition => DataRegister => num
    | DIVS of AddressingMode => DataRegister
    | DIVU of AddressingMode => DataRegister
    | EOR of Size => DataRegister => AddressingMode
    | EORI of Size => num => AddressingMode
    | EORItoCCR of num
    | EORItoSR of num
    | EXG of DataOrAddressRegister => DataOrAddressRegister
    | EXT of Size => DataRegister
    | ILLEGAL
    | JMP of AddressingMode
    | JSR of AddressingMode
    | LEA of AddressingMode => AddressRegister
    | LINK of AddressRegister num
    | LSL of Size => AddressingMode => DataRegister
    | LSLW of AddressingMode
    | LSR of Size => AddressingMode => DataRegister
    | LSRW of AddressingMode
    | MOVE of Size => AddressingMode => AddressingMode
    | MOVEtoCCR of AddressingMode
    | MOVEtoSR of AddressingMode
    | MOVEfromSR of AddressingMode
    | MOVEtoUSP of AddressingMode
    | MOVEfromUSP of AddressingMode
    | MOVEA of Size => AddressingMode => AddressRegister
    | MOVEMto of Size => AddressingMode => DataOrAddressRegister list
    | MOVEMfrom of Size => DataOrAddressRegister list => AddressingMode
    | MOVEP of Size => AddressingMode => AddressingMode
    | MOVEQ of num => DataRegister
    | MULS of AddressingMode => DataRegister
    | MULU of AddressingMode => DataRegister
    | NBCD of AddressingMode
    | NEG of Size => AddressingMode
    | NEGX of Size => AddressingMode
    | NOP
    | NOT of Size => AddressingMode
    | OR of Size => AddressingMode => AddressingMode
    | ORI of Size => num => AddressingMode
    | ORItoCCR of num
    | ORItoSR of num
    | PEA of AddressingMode
    | RESET
    | ROL of Size => AddressingMode => DataRegister
    | ROLW of AddressingMode
    | ROR of Size => AddressingMode => DataRegister
    | RORW of AddressingMode
    | ROXL of Size => AddressingMode => DataRegister
    | ROXLW of AddressingMode
    | ROXR of Size => AddressingMode => DataRegister
    | ROXRW of AddressingMode
    | RTE
    | RTR
    | RTS
    | SBCD of AddressingMode => AddressingMode
    | ST of AddressingMode
    | SF of AddressingMode
    | Scc of Condition => AddressingMode
    | STOP of num
    | SUB of Size => AddressingMode => AddressingMode
    | SUBA of Size => AddressingMode => AddressingMode
    | SUBI of Size => num => AddressingMode
    | SUBQ of Size => num => AddressingMode
    | SUBX of Size => AddressingMode => AddressingMode
    | SWAP of DataRegister
    | TAS of AddressingMode
    | TRAP of num
    | TRAPV
    | TST of Size => AddressingMode
    | UNLK of AddressRegister`;;

(* ------------------------------------------------------------------------- *)
(* Example from Myra: part of the syntax of SML.                             *)
(* ------------------------------------------------------------------------- *)

time basicdefine_type
  "string = EMPTY_STRING | CONS_STRING num string";;

let strid_INDUCTION,strid_RECURSION = time define_type
  "strid = STRID string;
   var = VAR string;
   con = CON string;
   scon = SCINT int | SCSTR string;
   excon = EXCON string;
   label = LABEL string";;

let nonemptylist_INDUCTION,nonemptylist_RECURSION = time define_type
  "nonemptylist = Head_and_tail A (A list)";;

let long_INDUCTION,long_RECURSION = time define_type
  "long = BASE A | QUALIFIED strid long";;

let myra_INDUCTION,myra_RECURSION = time define_type
  "atpat_e = WILDCARDatpat_e
           | SCONatpat_e scon
           | VARatpat_e var
           | CONatpat_e (con long)
           | EXCONatpat_e (excon long)
           | RECORDatpat_e (patrow_e option)
           | PARatpat_e pat_e;

   patrow_e = DOTDOTDOT_e
            | PATROW_e label pat_e (patrow_e option);

   pat_e = ATPATpat_e atpat_e
         | CONpat_e (con long) atpat_e
         | EXCONpat_e (excon long) atpat_e
         | LAYEREDpat_e var pat_e;

   conbind_e = CONBIND_e con (conbind_e option);

   datbind_e = DATBIND_e conbind_e (datbind_e option);

   exbind_e = EXBIND1_e excon (exbind_e option)
            | EXBIND2_e excon (excon long) (exbind_e option);

   atexp_e = SCONatexp_e scon
           | VARatexp_e (var long)
           | CONatexp_e (con long)
           | EXCONatexp_e (excon long)
           | RECORDatexp_e (exprow_e option)
           | LETatexp_e dec_e exp_e
           | PARatexp_e exp_e;

   exprow_e = EXPROW_e label exp_e (exprow_e option);

   exp_e = ATEXPexp_e atexp_e
         | APPexp_e exp_e atexp_e
         | HANDLEexp_e exp_e match_e
         | RAISEexp_e exp_e
         | FNexp_e match_e;

   match_e = MATCH_e mrule_e (match_e option);

   mrule_e = MRULE_e pat_e exp_e;

   dec_e = VALdec_e valbind_e
         | DATATYPEdec_e datbind_e
         | ABSTYPEdec_e datbind_e dec_e
         | EXCEPTdec_e exbind_e
         | LOCALdec_e dec_e dec_e
         | OPENdec_e ((strid long) nonemptylist)
         | EMPTYdec_e
         | SEQdec_e dec_e dec_e;

   valbind_e = PLAINvalbind_e pat_e exp_e (valbind_e option)
             | RECvalbind_e valbind_e";;

(* ------------------------------------------------------------------------- *)
(* Example from Daryl: a Verilog grammar.                                    *)
(* ------------------------------------------------------------------------- *)

let daryl_INDUCTION,daryl_RECURSION = time define_type
  "Source_text
     = module string (string list) (Module_item list)
     | Source_textMeta string;
  Module_item
     = declaration Declaration
     | initial Statement
     | always Statement
     | assign Lvalue Expression
     | Module_itemMeta string;
  Declaration
     = reg_declaration (Range option) (string list)
     | net_declaration (Range option) (string list)
     | input_declaration (Range option) (string list)
     | output_declaration (Range option) (string list)
     | DeclarationMeta string;
  Range = range Expression Expression | RangeMeta string;
  Statement
     = clock_statement Clock Statement_or_null
     | blocking_assignment Lvalue Expression
     | non_blocking_assignment Lvalue Expression
     | conditional_statement
          Expression Statement_or_null (Statement_or_null option)
     | case_statement Expression (Case_item list)
     | while_loop Expression Statement
     | repeat_loop Expression Statement
     | for_loop
          Lvalue Expression Expression Lvalue Expression Statement
     | forever_loop Statement
     | disable string
     | seq_block (string option) (Statement list)
     | StatementMeta string;
  Statement_or_null
     = statement Statement | null_statement | Statement_or_nullMeta string;
  Clock
     = posedge string
     | negedge string
     | clock string
     | ClockMeta string;
  Case_item
     = case_item (Expression list) Statement_or_null
     | default_case_item Statement_or_null
     | Case_itemMeta string;
  Expression
     = plus Expression Expression
     | minus Expression Expression
     | lshift Expression Expression
     | rshift Expression Expression
     | lt Expression Expression
     | leq Expression Expression
     | gt Expression Expression
     | geq Expression Expression
     | logeq Expression Expression
     | logneq Expression Expression
     | caseeq Expression Expression
     | caseneq Expression Expression
     | bitand Expression Expression
     | bitxor Expression Expression
     | bitor Expression Expression
     | logand Expression Expression
     | logor Expression Expression
     | conditional Expression Expression Expression
     | positive Primary
     | negative Primary
     | lognot Primary
     | bitnot Primary
     | reducand Primary
     | reducxor Primary
     | reducor Primary
     | reducnand Primary
     | reducxnor Primary
     | reducnor Primary
     | primary Primary
     | ExpressionMeta string;
  Primary
     = primary_number Number
     | primary_IDENTIFIER string
     | primary_bit_select string Expression
     | primary_part_select string Expression Expression
     | primary_gen_bit_select Expression Expression
     | primary_gen_part_select Expression Expression Expression
     | primary_concatenation Concatenation
     | primary_multiple_concatenation Multiple_concatenation
     | brackets Expression
     | PrimaryMeta string;
  Lvalue
     = lvalue string
     | lvalue_bit_select string Expression
     | lvalue_part_select string Expression Expression
     | lvalue_concatenation Concatenation
     | LvalueMeta string;
  Number
     = decimal string
     | based string option string
     | NumberMeta string;
  Concatenation
     = concatenation (Expression list) | ConcatenationMeta string;
  Multiple_concatenation
     = multiple_concatenation Expression (Expression list)
     | Multiple_concatenationMeta string;
  meta
     = Meta_Source_text Source_text
     | Meta_Module_item Module_item
     | Meta_Declaration Declaration
     | Meta_Range Range
     | Meta_Statement Statement
     | Meta_Statement_or_null Statement_or_null
     | Meta_Clock Clock
     | Meta_Case_item Case_item
     | Meta_Expression Expression
     | Meta_Primary Primary
     | Meta_Lvalue Lvalue
     | Meta_Number Number
     | Meta_Concatenation Concatenation
     | Meta_Multiple_concatenation Multiple_concatenation";;
