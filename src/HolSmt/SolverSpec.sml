(* Copyright (c) 2009 Tjark Weber. All rights reserved. *)

structure SolverSpec = struct

  (* possible values:
     0 - no output at all (except for fatal errors)
     1 - warnings only
     2 - also diagnostic messages of constant length
     3 - also diagnostic messages that are potentially lengthy (e.g., terms,
         models, proofs)
     4 - moreover, temporary files (for communication with the SMT solver) are
         not removed after solver invocation *)
  val trace = ref 2

  val _ = Feedback.register_trace ("HolSmtLib", trace, 4)

  datatype result = SAT of string option  (* model, should perhaps be a thm *)
                  | UNSAT of Thm.thm option  (* assumptions |- conclusion *)
                  | UNKNOWN of string option  (* reason for failure *)

  (* checks that no file given in 'files' exists; then calls 'pre' (which is
     supposed to create any input files the SMT solver may need) on the input
     goal, executes 'cmd' as a system command, calls 'post' (which is supposed
     to parse relevant output files generated by the SMT solver); deletes all
     files in 'files' (unless '!trace' = 4); emits messages according to
     '!trace' *)
  fun make_solver (pre : Abbrev.goal -> 'a)
                  (cmd : string)
                  (post : 'a -> result)
                  (files : string list) : Abbrev.goal -> result =
  fn goal =>
  let
    (* check that no file given in 'files' exists *)
    val _ = map (fn path =>
              if OS.FileSys.access (path, []) then
                raise (Feedback.mk_HOL_ERR "SolverSpec" "make_solver"
                  ("file '" ^ path ^ "' exists, please remove it"))
              else ()) files
    (* call 'pre goal' to generate input files *)
    val x = pre goal
    (* the actual system call to the SMT solver *)
    val _ = if !trace > 1 then
        Feedback.HOL_MESG ("HolSmtLib: calling external command '" ^ cmd ^ "'")
      else ()
    val _ = Systeml.system_ps cmd
    (* call 'post' to determine the result *)
    val result = post x
    val _ = if !trace > 1 then
        Feedback.HOL_MESG ("HolSmtLib: solver returned '" ^
          (case result of
             SAT NONE => "satisfiable' (no model given)"
           | SAT (SOME _) => "satisfiable' (model given)"
           | UNSAT NONE => "unsatisfiable' (no proof given)"
           | UNSAT (SOME thm) =>
             if !trace > 2 then
               "unsatisfiable' (theorem: " ^ Hol_pp.thm_to_string thm ^ ")"
             else
               "unsatisfiable' (proof checked)"
           | UNKNOWN NONE => "unknown' (no reason given)"
           | UNKNOWN (SOME _) => "unknown' (reason given)"))
      else ()
    (* if the SMT solver returned a theorem 'thm', then this should be of the
       form "A' |- g" with A' \subseteq A, where (A, g) is the input goal *)
    val _ = if !trace > 0 then
        case result of
          UNSAT (SOME thm) =>
            let
              val (A, g) = goal
              val A_set = HOLset.addList (HOLset.empty Term.compare, A)
            in
              if not (HOLset.isSubset (Thm.hypset thm, A_set)) then
                Feedback.HOL_WARNING "SolverSpec" "make_solver"
                  "theorem contains additional hyp(s)"
              else ();
              if not (Term.aconv (Thm.concl thm) g) then
                Feedback.HOL_WARNING "SolverSpec" "make_solver"
                  "conclusion of theorem does not match goal"
              else ()
            end
        | _ =>
          ()
      else ()
    (* delete all files in 'files' *)
    val _ = if !trace < 4 then
        ignore (map (fn path => OS.FileSys.remove path handle SysErr _ => ())
          files)
      else ()
  in
    result
  end

end
