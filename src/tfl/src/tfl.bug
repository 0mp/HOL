new_constant ("split", ``:num -> num list -> (num list # num # num list)option``);

val defn = 
 Hol_defn 
  "foo" 
  `foo L = 
     case split 3 L
      of NONE => L
       | SOME(L1,x,L2) =>
          case split 2 L1
           of NONE => []
            | SOME (L1a, y, L1b) => foo (L1a ++ [y] ++ L2)`;

Defn.tgoal defn;

e (RW_TAC list_ss []);

(* load Defn.sml *)

val stem = "foo" ;

val q = 
  `foo L = 
     case split 3 L
      of NONE => L
       | SOME(L1,x,L2) =>
          case split 2 L1
           of NONE => []
            | SOME (L1a, y, L1b) => foo (L1a ++ [y] ++ L2)`;

val [eqns] = parse_quote q;
val facts = TypeBase.theTypeBase();
val tup_eqs = eqns;
val wfrec_res = wfrec_eqns facts tup_eqs;
val {functional,pats} =
        mk_functional (TypeBasePure.toPmatchThry facts) (protect tup_eqs)
     val SV = free_vars functional    (* schematic variables *)
     val _ = checkSV pats SV
     val (f, Body) = dest_abs functional
     val (x,_) = dest_abs Body
     val (Name, fty) = dest_var f
     val (f_dty, f_rty) = Type.dom_rng fty
     val WFREC_THM0 = ISPEC functional relationTheory.WFREC_COROLLARY
     val R = variant (free_vars tup_eqs) (fst(dest_forall(concl WFREC_THM0)))
     val WFREC_THM = ISPECL [R, f] WFREC_THM0
     val tmp = fst(wfrecUtils.strip_imp(concl WFREC_THM))
     val proto_def = Lib.trye hd tmp
     val WFR = Lib.trye (hd o tl) tmp
     val R1 = rand WFR
     val corollary' = funpow 2 UNDISCH WFREC_THM
     val given_pats = givens pats
     val corollaries = map (C SPEC corollary') given_pats
     val eqns_consts = mk_set(find_terms is_const functional)
     val (case_rewrites,congs) = extraction_thms eqns_consts facts
     val RWcnv = REWRITES_CONV (add_rewrites empty_rewrites
                                (literal_case_THM::case_rewrites))
     val rule = unprotect_thm o
                RIGHT_CONV_RULE
                   (LIST_BETA_CONV
                    THENC REPEATC ((RWcnv THENC LIST_BETA_CONV) ORELSEC
                                   elim_triv_literal_CONV))
     val corollaries' = map rule corollaries;
val [(p,th)] = zip given_pats corollaries';
val FV = [R1];
val R = rand WFR
val CUT_LEM = ISPECL [f,R] relationTheory.RESTRICT_LEMMA
val restr_fR = rator(rator(lhs(snd(dest_imp (concl (SPEC_ALL CUT_LEM))))))
fun mk_restr p = mk_comb(restr_fR, p);
val nested_ref = ref false
val FV' = FV@free_vars(concl th)
(* open RW.sml *)
val rwArgs = (Pure [CUT_LEM],
              Context ([],DONT_ADD),
              Congs congs,
              Solver (solver (mk_restr p, f, FV', nested_ref)));
val tmA = concl th;
Rewrite Fully rwArgs tmA;

val tm = rhs tmA;
Rewrite Fully rwArgs tm;

val tm1 = rand tm;
Rewrite Fully rwArgs tm1;

val tm2 = body tm1;
Rewrite Fully rwArgs tm2;

val tm3 = rand tm2;
Rewrite Fully rwArgs tm3;

val tm4 = snd(strip_abs tm3);
Rewrite Fully rwArgs tm4;

val tm5 = rand tm4;
Rewrite Fully rwArgs tm5;

(*---------------------------------------------------------------------------*)
(* Issue seeems to be that pair_CASE has a cong rule, which may be           *)
(* interacting with the handling of paired abstractions in antecedents of    *)
(* instantiate cong. rules.                                                  *)
(*---------------------------------------------------------------------------*)

val [v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, 
     v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21] = congs;

val congs_without_pair_CASE = 
[v0, v2, v3, v4, v5, v6, v7, v8, v9, v10, 
 v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21];

val rwArgs' = (Pure [CUT_LEM],
              Context ([],DONT_ADD),
              Congs congs_without_pair_CASE,
              Solver (solver (mk_restr p, f, FV', nested_ref)));

Rewrite Fully rwArgs' tm4;

