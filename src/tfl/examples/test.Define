(*---------------------------------------------------------------------------
     A battery of tests for the "Define" function in bossLib.
 ---------------------------------------------------------------------------*)

open TotalDefn bossLib;

(*---------------------------------------------------------------------------
        First, a few straightforward recursions, some with 
        extended pattern matching.
 ---------------------------------------------------------------------------*)

val fact_def = Define `fact x = if x = 0 then 1 else x * fact(x-1)`;

val Fib_def = 
 Define `(Fib 0       = 1) 
   /\    (Fib (SUC 0) = 1) 
   /\    (Fib (SUC(SUC x)) = Fib x + Fib (SUC x))`;

val assoc_def =
 Define
    `assoc (x:'a) ((a,y)::t) = if x=a then y else assoc x t`;

Define`step x = x`;

val SM = Define `SM s n = if n=0 then s else SM (step s) (n-1)`;

Hol_datatype `tau = Ctr of bool # bool # bool`;
Define `goo(Ctr(d,_,_)) = d`;

(*---------------------------------------------------------------------------
   For the following 3, a "normal" size measure like LENGTH wouldn't 
   allow termination to be proved. Our parameterized size measure 
   does work, however.
 ---------------------------------------------------------------------------*)

val flatten_def =
  Define `(flatten  []           = [])
     /\   (flatten ([]::rst)     = flatten rst)
     /\   (flatten ((h::t)::rst) = h::flatten(t::rst))`;

val Tot_def = 
  Define
    `(Tot [] = 0) /\
     (Tot (0::t) = Tot t) /\
     (Tot (SUC n::t) = 1 + Tot (n::t))`;

val Tot_def = 
  Define
    `(Tot [] = 0) /\
     (Tot (0::t) = Tot t) /\
     (Tot (n::t) = 1 + Tot (n-1::t))`;

val gcd_def = 
Define 
    `(gcd (0,y) = y)         
 /\  (gcd (SUC x, 0) = SUC x)
 /\  (gcd (SUC x, SUC y) = 
         if y <= x then gcd(x-y, SUC y) 
                   else gcd(SUC x, y-x))`;

val gcd_def =  (* curried *)
  Define 
    `(gcd 0 y = y)  /\
     (gcd (SUC x) 0 = SUC x) /\
     (gcd (SUC x) (SUC y) = 
         if y <= x then gcd (x-y)   (SUC y) 
                   else gcd (SUC x) (y-x))`;

(* Should fail with informative error message *)
val percent2 = 
  Define 
    `(%% 0 y        = y)      /\
     (%% (SUC x) 0  = SUC x)  /\
     (%% (SUC x) (SUC y) = if y <= x then %% (x-y) (SUC y) 
                                     else %% (SUC x) (y-x))`;

val percent2 = 
  xDefine "percentpercent"
    `(%% 0 y        = y)      /\
     (%% (SUC x) 0  = SUC x)  /\
     (%% (SUC x) (SUC y) = if y <= x then %% (x-y) (SUC y) 
                                     else %% (SUC x) (y-x))`;

val map2_def = 
 Define
  `(map2(f, []:'a list,L:'b list) = []:'c list) /\
   (map2(f, h::t,   []) = [])                     /\
   (map2(f, h1::t1, h2::t2) = f h1 h2::map2 (f, t1, t2))`;

val sorted_def = 
 Define
    `(sorted (R, [])  = T) /\
     (sorted (R, [x]) = T) /\   
     (sorted (R, x::y::rst) = R x y /\ sorted (R, y::rst))`;

val part_def = 
Define
     `(part (P, [], l1,l2) = (l1,l2)) /\
      (part (P, h::rst, l1,l2) 
         = if P h then part(P,rst, h::l1, l2)
                  else part(P,rst,  l1,  h::l2))`;

val div_def = Define
   `(div(0,x) = (0,0)) /\
    (div(SUC x, y) = 
      let (q,r) = div(x,y)
      in (if y <= SUC r then (SUC q,0) else (q, SUC r)))`;

(* Test nested lets *)
val div_def = Define
   `(Div(0,x) = (0,0)) /\
    (Div(SUC x, y) = 
       let q = FST(Div(x,y)) 
       and r = SND(Div(x,y))
       in 
         if y <= SUC r then (SUC q,0) else (q, SUC r))`;

(* Test nested ifs *)
val smaller_def = Define
  `(smaller((0,i), z) = (i:num))    /\
   (smaller((SUC x, i), (0,j)) = j) /\
   (smaller((SUC x, i), (SUC y,j)) = 
        if SUC y = i then i else
        if SUC x = j then j 
        else smaller((x,i), (y,j)))`;

val min_def = Define
    `(min (SUC x) (SUC y) = min x y + 1)
 /\  (min x y = 0)`;


(*---------------------------------------------------------------------------*
 * Dutch National Flag by functional programming. Similar to bubble sort.    *
 *---------------------------------------------------------------------------*)

Hol_datatype `colour = Red | White | Blue`;

val Swap_def =
 Define 
   `(Swap  []                = NONE) 
 /\ (Swap (White::Red::rst)  = SOME(Red::White::rst))
 /\ (Swap (Blue::Red::rst)   = SOME(Red::Blue::rst))
 /\ (Swap (Blue::White::rst) = SOME(White::Blue::rst))
 /\ (Swap (x::rst)           = OPTION_MAP (CONS x) (Swap rst))`;

val Swap_def' = 
  let val Swap_NIL = CONJUNCT1 Swap_def
  in 
    CONJ Swap_NIL 
     (REWRITE_RULE [Swap_NIL,optionTheory.OPTION_MAP_DEF] 
             (CONJUNCT2 Swap_def))
  end;

val Flag_defn = 
 Hol_defn "Flag" 
          `Flag list = case Swap list
                        of NONE -> list
                        || SOME slist -> Flag slist`;



(*---------------------------------------------------------------------------
           Primitive recursion
 ---------------------------------------------------------------------------*)

val Fact_def = Define
   `(Fact 0 = 1) /\
    (Fact (SUC x) = Fact x * SUC x)`;

val mem_def = 
 Define 
    `(mem x [] = F) /\ 
     (mem x (h::t) = (x=h) \/ mem x t)`;

val filter_def = 
 Define 
    `(filter P [] = []) /\ 
     (filter P (h::t) = if P h then h::filter P t else filter P t)`;

val part_def = 
   Define
       `(part P [] l1 l2 = (l1,l2)) /\
        (part P (h::rst) l1 l2 =
           if P h then part P rst (h::l1) l2
                  else part P rst  l1 (h::l2))`;

val fold_def = 
 Define
     `(fold b f [] = b) /\
      (fold b f (h::t) = f h (fold b f t))`;

val exists_def = 
 Define
     `(exists P [] = F) /\
      (exists P (h::t) = (P h) \/ exists P t)`;

val sumf_def = 
 Define
     `(sumf f [] = 0) /\
      (sumf f (h::t) = f h + sumf f t)`;

(*---------------------------------------------------------------------------
     Iterated primitive recursion (see it_prim_rec)
 ---------------------------------------------------------------------------*)

val Ack_def = 
 Define
  `(Ack (0,n) =  n+1) /\
   (Ack (SUC m,0) = Ack (m, 1)) /\
   (Ack (SUC m, SUC n) = Ack (m, Ack (SUC m, n)))`;

val Sudan_def = 
 Define
   `(Sudan 0 (x,y)           = x+y)
 /\ (Sudan (SUC n) (x,0)     = x)
 /\ (Sudan (SUC n) (x,SUC y) = Sudan n (Sudan (SUC n) (x,y), 
                                        Sudan (SUC n) (x,y) + SUC y))`;

val V_def = 
 Define
   `(V (SUC 0, n, m)                = n) 
/\  (V (SUC(SUC k), n, SUC 0)       = V (SUC k, SUC n, SUC n))
/\  (V (SUC(SUC k), n, SUC (SUC m)) = V (SUC k, V(SUC(SUC k),n,SUC m)+1,
                                                V(SUC(SUC k),n,SUC m)+1))`;

(*---------------------------------------------------------------------------
             Schematic definitions
 ---------------------------------------------------------------------------*)

val While = DefineSchema `While s = if B s then While (C s) else s`;


Hol_datatype `btree = LEAF 
                    | NODE of btree => 'a => btree`;

val btreeRec_def = 
 Define
   `(btreeRec LEAF (v:'a) (f:'a->'b->'a->'a)  = v)
 /\ (btreeRec (NODE t1 M t2) v f = f (btreeRec t1 v f) M (btreeRec t2 v f))`;


val unfold_def = 
 DefineSchema
    `unfold (x:'a) = 
        if more x 
        then let (y1,b,y2) = dest x 
             in 
               NODE (unfold y1) b (unfold y2)
        else LEAF`;

val fusion_def = 
 DefineSchema
     `fusion (x:'a) = 
          if more x 
          then let (y,i,z) = dest x
               in 
                g (fusion y) (i:'b) (fusion z)
          else (c:'c)`;

val linRec_def = 
 DefineSchema
    `linRec (x:'a) = 
       if atomic x then A x 
       else  join (linRec (dest x)) (D x:'b)`;

val accRec_def0 = 
 DefineSchema
    `accRec (x:'a, u:'b) = 
         if atomic x 
         then join (A x) u
         else accRec (dest x, join (D x:'b) u)`;

(*---------------------------------------------------------------------------
        Binary recursive schema.
 ---------------------------------------------------------------------------*)

val binRec_def = 
 DefineSchema
    `binRec (x:'a) = 
      if atomic x then (A x:'b) 
      else join (binRec (left x)) 
                (binRec (right x))`;

(*---------------------------------------------------------------------------
         General tail recursive schema for lists.
 ---------------------------------------------------------------------------*)

val baRec_def = 
 DefineSchema
    `(baRec ([],v) = (v:'b)) 
  /\ (baRec (h::t, v) =
        if atomic h 
        then baRec (t, join v (A h:'b))
        else baRec (APPEND (dest (h:'a)) t, v))`;

(* Used to fail *)
val baRec_def = 
 DefineSchema
    `(baRec [] v = (v:'b)) 
  /\ (baRec (h::t) v =
        if atomic h 
        then baRec t (join v (A h:'b))
        else baRec (APPEND (dest (h:'a)) t) v)`;


(*---------------------------------------------------------------------------
        Non-recursive, curried, complex patterns, wildcards
 ---------------------------------------------------------------------------*)


Define `(g2 0 _ = 1) /\
        (g2 _ 0 = 2)`;

Define `(g3 0 _ _ = 1) /\
        (g3 _ 0 _ = 2) /\
        (g3 _ _ 0 = 3)`;

Define `(g4 (0,_,_,_) = 1) /\
        (g4 (_,0,_,_) = 2) /\
        (g4 (_,_,0,_) = 3) /\
        (g4 (_,_,_,0) = 4)`;

Define `(g5 (0,_,_,_,_) = 1) /\
        (g5 (_,0,_,_,_) = 2) /\
        (g5 (_,_,0,_,_) = 3) /\
        (g5 (_,_,_,0,_) = 4) /\
        (g5 (_,_,_,_,0) = 5)`;

(*---------------------------------------------------------------------------
      Some simple cases where termination is not yet proved automatically.
 ---------------------------------------------------------------------------*)

val qsort_def = 
 Hol_defn "qsort"
   `(qsort(ord,[]) = []) /\
    (qsort(ord, x::rst) = 
      APPEND (qsort(ord,FILTER ($~ o ord x) rst))
             (x :: qsort(ord,FILTER(ord x) rst)))`;

val fqsort_def = 
 Hol_defn "fqsort"
   `(fqsort ord [] = []) /\
    (fqsort ord (x::rst) = 
       let (l1,l2) = part (ord x) rst [] []
       in 
        APPEND (fqsort ord l1)  (x::fqsort ord l2))`;

val variant_def = 
  Hol_defn "variant" 
     `variant x L = if MEM x L then variant (x+1) L else x`;


(*---------------------------------------------------------------------------
        Wang's algorithm for propositional logic.
 ---------------------------------------------------------------------------*)

Hol_datatype `prop = VAR of 'a
                   | NOT of prop
                   | AND of prop => prop
                   | OR  of prop => prop`;

val Pr_def = 
 Defn.Hol_defn "Pr"
    `(Pr vl [] (VAR v::r)   vr = Pr vl [] r (v::vr))
 /\  (Pr vl [] (NOT x::r)   vr = Pr vl [x] r vr)
 /\  (Pr vl [] (OR x y::r)  vr = Pr vl [] (x::y::r) vr)
 /\  (Pr vl [] (AND x y::r) vr = Pr vl [] (x::r) vr /\ Pr vl [] (y::r) vr)

 /\  (Pr vl (VAR v::l)    r vr = Pr (v::vl) l r vr)
 /\  (Pr vl (NOT x::l)    r vr = Pr vl l (x::r) vr)
 /\  (Pr vl (AND x y::l)  r vr = Pr vl (x::y::l) r vr)
 /\  (Pr vl (OR x y::l)   r vr = Pr vl (x::l) r vr /\ Pr vl (y::l) r vr)

 /\  (Pr vl [] [] vr           = EXISTS (\y. MEM y vl) vr)`;


val Prove_def = Define `Prove P = Pr [] [] [P] []`;

(*---------------------------------------------------------------------------
     Termination of Pr. We need a subsidiary measure function on 
     propositions which makes a 2-argument proposition bigger than a 
     list of 2 propositions. 
 ---------------------------------------------------------------------------*)

val Meas_def =
 Define 
    `(Meas (VAR v)   = 0)
 /\  (Meas (NOT x)   = SUC (Meas x))
 /\  (Meas (AND x y) = Meas x + Meas y + 2)
 /\  (Meas (OR x y)  = Meas x + Meas y + 2)`;

(*---------------------------------------------------------------------------*
 *  Termination of Pr.                                                       *
 *---------------------------------------------------------------------------*)

val (Pr_eqns, Pr_ind) = Defn.tprove 
(Pr_def,
 WF_REL_TAC `measure \(w:'a list, x:'a prop list, y:'a prop list, z:'a list). 
                       list_size Meas x + list_size Meas y`
  THEN RW_TAC arith_ss [Meas_def,listTheory.list_size_def]);


(*---------------------------------------------------------------------------
    Binary trees (again).
 ---------------------------------------------------------------------------*)

Hol_datatype 
    `Btree = Leaf of 'a
           | Brh of 'a => Btree => Btree`;
 
(* prim. rec. *)
Define 
   `(upheap R w (Leaf x) = Brh w (Leaf x) (Leaf x)) /\
    (upheap R w (Brh v p q) =
         if R w v then Brh w (upheap R v q) p
                  else Brh v (upheap R w q) p)`;

(*---------------------------------------------------------------------------
     Not sure if this actually does anything useful. It might be nicer 
     to define this schematically on R, and still have termination proved.
 ---------------------------------------------------------------------------*)
DefineSchema
   `(merge_heap R (Leaf x) b = b)                         
 /\ (merge_heap R (Brh v b1 b2) (Leaf x) = Brh v b1 b2) 
 /\ (merge_heap R (Brh v b1 b2) (Brh w c1 c2) 
       = if R v w 
         then Brh v (merge_heap R b1 b2) (Brh w c1 c2)
         else Brh w (Brh v b1 b2) (merge_heap R c1 c2))`;

DefineSchema
   `(merge_heap (Leaf x) b = b)                         
 /\ (merge_heap (Brh v b1 b2) (Leaf x) = Brh v b1 b2) 
 /\ (merge_heap (Brh v b1 b2) (Brh w c1 c2) 
       = if R v w 
         then Brh v (merge_heap b1 b2) (Brh w c1 c2)
         else Brh w (Brh v b1 b2) (merge_heap c1 c2))`;

(*---------------------------------------------------------------------------*
 * This one fails, because you need to know a relation between term_size and *
 * list_size. Might work with multiset ordering.                             *
 *---------------------------------------------------------------------------*)

val V_def = 
Define
   `(V [] acc = acc)
 /\ (V (Leaf s::rst) acc        = V rst ([Leaf s]::acc)) 
 /\ (V (Brh x tm1 tm2::rst) acc = V (tm1::tm2::rst) acc)`;

TypeBasePure.type_size (TypeBase.theTypeBase()) (Type`:'a Btree list`);

(*---------------------------------------------------------------------------*
 * This one fails because the size of the tree is not changed.               *
 * Termination is provable with the following interpretation "Int":          *
 *                                                                           *
 *    Int (Leaf) = 0                                                         *
 *    Int (Brh x y) = 2 * Int x + Int y + 1                                  *
 *---------------------------------------------------------------------------*)

val Lin_def = 
Define`(Lin (Leaf x) = Leaf x) 
  /\   (Lin (Brh a (Leaf x) bt)        = Brh a (Leaf x) (Lin bt))
  /\   (Lin (Brh a (Brh x bt1 bt2) bt) = Lin (Brh x bt1 (Brh a bt2 bt)))`;


(*---------------------------------------------------------------------------
     Majority vote, in a variety of slightly different presentations, 
     some of which at one time or other made our naive termination 
     prover fail.
 ---------------------------------------------------------------------------*)

Define 
  `(Maj [] (winner,lead)  = (winner,lead))
/\ (Maj (h::t) (leader,0) = if h=leader then Maj t (leader,1) else Maj t (h,1))
/\ (Maj (h::t) (leader, SUC m) = 
        if h=leader then Maj t (leader, m+2) else Maj t (leader, m))`;

(* Alternative formulation *)
Define 
   `(Maj [] (winner,lead)  = (winner,lead))
 /\ (Maj (h::t) (leader,0) = Maj t (if h=leader then (leader,1) else (h,1)))
 /\ (Maj (h::t) (leader, SUC m) = 
        if h=leader then Maj t (leader, m+2)
                    else Maj t (leader, m))`;

(* Alternative formulation *)
Define 
   `(Maj [] (winner,lead)  = (winner,lead))
 /\ (Maj (h::t) (leader,0) = Maj t (if h=leader then (leader,1) else (h,1)))
 /\ (Maj (h::t) (leader,SUC m) = Maj t (leader, if h=leader then m+2 else m))`;

Define 
   `(Maj [] (winner,lead)      = (winner,lead))
 /\ (Maj (h::t) (leader,0)     = Maj t ((if h=leader then leader else h),1))
 /\ (Maj (h::t) (leader,SUC m) = Maj t (leader, if h=leader then m+2 else m))`;

Define 
   `(Maj [] (winner,lead)      = (winner,lead))
 /\ (Maj (h::t) (leader,0)     = Maj t (h,1))
 /\ (Maj (h::t) (leader,SUC m) = Maj t (leader, if h=leader then m+2 else m))`;

(* Wildcards. *)
Define 
   `(Maj [] (winner,lead) = (winner,lead))
 /\ (Maj (h::t) (_,0)     = Maj t (h,1))
 /\ (Maj (h::t) (leader, SUC m) 
       = Maj t (leader, (if h=leader then m+2 else m)))`;


(*---------------------------------------------------------------------------
              Nested recursion
 ---------------------------------------------------------------------------*)

val N = Define `N x = if x>100 then x-10 else N(N(x+11))`; (* Fails *)
val Ndef = Hol_defn "ninety1"
                    `N x = if x>100 then x-10 else N(N(x+11))`;

xDefine "percentage" `% x = if x>100 then x-10 else %(%(x+11))`;  

(*---------------------------------------------------------------------------
              Mutual recursion
 ---------------------------------------------------------------------------*)

val even_odd =
 xDefine "even_odd"
     `(even 0 = T)
  /\  (even (SUC n) = odd n) 
  /\  (odd 0 = F)
  /\  (odd (SUC n) = even n)`;

val even_odd =
xDefine "even_odd_again"
  `(&& 0 = T)          /\
   (&& (SUC n) = !! n) /\
   (!! 0 = F)          /\
   (!! (SUC n) = && n)`;

val nnf_mutrec_eqns =
 xDefine "nnfs"
     `(nnfpos (VAR x)   = VAR x)
 /\   (nnfpos (NOT p)   = nnfneg p)
 /\   (nnfpos (AND p q) = AND (nnfpos p) (nnfpos q))
 /\   (nnfpos (OR p q)  = OR  (nnfpos p) (nnfpos q))

 /\   (nnfneg (VAR x)   = NOT (VAR x))
 /\   (nnfneg (NOT p)   = nnfpos p)
 /\   (nnfneg (AND p q) = OR  (nnfneg p) (nnfneg q))
 /\   (nnfneg (OR p q)  = AND (nnfneg p) (nnfneg q))`;


(*---------------------------------------------------------------------------
      Higher order recursion. First we prove and install a
      congruence rule for sum. Congruence rules for common 
      higher-order list functions (MAP, EXISTS) have already  
      been installed.
 ---------------------------------------------------------------------------*)

val sumf_cong = prove
(Term
  `!l1 l2 f f'. 
    (l1=l2) /\ (!x. MEM x l2 ==> (f x = f' x))
          ==>
    (sumf f l1 = sumf f' l2)`,
Induct 
  THEN NTAC 2 (RW_TAC list_ss [sumf_def,listTheory.MEM]));

local open DefnBase
in 
  val _ = write_congs (sumf_cong::read_congs())
end;
  
(*---------------------------------------------------------------------------
        Now some "higher-order recursive" functions over a type of 
        labelled n-ary trees (built from constructor "Node").
 ---------------------------------------------------------------------------*)
 
app load ["numLib"]; open numLib listTheory;

val _ = Hol_datatype `ltree = LNODE of 'a => ltree list`;

val ltree_size_def = snd (TypeBase.size_of ``:'a ltree``);

val ltree_map_def =
  Defn.Hol_defn "ltree_map"
    `ltree_map f (LNODE v tl) = LNODE (f v) (MAP (ltree_map f) tl)`;

val (ltree_map_eqn, ltree_map_ind) =
 Defn.tprove
 (ltree_map_def, 
   WF_REL_TAC `^(hd(tl (TotalDefn.guessR ltree_map_def)))`
    THEN Induct 
    THEN RW_TAC list_ss [MEM,list_size_def,ltree_size_def]
    THENL [ARITH_TAC,
           PROVE_TAC [DECIDE (Term`x < 1+y ==> x < y + (z + 2)`)]]);

val ltree_map_o = Q.prove(
`!g t f. ltree_map f (ltree_map g t) = ltree_map (f o g) t`,
recInduct ltree_map_ind
  THEN RW_TAC std_ss [ltree_map_eqn]
  THEN Induct_on `tl` 
  THEN ZAP_TAC list_ss [listTheory.MEM]);

val ltree_occurs_def =
 Hol_defn "ltree_occurs"
    `ltree_occurs x (LNODE v tl) = (x=v) \/ EXISTS (ltree_occurs x) tl`;

(*---------------------------------------------------------------------------
    Can also obtain the same result with the schematic :

       `ltree_occurs (LNODE v tl) = (x=v) \/ EXISTS ltree_occurs tl`
 ---------------------------------------------------------------------------*)

val collect_defn =
 Hol_defn "collect"
    `collect f (LNODE v tl) = FOLDR (\h a. APPEND (collect f h) a) [f v] tl`;

val (collect_eqn, collect_ind) =
 Defn.tprove
 (collect_defn,
  WF_REL_TAC `^(Lib.el 2 (TotalDefn.guessR ltree_map_def))`
    THEN Induct 
    THEN RW_TAC list_ss [MEM,list_size_def,ltree_size_def]
    THENL [ARITH_TAC,
           PROVE_TAC [ARITH_PROVE (Term`x < 1+y ==> x < y + (z + 2)`)]]);

val ltree_size_def2 =
 Hol_defn "ltree_size2"
    `ltree_size2 f (LNODE v tl) = 1 + f v + SUM (MAP (ltree_size2 f) tl)`;

val ltree_SIZE_def =
 Hol_defn 
     "ltree_SIZE"
     `ltree_SIZE f (LNODE v tl) = 1 + f v + sumf (ltree_SIZE f) tl`;

(*---------------------------------------------------------------------------
   TC extraction, case of regexp matching
 ---------------------------------------------------------------------------*)

load "stringTheory";

val _ = set_fixity "<>" (Infixl 500);
val _ = overload_on ("<>", Term`APPEND`);

Hol_datatype `regexp =
   Any                       (* Any character *)
 | Epsilon                   (* Empty string *)
 | Atom of char              (* Specific character *)
 | Or of regexp => regexp    (* Union *)
 | Then of regexp => regexp  (* Concatenation *)
 | Repeat of regexp`;        (* Iterated concat, >= 0 *)


val SPLIT_def = Define
  `(SPLIT P [] acc = NONE) /\
   (SPLIT P (h::t) acc = if P h then SOME (acc, h, t)
                                else SPLIT P t (acc<>[h]))`;

val csp_def = Define
  `(csp [] ns = []) 
/\ (csp ((Repeat r::cdr, w, s)::b::c) ns = 
     if b = (r::Repeat r::cdr, w, SOME (Repeat r::cdr)) 
       then (Repeat r::cdr, w, ns)::b::c
       else (Repeat r::cdr, w, ns)::csp (b::c) ns) 
/\ (csp ((Any::cdr, w, s)::c) ns     = (Any::cdr, w, ns)::c) 
/\ (csp ((Atom c1::cdr, w, s)::c) ns = (Atom c1::cdr, w, ns) :: c)
/\ (csp ((rl,w,s)::c) ns             = (rl,w,ns)::csp c ns)`;

val nS_defn = Hol_defn 
 "nS"
 `nS ms =
   case SPLIT (\x. ?r l w. x = (Repeat r::l, w, SOME (Repeat r::l))) ms [] 
    of NONE -> ms
    || SOME (l1, (bad_r, bad_w, bad_s), z) ->
         case SPLIT (\x. ?s. x = (bad_r, bad_w, s)) l1 []
          of NONE -> []
          || SOME (x1, (rl,w1,s1), y) -> nS (x1 <> [(rl, w1, s1)] <> csp z s1)`;

Hol_defn "foo" 
  `foo L = case SPLIT ($= 3) L []
            of NONE -> L
            || SOME(L1,x,L2) ->
                case SPLIT ($=2) L1 []
                 of NONE -> []
                 || SOME (L1a,y, L1b) -> foo (L1a <> [y] <> L2)`;

Hol_defn "foo" 
  `bar L = case L 
            of [] -> 1
            || h::t -> case t
                        of [] -> 2
                        || h1::t1 -> bar t1`;
