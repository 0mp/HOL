(*---------------------------------------------------------------------------
           McCarthy's 91 function.
 ---------------------------------------------------------------------------*)

app load ["bossLib", "numLib"];

open TotalDefn bossLib numLib;


(*---------------------------------------------------------------------------
       Define the function. Note that the definition of nested
       functions is achieved by the invisible definition of an
       "auxiliary" function from which the desired function is 
       obtained. The termination proof of the desired function
       is reduced to that of the auxiliary function.

       We use Hol_defn to make the definition, since we tackle
       the termination proof ourselves.
 ---------------------------------------------------------------------------*)

val N_defn = 
 Defn.Hol_defn "N" 
               `N(x) = if x>100 then x-10 else N (N (x+11))`;

val [Neqn] = Defn.eqns_of N_defn;

(*---------------------------------------------------------------------------
      Prove partial correctness for N, to see how such a proof
      works when the termination relation has not yet been supplied.
      The proof is a bit slow because it's short, and because the 
      rewriter invokes the arithmetic decision procedure repeatedly.
 ---------------------------------------------------------------------------*)

local val SOME Nind = Defn.ind_of N_defn
in
val Npartly_correct = Q.prove(
 `WF R /\ 
  (!x. ~(x > 100) ==> R (N_aux R (x + 11)) x) /\
  (!x. ~(x > 100) ==> R (x + 11) x)
     ==>
  !n. N(n) = if n>100 then n-10 else 91`,
STRIP_TAC THEN recInduct Nind
  THEN REPEAT STRIP_TAC
  THEN ONCE_REWRITE_TAC [Neqn]
  THEN RW_TAC bool_ss [DECIDE(Term`x+11-10 = x+1`)]
  THEN RW_TAC arith_ss [])
end;


(*---------------------------------------------------------------------------
         Miscellaneous support
 ---------------------------------------------------------------------------*)

val measure_def   = prim_recTheory.measure_def;
val inv_image_def = relationTheory.inv_image_def;

fun ARITH q = DECIDE (Term q);
val lem = ARITH `~(x > 100) ==> (101-y < 101-x = x<y)`;



(*---------------------------------------------------------------------------
      Prove termination for N. The termination relation is 
      "measure \x. 101 - x". 
 ---------------------------------------------------------------------------*)

val N_defn_1 = Defn.set_reln N_defn (Term `measure \x. 101 - x`);

val tcs as [nested, tc1,tc2] = Defn.tcs_of N_defn_1;

val non_nested_tcs = prove
(mk_conj(tc1,tc2),
 TotalDefn.TC_SIMP_TAC [] []);

val N_defn_2 = Defn.elim_tcs N_defn_1 (CONJUNCTS non_nested_tcs);

val SOME aux_defn_2 = Defn.aux_defn N_defn_2;
val [E0] = Defn.eqns_of aux_defn_2;
val E1 = CONV_RULE (TC_SIMP_CONV []) (DISCH_ALL E0);
val E2 = simpLib.SIMP_RULE std_ss [lem] E1;

(*---------------------------------------------------------------------------

        Termination proof. It's worth noting that termination is
        completely independent of the partial correctness proof.
        [People used to think that termination and partial correctness
         of nested recursive functions had to be proved simultaneously;
         instead of unrolling the function definition for the nested 
         application of the function, the partial correctness would be
         used instead. The fear was that it would be circular to expand
         the function definition before the termination of the function 
         was proved, i.e., to use it in its own termination proof. This 
         isn't so: one can validly unroll the definition at "sufficiently 
         small" instances. Often this suffices to get the proof, and, in
         such cases, partial correctness need not be involved.]

 ---------------------------------------------------------------------------*)

Defn.tgoal N_defn_2;
e (TC_SIMP_TAC [] []);
e (simpLib.SIMP_TAC std_ss [lem]);
e (GEN_TAC THEN measureInduct_on `(\m. 101 - m) x`);
e (RW_TAC std_ss []);
e (IMP_RES_THEN (fn th => RULE_ASSUM_TAC (REWRITE_RULE [th])) lem);
e (MP_TAC (Q.SPEC `x+11` (GEN_ALL E2)));
e (RW_TAC std_ss [DECIDE (Term `x < x+11-10`)]);
e (`x + 11 < N_aux (\x y. 101 - x < 101 - y) (x + 11 + 11)`
   by PROVE_TAC [DECIDE (Term `x < x+11`)]);
e (RW_TAC std_ss []);  (* Unroll the function *)
e (WEAKEN_TAC is_imp);

e (MP_TAC (Q.SPEC `x+11` (GEN_ALL E2)));
e (Cases_on `N_aux (\x y. 101 - x < 101 - y) (x + 11 + 11) - 11 > 100`);

val (N_eqn, N_ind) = Defn.tprove(N_defn,
WF_REL_TAC `measure \x. 101 - x`  (* non-nested TC proved here *)
  THEN RW_TAC bool_ss [GSYM Nine1_def', lem]
  THEN measureInduct_on `(\m. 101 - m) x`
  THEN RW_TAC bool_ss [] 
  THEN IMP_RES_THEN (fn th => RULE_ASSUM_TAC (REWRITE_RULE [th])) lem
  THEN Cases_on `x+11 > 100` THENL
   [RW_TAC arith_ss [eqn1],
    `x+11 < Nine1((x+11)+11)`  by PROVE_TAC [ARITH `x<x+11`]            THEN
    `x < Nine1((x+11)+11) -11` by PROVE_TAC [ARITH `x+y < z = x < z-y`] THEN
    `Nine1 (x+11) = Nine1 (Nine1 ((x+11) + 11))` by PROVE_TAC[eqn2]     THEN
    Cases_on `Nine1((x+11)+11) -11 > 100` THENL
     [`Nine1((x+11)+11) > 100` by PROVE_TAC [ARITH`x-11 > 100 ==> x>100`] THEN
      `Nine1(Nine1((x+11)+11)) = Nine1((x+11)+11) -10` by PROVE_TAC[eqn1] 
        THEN Q.PAT_ASSUM `Nine1 (x+11) = M` (SUBST_ALL_TAC o SYM) 
        THEN PROVE_TAC[ARITH`x>100 ==> x-11<x-10`,arithmeticTheory.LESS_TRANS],
      RES_TAC 
       THEN IMP_RES_THEN SUBST_ALL_TAC (ARITH`w+11<y ==> ((y-11)+11 = y)`)
       THEN PROVE_TAC [eqn2,arithmeticTheory.LESS_TRANS]]]);
 


(*---------------------------------------------------------------------------
      Note that the above development is slightly cranky, since
      the partial correctness theorem has constraints remaining. 
      These were actually addressed by the termination proof, but 
      the witnesses were proved and then thrown away. 

      Now try some computations with N.
 ---------------------------------------------------------------------------*)

EVAL (Term `N 0`);
EVAL (Term `N 10`);
EVAL (Term `N 11`);
EVAL (Term `N 12`);
EVAL (Term `N 40`);
EVAL (Term `N 89`);
EVAL (Term `N 90`);
EVAL (Term `N 99`);
EVAL (Term `N 100`);
EVAL (Term `N 101`);
EVAL (Term `N 102`);
EVAL (Term `N 127`);
