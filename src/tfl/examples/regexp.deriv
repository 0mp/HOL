(*---------------------------------------------------------------------------*)
(* Brzozowski's paper on taking the derivative of a regular expression       *)
(* allows the language of regular expressions to be expanded to include      *)
(* any boolean operator (beyond the standard disjunction).                   *)
(*---------------------------------------------------------------------------*)

load "metisLib"; open metisLib;
open listTheory;

(*---------------------------------------------------------------------------*)
(* Make list append into an infix recognized by the parser                   *)
(*---------------------------------------------------------------------------*)

val _ = set_fixity "<>" (Infixl 500);
val _ = overload_on ("<>", Term`APPEND`);

val NULL_EQ_NIL = Q.prove
(`!l. NULL l = (l = [])`,
 Cases THEN RW_TAC list_ss []);

val FLAT_EQ_NIL = Q.prove
(`!wlist. (FLAT wlist = []) = EVERY NULL wlist`,
 Induct THEN RW_TAC list_ss [FLAT,NULL_EQ_NIL]);

val NULL_FLAT_THM = Q.prove
(`!L. NULL (FLAT L) = EVERY NULL L`,
 PROVE_TAC [FLAT_EQ_NIL, NULL_EQ_NIL]);

val FLAT_APPEND_DISTRIB = Q.prove
(`!l1 l2. FLAT (l1 <> l2) = FLAT l1 <> FLAT l2`,
 Induct THEN RW_TAC list_ss [FLAT]);

val FIRST_EXISTS_THM = Q.prove
(`!P L. EXISTS P L ==>
      ?prefix w suffix. 
        (L = prefix <> [w] <> suffix) /\ EVERY ($~ o P) prefix /\ P w`,
 GEN_TAC THEN Induct THEN RW_TAC list_ss []
  THEN FULL_SIMP_TAC list_ss [EXISTS_DEF] THEN RW_TAC list_ss []
  THENL [MAP_EVERY Q.EXISTS_TAC [`[]`, `h`, `L`] THEN RW_TAC list_ss [],
         RES_TAC THEN Cases_on `P h` THENL
         [MAP_EVERY Q.EXISTS_TAC [`[]`, `h`, `L`] THEN RW_TAC list_ss [],
          MAP_EVERY Q.EXISTS_TAC [`h::prefix`, `w`, `suffix`] THEN 
          RW_TAC list_ss [combinTheory.o_DEF]]]);


(*---------------------------------------------------------------------------*)
(* Datatype of extended regular expressions.                                 *)
(*---------------------------------------------------------------------------*)

Hol_datatype 
   `regex = Empty 
          | Epsilon
          | Any
          | Symbol of 'a
          | Not of regex
          | Or of regex => regex
          | And of regex => regex
          | Then of regex => regex
          | Star of regex
          | Prefix of regex`;

(*---------------------------------------------------------------------------*)
(* Parser fiddling to get | and # as infixes - we have to first get rid      *)
(* of the pre-defined behaviour of | (used in old-style conditional          *)
(* expressions.                                                              *)
(*---------------------------------------------------------------------------*)

val _ = remove_termtok{term_name = "COND",tok="=>"};  
val _ = overload_on ("|", Term`$Or`);
val _ = overload_on ("&", Term`$And`);
val _ = overload_on ("#", Term`$Then`);

val _ = set_fixity "|" (Infixr 501);
val _ = set_fixity "&" (Infixr 551);
val _ = set_fixity "#" (Infixr 601);

(*---------------------------------------------------------------------------*)
(* Semantics. "sem r w" means w is a member of the language generated by r.  *)
(*---------------------------------------------------------------------------*)

val sem_def =
 Define
  `(sem Empty w      = F)                                               /\
   (sem Epsilon w    = (w = []))                                        /\
   (sem Any w        = ?c. w = [c])                                     /\
   (sem (Symbol c) w = (w = [c]))                                       /\
   (sem (Not r) w    = ~sem r w)                                        /\
   (sem (r1 | r2) w  = sem r1 w \/ sem r2 w)                            /\
   (sem (r1 & r2) w  = sem r1 w /\ sem r2 w)                            /\
   (sem (r1 # r2) w  = ?w1 w2. (w = w1<>w2) /\ sem r1 w1 /\ sem r2 w2)  /\
   (sem (Star r) w   = ?wlist. (w = FLAT wlist) /\ EVERY (sem r) wlist) /\
   (sem (Prefix r) w = ?w'. sem r (w <> w'))`;


(*---------------------------------------------------------------------------*)
(* Is Epsilon in the generated language of a regular expression. We bail out *)
(* in the case of Prefix, by appealing to the semantics.                     *)
(*---------------------------------------------------------------------------*)

val hasEpsilon_def = Define
  `(hasEpsilon Empty      = F) /\
   (hasEpsilon Epsilon    = T) /\
   (hasEpsilon Any        = F) /\
   (hasEpsilon (Symbol _) = F) /\
   (hasEpsilon (Not r)    = ~hasEpsilon r) /\
   (hasEpsilon (r1 | r2)  = hasEpsilon r1 \/ hasEpsilon r2) /\
   (hasEpsilon (r1 & r2)  = hasEpsilon r1 /\ hasEpsilon r2) /\
   (hasEpsilon (r1 # r2)  = hasEpsilon r1 /\ hasEpsilon r2) /\
   (hasEpsilon (Star _)   = T) /\
   (hasEpsilon (Prefix r) = ~(sem r = sem Empty))`;

(*---------------------------------------------------------------------------*)
(* Deriv x r finds a regex that generates the language obtained after taking *)
(* symbol x off the front of all strings in L(r). Starting from r, we can    *)
(* iteratively build up an automaton by taking Deriv a r for each a in the   *)
(* alphabet.                                                                 *)
(*---------------------------------------------------------------------------*)

val Deriv_def = Define
  `(Deriv x Empty      = Empty) 
/\ (Deriv x Epsilon    = Empty) 
/\ (Deriv x Any        = Epsilon)
/\ (Deriv x (Symbol a) = if x=a then Epsilon else Empty)
/\ (Deriv x (Not P)    = Not (Deriv x P))
/\ (Deriv x (P|Q)      = Deriv x P | Deriv x Q)
/\ (Deriv x (P&Q)      = Deriv x P & Deriv x Q)
/\ (Deriv x (P#Q)      = (Deriv x P # Q) | 
                         if hasEpsilon P then Deriv x Q else Empty)
/\ (Deriv x (Star P)   = Deriv x P # Star P)
/\ (Deriv x (Prefix P) = Prefix (Deriv x P))`;


val DerivString_def = Define
  `(DerivString [] r = r) /\
   (DerivString (h::t) r = DerivString t (Deriv h r))`;

val Matches_def = Define `Matches r w = hasEpsilon (DerivString w r)`;

val hasEpsilon_sem = Q.prove
(`!r. hasEpsilon r = sem r []`,
 Induct THEN RW_TAC list_ss [hasEpsilon_def,sem_def]
        THENL [METIS_TAC [EVERY_DEF,FLAT],
               RW_TAC list_ss [FUN_EQ_THM,sem_def]]);


(*---------------------------------------------------------------------------*)
(* Basic correctness property of Deriv is straightforward.                   *)
(*---------------------------------------------------------------------------*)

val semDeriv = Q.prove
(`!r w x. sem (Deriv x r) w = sem r (x::w)`,
 Induct THENL
 [RW_TAC list_ss [Deriv_def, sem_def],
  RW_TAC list_ss [Deriv_def, sem_def],
  RW_TAC list_ss [Deriv_def, sem_def],
  RW_TAC list_ss [Deriv_def, sem_def],
  RW_TAC list_ss [Deriv_def, sem_def],
  RW_TAC list_ss [Deriv_def, sem_def],
  RW_TAC list_ss [Deriv_def, sem_def],
  RW_TAC list_ss [Deriv_def, sem_def] THENL
  [REPEAT (STRIP_TAC ORELSE EQ_TAC) THEN RW_TAC list_ss [] THENL
   [MAP_EVERY Q.EXISTS_TAC [`x::w1`, `w2`] THEN RW_TAC list_ss [],
    FULL_SIMP_TAC list_ss [hasEpsilon_sem] 
      THEN MAP_EVERY Q.EXISTS_TAC [`[]`, `x::w`] THEN RW_TAC list_ss [],
    Cases_on `w1` THENL
    [FULL_SIMP_TAC list_ss [],
     DISJ1_TAC THEN FULL_SIMP_TAC list_ss [] THEN METIS_TAC []]],
   REPEAT (STRIP_TAC ORELSE EQ_TAC) THEN RW_TAC list_ss [] THENL
   [MAP_EVERY Q.EXISTS_TAC [`x::w1`, `w2`] THEN RW_TAC list_ss [],
    Cases_on `w1` THENL
    [FULL_SIMP_TAC list_ss [hasEpsilon_sem],
     FULL_SIMP_TAC list_ss [] THEN METIS_TAC []]]],
  RW_TAC list_ss [Deriv_def, sem_def] THEN WEAKEN_TAC (K true) 
    THEN REPEAT (STRIP_TAC ORELSE EQ_TAC) THEN RW_TAC list_ss [] THENL
    [Q.EXISTS_TAC `(x::w1) :: wlist` THEN RW_TAC list_ss [],
     Cases_on `NULL (FLAT wlist)` THENL
     [FULL_SIMP_TAC list_ss [NULL_EQ_NIL],
      FULL_SIMP_TAC list_ss [NULL_FLAT_THM] 
        THEN IMP_RES_TAC FIRST_EXISTS_THM 
        THEN Cases_on `w'` THENL
             [FULL_SIMP_TAC list_ss [],
              MAP_EVERY Q.EXISTS_TAC [`t`, `FLAT suffix`]
                THEN POP_ASSUM (K ALL_TAC) 
                THEN BasicProvers.VAR_EQ_TAC
                THEN `$~ o $~ o NULL = NULL` 
                     by (RW_TAC list_ss [combinTheory.o_DEF] THEN METIS_TAC [])
                THEN POP_ASSUM SUBST_ALL_TAC
                THEN `FLAT prefix = []` by METIS_TAC [NULL_EQ_NIL,NULL_FLAT_THM]
                THEN RULE_ASSUM_TAC (REWRITE_RULE [FLAT_APPEND_DISTRIB])
                THEN POP_ASSUM SUBST_ALL_TAC
                THEN RULE_ASSUM_TAC (SIMP_RULE list_ss [])
                THEN METIS_TAC []]]],
  RW_TAC list_ss [Deriv_def, sem_def]]);


(*---------------------------------------------------------------------------*)
(* Correctness of matcher follows by induction.                              *)
(*---------------------------------------------------------------------------*)

val MatchesCorrect = Q.prove
(`!r w. sem r w =  Matches r w`,
 SIMP_TAC list_ss [Matches_def] 
  THEN Induct_on `w`
  THEN RW_TAC list_ss [DerivString_def]
  THENL [METIS_TAC [hasEpsilon_sem],
         RW_TAC list_ss [GSYM semDeriv]]);



(*---------------------------------------------------------------------------*)
(* Test the matcher:                                                         *)
(*---------------------------------------------------------------------------*)
(*
load "stringLib";
fun CHECK r s = Count.apply EVAL 
                  (Term `Matches ^r (EXPLODE ^(stringSyntax.fromMLstring s))`);

val Zero = rhs(concl(EVAL(Term`Symbol(HD(EXPLODE "0"))`))); 
val One = rhs(concl(EVAL(Term`Symbol(HD(EXPLODE "1"))`))); 
val Two = rhs(concl(EVAL(Term`Symbol(HD(EXPLODE "2"))`))); 
val Three = rhs(concl(EVAL(Term`Symbol(HD(EXPLODE "3"))`))); 
val a = rhs(concl(EVAL(Term`Symbol(HD(EXPLODE "a"))`))); 
val b = rhs(concl(EVAL(Term`Symbol(HD(EXPLODE "b"))`))); 
val c = rhs(concl(EVAL(Term`Symbol(HD(EXPLODE "c"))`)));
(* val Any = Term `^Zero | ^One | ^Two | ^Three | ^a | ^b | ^c `; *)

val r0 = Term `^One # ^Two`;
val r1 = Term `Star (^One # ^Two)`
val r2 = Term `Star Any # ^One`;
val r3 = Term `^r2 # ^r1`;

(* val true  = *) CHECK r0 "12";
(* val true  = *) CHECK r1 "12";
(* val true  = *) CHECK r1 "1212";
(* val true  = *) CHECK r1 "121212121212121212121212";
(* val false = *) CHECK r1 "12123";
(* val false = *) CHECK r2 "";
(* val true  = *) CHECK r2 "1";
(* val true  = *) CHECK r2 "0001";
(* val false = *) CHECK r2 "0002";
(* val true  = *) CHECK r3 "00011212";
(* val false = *) CHECK r3 "00011213";
(* val true  = *) CHECK (Term`Star(Star Any)`) "";
(* val true  = *) CHECK (Term`Star(Star Any)`) "0";
(* val true  = *) CHECK (Term`Star(Star Any)`) "0123";
(* val true  = *) CHECK (Term`Star (^Any # Star ^Any)`) "0";
(* val true  = *) CHECK (Term`Star (^Any # Star ^Any)`) "01";
(* val true  = *) CHECK (Term`Star (^Any # Star ^Any)`) "012";
(* val true  = *) CHECK (Term`^a # Star(^a | ^b) # Star(^b # ^a)`) "abba";

(* At most 2 a's. Alphabet = {a,b} *)
val AtMostTwo_a = Term `Star ^b 
                     |  Star ^b # (^a | ^a # Star ^b # ^a) # Star ^b`;
CHECK AtMostTwo_a "";
CHECK AtMostTwo_a "b";
CHECK AtMostTwo_a "a";
CHECK AtMostTwo_a "aa";
CHECK AtMostTwo_a "ab";
CHECK AtMostTwo_a "ba";
CHECK AtMostTwo_a "bb";
CHECK AtMostTwo_a "abbbbabbbb";
CHECK AtMostTwo_a "bbbbabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb";
(* false *) CHECK AtMostTwo_a "abbbbabbbab";

(* Exactly 2 a's. Alphabet = {a,b} *)
val ExactlyTwo_a = Term `Star ^b # ^a # Star ^b # ^a # Star ^b`;

(* false *) CHECK ExactlyTwo_a "";
(* false *) CHECK ExactlyTwo_a "b";
(* false *) CHECK ExactlyTwo_a "a";
(* true *)  CHECK ExactlyTwo_a "aa";
(* false *) CHECK ExactlyTwo_a "ab";
(* false *) CHECK ExactlyTwo_a "ba";
(* false *) CHECK ExactlyTwo_a "bb";
(* true *)  CHECK ExactlyTwo_a "abbbbabbbb";
(* true *)  CHECK ExactlyTwo_a 
               "bbbbabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbab";
(* false *) CHECK ExactlyTwo_a "abbbbabbbab";

(* All strings of length 0-3 *)
val UpTo3 = Term `Epsilon | ^Any | ^Any#^Any | ^Any#^Any#^Any`;

(* true *) CHECK UpTo3 "";
(* true *) CHECK UpTo3 "b";
(* true *) CHECK UpTo3 "a";
(* true *) CHECK UpTo3 "aa";
(* false *) CHECK UpTo3 "abbbbabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb";

(* All strings with no occurrences of aa or bb *)
val NoStars = Term `^Any | Star (^a # ^b) | Star (^b # ^a)`;

(* true *)  CHECK NoStars "";
(* true *)  CHECK NoStars "a";
(* true *)  CHECK NoStars "b";
(* false *) CHECK NoStars "aa";
(* true *)  CHECK NoStars "ab";
(* true *)  CHECK NoStars "ba";
(* false *) CHECK NoStars "bb";
(* true *)  CHECK NoStars 
              "ababababababababababababababababababababababababababab";
(* false *) CHECK NoStars 
              "abababababababababababbababababababababababababababab";

*)
(*---------------------------------------------------------------------------*)
