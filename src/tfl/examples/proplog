(*---------------------------------------------------------------------------
      A type of propositions and algorithms on it.
 ---------------------------------------------------------------------------*)

app load ["bossLib", "computeLib"]; 
open computeLib bossLib;

Hol_datatype `prop = VAR of 'a
                   | NOT of prop
                   | AND of prop => prop
                   | OR  of prop => prop`;


(*---------------------------------------------------------------------------
       Wang's algorithm.
 ---------------------------------------------------------------------------*)

val Pr_def = 
 Hol_defn "Pr"
    `(Pr vl [] (VAR v::r)   vr = Pr vl [] r (v::vr))
 /\  (Pr vl [] (NOT x::r)   vr = Pr vl [x] r vr)
 /\  (Pr vl [] (OR x y::r)  vr = Pr vl [] (x::y::r) vr)
 /\  (Pr vl [] (AND x y::r) vr = Pr vl [] (x::r) vr /\ Pr vl [] (y::r) vr)

 /\  (Pr vl (VAR v::l)    r vr = Pr (v::vl) l r vr)
 /\  (Pr vl (NOT x::l)    r vr = Pr vl l (x::r) vr)
 /\  (Pr vl (AND x y::l)  r vr = Pr vl (x::y::l) r vr)
 /\  (Pr vl (OR x y::l)   r vr = Pr vl (x::l) r vr /\ Pr vl (y::l) r vr)
 /\  (Pr vl [] [] vr           = EXISTS (\y. MEM y vl) vr)`;


val Wang_def = Define `Wang P = Pr [] [] [P] []`;


(*---------------------------------------------------------------------------
     Termination of Pr. We need a subsidiary measure function on 
     propositions which makes a 2-argument proposition bigger than a 
     list of 2 propositions. 
 ---------------------------------------------------------------------------*)

val Meas_def =
 Define 
    `(Meas (VAR v)   = 0)
 /\  (Meas (NOT x)   = SUC (Meas x))
 /\  (Meas (AND x y) = Meas x + Meas y + 2)
 /\  (Meas (OR x y)  = Meas x + Meas y + 2)`;

(*---------------------------------------------------------------------------*
 *  Termination of Pr.                                                       *
 *---------------------------------------------------------------------------*)

val (Pr_eqns, Pr_ind) = 
 Defn.tprove (Pr_def,
   WF_REL_TAC Pr_def
       `measure \(w:'a list, x:'a prop list, y:'a prop list, z:'a list). 
                      list_size Meas x + list_size Meas y`
     THEN RW_TAC arith_ss [Meas_def,listTheory.list_size_def]);



(*---------------------------------------------------------------------------
    Build a computing base that knows basic facts about 
    booleans, plus whatever list operations are used in Pr.
 ---------------------------------------------------------------------------*)

local open computeLib
      val MEM_IF = Q.prove(
           `!x h t. MEM x (h::t) = if x=h then T else MEM x t`,
            RW_TAC list_ss [listTheory.MEM])
      val EXISTS_IF = Q.prove(
           `!P h t. EXISTS P (h::t) = if P h then T else EXISTS P t`,
            RW_TAC list_ss [listTheory.EXISTS_DEF])
      val MEM_DEF'    = CONJ (CONJUNCT1 listTheory.MEM) MEM_IF
      val EXISTS_DEF' = CONJ (CONJUNCT1 listTheory.EXISTS_DEF) EXISTS_IF
      val compset = reduceLib.reduce_rws()
      val _ = add_thms (false,[REFL_CLAUSE]) compset
      val _ = add_thms (true,[Pr_eqns,Wang_def,MEM_DEF',EXISTS_DEF']) compset
      val eval_iota = CBV_CONV compset
in
fun Eval q = Count.apply eval_iota (Term q)
end;


(*---------------------------------------------------------------------------
      Examples.
 ---------------------------------------------------------------------------*)

val x = Term`VAR x`;
val y = Term`VAR y`;
val z = Term`VAR z`;
val p = Term`VAR p`;
val q = Term`VAR q`;
val r = Term`VAR r`;
val s = Term`VAR s`;

fun imp x y = Term`OR (NOT ^x) ^y`;
fun iff x y = Term`AND ^(imp x y) ^(imp y x)`;

val BOOL_CASES = Eval `Wang (OR ^x (NOT ^x))`;
val NOT_BCASES = Eval `Wang (OR ^x (NOT ^y))`;
val IMP_REFL   = Eval `Wang (OR (NOT ^x) ^x)`;
val DISTRIB    = Eval `Wang ^(iff (Term`AND ^x (OR ^y ^z)`)
                                       (Term`OR (AND ^x ^y) (AND ^x ^z)`))`;

val PEIRCE = Eval `Wang ^(imp (imp (imp p q) p) p)`;

val ANDREWS = Eval `Wang
 ^(imp (Term`AND ^(imp p (Term`AND ^q (OR ^r ^s)`))
                (OR (NOT ^q) (NOT ^r))`)
     (imp p s))`;

val CLASSIC = Eval `Wang
 ^(imp (imp (Term`AND ^p ^q`) r)
       (Term `OR ^(imp p r) ^(imp q r)`))`;

(*---------------------------------------------------------------------------
      The following are adapted from jrh's tautology collection
      in the examples directory.
 ---------------------------------------------------------------------------*)

val v0 = Term`VAR v0`;
val v1 = Term`VAR v1`;
val v2 = Term`VAR v2`;
val v3 = Term`VAR v3`;
val v4 = Term`VAR v4`;
val v5 = Term`VAR v5`;
val v6 = Term`VAR v6`;
val v7 = Term`VAR v7`;
val v8 = Term`VAR v8`;
val v9 = Term`VAR v9`;

set_fixity "OR" (Infixr 300);
set_fixity "AND" (Infixr 400);

val syn323_1 = Eval 
`Wang (NOT((^v0 OR ^v1) AND 
            (NOT ^v0 OR ^v1) AND 
            (NOT ^v1 OR ^v0) AND 
            (NOT ^v0 OR NOT ^v1)))`;


val syn029_1 = Eval
`Wang
   (NOT((NOT ^v2 OR NOT ^v1) AND
        ^v0 AND 
        (NOT ^v0 OR NOT ^v1 OR ^v2) AND 
        (NOT ^v2 OR ^v1) AND (^v1 OR ^v2)))`;


val syn052_1 = Eval
`Wang
   (NOT((NOT ^v1 OR ^v0) AND 
        (NOT ^v0 OR ^v1) AND 
        (^v1 OR ^v0)     AND 
        (NOT ^v1 OR ^v1) AND 
        (NOT ^v0 OR NOT ^v1)))`;

val syn051_1 = Eval
`Wang
  (NOT(( ^v1 OR ^v0) AND
       (^v1 OR ^v2) AND
       (NOT ^v0 OR NOT ^v1) AND
       (NOT ^v2 OR NOT ^v1) AND
       (NOT ^v0 OR ^v1) AND
       (NOT ^v1 OR ^v2)))`;

val syn044_1 = Eval
`Wang
  (NOT((^v0 OR ^v1) AND
       (NOT ^v0 OR NOT ^v1) AND
       (NOT ^v0 OR ^v1 OR ^v2) AND
       (NOT ^v2 OR ^v1) AND
       (NOT ^v2 OR ^v0) AND
       (NOT ^v1 OR ^v2)))`;

val syn011_1 = Eval
`Wang
  (NOT(^v6 AND
       (NOT ^v0 OR NOT ^v2) AND
       (^v0 OR ^v1 OR ^v5) AND
       (NOT ^v2 OR NOT ^v1) AND
       (NOT ^v4 OR ^v2) AND
       (NOT ^v3 OR ^v2) AND
       (^v3 OR ^v4 OR ^v5) AND
       (NOT ^v5 OR NOT ^v6)))`;

val syn032_1 = Eval
`Wang
  (NOT((NOT ^v5 OR NOT ^v1) AND
       (NOT ^v4 OR NOT ^v0) AND
       (NOT ^v4 OR ^v0) AND
       (NOT ^v5 OR ^v1) AND
       (NOT ^v2 OR ^v4 OR ^v3) AND
       (^v4 OR ^v2 OR ^v3) AND
       (NOT ^v3 OR ^v4 OR ^v5)))`;

val syn030_1 = Eval
`Wang
   (NOT((NOT ^v4 OR NOT ^v0 OR NOT ^v1) AND
        (NOT ^v3 OR NOT ^v4 OR ^v0) AND
        (NOT ^v1 OR ^v0) AND
        (^v0 OR ^v1) AND
        (NOT ^v0 OR ^v1) AND
        (NOT ^v1 OR NOT ^v0 OR ^v2) AND
        (NOT ^v2 OR ^v1) AND
        (NOT ^v1 OR ^v3) AND
        (NOT ^v2 OR NOT ^v3 OR ^v4)))`;

val syn054_1 = Eval
`Wang
  (NOT((NOT ^v1 OR NOT ^v7) AND
       (NOT ^v2 OR NOT ^v0) AND
       (NOT ^v3 OR ^v7 OR ^v4) AND
       (NOT ^v6 OR ^v0 OR ^v5) AND
       (NOT ^v7 OR ^v1) AND
       (NOT ^v0 OR ^v2) AND
       (NOT ^v4 OR ^v1) AND
       (NOT ^v5 OR ^v2) AND
       (NOT ^v3 OR NOT ^v4) AND
       (NOT ^v6 OR NOT ^v5) AND
       (^v6 OR ^v7)))`;

(* Takes a long time, but it gets there in the end. *)
val gra001_1 = Eval
`Wang
  (NOT((NOT ^v1 OR ^v0) AND
       (NOT ^v0 OR ^v1) AND
       (NOT ^v4 OR NOT ^v2 OR NOT ^v0) AND
       (NOT ^v4 OR ^v2 OR ^v0) AND
       (NOT ^v2 OR ^v4 OR ^v0) AND
       (NOT ^v0 OR ^v4 OR ^v2) AND
       (NOT ^v3 OR NOT ^v2 OR NOT ^v1) AND
       (NOT ^v3 OR ^v2 OR ^v1) AND
       (NOT ^v2 OR ^v3 OR ^v1) AND
       (NOT ^v1 OR ^v3 OR ^v2) AND
       (NOT ^v3 OR NOT ^v4) AND
       (^v3 OR ^v4)))`;


val syn321_1 =  Eval
`Wang
  (NOT((NOT ^v0 OR ^v9) AND
       (NOT ^v0 OR ^v6) AND
       (NOT ^v0 OR ^v7) AND
       (NOT ^v8 OR ^v9) AND
       (NOT ^v8 OR ^v6) AND
       (NOT ^v8 OR ^v7) AND
       (NOT ^v1 OR ^v9) AND
       (NOT ^v1 OR ^v6) AND
       (NOT ^v1 OR ^v7) AND
       (NOT ^v2 OR ^v3) AND
       (NOT ^v4 OR ^v5) AND
       (NOT ^v7 OR ^v8) AND
       (^v8 OR ^v9) AND
       (^v8 OR ^v6) AND
       (^v8 OR ^v7) AND
       (NOT ^v8 OR NOT ^v9)))` ;

(*---------------------------------------------------------------------------
         The SML version

fun mem x [] = false
  | mem x (h::t) = (x=h) orelse mem x t;

datatype 'a prop = VAR of 'a
                 | NOT of 'a prop
                 | AND of 'a prop * 'a prop
                 | OR  of 'a prop * 'a prop;

fun Prv vl [] (VAR v::r) vr    = Prv vl [] r (v::vr)
  | Prv vl [] (NOT x::r) vr    = Prv vl [x] r vr
  | Prv vl [] (OR(x,y)::r) vr  = Prv vl [] (x::y::r) vr
  | Prv vl [] (AND(x,y)::r) vr = Prv vl [] (x::r) vr
                                      andalso
                                  Prv vl [] (y::r) vr
  | Prv vl (VAR v::l) r vr     = Prv (v::vl) l r vr
  | Prv vl (NOT x::l) r vr     = Prv vl l (x::r) vr
  | Prv vl (AND(x,y)::l) r vr  = Prv vl (x::y::l) r vr
  | Prv vl (OR(x,y)::l) r vr   = Prv vl (x::l) r vr
                                    andalso
                                Prv vl (y::l) r vr

  | Prv vl [] [] vr = List.exists (fn y => mem y vl) vr;

infixr 5 AND;
infixr 4 OR;

fun Wang M = Prv [] [] [M] [];

val x = VAR "x";
val y = VAR "y";
val z = VAR "z";
val p = VAR "p";
val q = VAR "q";
val r = VAR "r";
val s = VAR "s";

fun imp x y = NOT x OR y;
fun iff x y = (imp x y) AND (imp y x);

val BOOL_CASES = time Wang (x OR (NOT x));
val NOT_BCASES = time Wang (x OR (NOT y));
val IMP_REFL   = time Wang (imp x x);
val DISTRIB    = time Wang (iff (x AND (y OR z))
                            ((x AND y) OR (x AND z)));

val PEIRCE     = time Wang (imp (imp (imp p q) p) p);

val ANDREWS    = time Wang
 (imp ((imp p (q AND (r OR s))) AND ((NOT q) OR (NOT r)))
     (imp p s));

val v0 = VAR "v0";
val v1 = VAR "v1";
val v2 = VAR "v2";
val v3 = VAR "v3";
val v4 = VAR "v4";
val v5 = VAR "v5";
val v6 = VAR "v6";
val v7 = VAR "v7";
val v8 = VAR "v8";
val v9 = VAR "v9";

val syn323_1 = time Wang 
  (NOT((v0 OR v1) AND 
       (NOT v0 OR v1) AND 
       (NOT v1 OR v0) AND 
       (NOT v0 OR NOT v1)));


val syn029_1 = 
time Wang
   (NOT((NOT v2 OR NOT v1) AND
        v0 AND 
        (NOT v0 OR NOT v1 OR v2) AND 
        (NOT v2 OR v1) AND (v1 OR v2)));


val syn052_1 = 
time Wang
   (NOT((NOT v1 OR v0) AND 
        (NOT v0 OR v1) AND 
        (v1 OR v0) AND (NOT v1 OR v1) AND (NOT v0 OR NOT v1)));

val syn051_1 = 
time Wang
  (NOT((v1 OR v0) AND
       (v1 OR v2) AND
       (NOT v0 OR NOT v1) AND
       (NOT v2 OR NOT v1) AND
       (NOT v0 OR v1) AND
       (NOT v1 OR v2)));

val syn044_1 = 
time Wang
  (NOT((v0 OR v1) AND
       (NOT v0 OR NOT v1) AND
       (NOT v0 OR v1 OR v2) AND
       (NOT v2 OR v1) AND
       (NOT v2 OR v0) AND
       (NOT v1 OR v2)));

val syn011_1 = 
time Wang
  (NOT(v6 AND
       (NOT v0 OR NOT v2) AND
       (v0 OR v1 OR v5) AND
       (NOT v2 OR NOT v1) AND
       (NOT v4 OR v2) AND
       (NOT v3 OR v2) AND
       (v3 OR v4 OR v5) AND
       (NOT v5 OR NOT v6)));

val syn032_1 = 
time Wang
  (NOT((NOT v5 OR NOT v1) AND
       (NOT v4 OR NOT v0) AND
       (NOT v4 OR v0) AND
       (NOT v5 OR v1) AND
       (NOT v2 OR v4 OR v3) AND
       (v4 OR v2 OR v3) AND
       (NOT v3 OR v4 OR v5)));

val syn030_1 = 
time Wang
   (NOT((NOT v4 OR NOT v0 OR NOT v1) AND
        (NOT v3 OR NOT v4 OR v0) AND
        (NOT v1 OR v0) AND
        (v0 OR v1) AND
        (NOT v0 OR v1) AND
        (NOT v1 OR NOT v0 OR v2) AND
        (NOT v2 OR v1) AND
        (NOT v1 OR v3) AND
        (NOT v2 OR NOT v3 OR v4)));

val syn054_1 =  
time Wang
  (NOT((NOT v1 OR NOT v7) AND
       (NOT v2 OR NOT v0) AND
       (NOT v3 OR v7 OR v4) AND
       (NOT v6 OR v0 OR v5) AND
       (NOT v7 OR v1) AND
       (NOT v0 OR v2) AND
       (NOT v4 OR v1) AND
       (NOT v5 OR v2) AND
       (NOT v3 OR NOT v4) AND
       (NOT v6 OR NOT v5) AND
       (v6 OR v7)));


val gra001_1 = 
time Wang
  (NOT((NOT v1 OR v0) AND
       (NOT v0 OR v1) AND
       (NOT v4 OR NOT v2 OR NOT v0) AND
       (NOT v4 OR v2 OR v0) AND
       (NOT v2 OR v4 OR v0) AND
       (NOT v0 OR v4 OR v2) AND
       (NOT v3 OR NOT v2 OR NOT v1) AND
       (NOT v3 OR v2 OR v1) AND
       (NOT v2 OR v3 OR v1) AND
       (NOT v1 OR v3 OR v2) AND
       (NOT v3 OR NOT v4) AND
       (v3 OR v4)));

val syn321_1 = 
time Wang 
  (NOT((NOT v0 OR v9) AND
       (NOT v0 OR v6) AND
       (NOT v0 OR v7) AND
       (NOT v8 OR v9) AND
       (NOT v8 OR v6) AND
       (NOT v8 OR v7) AND
       (NOT v1 OR v9) AND
       (NOT v1 OR v6) AND
       (NOT v1 OR v7) AND
       (NOT v2 OR v3) AND
       (NOT v4 OR v5) AND
       (NOT v7 OR v8) AND
       (v8 OR v9) AND
       (v8 OR v6) AND
       (v8 OR v7) AND
       (NOT v8 OR NOT v9))) ;


     End of SML version.
 ---------------------------------------------------------------------------*)


(*---------------------------------------------------------------------------
        Negation normal form (from Paulson's ML book). First a naive
        version, which has a complicated termination proof, and then
        a faster mutually recursive version, which has an easy 
        termination proof.
 ---------------------------------------------------------------------------*)

val nnf_defn0 =
 Hol_defn "nnf0"
     `(nnf (VAR x)        = VAR x)
 /\   (nnf (NOT (VAR x))  = NOT(VAR x))
 /\   (nnf (NOT(NOT p))   = nnf p)
 /\   (nnf (NOT(AND p q)) = nnf (OR  (NOT p) (NOT q)))
 /\   (nnf (NOT(OR p q))  = nnf (AND (NOT p) (NOT q)))
 /\   (nnf (AND p q)      = AND (nnf p) (nnf q))
 /\   (nnf (OR p q)       = OR (nnf p) (nnf q))`;

(*---------------------------------------------------------------------------
    The size of the largest NOT expression in a proposition.
 ---------------------------------------------------------------------------*)

val prop_size_def = definition "prop_size_def";

val MAX_def = Define `MAX x y = if x<y then y else x`;

val NOT_SIZE_def = 
 Define
    `(NOT_SIZE (VAR x)   = 0)
  /\ (NOT_SIZE (NOT p)   = prop_size (\v.0) p)
  /\ (NOT_SIZE (AND p q) = MAX (NOT_SIZE p) (NOT_SIZE q))
  /\ (NOT_SIZE (OR p q)  = MAX (NOT_SIZE p) (NOT_SIZE q))`;


val NOT_SIZE_LESS = Q.prove
(`!p. NOT_SIZE p < prop_size (\v.0) p + 1`,
 Induct
   THEN RW_TAC arith_ss [NOT_SIZE_def, MAX_def, prop_size_def]);
 
val (nnf0_eqns, nnf0_ind) = 
Defn.tprove
 (nnf_defn0,
  WF_REL_TAC nnf_defn0 
      `inv_image ($< LEX $<) (\x. (NOT_SIZE x, prop_size (\v.0) x))`
    THEN RW_TAC arith_ss [NOT_SIZE_def, MAX_def, 
                          prop_size_def, NOT_SIZE_LESS]);


val nnf_mutrec_eqns =
 xDefine "nnf1"
     `(nnfpos (VAR x)   = VAR x)
 /\   (nnfpos (NOT p)   = nnfneg p)
 /\   (nnfpos (AND p q) = AND (nnfpos p) (nnfpos q))
 /\   (nnfpos (OR p q)  = OR  (nnfpos p) (nnfpos q))
 /\   (nnfneg (VAR x)   = NOT (VAR x))
 /\   (nnfneg (NOT p)   = nnfpos p)
 /\   (nnfneg (AND p q) = OR  (nnfneg p) (nnfneg q))
 /\   (nnfneg (OR p q)  = AND (nnfneg p) (nnfneg q))`;

local open computeLib
      val compset = reduceLib.reduce_rws()
      val _ = add_thms (false,[REFL_CLAUSE]) compset
      val _ = add_thms (true,[nnf_mutrec_eqns]) compset
      val eval_nnf = CBV_CONV compset
in
fun Eval q = Count.apply eval_nnf (Term q)
end;

val syn052_1 = Eval
`nnfpos
   (NOT((NOT ^v1 OR ^v0) AND 
        (NOT ^v0 OR ^v1) AND 
        (^v1 OR ^v0)     AND 
        (NOT ^v1 OR ^v1) AND 
        (NOT ^v0 OR NOT ^v1)))`;

val syn051_1 = Eval
`nnfpos
  (NOT(( ^v1 OR ^v0) AND
       (^v1 OR ^v2) AND
       (NOT ^v0 OR NOT ^v1) AND
       (NOT ^v2 OR NOT ^v1) AND
       (NOT ^v0 OR ^v1) AND
       (NOT ^v1 OR ^v2)))`;

val syn044_1 = Eval
`nnfpos
  (NOT((^v0 OR ^v1) AND
       (NOT ^v0 OR NOT ^v1) AND
       (NOT ^v0 OR ^v1 OR ^v2) AND
       (NOT ^v2 OR ^v1) AND
       (NOT ^v2 OR ^v0) AND
       (NOT ^v1 OR ^v2)))`;

val syn011_1 = Eval
`nnfpos
  (NOT(^v6 AND
       (NOT ^v0 OR NOT ^v2) AND
       (^v0 OR ^v1 OR ^v5) AND
       (NOT ^v2 OR NOT ^v1) AND
       (NOT ^v4 OR ^v2) AND
       (NOT ^v3 OR ^v2) AND
       (^v3 OR ^v4 OR ^v5) AND
       (NOT ^v5 OR NOT ^v6)))`;

val syn032_1 = Eval
`nnfpos
  (NOT((NOT ^v5 OR NOT ^v1) AND
       (NOT ^v4 OR NOT ^v0) AND
       (NOT ^v4 OR ^v0) AND
       (NOT ^v5 OR ^v1) AND
       (NOT ^v2 OR ^v4 OR ^v3) AND
       (^v4 OR ^v2 OR ^v3) AND
       (NOT ^v3 OR ^v4 OR ^v5)))`;

val syn030_1 = Eval
`nnfpos
   (NOT((NOT ^v4 OR NOT ^v0 OR NOT ^v1) AND
        (NOT ^v3 OR NOT ^v4 OR ^v0) AND
        (NOT ^v1 OR ^v0) AND
        (^v0 OR ^v1) AND
        (NOT ^v0 OR ^v1) AND
        (NOT ^v1 OR NOT ^v0 OR ^v2) AND
        (NOT ^v2 OR ^v1) AND
        (NOT ^v1 OR ^v3) AND
        (NOT ^v2 OR NOT ^v3 OR ^v4)))`;

val syn054_1 = Eval
`nnfpos
  (NOT((NOT ^v1 OR NOT ^v7) AND
       (NOT ^v2 OR NOT ^v0) AND
       (NOT ^v3 OR ^v7 OR ^v4) AND
       (NOT ^v6 OR ^v0 OR ^v5) AND
       (NOT ^v7 OR ^v1) AND
       (NOT ^v0 OR ^v2) AND
       (NOT ^v4 OR ^v1) AND
       (NOT ^v5 OR ^v2) AND
       (NOT ^v3 OR NOT ^v4) AND
       (NOT ^v6 OR NOT ^v5) AND
       (^v6 OR ^v7)))`;

(* Takes a long time, but it gets there in the end. *)
val gra001_1 = Eval
`nnfpos
  (NOT((NOT ^v1 OR ^v0) AND
       (NOT ^v0 OR ^v1) AND
       (NOT ^v4 OR NOT ^v2 OR NOT ^v0) AND
       (NOT ^v4 OR ^v2 OR ^v0) AND
       (NOT ^v2 OR ^v4 OR ^v0) AND
       (NOT ^v0 OR ^v4 OR ^v2) AND
       (NOT ^v3 OR NOT ^v2 OR NOT ^v1) AND
       (NOT ^v3 OR ^v2 OR ^v1) AND
       (NOT ^v2 OR ^v3 OR ^v1) AND
       (NOT ^v1 OR ^v3 OR ^v2) AND
       (NOT ^v3 OR NOT ^v4) AND
       (^v3 OR ^v4)))`;


val syn321_1 =  Eval
`nnfpos
  (NOT((NOT ^v0 OR ^v9) AND
       (NOT ^v0 OR ^v6) AND
       (NOT ^v0 OR ^v7) AND
       (NOT ^v8 OR ^v9) AND
       (NOT ^v8 OR ^v6) AND
       (NOT ^v8 OR ^v7) AND
       (NOT ^v1 OR ^v9) AND
       (NOT ^v1 OR ^v6) AND
       (NOT ^v1 OR ^v7) AND
       (NOT ^v2 OR ^v3) AND
       (NOT ^v4 OR ^v5) AND
       (NOT ^v7 OR ^v8) AND
       (^v8 OR ^v9) AND
       (^v8 OR ^v6) AND
       (^v8 OR ^v7) AND
       (NOT ^v8 OR NOT ^v9)))` ;
