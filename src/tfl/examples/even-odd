(*---------------------------------------------------------------------------*
 *                                                                           *
 *            Mutual recursion : even and odd                                *
 *                                                                           *
 * This isn't such an interesting example, since the induction theorems      *
 * obtained are just standard mathematical induction!                        *
 *---------------------------------------------------------------------------*)

app load ["bossLib"]; open bossLib;

Hol_datatype `tag = Even of num | Odd of num`;

val EO = Define `(EO (Even 0) = T)              /\
                 (EO (Odd 0) = F)               /\
                 (EO (Even(SUC x)) = EO(Odd x)) /\
                 (EO (Odd(SUC x)) = EO(Even x))`;

val even_def = Define `even n = EO(Even n)`;
val odd_def  = Define `odd n  = EO(Odd n)`;

(*---------------------------------------------------------------------------
       |- (even 0 = T) /\
          (!x. even (SUC x) = odd x) /\
          (odd 0 = F) /\
          (!x. odd (SUC x) = even x) : thm
 ----------------------------------------------------------------------------*)

val (even_odd_rules as [even0,evenSUC,odd0,oddSUC]) = 
   map GEN_ALL
    (CONJUNCTS (Rewrite.PURE_REWRITE_RULE [GSYM even_def, GSYM odd_def] 
                 (CONJUNCT1 EO)));

val APART = prove(Term `!n. even n = ~odd n`,
  Induct 
    THEN RW_TAC bool_ss even_odd_rules);


(*---------------------------------------------------------------------------
    Taking an implication out of the equality makes the proof harder, 
    since the inductive hypothesis is not in shape to be used. Fortunately,
    some propositional reasoning puts things right.
 ---------------------------------------------------------------------------*)

val APART_IMP = prove(Term `!n. even n ==> ~odd n`,
  Induct 
    THEN RW_TAC bool_ss even_odd_rules
    THEN PROVE_TAC[]);
