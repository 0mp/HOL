(*---------------------------------------------------------------------------

    An example taken from

        "Automating induction over mutually recursive functions",
        Deepak Kapur and M. Subramaniam, Proceedings of AMAST'96,
        Springer LNCS 1101.

    The example displays the equivalence of call-by-name and 
    call-by-value evaluation strategies for a type of simple arithmetic 
    terms. The evaluation functions feature mutual and nested recursions.

 ---------------------------------------------------------------------------*)

load "bossLib"; open bossLib;


Hol_datatype `arith = C     of num                   (* constant *)
                    | V     of 'a                    (* variable *)
                    | Plus  of arith => arith        (* addition *)
                    | Apply of arith => 'a => arith  (* func. application *)`;


(*---------------------------------------------------------------------------
                     Call-by-name evaluation
 ---------------------------------------------------------------------------*)

val CBN_defn = Hol_fun "CBN_CBNh"

val stem = "CBN_CBNh";
val eqs0 = Term
     `(CBN (C n) y z         = C n)
 /\   (CBN (V x) y z         = if x=y then CBNh z else V x)
 /\   (CBN (Plus a1 a2) y z  = Plus (CBN a1 y z) (CBN a2 y z))
 /\   (CBN (Apply B v M) y z = CBN (CBN B v M) y z)

 /\   (CBNh (C n) = C n)
 /\   (CBNh (V x) = V x)
 /\   (CBNh (Plus a1 a2)  = Plus (CBNh a1) (CBNh a2))
 /\   (CBNh (Apply B v M) = CBN B v M)`;


val CBN_eqns      = Defn.eqns_of CBN_defn;
val SOME CBN_ind  = Defn.ind_of CBN_defn;


(*---------------------------------------------------------------------------
                     Environment lookup
 ---------------------------------------------------------------------------*)

val lookup_def = 
 Define
     `(lookup x [] = 0)
  /\  (lookup x ((y,z)::rst) = if x=y then z else lookup x rst)`;


(*---------------------------------------------------------------------------
                     Call-by-value evaluation
 ---------------------------------------------------------------------------*)

val CBV_defn = Hol_fun "CBV"
   `(CBV (C n, env)         = n)
/\  (CBV (V x, env)         = lookup x env)
/\  (CBV (Plus a1 a2, env)  = CBV(a1,env) + CBV(a2,env))
/\  (CBV (Apply B v M, env) = CBV(B, (v,CBV(M,env))::env))`;


val CBV_eqns      = Defn.eqns_of CBV_defn;
val SOME CBV_ind  = Defn.ind_of CBV_defn;


(*---------------------------------------------------------------------------
          Some munging to get tidier defns and induction thms.
 ---------------------------------------------------------------------------*)

val SOME R  = Defn.reln_of CBN_defn;
val SOME R1 = Defn.reln_of CBV_defn;

val CBNTerminates_def =
 Define
    `CBNTerminates ^R = ^(list_mk_conj (Defn.tcs_of CBN_defn))`;

val CBVTerminates_def =
 Define
    `CBVTerminates ^R1 = ^(list_mk_conj (Defn.tcs_of CBV_defn))`;

val TC0thms = 
 CONJUNCTS 
   (EQ_MP (SPEC_ALL CBNTerminates_def)
        (ASSUME (lhs(concl(SPEC_ALL CBNTerminates_def)))));

val TC1thms = 
 CONJUNCTS 
   (EQ_MP (SPEC_ALL CBVTerminates_def)
        (ASSUME (lhs(concl(SPEC_ALL CBVTerminates_def)))));

show_assums := true;

val CBN_eqns' = itlist PROVE_HYP TC0thms CBN_eqns;
val CBN_ind'  = itlist PROVE_HYP TC0thms CBN_ind;
val CBV_eqns' = itlist PROVE_HYP TC1thms CBV_eqns;


(*---------------------------------------------------------------------------
    Partial correctness is phrased as the following:

       CBNTerminates R /\ CBVTerminates R1 
           ==>
       !x y z env. 
           CBV (CBN(x,y,z),env) 
              = 
           CBV (x, (y,CBV(z,env))::env)

    We build an induction theorem first, by instantiating the 
    induction theorem for CBN to the predicates suggested by the 
    method of Richard Boulton.
 ---------------------------------------------------------------------------*)

val tm = Term
 `\(x,y,z). 
    !env. CBV (CBN (x,y,z), env) 
               = 
          CBV(x, (y, CBV(z,env))::env)`;

val tm1 = Term `\z. !env. CBV (CBNh z, env) = CBV(z,env)`;

val [P0,P1] = fst(strip_forall(concl CBN_ind'));
val ind0 = SPEC_ALL CBN_ind';
val ind1 = CONV_RULE (DEPTH_CONV Let_conv.GEN_BETA_CONV)
              (Rsyntax.INST [P0 |-> tm, P1 |-> tm1] ind0);
val [ind2a, _] = CONJUNCTS (UNDISCH ind1);
val ind3 = REWRITE_RULE pairTheory.pair_rws
             (SPEC (Term`(x,y,z):'a arith#'a#'a arith`) ind2a);
val ind4 = DISCH (fst(dest_imp(concl ind1)))
                 (SPEC_ALL ind3);


(*---------------------------------------------------------------------------
      We distinguish the names "R" and "R1" of the termination 
      relations; otherwise, the termination relations for both 
      CBN and CBV would have the same name, which is confusing.
 ---------------------------------------------------------------------------*)

val R1' = mk_var("R1", type_of R1);;

val CBV_eqns'' = UNDISCH (Rsyntax.INST [R1 |-> R1'] (DISCH_ALL CBV_eqns'));


(*---------------------------------------------------------------------------
           Given ind4, the correctness proof is easy!
 ---------------------------------------------------------------------------*)

val KapurSubra = store_thm("KapurSubra",
 Term`!R R1.
        CBNTerminates ^R /\ CBVTerminates ^R1'
            ==>
        !x (y:'a) z env. 
                CBV (CBN(x,y,z),env) 
                   = 
                CBV (x, (y, CBV(z,env))::env)`,
REPEAT GEN_TAC THEN STRIP_TAC
 THEN MATCH_MP_TAC ind4
 THEN RW_TAC base_ss [CBN_eqns',CBV_eqns'',lookup_def]);


(*---------------------------------------------------------------------------
       Remaining task: supply R and R1 such that 

          CBNTerminates R /\ CBVTerminates R1

       This will require reasoning about the auxiliary functions
       used in defining CBN and CBV. Since CBN is mutual recursive 
       with CBNh and also a nested recursion, this makes things 
       not completely obvious.
 ---------------------------------------------------------------------------*)

val SOME CBN_union = Defn.union_defn CBN_defn;
val SOME CBN_aux   = Defn.aux_defn CBN_union;

val SOME CBV_aux   = Defn.aux_defn CBV_defn;
Defn.eqns_of CBV_aux;

