app load ["bossLib", "Q"]; open bossLib; 

infix 8 by; infix &&;
show_assums := true;

(*---------------------------------------------------------------------------
       Definitions of schemas for binary recursion, 
       continuation-passing style, and accumulator style.
 ---------------------------------------------------------------------------*)

val binRec_eqn = 
 Define
    `binRec (x:'a) = 
        if atomic x then A x 
        else join (binRec (left x)) 
                  (binRec (right x))`;

val binRec_ind = theorem "binRec_def";

val bin_cpRec_def = 
 Define 
    `bin_cpRec (x:'a, f) = 
       if atomic x then f (base x) 
       else bin_cpRec (right x, \u. join (bin_cpRec (left x,f)) u)`;


(*---------------------------------------------------------------------------
     Complex, but tail recursive 
 ---------------------------------------------------------------------------*)

val bin_accRec_def0 = 
 Define
    `bin_accRec0 (x:'a, todo, v) = 
        if atomic x
        then (list_case (join v (base x))
                        (\h t. bin_accRec0 (h, t, join v (base x))) todo)
        else bin_accRec0 (left x, right x::todo, v)`;

(*---------------------------------------------------------------------------
        More general version.
 ---------------------------------------------------------------------------*)
val baRec_def0 = 
 Define
    `(baRec ([],v) = (v:'b)) 
  /\ (baRec ((h:'a)::t, v) =
        if atomic h 
          then baRec (t, join v (A h:'b))
          else baRec (APPEND (dest h) t, v))`;


load "multisetTheory";  (* not currently in release *)

val APPEND_Summ = Q.prove
`!l1 l2. 
    list_to_mset (APPEND l1 l2) = Summ (list_to_mset l1) (list_to_mset l2)`
(Induct THEN RW_TAC list_ss [multisetTheory.list_to_mset_def,
                             multisetTheory.Summ]);

val mem_Inm = Q.prove
`!x l. x <- list_to_mset l = MEM x l`
(Induct_on `l` THEN RW_TAC list_ss [multisetTheory.In_mset, 
                                    multisetTheory.list_to_mset_def,mem_def]);

val tc_lemma = Q.prove
`!atomic dest join A R. 
 WF R /\ (!h y. ~atomic h /\ mem y (dest h) ==> R y h)
      ==>
 ?R'. WF R' /\   
     (!v t h. ~atomic h ==> R' (APPEND (dest h) t, v) (h::t, v)) /\
    (!v t (h:'a). atomic h ==> R' (t, join (v:'b) (A h:'b)) (h::t,v))`
let open multisetTheory multisetWFTheory 
in REPEAT STRIP_TAC 
 THEN Q.EXISTS_TAC `inv_image (pred_multiset R) (list_to_mset o FST)`
 THEN CONJ_TAC THENL
 [PROVE_TAC [relationTheory.WF_inv_image, WF_multiset],
  RW_TAC bool_ss [relationTheory.inv_image_def, list_to_mset_def,
        pred_multiset_def,combinTheory.o_DEF,Finitem_list_to_mset] THENL
 [Q.EXISTS_TAC `h` THEN RW_TAC bool_ss [Diffm_Addm_same,Diffm_Mnil,In_mset]
   THEN Q.EXISTS_TAC `list_to_mset (dest (h:'a))`
   THEN RW_TAC bool_ss [Finitem_list_to_mset,mem_Inm,APPEND_Summ]
   THEN RW_TAC bool_ss [mset_ext,Countm,Countm_Summ] 
   THEN RW_TAC arith_ss [],
  MAP_EVERY Q.EXISTS_TAC [`h`, `Mnil`]
   THEN RW_TAC bool_ss [Finitem_Mnil, Finitem_Addm,In_mset]
   THEN RW_TAC bool_ss [Diffm_Addm_same,Diffm_Mnil, Summ]]]
end;

val baRec_def1 = 
 UNDISCH 
   (ONCE_REWRITE_RULE [PROVE[]`x ==> y ==> z ==> a = z /\ y /\ x ==> a`]
          (DISCH_ALL baRec_def0));

val baRec_def2 = 
  CHOOSE (Term`R:'a list#'b -> 'a list#'b -> bool`, 
          UNDISCH_ALL (SPEC_ALL tc_lemma)) baRec_def1;

val baRec_def3 = 
  REWRITE_RULE [AND_IMP_INTRO]
    (UNDISCH_ALL (REWRITE_RULE [GSYM AND_IMP_INTRO]
                                 (DISCH_ALL baRec_def2)));

val baRec_eqn = CONJUNCT1 baRec_def3;
val baRec_ind = CONJUNCT2 baRec_def3;

(*---------------------------------------------------------------------------
    Relating binary recursion to tail recursion, via the 
    "hd-multiset" tail recursion of baRec.
 ---------------------------------------------------------------------------*)

val lem = Q.prove
`(!(h:'a) (y:'a). ~atomic h ==> (y=left h) \/ (y=right h) ==> R y h) = 
  !h. ~atomic h ==> R (left h) h /\ R (right h) h` (PROVE_TAC[]);

val baRec_def4 = 
UNDISCH_ALL
 (REWRITE_RULE[mem_def,lem]
   (BETA_RULE
     (Q.INST [`dest:'a -> 'a list` |-> `\x:'a. [left x; right x]:'a list`] 
            (DISCH_ALL baRec_def3))));;

val lem2 = Q.prove 
    `(!x:'a. ~(atomic x) ==> R (left x) x) ==>
     (!x:'a. ~(atomic x) ==> R (right x) x) ==> Q
      = 
     (!h:'a. ~atomic h ==> R (left h) h /\ R (right h) h) ==> Q` (PROVE_TAC[]);

val binRec_def1 = UNDISCH_ALL (REWRITE_RULE [lem2] (DISCH_ALL binRec_def));

val REV_ITLIST_DEF =
 Define
     `(REV_ITLIST f [] v = v) /\
      (REV_ITLIST f (CONS h t) v = REV_ITLIST f t (f h v))`;

(*---------------------------------------------------------------------------
     This is the interesting proof.
 ---------------------------------------------------------------------------*)

val binRec_to_baRec = 
 Q.prove
  `!R atomic A join left right.
       WF R /\ (!x. ~atomic x ==> R (left x) x /\ R (right x) x)
            /\ (!p q r:'b. join (join p q) r = join p (join q r))
       ==> 
        !(todo:'a list) (res0:'b). 
          REV_ITLIST 
             (\tr res. join res (binRec right left join A atomic tr)) todo res0
            =
          baRec (\x:'a. [left x; right x]) A join atomic (todo,res0)`
(REPEAT GEN_TAC THEN STRIP_TAC
  THEN tflLib.REC_INDUCT_TAC (CONJUNCT2 baRec_def4)
  THEN RW_TAC bool_ss [] THENL
  [RW_TAC list_ss [REV_ITLIST_DEF,CONJUNCT1 baRec_def4],
   RW_TAC list_ss [REV_ITLIST_DEF] 
     THEN ONCE_REWRITE_TAC [CONJUNCT1 baRec_def4] 
     THEN RW_TAC bool_ss [] THENL
     [GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o RAND_CONV o RAND_CONV)
           empty_rewrites [CONJUNCT1 binRec_def1] THEN ZAP_TAC bool_ss [],
      RES_TAC THEN NTAC 2 (POP_ASSUM (K ALL_TAC))
        THEN POP_ASSUM (SUBST_ALL_TAC o SYM)
        THEN GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o RAND_CONV o RAND_CONV)
                  empty_rewrites [CONJUNCT1 binRec_def1] 
        THEN RW_TAC list_ss [REV_ITLIST_DEF]]]);


(*---------------------------------------------------------------------------
    Thus, we have the final transformation for binary recursions:

    [!x. ~(atomic x) ==> R (left x) x /\ R (right x) x, WF R,
     !p q r. join (join p q) r = join p (join q r)]
    |- !x res0.
         join res0 (binRec right left join A atomic x)
             =
         baRec (\x. [left x; right x]) A join atomic ([x],res0)

 ---------------------------------------------------------------------------*)

val tail_binRec = 
DISCH_ALL
 (BETA_RULE (REWRITE_RULE [REV_ITLIST_DEF] 
   (GEN (Term `x`) (SPEC (Term`[x]`) 
      (UNDISCH_ALL (REWRITE_RULE [GSYM AND_IMP_INTRO] 
         (SPEC_ALL binRec_to_baRec)))))));

