app load ["bossLib", "Q", "tflLib"];
open bossLib; infix 8 by; infix &&;
show_assums := true;

use"/home/kxs/hol/let.support";

Hol_datatype `btree 
                = LEAF 
                | NODE of btree => 'a => btree`;

val btreeRec_def = 
 Define
   `(btreeRec LEAF (v:'a) (f:'a->'b->'a->'a)  = v)
 /\ (btreeRec (NODE t1 M t2) v f = f (btreeRec t1 v f) M (btreeRec t2 v f))`;


(*---------------------------------------------------------------------------
     The following doesn't work, because P and f should be free in 
     the definition.
 ---------------------------------------------------------------------------*)
(*
val unfold_def = 
 Define
     `unfold P f x = 
          (P (x:'a) 
            => let (y,a,z) = f x
                  in 
                  NODE (unfold P f y) a (unfold P f z)
            | LEAF)`;
*)

(*---------------------------------------------------------------------------
        Following is the right way to define the unfold schema.
 ---------------------------------------------------------------------------*)

val unfold_def = 
 Define
     `unfold (x:'a) = 
        if more x 
          then let (y1,b,y2) = dest x 
               in 
                  NODE (unfold y1) b (unfold y2)
          else LEAF`;

val fusion_def = 
 Define
     `fusion (x:'a) = 
         if more x 
           then let (y,i,z) = dest x
                in 
                   g (fusion y) (i:'b) (fusion z)
           else (c:'c)`;

val unfold_eqn = unfold_def;
val unfold_ind = theorem "unfold_ind";

val fusion_eqn = fusion_def;
val fusion_ind = theorem "fusion_ind";

(*---------------------------------------------------------------------------
     Prove that unfolding and then reducing is the same as doing 
     a fusion. 
 ---------------------------------------------------------------------------*)

(* hack for broken rewriter *)
local val contxt = Term
  `\nde. (btreeRec :'b btree->'c->('c->'b->'c->'c)->'c) nde c g 
   =  g (fusion c (dest:'a->'a#'b#'a) g (more:'a->bool) x')
        i (fusion c dest g more z)`
      val M = Term `(dest:'a->'a#'b#'a) x`
      val N = Term `\y a z. NODE (unfold dest (more:'a -> bool) y) 
                                 (a:'b) (unfold dest more z)`
in 
val PULL_LET3_lem = BETA_RULE (ISPECL [contxt,M,N] PULL_LET3)
end;


val fusion_thm = Q.prove
`!R dest more.
     WF R
     /\ (!x y1 b y2. more x /\ ((y1,b,y2) = dest x) ==> R y2 x) 
     /\ (!x y1 b y2. more x /\ ((y1,b,y2) = dest x) ==> R y1 x) 
     ==>
        !(x:'a) (c:'c) g. 
           btreeRec (unfold dest more x) c g = fusion c dest g more x`
(REPEAT GEN_TAC THEN STRIP_TAC 
  THEN tflLib.REC_INDUCT_TAC unfold_ind THEN RW_TAC bool_ss []
  THEN ONCE_REWRITE_TAC[unfold_eqn] THEN ONCE_REWRITE_TAC[fusion_eqn] 
  THEN RW_TAC bool_ss [btreeRec_def,PULL_LET3] 
  THEN LET_INTRO_TAC THEN RW_TAC bool_ss [PULL_LET3_lem]
  THEN LET_INTRO_TAC THEN RW_TAC bool_ss [btreeRec_def]
  THEN Q.PAT_ASSUM `x = y` (SUBST_ALL_TAC o SYM)
  THEN ZAP_TAC bool_ss []);



(*---------------------------------------------------------------------------
       Prove continuation-passing transforms for linear recursions.
 ---------------------------------------------------------------------------*)

val linRec_def = 
 Define
    `linRec (x:'a) = if atomic x then A x 
                     else join (linRec (dest x)) (D x:'b)`;

val cpRec_def0 = 
 Define
    `cpRec (x:'a, (f:'b -> 'c)) = 
        if atomic x then f (A x) 
        else cpRec (dest x, \u:'b. f (join u (D x:'b)))`;

val accRec_def0 = 
 Define
    `accRec (x:'a, (u:'b)) = 
        if atomic x then join (A x) u
        else accRec (dest x, join (D x:'b) u)`;


(*---------------------------------------------------------------------------
       Minor massaging of definitions in order to clean up the TCs
 ---------------------------------------------------------------------------*)

fun ID_SPEC thm = SPEC (#Bvar(dest_forall(concl thm))) thm;

val cpRec_def = 
 UNDISCH
 (REWRITE_RULE pairTheory.pair_rws
   (BETA_RULE (REWRITE_RULE[relationTheory.inv_image_def]
      (REWRITE_RULE[UNDISCH (ISPEC (Term`FST:'a#('b->'c)->'a`)
                              (ID_SPEC relationTheory.WF_inv_image))]
        (INST [Term`R :'a # ('b -> 'c) -> 'a # ('b -> 'c) -> bool`
                |->
               Term`inv_image R (FST :'a # ('b -> 'c) -> 'a)`]
         (DISCH_ALL cpRec_def0))))));

val accRec_def = 
 UNDISCH
 (REWRITE_RULE pairTheory.pair_rws
   (BETA_RULE (REWRITE_RULE[relationTheory.inv_image_def]
      (REWRITE_RULE[UNDISCH (ISPEC (Term`FST:'a#'b->'a`)
                              (ID_SPEC relationTheory.WF_inv_image))]
        (INST [Term`R :'a#'b -> 'a#'b -> bool`
                 |->
               Term`inv_image R (FST :'a#'b -> 'a)`]
         (DISCH_ALL accRec_def0))))));

val linRec_eqn = linRec_def;
val linRec_ind = theorem "linRec_ind";

val cpRec_eqn = cpRec_def;
val cpRec_ind = theorem "cpRec_ind";

val accRec_eqn = accRec_def;
val accRec_ind = theorem "accRec_ind";

val cpRec_eq_linRec = Q.prove
`!R atomic A join dest D.
    WF R 
     /\ (!x. ~(atomic x) ==> R (dest x) x)
     ==> 
      !x f. cpRec A D atomic dest join (x, f) 
              = 
            f (linRec A D atomic dest join x)`
(REPEAT GEN_TAC THEN STRIP_TAC
  THEN tflLib.REC_INDUCT_TAC linRec_ind
  THEN RW_TAC bool_ss [] THEN ONCE_REWRITE_TAC[linRec_eqn]
  THEN ONCE_REWRITE_TAC[cpRec_eqn] THEN RW_TAC bool_ss []);


val accRec_eq_cpRec = Q.prove
`!R atomic A join dest D.
    WF R 
    /\ (!x. ~atomic x ==> R (dest x) x) 
    /\ (!p q r:'b. join p (join q r) = join (join p q) r)
     ==> 
      !x u. accRec A D atomic dest join (x,u) 
              = 
            cpRec A D atomic dest join (x, \w. join w u)`
(REPEAT GEN_TAC THEN STRIP_TAC
  THEN tflLib.REC_INDUCT_TAC accRec_ind THEN RW_TAC bool_ss []
  THEN ONCE_REWRITE_TAC[cpRec_eqn] THEN ONCE_REWRITE_TAC[accRec_eqn] 
  THEN RW_TAC bool_ss []);


(*---------------------------------------------------------------------------
     Ergo, we have the following equality between linear and 
     accumulator recursions ... this can also be proved directly
     via an equally easy proof.
 ---------------------------------------------------------------------------*)

val linRec_eq_accRec = Q.prove
`!R atomic A join dest D.
    WF R 
    /\ (!x. ~(atomic x) ==> R (dest x) x)
    /\ (!p q r:'b. join p (join q r) = join (join p q) r)
     ==> 
      !x u. join (linRec D dest join A atomic x) u 
              = 
            accRec D dest A join atomic (x,u)`
(REPEAT STRIP_TAC   (* weakness in solver forces use of IMP_RES_THEN *)
  THEN IMP_RES_THEN (fn th => RW_TAC bool_ss [th]) accRec_eq_cpRec
  THEN IMP_RES_THEN (fn th => RW_TAC bool_ss [th]) cpRec_eq_linRec);


(*---------------------------------------------------------------------------
              Two versions of reverse.
 ---------------------------------------------------------------------------*)

val rev_def = 
 Define
    `rev = linRec (\l. [HD l]) (*  D  *)
                  TL           (*  dest  *)
                  APPEND       (*  join  *)
                  (\x.x)       (*  A  *)
                  NULL         (* atomic *)`;


val frev_def = 
 Define
    `frev l a = accRec (\l. [HD l]) (*  D  *)
                       TL           (*  dest  *)
                       (\x.x)       (*  A  *)
                       APPEND       (*  join  *)
                       NULL         (* atomic *)
                       (l,a)`;


(*---------------------------------------------------------------------------
      Equivalence of the two forms of reverse. First, instantiate
      the program transformation "sufficiently".
 ---------------------------------------------------------------------------*)

val lem0 = GEN_ALL (DISCH_ALL (GSYM 
             (UNDISCH_ALL (SPEC_ALL 
               (Q.ISPEC `measure LENGTH` linRec_eq_accRec)))));

val lem1 = Q.prove
`!x. ~NULL x ==> measure LENGTH (TL x) x`
(Cases THEN RW_TAC list_ss [WFTheory.measure_def,relationTheory.inv_image_def]);


val rev_eq_frev = Q.prove `!l x. rev l = frev l []`
(RW_TAC list_ss [rev_def, frev_def, lem0, lem1, WFTheory.WF_measure]);


(*---------------------------------------------------------------------------
    The natural way to apply these rewrites seems to be to let the
    user write something in a simple style and then let the
    system do some waily higher-order matching in order to choose
    and apply a transformation. Even after the transformation has 
    been applied, the new recursion equations may have to be simplified
    in order to be intelligible to the user.
 ---------------------------------------------------------------------------*)

val REV_DEF = 
 Define
    `(REV [] = []) /\
     (REV (h::t) = APPEND (REV t) [h])`;

(*
val REV_eq_rev = Q.prove `REV = rev`
 (CONV_TAC FUN_EQ_CONV 
    THEN Cases THEN RW_TAC list_ss [rev_def, linRec_def, REV_DEF]
*)

(*---------------------------------------------------------------------------
        Prove continuation-passing transforms for binary recursions.
 ---------------------------------------------------------------------------*)

val binRec_def = 
 Define
    `binRec (x:'a) = 
      (atomic x => A x 
              | join (binRec (left x)) 
                     (binRec (right x)))`;

val binRec_eqn = CONJUNCT1 binRec_def;
val binRec_ind = CONJUNCT2 binRec_def;

(* Problem ! nested defn *)
(*
val bin_cpRec_def = 
 tflLib.Rfunction "fb_def" `measure FST`
    `bin_cpRec (x:'a, f) = 
         (atomic x => f (A x) 
              |  bin_cpRec (right x, \u. join (bin_cpRec (left x,f)) u))`;
*)

loadPath := "/home/kxs/TFL/examples/wfmset" :: !loadPath;
app load ["multisetTheory", "multisetWFTheory"];


(* Complex, but tail recursive *)
val bin_accRec_def0 = 
 Define
    `bin_accRec0 (x:'a, todo, v) = 
         (atomic x => (list_case (join v (A x))
                         (\h t. bin_accRec0 (h, t, join v (A x))) todo)
              |  bin_accRec0 (left x, CONS (right x) todo, v))`;

val tc_lemma = Q.prove
`!atomic left right (join:'b ->'c->'b) A R. 
 WF R /\ (!x. ~atomic x ==> R (left x) x /\ R (right x) x)
      ==>
 ?R'. WF R' /\   
     (!v todo x. ~atomic x ==> R' (left x, CONS (right x) todo,v) (x,todo,v)) 
     /\
     (!v todo x h t. 
        atomic x /\ (todo = CONS h t) ==> R' (h,t,join v (A x)) (x,todo,v))`
let open multisetTheory multisetWFTheory 
in 
REPEAT STRIP_TAC 
 THEN Q.EXISTS_TAC `inv_image (pred_multiset R) 
                     (\(x,y,(z:'b)). list_to_mset (CONS x y))`
 THEN CONJ_TAC THENL
 [PROVE_TAC [relationTheory.WF_inv_image, WF_multiset],
  RW_TAC bool_ss [relationTheory.inv_image_def, list_to_mset_def,
        pred_multiset_def,Finitem_list_to_mset] THENL
 [MAP_EVERY Q.EXISTS_TAC [`x`, `Addm (left (x:'a)) (Addm (right x) Mnil)`]
   THEN RW_TAC bool_ss 
          [Finitem_Mnil, Finitem_Addm, In_mset,Finitem_list_to_mset] THENL
   [RW_TAC bool_ss [Diffm_Addm_same,Diffm_Mnil] THEN 
    RW_TAC bool_ss [mset_ext,Countm,Countm_Summ] THEN RW_TAC arith_ss [],
    PROVE_TAC[], PROVE_TAC[]],
  MAP_EVERY Q.EXISTS_TAC [`x`, `Mnil`]
   THEN RW_TAC bool_ss [Finitem_Mnil,Finitem_Addm,Finitem_list_to_mset,In_mset]
   THEN RW_TAC bool_ss [Diffm_Addm_same,Diffm_Mnil,Summ]]]
end;

val bin_accRec_def1 = 
 UNDISCH 
   (ONCE_REWRITE_RULE [PROVE[]`x ==> y ==> z ==> a = z /\ y /\ x ==> a`]
          (DISCH_ALL bin_accRec_def0));

val bin_accRec_def = 
  CHOOSE (Term`R:'a#'a list#'b -> 'a#'a list#'b -> bool`, 
          UNDISCH_ALL (SPEC_ALL tc_lemma)) bin_accRec_def1;

val bin_accRec_eqn = CONJUNCT1 bin_accRec_def;
val bin_accRec_ind = CONJUNCT2 bin_accRec_def;


(* Tail recursive -- TFL bug:fails if curried *)
val baccRec_def0 = 
 Define
    `(baccRec ([],v) = v) 
  /\ (baccRec (CONS (h:'a) t, v) =
        (atomic h => baccRec (t, join v (A h))
                  |  baccRec (CONS (left h) (CONS (right h) t), v)))`;

val tc_lemma = Q.prove
`!atomic left right join A R. 
 WF R /\ (!h. ~atomic h ==> R (left h) h /\ R (right h) h)
      ==>
 ?R'. WF R' /\   
     (!v t h. ~atomic h ==> R' (CONS (left h) (CONS (right h) t), v) 
                               (CONS h t, v)) /\
     (!v t h. atomic h ==> R' (t, join v (A h)) (CONS h t,v))`
let open multisetTheory multisetWFTheory 
in REPEAT STRIP_TAC 
 THEN Q.EXISTS_TAC `inv_image (pred_multiset R) (list_to_mset o FST)`
 THEN CONJ_TAC THENL
 [PROVE_TAC [relationTheory.WF_inv_image, WF_multiset],
  RW_TAC bool_ss [relationTheory.inv_image_def, list_to_mset_def,
        pred_multiset_def,Finitem_list_to_mset,combinTheory.o_DEF] THENL
 [MAP_EVERY Q.EXISTS_TAC [`h`, `Addm (left (h:'a)) (Addm (right h) Mnil)`]
   THEN RW_TAC bool_ss [Finitem_Mnil, Finitem_Addm,In_mset] THENL
   [RW_TAC bool_ss [Diffm_Addm_same,Diffm_Mnil]
      THEN RW_TAC bool_ss [mset_ext,Countm,Countm_Summ] 
      THEN RW_TAC arith_ss [],
    PROVE_TAC[], PROVE_TAC[]],
  MAP_EVERY Q.EXISTS_TAC [`h`, `Mnil`]
   THEN RW_TAC bool_ss [Finitem_Mnil, Finitem_Addm,In_mset]
   THEN RW_TAC bool_ss [Diffm_Addm_same,Diffm_Mnil, Summ]]]
end;

val baccRec_def1 = 
 UNDISCH 
   (ONCE_REWRITE_RULE [PROVE[]`x ==> y ==> z ==> a = z /\ y /\ x ==> a`]
          (DISCH_ALL baccRec_def0));

val baccRec_def = 
  CHOOSE (Term`R:'a list#'b -> 'a list#'b -> bool`, 
          UNDISCH_ALL (SPEC_ALL tc_lemma)) baccRec_def1;

val baccRec_eqn = CONJUNCT1 baccRec_def;
val baccRec_ind = CONJUNCT2 baccRec_def;


(* (More general) Tail recursive -- TFL bug:fails if curried *)
val baRec_def0 = 
 Define
    `(baRec ([],v) = (v:'b)) 
  /\ (baRec (CONS (h:'a) t, v) =
        (atomic h => baRec (t, join v (A h:'b))
                  |  baRec (APPEND (dest h) t, v)))`;

val mem_def = 
 Define
    `(mem x [] = F) /\ (mem x (CONS h t) = (x=h) \/ mem x t)`;

val APPEND_Summ = Q.prove
`!l1 l2. 
    list_to_mset (APPEND l1 l2) = Summ (list_to_mset l1) (list_to_mset l2)`
(Induct THEN RW_TAC list_ss [multisetTheory.list_to_mset_def,
                             multisetTheory.Summ]);

val mem_Inm = Q.prove
`!x l. x <- list_to_mset l = mem x l`
(Induct_on `l` THEN RW_TAC list_ss [multisetTheory.In_mset, 
                                    multisetTheory.list_to_mset_def,mem_def]);

val tc_lemma = Q.prove
`!atomic dest join A R. 
 WF R /\ (!h y. ~atomic h /\ mem y (dest h) ==> R y h)
      ==>
 ?R'. WF R' /\   
     (!v t h. ~atomic h ==> R' (APPEND (dest h) t, v) (CONS h t, v)) /\
    (!v t (h:'a). atomic h ==> R' (t, join (v:'b) (A h:'b)) (CONS h t,v))`
let open multisetTheory multisetWFTheory 
in REPEAT STRIP_TAC 
 THEN Q.EXISTS_TAC `inv_image (pred_multiset R) (list_to_mset o FST)`
 THEN CONJ_TAC THENL
 [PROVE_TAC [relationTheory.WF_inv_image, WF_multiset],
  RW_TAC bool_ss [relationTheory.inv_image_def, list_to_mset_def,
        pred_multiset_def,combinTheory.o_DEF,Finitem_list_to_mset] THENL
 [Q.EXISTS_TAC `h` THEN RW_TAC bool_ss [Diffm_Addm_same,Diffm_Mnil,In_mset]
   THEN Q.EXISTS_TAC `list_to_mset (dest (h:'a))`
   THEN RW_TAC bool_ss [Finitem_list_to_mset,mem_Inm,APPEND_Summ]
   THEN RW_TAC bool_ss [mset_ext,Countm,Countm_Summ] 
   THEN RW_TAC arith_ss [],
  MAP_EVERY Q.EXISTS_TAC [`h`, `Mnil`]
   THEN RW_TAC bool_ss [Finitem_Mnil, Finitem_Addm,In_mset]
   THEN RW_TAC bool_ss [Diffm_Addm_same,Diffm_Mnil, Summ]]]
end;

val baRec_def1 = 
 UNDISCH 
   (ONCE_REWRITE_RULE [PROVE[]`x ==> y ==> z ==> a = z /\ y /\ x ==> a`]
          (DISCH_ALL baRec_def0));

val baRec_def2 = 
  CHOOSE (Term`R:'a list#'b -> 'a list#'b -> bool`, 
          UNDISCH_ALL (SPEC_ALL tc_lemma)) baRec_def1;

val baRec_def3 = 
  REWRITE_RULE [AND_IMP_INTRO]
    (UNDISCH_ALL (REWRITE_RULE [GSYM AND_IMP_INTRO]
                                 (DISCH_ALL baRec_def2)));

val baRec_eqn = CONJUNCT1 baRec_def3;
val baRec_ind = CONJUNCT2 baRec_def3;

(*---------------------------------------------------------------------------
    Relating binary recursion to tail recursion, via the 
    "hd-multiset" tail recursion of baRec.
 ---------------------------------------------------------------------------*)

val lem = Q.prove
`(!(h:'a) (y:'a). ~atomic h ==> (y=left h) \/ (y=right h) ==> R y h) = 
  !h. ~atomic h ==> R (left h) h /\ R (right h) h` (PROVE_TAC[]);

val baRec_def4 = 
UNDISCH_ALL
 (REWRITE_RULE[mem_def,lem]
   (BETA_RULE
     (Q.INST [`dest:'a -> 'a list` |-> `\x:'a. [left x; right x]:'a list`] 
            (DISCH_ALL baRec_def3))));;

val lem2 = Q.prove 
    `(!x:'a. ~(atomic x) ==> R (left x) x) ==>
     (!x:'a. ~(atomic x) ==> R (right x) x) ==> Q
      = 
     (!h:'a. ~atomic h ==> R (left h) h /\ R (right h) h) ==> Q` (PROVE_TAC[]);

val binRec_def1 = UNDISCH_ALL (REWRITE_RULE [lem2] (DISCH_ALL binRec_def));

val REV_ITLIST_DEF =
 Define
     `(REV_ITLIST f [] v = v) /\
      (REV_ITLIST f (CONS h t) v = REV_ITLIST f t (f h v))`;

val binRec_to_baRec = 
 Q.prove
  `!R atomic A join left right.
       WF R /\ (!x. ~atomic x ==> R (left x) x /\ R (right x) x)
            /\ (!p q r:'b. join (join p q) r = join p (join q r))
       ==> 
        !(todo:'a list) (res0:'b). 
          REV_ITLIST 
             (\tr res. join res (binRec right left join A atomic tr)) todo res0
            =
          baRec (\x:'a. [left x; right x]) A join atomic (todo,res0)`
(REPEAT GEN_TAC THEN STRIP_TAC
  THEN tflLib.REC_INDUCT_TAC (CONJUNCT2 baRec_def4)
  THEN RW_TAC bool_ss [] THENL
  [RW_TAC list_ss [REV_ITLIST_DEF,CONJUNCT1 baRec_def4],
   RW_TAC list_ss [REV_ITLIST_DEF] 
     THEN ONCE_REWRITE_TAC [CONJUNCT1 baRec_def4] 
     THEN RW_TAC bool_ss [] THENL
     [GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o RAND_CONV o RAND_CONV)
           empty_rewrites [CONJUNCT1 binRec_def1] THEN ZAP_TAC bool_ss [],
      RES_TAC THEN NTAC 2 (POP_ASSUM (K ALL_TAC))
        THEN POP_ASSUM (SUBST_ALL_TAC o SYM)
        THEN GEN_REWRITE_TAC (RATOR_CONV o RAND_CONV o RAND_CONV o RAND_CONV)
                  empty_rewrites [CONJUNCT1 binRec_def1] 
        THEN RW_TAC list_ss [REV_ITLIST_DEF]]]);


(*---------------------------------------------------------------------------
    Thus, we have the final transformation for binary recursions:

    [!x. ~(atomic x) ==> R (left x) x /\ R (right x) x, WF R,
     !p q r. join (join p q) r = join p (join q r)]
    |- !x res0.
         join res0 (binRec right left join A atomic x)
             =
         baRec (\x. [left x; right x]) A join atomic ([x],res0)

 ---------------------------------------------------------------------------*)

val tail_binRec = 
DISCH_ALL
 (BETA_RULE (REWRITE_RULE [REV_ITLIST_DEF] 
   (GEN (Term `x`) (SPEC (Term`[x]`) 
      (UNDISCH_ALL (REWRITE_RULE [GSYM AND_IMP_INTRO] 
         (SPEC_ALL binRec_to_baRec)))))));

val filter_def = 
 Define 
     `(filter P [] = []) /\
      (filter P (CONS h t) = (P h => CONS h (filter P t) | filter P t))`;

val filter_LENGTH = 
 Q.prove
   `!P l. LENGTH (filter P l) <= LENGTH l`
(Induct_on `l` 
  THEN ZAP_TAC (list_ss && [filter_def]) [DECIDE `x<=y ==> x <= SUC y`]);

fun left(x,h::t) =  (x,filter (curry (op <=) h) t);
fun right(x,h::t) = (h,filter (curry (op >) h) t);
fun join (p1,l1) (p2,l2) = (p1, l1@(p2::l2));
fun atomic(n,[]) = true
  | atomic(n,l) = false;

fun quik0 (nl) = 
  if atomic nl then nl
  else join (quik (left nl)) (quik0 (right nl));

fun quik l = quik0 (hd l,l);

val def1 = INST_TYPE [alpha |-> Type `:num # num list`,
                      beta  |-> Type `:num # num list`] tail_binRec;
val def2 = Q.INST [`A` |-> `\x:num#num list. x`] def1;
val def3 = Q.INST [`atomic` |-> `pair_case(\(x:num) (y:num list). 
                                   list_case T (\h t. F) y)`] def2;
val def4 = Q.INST [`R` |-> `measure 
                              (LENGTH o (SND:num#num list -> num list))`] def3;
val cat_def =
 Define
    `cat (p1,q1) (p2,q2) = (p1, APPEND q1 (CONS p2 q2))`;

val cat_assoc = 
 Q.prove
     `!p q r. cat p (cat q r) = cat (cat p q) r`
(REPEAT Cases
   THEN RW_TAC list_ss [cat_def]
   THEN ONCE_REWRITE_TAC [GSYM listTheory.APPEND_ASSOC]
   THEN REWRITE_TAC [listTheory.APPEND]);

val def5 = Q.INST [`join` |-> `cat:num#num list->num#num list->num#num list`]
                  def4;
val witleft_def =
 Define
    `witleft (x:num, CONS h t) = (x, filter ($<= h) t)`;

val witright_def =
 Define
    `witright (x:num, CONS h t) = (h, filter ($> h) t)`;

val def6 = Q.INST [`left` |-> `witleft`] def5;
val def7 = Q.INST [`right` |-> `witright`] def6;
val def8 = REWRITE_RULE [WFTheory.WF_measure, GSYM cat_assoc] def7

val termination = 
 Q.prove
      `!x:num#num list.
            ~(pair_case (\x y. list_case T (\h t. F) y) x) 
               ==>
               measure (LENGTH o SND) (witleft x) x /\
               measure (LENGTH o SND) (witright x) x`
(Cases_on `x` THEN REWRITE_TAC [pairTheory.pair_case_def]
  THEN CONV_TAC (DEPTH_CONV Let_conv.GEN_BETA_CONV)
  THEN Cases_on `y` THENL
 [RW_TAC bool_ss [],
  REWRITE_TAC [listTheory.list_case_def] 
    THEN RW_TAC list_ss 
          [WFTheory.measure_def, relationTheory.inv_image_def,
           witleft_def,witright_def,combinTheory.o_DEF]
    THEN PROVE_TAC [DECIDE `x <= y ==> x < SUC y`, filter_LENGTH]]);

val def9 = MP def8 termination;

val Quick_def =
 Define
     `Quick l = SND(binRec witright witleft cat (\x.x)
                      (pair_case (\x y. list_case T (\h t. F) y)) (0,l))`;

g`(Quick [] = []) /\
  !h t. Quick (CONS h t) = 
          APPEND (Quick (filter ($<= h) t))
              (CONS h (Quick (filter ($> h) t)))`;

e (CONJ_TAC);
(*1*)
e (REWRITE_TAC [Quick_def]);
expandf (REWRITE_TAC [binRec_eqn]);
(*2*)
e (REWRITE_TAC [Quick_def]);
expandf (REWRITE_TAC [binRec_eqn]);



(*
val filter_def = 
 CONJUNCT1
  (Define 
      `(filter P [] r = r) /\
       (filter P (CONS h t) (Y,N) 
          = filter P t (P h => (CONS h Y, N) | (Y, CONS h N)))`);

val filter_LENGTH = 
 Q.prove
     `!P l l0 l1 m0 m1. 
         ((l0,l1) = filter P l (m0,m1)) 
            ==> (LENGTH l0 + LENGTH l1
                   =
                 LENGTH l + LENGTH m0 + LENGTH m1)`
(Induct_on `l` THEN RW_TAC list_ss [filter_def]
  THEN RES_TAC THEN RW_TAC list_ss []);

val filter_LENGTH1 = 
 Q.prove
     `!P l l0 l1.
        ((l0,l1) = filter P l ([],[])) 
            ==> LENGTH l0 <= LENGTH l /\ LENGTH l1 <= LENGTH l`
(RW_TAC bool_ss [] 
  THEN IMP_RES_THEN (MP_TAC o SYM) filter_LENGTH
  THEN RW_TAC list_ss []);

val qsort_def = 
 let val def0 = DISCH_ALL baRec_eqn
     val def1 = INST_TYPE [alpha |-> Type `:'a list`,
                           beta  |-> Type `:'a list`] def0
     val def2 = Q.INST [`atomic` |-> `list_case T (\h t. F)`] def1
     val def3 = Q.INST [`R` |-> `measure LENGTH`] def2
     val def4 = Q.INST [`join` |-> `\v l. list_case v (\h t. CONS h v) l`] def3
     val def5 = Q.INST [`dest` |-> 
                        `\l. list_case ARB 
                               (\h t. pair_case (\p1 p2. [p1; p2])
                                        (filter (Q h) t ([],[]))) l`] def4
     val def6 = Q.INST [`A:'a list -> 'a list` |-> `\x:'a list. x`] def5
     val def7 = BETA_RULE def6
     val def8 = REWRITE_RULE [WFTheory.WF_measure] def7

(* Bug: Define needs variables? 
val Quick_def = 
 Define
     `Quick Q = baRec
          (\l.
            list_case ARB
              (\h t. pair_case (\p1 p2. [p1; p2]) (filter (Q h) t ([],[])))
              l)
          (\x. x)
          (\v l. list_case v (\h t. CONS h v) l)
          (list_case T (\h t. F))`;

val def9 = PURE_REWRITE_RULE[GSYM Quick_def] def8;

val termination =
 Q.prove
   `!h y. 
      ~(list_case T (\h t. F) h) 
       ==>
        mem y
         (list_case ARB
           (\h t. pair_case (\p1 p2. [p1; p2]) (filter (Q h) t ([],[]))) h)
       ==>
         measure LENGTH y h`
(Cases_on `h` THENL
 [RW_TAC bool_ss [],
  REWRITE_TAC [listTheory.list_case_def] 
    THEN RW_TAC bool_ss [pairTheory.pair_case_def] THEN POP_ASSUM MP_TAC
    THEN CONV_TAC (DEPTH_CONV (Let_conv.GEN_BETA_CONV))
    THEN RW_TAC list_ss 
          [mem_def,WFTheory.measure_def, relationTheory.inv_image_def]
    THEN MATCH_MP_TAC (DECIDE `x <= y ==> x < SUC y`)
    THEN PROVE_TAC (filter_LENGTH1::pairTheory.pair_rws)]);

val pair_case_distrib = 
  Q.prove`!P f p. P (pair_case f p) = pair_case (\x y. P (f x y)) p`
 (Cases_on `p` THEN RW_TAC bool_ss []);

val trivlem = 
 Q.prove
   `!l p. APPEND (pair_case (\p1 p2. [p1; p2]) p) l 
            = 
          let (p1,p2) = p in CONS p1 (CONS p2 l)`
(Cases_on `p` THEN RW_TAC list_ss [pairTheory.pair_case_def]);

val def10 = MP def9 termination;
val def11 = Q.INST [`h` |-> `[]`] def10;
val def11a = REWRITE_RULE [listTheory.list_case_def] def11;
val def12 = Q.INST [`h` |-> `CONS h t`] (CONJUNCT2 def10);
val def12a = BETA_RULE (REWRITE_RULE [listTheory.list_case_def] def12);
val def12b = REWRITE_RULE [trivlem] def12a;
val def13 = LIST_CONJ (CONJUNCTS def11a @ [def12b]);

(* Question. Does this thing do quicksort? I bet not. *)

*)