\documentclass{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{theorem}
\usepackage[dvips]{graphicx}
\usepackage{comment}
\usepackage{color}
\usepackage{url}

\newcommand{\tsu}[1]{\textsf{\textup{#1}}}
\newcommand{\semb}[1]{\ensuremath{[\![#1]\!]}}
\newcommand{\rvset}{\ensuremath{V\!\!AR}}
\newcommand{\wff}{\ensuremath{w\!f\!\!f}}
\newcommand{\nnf}{\ensuremath{N\!N\!F\,}}
\newcommand{\ctl}{\textsf{CTL}\,}
\newcommand{\hc}{\textsc{holcheck\,}}
\newcommand{\hol}{\textsc{hol\,}}

% ---------------------------------------------------------------------
% Macros for little HOL sessions displayed in boxes.
%
% Usage: (1) \setcounter{sessioncount}{1} resets the session counter
%
%        (2) \begin{session}\begin{verbatim}
%             .
%              < lines from hol session >
%             .
%            \end{verbatim}\end{session}   
%
%            typesets the session in a numbered box.
% ---------------------------------------------------------------------

\newlength{\hsbw}
\setlength{\hsbw}{\textwidth}
\addtolength{\hsbw}{-\arrayrulewidth}
\addtolength{\hsbw}{-\tabcolsep}

\newcounter{sessioncount}
\setcounter{sessioncount}{1}

\newcommand\MLSpacing{13pt}
\newenvironment{session}{\begin{flushleft}
 \begin{tabular}{@{}|c@{}|@{}}\hline 
 \begin{minipage}[b]{\hsbw}
 \vspace*{-.5pt}
 \begin{flushright}
 \rule{0.01in}{.15in}\rule{0.3in}{0.01in}\hspace{-0.35in}
 \raisebox{0.04in}{\makebox[0.3in][c]{\footnotesize\sl \thesessioncount}}
 \end{flushright}
 \vspace*{-.45in}
 \begingroup\small\baselineskip\MLSpacing}{\endgroup\end{minipage}\\ \hline 
 \end{tabular}
 \end{flushleft}
 \stepcounter{sessioncount}}

\begin{document}
\title{\textsc{holcheck} Manual}
\author{Hasan Amjad}
\maketitle
\bibliographystyle{plain}

This manual is a currently just a primer on how to use the \hc model checker. It assumes the reader is familiar with model checking \cite{Clarke1999}, with \hol \cite{HOL}, and, ideally, with the \hol interface to BDDs \cite{Gordon2002}. In time, more material on the internal workings of \hc will be added

\section{Introduction}\label{sec:intro}

\hc is a BDD-based model checker embedded in the \hol theorem prover, interfaced to a high-performance BDD engine for efficiency. It currently has the following features:

\begin{itemize}
\item All steps of the algorithm are proved in \hol, with BDD operations considered atomic.
\item Results are returned as \hol theorems that seamlessly incorporate into \hol.
\item Model checking for the modal \(\mu\)-calculus and \ctl temporal logics is supported.
\item Counterexamples and witnesses are generated when appropriate.
\item A fully-automatic counterexample-guided abstraction refinement framework is included.  
\end{itemize}

The user inputs a model and a list of properties to be checked, and the model checker returns theorems, counterexamples and/or witnesses for each property with respect to the model. Models are formally treated as labelled transition system described by the quintuple \( (S, S_0, T, P, L) \) where 

\begin{itemize}
\item \( S \) is the set of states of the model. Each state is modelled as a tuple of state variables. Currently only boolean state variables are supported.
\item \( S_0\) is the set of initial states.
\item \( T \) is the set of actions or program letters, such that for each \( a \in T \), we have \( R_a \subseteq S \times S\). This says that the model has a transition labelled \( a \) from a state \( s \) to a state \( s' \) if and only if \( R_a(s,s') \). Next state variables are distinguished from current state variables by priming. 
\item \( P \) is the set of atomic propositions. Since only boolean state variables are currently supported, \( P \) is simply the set of state variables.
\item \( L:S\rightarrow 2^P \) labels each state with those propositions that are true in it.   
\end{itemize}

Currently the user is required to supply only \( S_0 \) and \( T \) as the remaining components can be calculated from these. Properties are input as \hol terms of type \(\mathtt{mu}\) or \(\mathtt{ctl}\), \hol datatypes for which have been defined. A property is satisfied by a model if the set of initial states of the model is a subset of the set of states satisfying the property. 

The next section describes the usage of \hc in more detail. As a running example we will take the children's game of tic-tac-toe or noughts-and-crosses, usually played on a 3-by-3 grid. For simplicity and to keep the formulas under consideration manageable, we consider the trivial 1-by-1 variant. Thus, the grid starts off empty, the player to go first makes a move and immediately wins, ending the game.

For this model, we need one state variable to track whose move it is, and we shall call this \(m\), which is true if the first player (call her A) is to move and false if the second player (call him B) is to move. We also need two state variables to keep track of the moves already played. The state variable \(u_{0,0}\) is true if A has claimed grid cell \((0,0)\) and false otherwise, and similarly the state variable \(v_{0,0}\) tracks B's moves. It is easy to see how this scheme can be generalised to arbitrary grids.

Thus the state is described by the tuple \( (m,u_{0,0},v_{0,0}) \). \(S_0\) is \( \{ (T,F,F) \} \) and \( T \) is 

\begin{eqnarray*}
 [&(&''{u_{0,0}}'',(\lnot u_{0,0} \land \lnot v_{0,0} \land m) \land \lnot((\lnot m \land u_{0,0}) \lor (m \land v_{0,0}))\\
       &&\land (u_{0,0}' \land \lnot m' \land (v_{0,0}' = v_{0,0}))),\\
     &(&''{v_{0,0}}'',(\lnot v_{0,0} \land \lnot u_{0,0} \land \lnot m) \land \lnot((\lnot m \land u_{0,0}) \lor (m \land v_{0,0}))\\
        &&\land (v_{0,0}' \land m' \land (u_{0,0}' = u_{0,0})))]
\end{eqnarray*}

This says for instance that the move \(''{u_{0,0}}''\) may be played if and only if the board is empty and it is A's turn AND the game is not already over AND in the next state A will have claimed \((0,0)\) and it will be B's turn, whose status will remained unchanged. And similarly for the move \(''{v_{0,0}}''\). 

Note that although there are eight possible states, only two (\((T,F,F)\) and \((F,T,F) \)) are actually reachable.

\section{Usage}

For our running example, we use the \texttt{ttt} example in \texttt{src/HolCheck/examples}. Build this example (and others) by typing \texttt{Holmake} in \texttt{src/HolCheck/examples}. Now start \hol from this directory (or use the -I command-line parameter).

The first step after loading \hol is to load \hc. \hol messages have been elided.

\begin{session}\begin{verbatim}
- app load ["holCheckLib","ttt"];
> val it = () : unit
\end{verbatim}\end{session}

The user interacts with \hc through a single ML function \texttt{holCheck}, found in the library \texttt{holCheckLib}. 

\begin{session}\begin{verbatim}
- holCheckLib.holCheck;
> val holCheck = fn : model -> model
\end{verbatim}\end{session}

The function takes a \hc model as an argument, and returns a model which is the same as the argument, but additionally contains the results of the model checking. We now describe how a \hc model is constructed.

\subsection{The Input Model}

A \hc model is a data structure that contains all the information required for model checking. We use the model construction function provided in the \texttt{ttt} example to create the model. 

\begin{session}\begin{verbatim}
- val ttt1 = ttt.makeTTT 1;
> val ttt1 = <model> : model
\end{verbatim}\end{session}
 
The numeric argument to \(\mathtt{ttt.makeTTT}\) gives the size of grid required.  Now we consider each component of the model \texttt{ttt1}, using the \texttt{holCheckLib.get\_*} family of functions. The corresponding \texttt{holCheckLib.set\_*} functions are sufficient to actually construct the model. See the source code of \texttt{mod8.sml} in the HolCheck examples directory for a simple example of how this is done.

\begin{session}\begin{verbatim}
- val S0 = holCheckLib.get_init ttt1;
> val S0 = ``~u0_0 /\ ~v0_0 /\ m`` : term
\end{verbatim}\end{session}

\(\mathtt{S0}\) is a term over the state variables of the model, such that only those assignments to the variables that satisfy the initial states of the model also satisfy \(\mathtt{S0}\). Thus \(\mathtt{S0}\) denotes the initial states. Note that since only boolean variables are supported, \(\mathtt{S0}\) must be a purely propositional term.

\begin{session}\begin{verbatim}
- val TS = holCheckLib.get_trans ttt1;
> val TS =
    [("u0_0",
      ``~u0_0 /\ ~v0_0 /\ m /\
        ~(~m /\ (u0_0 \/ u0_0 \/ u0_0 \/ u0_0) \/
          m /\ (v0_0 \/ v0_0 \/ v0_0 \/ v0_0)) /\ u0_0' /\ ~m' /\
        (v0_0' = v0_0)``),
     ("v0_0",
      ``~v0_0 /\ ~u0_0 /\ ~m /\
        ~(~m /\ (u0_0 \/ u0_0 \/ u0_0 \/ u0_0) \/
          m /\ (v0_0 \/ v0_0 \/ v0_0 \/ v0_0)) /\ v0_0' /\ m' /\
        (u0_0' = u0_0)``)] : (string * term) list
\end{verbatim}\end{session}

\(\mathtt{TS}\) is a list of pairs of the form \( (a,R_a)\), where the string \(a\) is an action name (or transition label) and the \hol term \(R_a\) is a relation over current and next states such that the model has a transition labelled \(a\) from a state \( s \) to a state \(s'\) if and only if the corresponding valuations of current and next state variables satisfy \( R_a \). 

Thus \(\mathtt{S0}\) and \(\mathtt{TS}\) are just \hol equivalents of \(S_0\) and \(T\) as described in section \ref{sec:intro}. \( \mathtt{TS} \) is named as such to avoid clashing with the global \hol term constant \( \mathtt{T} \). The redundancy in \(\mathtt{TS}\) is an artifact of how  \(\mathtt{ttt.makeTTT}\) generates the grid.

\begin{session}\begin{verbatim}
- val ric = holCheckLib.get_ric ttt1;
> val ric = false : bool
\end{verbatim}\end{session}

\(\mathtt{ric}\) is a boolean which is true if the transition system described by \(\mathtt{TS}\) is synchronous, and false otherwise. In a synchronous transition system, all actions much occur simultaneously. Otherwise \(\mathtt{TS}\) is asynchronous i.e. the actions are interleaved. In the case of our example for instance, \( \mathtt{TS} \) should be asynchronous since the players do not move together but interleave moves. The definition of \( \mathtt{TS} \) ensures that they do not play out of turn, or make illegal moves. 

\begin{session}\begin{verbatim}
- val nm = holCheckLib.get_name ttt1;
> val nm = SOME "ttt" : string option
\end{verbatim}\end{session}

\(\mathtt{nm}\) is an optional argument when constructing the model (hence it is stored internally as an option type). It is a string that names the formal model that is generated internally by \hc. Since the resulting theorems are stated in terms of this model, it is useful to have an abbreviation for the term representing the model to keep the theorem statement readable. \hc has a default name for models, but if the user expects to be using more than one model in the same session, then setting a name is required to avoid name clashes.

\begin{session}\begin{verbatim}
- val vord = holCheckLib.get_vord ttt1;
> val vord = SOME ["m", "m'", "u0_0", "u0_0'", "v0_0", "v0_0'"] : 
  string list option
\end{verbatim}\end{session}

\(\mathtt{vord}\) is an optional argument to the model. It is a list of current- and next-state variables names, given as strings without any type information. \(\mathtt{vord}\) is used to manually supply a variable ordering to the BDD engine. \hc has a default ordering heuristic but it is rather primitive at present (it just interleaves current- and next-state variables).

\begin{session}\begin{verbatim}
- val st =  holCheckLib.get_state ttt1;
> val st = SOME``(m,u0_0,v0_0)`` : term option
\end{verbatim}\end{session}

\(\mathtt{st}\) is an optional argument. It is a \hol tuple that explicitly describes the order in which state variables appear in the state tuple. \hc can automatically calculate the state from \(\mathtt{S0}\) and \(\mathtt{TS}\), but in some cases the user may wish to use the resulting theorems in other work where the state tuple has already been defined in a certain manner. \(\mathtt{st}\) is used in such cases. Note we do not use the identifier \texttt{state} as this already exists in the default HOL interactive session namespace.

At present the user must take care that \(\mathtt{vord}\) and \(\mathtt{st}\) are consistent with the rest of the arguments e.g. there are no missing variables. 

\texttt{holCheckLib.get\_props} returns the properties to be model checked. This is simply a list of \ctl or \(\mu\)-calculus formulas (they can be in the same list because both have ML type \(\mathtt{term}\)). Since the formulas contain atomic propositions, which are modelled as functions on the state, the user inputting the formulas needs to know what the state is going to be. \hc provides a function \(\mathtt{mk\_state}\) for this purpose.

\begin{session}
\begin{verbatim} 
- holCheckLib.mk_state;
> val it = fn : term -> (string * term) list -> term
- holCheckLib.mk_state S0 TS;
> val it = ``(m,u0_0,v0_0)`` : term
\end{verbatim}
\end{session}

Thus even though the state is an optional argument when constructing the model, in practice we nearly always use \texttt{mk\_state} and then \texttt{set\_state} to set it. 

\(\mathtt{ttt1}\) contains five \ctl properties. We consider these in turn.

\begin{session}
\begin{verbatim} 
- List.nth(holCheckLib.get_props ttt1,0);
> val it =
    ("isInit",
     ``~C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) /\
       ~C_BOOL (B_PROP (\(m,u0_0,v0_0). v0_0)) /\
       C_BOOL (B_PROP (\(m,u0_0,v0_0). m))``) : string * term
\end{verbatim}
\end{session}

Th first property describes the initial state of the system. Note how atomic propositions are formally modelled as boolean functions on the state. As noted earlier, all atomic propositions are currently just boolean variables.

\begin{session}
\begin{verbatim} 
- List.nth(holCheckLib.get_props ttt1,1);
> val it =
    ("A_win",
     ``~C_BOOL (B_PROP (\(m,u0_0,v0_0). m)) /\
       (C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) \/
        C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) \/
        C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) \/
        C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)))``) : string * term
\end{verbatim}
\end{session}

This property describes a winning position for A. As with \(\mathtt{TS}\) there is some redundancy here. We shall edit this redundancy form the next property to save space.

\begin{session} 
\begin{verbatim} 
- List.nth(holCheckLib.get_props ttt1,2);
> val it =
    ("B_win",
     ``C_BOOL (B_PROP (\(m,u0_0,v0_0). m)) /\
       C_BOOL (B_PROP (\(m,u0_0,v0_0). v0_0)``) : string * term
\end{verbatim}
\end{session}

This property similarly describes a winning position for B.

\begin{session}\begin{verbatim} 
- List.nth(holCheckLib.get_props ttt1,3);
> val it =
    ("A_canwin",
     ``C_EG
         (~C_BOOL (B_PROP (\(m,u0_0,v0_0). m)) /\
          (C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) \/
           C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) \/
           C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) \/
           C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0))) \/
          C_BOOL (B_PROP (\(m,u0_0,v0_0). m)) /\
          C_EF
            (~C_BOOL (B_PROP (\(m,u0_0,v0_0). m)) /\
             (C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) \/
              C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) \/
              C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) \/
              C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)))) \/
          ~C_BOOL (B_PROP (\(m,u0_0,v0_0). m)) /\
          C_AF
            (~C_BOOL (B_PROP (\(m,u0_0,v0_0). m)) /\
             (C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) \/
              C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) \/
              C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) \/
              C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)))))``) : 
  string * term
\end{verbatim}\end{session}

This property says that A has a winning strategy from the current state. Since we define success if the set of states satisfying the property contains the set of initial states, this suffices to check that A has a winning strategy. Cleaned up, this is the \ctl property \[ \mathbf{EG} (\textup{(A wins)} \lor (\textup{A to move} \land \mathbf{EF} (\textup{A wins})) \lor (\textup{B to move} \land \mathbf{AF} (\textup{A wins})))\] Intuitively, the property says that there exists a path from the current state such that at each step on that path either A has won the game, or it is A's turn and there exists at least one path in which A eventually wins the game, or it is not A's turn and on all paths A eventually wins the game. 

The last property similarly says the B has a winning strategy. 

\subsection{The Output Model}

The model returned by \(\mathtt{ttt.makeTTT}\) can be supplied as the first argument to \(\mathtt{holCheck}\).

\begin{session}\begin{verbatim} 
- val ttt2 = holCheckLib.holCheck ttt1;
> val ttt2 = <model> : model
\end{verbatim}\end{session}
 
\(\mathtt{holCheck}\) returns another model. This model is exactly the same as \texttt{ttt1}, except that it now contains the results of the model checking. These are recovered via \texttt{holCheckLib.get\_results}, and return a list in which the n\({}^{th}\) element gives the results of model checking the n\({}^{th}\) property in the list returned by \texttt{holCheckLib.get\_props}. \texttt{holCheckLib.get\_results} returns an option type, since no results are known before model checking takes place.

Each element is a triple of the form \( (term\_bdd,thm,trace) \). These are the BDD semantics of the property, a theorem certifying the property holds (if it does) and a counterexample or witness trace, if one could be recovered. 

We consider each result in turn.

\begin{session}\begin{verbatim} 
- List.nth(valOf (holCheckLib.get_results ttt2),0);
> val it =
    (<term_bdd>,
     SOME [.................]
         |- CTL_MODEL_SAT ctlKS_ttt
              (~C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) /\
               ~C_BOOL (B_PROP (\(m,u0_0,v0_0). v0_0)) /\
               C_BOOL (B_PROP (\(m,u0_0,v0_0). m))), NONE) :
  term_bdd * thm option * term list option
\end{verbatim}\end{session}

This is the result corresponding to the first property (which described the set of initial states).  The first component is the \(textup{term\_bdd}\) that corresponds to the set of states of the model satsified by this property. As expected, the set of initial states is contained in the set of initial states and thus the second component is a success theorem attesting to this. The predicate \( \mathtt{CTL\_MODEL\_SAT} \) says that the property holds in the model \( \mathtt{ctlKS\_ttt}\) (this stands for ``CTL Kripke structure'' augmented by the name that was supplied for this model). If the property had not held, the theorem derivation would have failed and the component would have been \( \mathtt{NONE}\). The third component is used to return the counterexample or witness associated with the property. Since we succeeded there is no counterexample, and witnesses are only returned for properties talking about paths, so this component is \( \mathtt{NONE}\). Note that the theorem has some assumptions associated with it. We shall return to these later. 

\begin{session}\begin{verbatim}
- List.nth(valOf (holCheckLib.get_results ttt2),1); 
> val it = (<term_bdd>, NONE, SOME []) :
  term_bdd * thm option * term list option
\end{verbatim}\end{session}

The second result corresponds to a win position for A. Since the initial state is not a win position for A, there is no success theorem and as before counterexamples are only provided for properties talking about paths. The third result is exacly the same, since the initial state is not a win position for B either.
 
\begin{session}\begin{verbatim}
- List.nth(valOf (holCheckLib.get_results ttt2),3); 
> val it =
    (<term_bdd>,
     SOME [....................................]
         |- CTL_MODEL_SAT ctlKS_ttt
              (C_EG
                 (~C_BOOL (B_PROP (\(m,u0_0,v0_0). m)) /\
                  (C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) \/
                   C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) \/
                   C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) \/
                   C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0))) \/
                  C_BOOL (B_PROP (\(m,u0_0,v0_0). m)) /\
                  C_EF
                    (~C_BOOL (B_PROP (\(m,u0_0,v0_0). m)) /\
                     (C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) \/
                      C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) \/
                      C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) \/
                      C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)))) \/
                  ~C_BOOL (B_PROP (\(m,u0_0,v0_0). m)) /\
                  C_AF
                    (~C_BOOL (B_PROP (\(m,u0_0,v0_0). m)) /\
                     (C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) \/
                      C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) \/
                      C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) \/
                      C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)))))),
     SOME [``(F,T,F)``]) : term_bdd * thm option * term list option
\end{verbatim}\end{session}

This result corresponds to the fourth property, that stated that A has a winning strategy. This is true, and we get the success theorem, as well as a witness, which shows that the state \((F,T,F)\) following from the initial state is a win for A. 

The last result is the same as the second and third, since B does not have a winning strategy, and counterexamples cannot be calculated for properties that assert the existence of specific paths (since the ``counterexample'' would effectively be the entire set of reachable states).

Finally, note that both success theorems have some assumptions to them. If the term\_bdd's were checked, they would also have the corresponding assumptions. This is because \hc uses postponed proof verification to speed up the model checking work-flow (i.e. no time is wasted proving intermediate lemmas for properties that fail eventually). Any success theorems and term\_bdd's thus end up with several undischarged assumptions. The idea is that the time-consuming proof verification can be postponed to a later time, when the user is otherwise occupied (e.g. asleep).

The assumptions are discharged as follows (HOL chatting messages have been elided).

\begin{session}\begin{verbatim}
- val ttt3 = holCheckLib.prove_model ttt2;
> val ttt3 = <model> : model
\end{verbatim}\end{session}

This returns a model that is exactly the same as \texttt{ttt2}, except that any assumptions introduced due to the postponed proof have been discharged. We can confirm this by looking at the first property again. 

\begin{session}\begin{verbatim}
- List.nth(valOf (holCheckLib.get_results ttt3),0);
> val it =
    (<term_bdd>,
     SOME|- CTL_MODEL_SAT ctlKS_ttt
              (~C_BOOL (B_PROP (\(m,u0_0,v0_0). u0_0)) /\
               ~C_BOOL (B_PROP (\(m,u0_0,v0_0). v0_0)) /\
               C_BOOL (B_PROP (\(m,u0_0,v0_0). m))), NONE) :
  term_bdd * thm option * term list option
\end{verbatim}\end{session}

This completes one cycle of the \hc work-flow (though typically calls to \texttt{prove\_model} are saved for the end of the checking, since  \texttt{prove\_model} just verifies the results fully-expansively; it cannot invalidate them unless there is a bug in \hc).

At this point the user would fix either \(S0\) or \(TS\) or the properties, and start over, until all expected properties are verified.
\bibliography{ha}
\end{document}