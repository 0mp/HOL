signature Pretype =
sig
  type prerank = Prerank.prerank
  type prekind = Prekind.prekind
  type uvarkind = Prekind.uvarkind
  type rank = Kind.rank
  type kind = Kind.kind
  type hol_type = Type.hol_type
  type pretyvar = string * prekind
  type tyvar = Type.tyvar
  type term = Term.term

 datatype pretype0
    = Vartype of pretyvar
    | Contype of {Thy : string, Tyop : string, Kind : prekind}
    | TyApp  of pretype * pretype
    | TyUniv of pretype * pretype
    | TyExis of pretype * pretype
    | TyAbst of pretype * pretype
    | TyKindConstr of {Ty : pretype, Kind : prekind}
    | TyRankConstr of {Ty : pretype, Rank : prerank}
    | UVar of uvartype ref
 and uvartype
    = SOMEU of pretype
    | NONEU of prekind
 and pretype = PT of pretype0 locn.located

val tylocn : pretype -> locn.locn

val eq : pretype -> pretype -> bool

val --> : pretype * pretype -> pretype
val dom_rng : pretype -> pretype * pretype
val is_fun_type : pretype -> bool
val dest_con_type : pretype -> {Tyop : string, Thy : string, Kind : prekind}
val dest_var_type : pretype -> pretyvar
val is_var_type : pretype -> bool
val is_uvar_type : pretype -> bool
val has_var_type : pretype -> bool
val mk_var_type : string * prekind -> pretype
val the_var_type : pretype -> pretype
val mk_app_type : pretype * pretype -> pretype
val list_mk_app_type : pretype * pretype list -> pretype
val dest_app_type : pretype -> pretype * pretype
val strip_app_type : pretype -> pretype * pretype list
val mk_univ_type : pretype * pretype -> pretype
val dest_univ_type : pretype -> pretype * pretype
val strip_univ_type : pretype -> pretype list * pretype
val is_univ_type : pretype -> bool
val is_not_univ_type : pretype -> bool
val with_homs_is_not_univ_type : pretype -> bool
val mk_exist_type : pretype * pretype -> pretype
val dest_exist_type : pretype -> pretype * pretype
val strip_exist_type : pretype -> pretype list * pretype
val is_exist_type : pretype -> bool
val mk_abs_type : pretype * pretype -> pretype
val list_mk_abs_type : pretype list * pretype -> pretype
val dest_abs_type : pretype -> pretype * pretype

val beta_conv_ty : pretype -> pretype
val eta_conv_ty  : pretype -> pretype
val deep_beta_ty : pretype -> pretype
val deep_eta_ty  : pretype -> pretype
val deep_beta_eta_ty : pretype -> pretype
val do_beta_conv_types : unit -> bool
val is_universal : pretype -> bool

val pkind_of : pretype -> prekind
val prank_of_type : pretype -> prerank
val is_atom  : pretype -> bool

val type_vars  : pretype -> pretype list
val type_varsl : pretype list -> pretype list
val variant_type : pretype list -> pretype -> pretype

val kindvars : pretype -> string list
val tyvars : pretype -> string list
val new_uvar : prekind -> pretype
val all_new_uvar : unit -> pretype
val uvars_of : pretype -> uvartype ref list
val ref_occurs_in : uvartype ref * pretype -> bool
val ref_equiv : uvartype ref * pretype -> bool
val has_free_uvar : pretype -> bool
val has_unbound_uvar : pretype -> bool
val mk_fun_ty : pretype * pretype -> pretype


(*val prekind_rank_compare : (prekind * prerank) * (prekind * prerank) -> order*)
val pretyvar_compare : pretyvar * pretyvar -> order


(* higher order matchings are generated by gen_unify and stored in a
   global variables, "homs", which is accessed through these functions: *)

type homatch = bool (*lep*) * int (*n*)
                   * pretyvar list * pretyvar list * pretype * pretype
                   * (string * (exn -> unit))
val begin_homs : unit -> unit
val add_hom    : bool (*lep*) * int (*n*)
                   * pretyvar list * pretyvar list * pretype * pretype -> unit
val get_homs   : unit -> homatch list
val reset_homs : unit -> homatch list
val end_homs   : unit -> homatch list

val set_error_report : string * (exn -> unit) -> unit
val get_error_report : unit -> string * (exn -> unit)

(* first argument is a function which performs a binding between a
   pretype reference and another pretype, updating some sort of environment
   (the 'a), returning the new alpha and a unit option, SOME () for a
   success, and a NONE, if not.

   To further complicate things, the bind argument also gets a copy of
   gen_unify to call, if it should choose.
*)
val gen_unify :
  (int -> prekind -> prekind -> ('a -> 'a * unit option)) ->  (* kind_unify    *)
  (int -> prekind -> prekind -> ('a -> 'a * unit option)) ->  (* kind_unify_le *)
  (int -> prekind -> prekind -> ('a -> 'a * unit option)) ->  (* conty_kind_unify *)
  (int -> prerank -> prerank -> ('a -> 'a * unit option)) ->  (* rank_unify    *)
  (int ->
   (pretyvar list -> pretyvar list -> pretype -> pretype -> ('a -> 'a * unit option)) ->
   pretyvar list -> pretyvar list ->
   uvartype ref -> pretype -> ('a -> 'a * unit option)) ->    (* bind          *)
  string ->                                                   (* cmp           *)
  ('a -> pretype -> pretype list) ->                          (* tyvars        *)
  int ->                                                      (* n             *)
  pretyvar list -> pretyvar list ->                           (* c1, c2        *)
  pretype -> pretype -> ('a -> 'a * unit option)              (* ty1, ty2      *)

val ho_match :
  (int -> pretyvar list -> pretyvar list -> pretype -> pretype -> ('a -> 'a * unit option)) ->
  (int -> pretyvar list -> pretyvar list -> pretype -> pretype -> ('a -> 'a * unit option)) ->
  homatch list ->
  ('a -> 'a * unit option)

val unify : pretype -> pretype -> unit
val unify_le : pretype -> pretype -> unit
val ho_unify : pretype -> pretype -> unit
val ho_unify_le : pretype -> pretype -> unit
val can_unify : pretype -> pretype -> bool
val can_unify_le : pretype -> pretype -> bool
val resolve_ho_matches : unit -> unit

val safe_unify :
  pretype -> pretype ->
  (  ((order * prerank) option ref * (order * prerank)) list
   * (uvarkind ref * uvarkind) list
   * (uvartype ref * uvartype) list ->
   (  ((order * prerank) option ref * (order * prerank)) list
    * (uvarkind ref * uvarkind) list
    * (uvartype ref * uvartype) list)
   * unit option)
val safe_unify_le :
  pretype -> pretype ->
  (  ((order * prerank) option ref * (order * prerank)) list
   * (uvarkind ref * uvarkind) list
   * (uvartype ref * uvartype) list ->
   (  ((order * prerank) option ref * (order * prerank)) list
    * (uvarkind ref * uvarkind) list
    * (uvartype ref * uvartype) list)
   * unit option)

val ho_safe_unify :
  pretype -> pretype ->
  (  ((order * prerank) option ref * (order * prerank)) list
   * (uvarkind ref * uvarkind) list
   * (uvartype ref * uvartype) list ->
   (  ((order * prerank) option ref * (order * prerank)) list
    * (uvarkind ref * uvarkind) list
    * (uvartype ref * uvartype) list)
   * unit option)
val ho_safe_unify_le :
  pretype -> pretype ->
  (  ((order * prerank) option ref * (order * prerank)) list
   * (uvarkind ref * uvarkind) list
   * (uvartype ref * uvartype) list ->
   (  ((order * prerank) option ref * (order * prerank)) list
    * (uvarkind ref * uvarkind) list
    * (uvartype ref * uvartype) list)
   * unit option)

val type_subst  : {redex : pretype, residue : pretype} list -> pretype -> pretype
val distinguish_btyvars : pretype list -> pretype -> pretype

val rename_typevars : string list -> string list -> pretype -> pretype
val rename_tv : string list -> string list -> pretype ->
           (prerank list * (string * prekind) list * (string * pretype) list) ->
           (prerank list * (string * prekind) list * (string * pretype) list) * pretype option
val reconcile_univ_types : pretype -> pretype -> pretype
val fromType : hol_type -> pretype
val remove_made_links : pretype -> pretype
val replace_null_links : pretype -> string list * string list
                                -> (string list * string list) * unit option
val clean : pretype -> hol_type
val toType : pretype -> hol_type
val chase : pretype -> pretype

val pp_pretype : PP.ppstream -> pretype -> unit
val pretype_to_string : pretype -> string
val print_pretype : pretype -> unit
val pp_pretypes : ppstream -> pretype list -> unit
val pretypes_to_string : pretype list -> string
val print_pretypes : pretype list -> unit

val checkkind :
      ((hol_type -> string) * (kind -> string)) option
        -> pretype -> unit
val kindcheck :
      ((hol_type -> string) * (kind -> string)) option
        -> pretype -> hol_type

datatype kcheck_error =
         TyAppFail of hol_type * hol_type
       | TyUnivFail of hol_type
       | TyExisFail of hol_type
       | TyKindConstrFail of hol_type * kind
       | TyRankConstrFail of hol_type * rank
       | TyRankLEConstrFail of hol_type * rank

val last_kcerror : (kcheck_error * locn.locn) option ref

val termantiq_constructors : (pretype,Term.term) parse_type.tyconstructors
val typantiq_constructors : (pretype,Type.hol_type) parse_type.tyconstructors

end

(*
   [chase pty]  If pty is of the form (dom --> rng), once all necessary
   uvar references have been followed, returns rng.

   [rename_typvars avds pty]  Avoiding type variables with names from avds,
   renames Vartypes into uvar references.

   [has_unbound_uvar pty] Returns true if pty includes (after chasing bound
   uvars), any unbound uvars.

   [mk_fun_ty (dom,rng)] Makes the pretype corresponding to the function space
   from dom to rng.
*)
