\chapter{The $n$-bit word Library}

\newcommand\ptt{\tt}

This document describes the facilities provided by the \ml{n-bit} word library and
explains its logical basis.
The library provides support for reasoning about natural numbers as finite length bit strings.  An executable \ml{mkword.exe} makes $n$-bit number theories available within \HOL; for example, \ml{mkword.exe 16} introduces the type \ml{word16}.
Such types are prevalent in computer architectures where, for example, one might find: bytes/octets (\ml{word8}), half-words (\ml{word16}), words (\ml{word32}) and long-words (\ml{word64}).

There is another theory of words in \HOL\ --  Wai Wong's word theory is more generic -- it supports words with differing number bases and word lengths~\cite{wong}.
The underlying data type for that theory is the list -- the theory was developed with Paul Curzon's \ml{rich\_list} theory.
However, \HOL's type system does not directly support predicate sub-types and so, when using Wong's theory, word lengths must be explicitly declared with the insertion of predicates.

Here $n$-bit words are represented as equivalence classes of natural numbers \ie{} as sets of numbers that are equivalent modulo $2^n$.
This has been implemented in \HOL\ via an \ML\ functor.  The original implementation made use of John Harrison's equivalence type package, but this has been superseded by Peter Homeier's quotient theory.
Each word theory instance is for a \emph{fixed} word size -- this works well provided that only a small selection of word sizes are required.
Word operations and theorems are lifted from the representing type \ie{} from natural number operations.
Consequently, the word operations are naturally and concisely defined.
Natural number theorems and reductions are used in proving word theorems and for ground-term (variable free) evaluation.

\section{Bits} \label{bits}

The \ml{bits} theory introduces some operations, over the natural numbers, that are useful in defining $n$-bit word operations.  (No new data types are provided by this theory.)
The main functions are: \ml{BITS}, \ml{SLICE}, \ml{BIT} and \ml{BITWISE}.  These are defined using operations from the theory \ml{arithmetic}; in particular, \ml{DIV}, \ml{MOD} and \ml{EXP}.
The predicate \ml{BIT n b} is true if, and only if, the bit $n$ of number $b$ has value one.
The other operations are illustrated in Figures~\ref{bits-slice} and~\ref{bitwise}.
\index{BITS@{\tt BITS}}%
\index{SLICE@{\tt SLICE}}%
\index{BIT@{\tt BIT}}%
\index{BITWISE@{\tt BITWISE}}%

\begin{figure}
\begin{center}
\input{figs/bits.tex} \\[3mm]
(a) \ml{BITS h l b}. \\[6mm]
\input{figs/slice.tex} \\[3mm]
(b) \ml{SLICE h l b}.
\end{center}
\caption{Bit field functions.\label{bits-slice}}
\end{figure}

\begin{figure}
\begin{center}
\input{figs/bitw.tex}
\end{center}
\caption{\ml{BITWISE l f a b}. Here $x\diamond y = (f(x)(y) \Rightarrow 1 \mid 0)$.\label{bitwise}}
\end{figure}

The \ml{numeral\_bits} theory provides a group of theorems which allow the \ml{bits} theory functions to be evaluated more efficiently.
This is done by working with \HOL's internal representation of numerals \ie{} in terms of \ml{ZERO}, \ml{BIT1} and \ml{BIT2}.

Some of the most significant (useful) theorems in \ml{bits} theory are presented below:
\begin{eqnarray*}
\mathtt{SLICE\_THM} & \vdash & \forall n\,h\,l.\ \;\slice\ h\ l\ n = (\bits\ h\ l\ n) * 2^l \\[4pt]
\mathtt{BITS\_COMP\_THM2} & \vdash & \forall h_1\,l_1\,h_2\,l_2\,n.\\*
&& \ \bits\ h_2\ l_2\ (\bits\ h_1\ l_1\ n) = \bits\ (\minn\ h_1\ (h_2 + l_1))\ (l_2 + l_1)\ n \\[4pt]
\mathtt{SLICE\_COMP\_THM} & \vdash &
   \forall h\,m\,l\,n.\ \;\suc(m) \leq h \mbox{ and } l \leq m \Rightarrow \\*
&& \quad (\slice\ h\ (\suc\ m)\ n + \slice\ m\ l\ n = \slice\ h\ l\ n) \\[4pt]
\mathtt{SLICE\_COMP\_THM2} & \vdash &
   \forall h_2\,l_2\,h_1\,l_1\,n.\ \; h_2 \leq h_1 \mbox{ and } l_1 \leq l_2 \Rightarrow \\*
&& \quad (\slice\ h_2\ l_2\ (\slice\ h_1\ l_1\ n) = \slice\ h_2\ l_2\ n) \\[4pt]
\mathtt{BITWISE\_THM} & \vdash &
   \forall x\,n\,f\,a\,b.\ \;
        x < n \Rightarrow \\*
&& \quad (\bit\ x\ (\bitwise\ n\ f\ a\ b) = f\ (\bit\ x\ a)\ (\bit\ x\ b))
\end{eqnarray*}

\noindent The theorem \ml{SLICE\_THM} shows that \ml{SLICE} is a shifted version of \ml{BITS}.  The theorems \ml{BITS\_COMP\_THM2} and \ml{SLICE\_COMP\_THM2} are used in simplifying repeated applications of \ml{BITS} and \ml{SLICE}.  The theorem \ml{SLICE\_COMP\_THM} shows that adjoining slices of the same number can be combined into a single slice.  Finally, theorem \ml{BITWISE\_THM} shows that every bit in the result of a \ml{BITWISE} operations is the expected single-bit function of the corresponding bits in the arguments.

\section{Words}

This section describes the $n$-bit word theory.  Section~\ref{mkword} shows how to build a word theory for a given word length.  The construction of the word type is described in Section~\ref{type}.  Word constants and operations are discussed in Section~\ref{ops} -- this includes: maps to/from the natural numbers; bit field, arithmetic and Boolean operations; as well as orderings and shifts.
Ground term evaluation and pretty printing are discussed in Section~\ref{eval}, and finally Section~\ref{multiple} shows how to work with multiple word sizes.

\subsection{Generating a Word Theory} \label{mkword}

The executable \ml{mkword.exe} constructs a word theory for a given word length.\footnote{The executable can be found in HOL's \ml{bin} directory.  The word length must be non-zero.}  This command creates files \ml{word<n>Theory.sml} and \ml{word<n>Lib.sml} in the working directory and these sources are then compiled. When the \ml{-sys} option is selected the object files are copied to the \ml{SIGOBJ} directory.\footnote{
However, there will not be an on-line help entry for the new theory.}
The word theory does not have a script file and so \ml{Holmake} does not automatically update these theories \eg{} when \HOL\ is re-built.  The easiest way to manage this is to use a \ml{Holmakefile} that includes the necessary calls to \ml{mkword.exe}, as in \ml{help/Holmakefile.example-32}.

\subsection{The Word Type} \label{type}

The word type is declared in \HOL\ using the function \ml{define\_equivalence\_type}, which is in the library \ml{quotient}.  The following equivalence relation is used to construct the word type:
\[ a \equiv b = (a \bmod 2^\ell = b \bmod 2^\ell) \]
where $\ell$ is the word length.
One can observe that this relation is reflexive, symmetric and transitive.
The \emph{representing type}~\cite{gordon-melham-hol} for words is $\mathtt{num}\rightarrow\mathtt{bool}$ \ie{} words are represented by the $2^\ell$ unique predicates ${\equiv_a}$ where ${\equiv_a}(b) = (a \equiv b)$.  That is, one can consider the predicate ${\equiv_i}$ to be representing the $\ell-bit$ word with value $i \bmod 2^\ell$.  Observe that for all $j$ and $i < 2^\ell$: ${\equiv_{j\cdot 2^\ell + i}} = {\equiv_i}$.

\subsection{Constants and Operations} \label{ops}

The \HOL\ constant \ml{WL} is equal to the word length $\ell$ and \ml{HB} is the highest bit position, that is, $\ell - 1$.

\subsubsection{Mapping To and From the Natural Numbers}

The function \ml{w2n} maps a word to a natural number; when given a word represented by the predicate ${\equiv_i}$ the value returned is $i \bmod 2^\ell$ -- this is the \emph{standard class representative} for the equivalence class.  The function \ml{n2w} maps a natural numbers to a word: for number $i$ the returned word has representative ${\equiv_i}$.

The map \ml{n2w} is the primary means of constructing new words and word operations are evaluated via natural number reductions; see Section~\ref{eval}.

\subsubsection{Bits and Slices}

The map \ml{w2n} is used to define the functions: \ml{WORD\_BITS}, \ml{WORD\_BIT} and \ml{WORD\_SLICE}.
The word is mapped to a natural number before applying the corresponding function from Section~\ref{bits}.
The predicates \ml{LSB} and \ml{MSB} specialise \ml{WORD\_BIT} to bit positions zero and $\ell - 1$ respectively.

\subsubsection{Arithmetic and Orderings}

Addition, negation (two's complement), subtraction and multiplication are all provided.  The two's complement maps ${\equiv_i}$ to ${\equiv_{2^\ell - (i \bmod 2^\ell)}}$ and subtraction is the addition of the two's complement.

Eight orderings are provided: these are signed and unsigned versions of $<$, $\leq$, $>$ and $\geq$.  The unsigned versions are suffixed by a full-stop; for example, \ml{<.} is unsigned less than.  The signed versions are for the two's complement representation \ie{} where bit $\ell - 1$ is taken to have value $-2^\ell$.  (At present, maps to and from the integers have not been provided.)  The orderings are defined using the function \ml{CMP\_NZCV} -- this subtracts one word from another and returns the negative, zero, carry and overflow flag values.  For example, \ml{a <.\ b} is true when the carry flag for \ml{a - b} is false.  A group of theorems are provided to connect these orderings with their natural number counterparts; for example, \ml{LO\_EVAL} (see Section~\ref{eval}).

\subsubsection{Shifts}

Six types of shifting are supported: logical shift left (which is synonymous with arithmetic shift left), rotate left and four types of shift right.
Shifting left $i$ places is defined to be multiplication by the word with value $2^i$.
Rotating left $i$ places is achieved by rotating right $\ell - i$ places.
Figure~\ref{right-one} shows the natural number (one place) shift operations for the four shift rights: these are lifted to words, giving the operations \ml{word\_ror1}, \ml{word\_lsr1}, \ml{word\_asr1} and \ml{RRX}.
The first three operations can be iterated and this gives the operations: rotate right (\ml{\#>>}), logical shift right (\ml{>>>}) and arithmetic shift right (\ml{>>}).  The theorems \ml{ROR\_THM}, \ml{LSR\_THM} and \ml{ASR\_THM} provide a more helpful semantics for these operations; they are especially useful for ground-term evaluation, see Section~\ref{eval}.

\begin{figure}
\begin{center}
\setlength{\entrysize}{7.5mm}
\input{figs/ror.tex} \\[3mm]
(a) Rotate right (\ml{ROR\_ONE}). \\[6mm]
\input{figs/lsr.tex} \\[3mm]
(b) Logical shift right (\ml{LSR\_ONE}). \\[6mm]
\input{figs/asr.tex} \\[3mm]
(c) Arithmetic shift right (\ml{ASR\_ONE}). \\[6mm]
\input{figs/rrx.tex} \\[3mm]
(d) Rotate right with extend (\ml{RRXn c}).
\end{center}
\caption{One place shift right operations.\label{right-one}}
\end{figure}

\subsubsection{Boolean Operations}

The one's complement (bitwise bit inversion) is given by the function \ml{NOT} and this maps ${\equiv_i}$ to ${\equiv_{2^\ell -1 - (i \bmod 2^\ell)}}$.  Bitwise conjunction (\ml{\&}), disjunction (\ml{|}) and exclusive-or (\ml{\#}) are also defined.  These operations are lifted versions of the function \ml{BITWISE}, specialised to the word length $\ell$ and with the appropriate Boolean operation.

\subsubsection{Word Constants}

The following table shows the values for some pre-defined word constants:
\begin{center}
\small
\begin{tabular}{cc}
Constant & Numeric Value \\
\noalign{\smallskip}
\hline
\noalign{\smallskip}
\ml{word\_{}0} & $0$ \\
\ml{word\_{}1} & $1$ \\
\ml{word\_T} & $2^\ell - 1$ \\
\ml{word\_L} & $2^{\ell - 1}$ \\
\ml{word\_H} & $2^{\ell - 1} - 1$
\end{tabular}
\end{center}
The constant \ml{word\_T} represents `true' for the Boolean operations -- every bit it set high.  Likewise, \ml{word\_{}0} represents the number zero and also `false'.  In the two's complement system \ml{word\_L} is the most negative value and \ml{word\_H} is the most positive value.  This is captured the theorems \ml{WORD\_L\_LESS\_EQ} and \ml{WORD\_LESS\_EQ\_H}.

\subsubsection{Table of Operators}

The strength and associativity of the word operations are as follows:
\begin{center}
\small
\begin{tabular}{lccc}
Constant & (Overloaded) Symbol & Strength & Associativity \\
\noalign{\smallskip}
\hline
\noalign{\smallskip}
\ml{word\_lt} & \ml{<} & 450 & right \\
\ml{word\_le} & \ml{<=} & 450 & right \\
\ml{word\_gt} & \ml{>} & 450 & right \\
\ml{word\_ge} & \ml{>=} & 450 & right \\
\ml{word\_lo} & \ml{<.} & 450 & right \\
\ml{word\_ls} & \ml{<=.} & 450 & right \\
\ml{word\_hi} & \ml{>.} & 450 & right \\
\ml{word\_hs} & \ml{>=.} & 450 & right \\
\ml{word\_add} & \ml{+} & 500 & left \\
\ml{word\_sub} & \ml{-} & 500 & left \\
\ml{word\_mul} & \ml{*} & 550 & left \\
\ml{bitwise\_or} & \ml{|} & 625 & left \\
\ml{bitwise\_eor} & \ml{\#} & 625 & left \\
\ml{bitwise\_and} & \ml{\&} & 650 & left \\
\ml{word\_lsl} & \ml{<<} & 680 & left \\
\ml{word\_lsr} & \ml{>>>} & 680 & left \\
\ml{word\_asr} & \ml{>>} & 680 & left \\
\ml{word\_ror} & \ml{\#>>} & 680 & left \\
\ml{word\_{}1comp} & \ml{NOT} & 900 & trueprefix \\
\ml{word\_{}2comp} & \verb"~" & 900 & trueprefix \\
\end{tabular}
\end{center}

\subsection{Evaluation and Pretty Printing} \label{eval}

The conversion \ml{WORD\_CONV} can be used to evaluate word expressions -- it uses re-write theorems for terms containing the map \ml{n2w}.  For example, word addition and unsigned less-than are evaluated using the theorems:

\begin{hol}\begin{verbatim}
ADD_EVAL |- !a b. n2w a + n2w b = n2w (a + b)
 LO_EVAL |- !m n. n2w m <. n2w n = MOD_2EXP WL m < MOD_2EXP WL n
\end{verbatim}\end{hol}

\noindent Natural number reductions can then evaluate the right-hand side.  When entering numeral values, the suffix \ml{w} denotes a word and the prefixes \ml{0x}, \ml{0} and \ml{0b} denote hexadecimal, octal and binary values.

\setcounter{sessioncount}{0}
\begin{session}\begin{verbatim}
- load "word8Lib";
- open word8Lib;
> ..
- WORD_CONV ``250w + 0b1000w``;
> val it = |- 250w + 8w = 2w : thm
- WORD_CONV ``21w <. 56w``;
> val it = |- 21w <. 56w = T : thm
\end{verbatim}\end{session}

The shift right operations are evaluated efficiently by using theorems that express the result in term of \ml{BITS}.  This ensures that the run-time is still quick when shifting by a large value.

\begin{session}\begin{verbatim}
- time WORD_CONV ``14w #>> 100001``;
runtime: 0.020s,    gctime: 0.010s,     systime: 0.000s.
> val it = |- 14w #>> 100001 = 7w : thm
\end{verbatim}\end{session}

It is possible to display word values as signed (two's complement) decimals or as signed or unsigned binary, octal or hexadecimal numbers.  The pretty printing directives are listed in Chapter~\ref{ml-functions}.  These functions are helpful when checking the results of computations.
\begin{session}\begin{verbatim}
- pp_word_unsigned_bin();
> val it = () : unit
- WORD_CONV ``219w #>> 5``;
> val it = |- 0b11011011w #>> 5 = 0b11011110w : thm
- pp_word_signed_dec();
> val it = () : unit
- WORD_CONV ``20w - 24w``;
> val it = |- 20w - 24w = ~4w : thm
\end{verbatim}\end{session}

\noindent Pretty printing can be turned off using the function \ml{pp\_word\_off}.

\subsection{Working with Multiple Word Sizes} \label{multiple}

The executable \ml{mkword.exe} can be run as many times as is needed -- generating theories for different word sizes.  If multiple word theories are opened then one has to ensure that the operator overloading is resolved correctly.  The session below shows how to do this by declaring the type of a variable, or by using the theory names.  These methods are also required when opening other theories; for example \ml{arithmetic} and \ml{integer}.
\setcounter{sessioncount}{0}
\begin{session}\begin{verbatim}
- app load ["word8Theory","word4Theory"];
> val it = () : unit
- open word8Theory word4Theory;
> ...
- show_types:=true;
> val it = () : unit
- ``a + b``;
<<HOL message: more than one resolution of overloading was possible>>
> val it = ``(a :word4) + (b :word4)`` : term
- ``(a:word8) + b``;
> val it = ``(a :word8) + (b :word8)`` : term
- ``word8$word_add a b``;
> val it = ``(a :word8) + (b :word8)`` : term
- WORD_SUB_SUB;
> val it = |- !(a :word4) (b :word4) (c :word4). a - (b - c) = a + c - b : thm
- word8Theory.WORD_SUB_SUB;
> val it = |- !(a :word8) (b :word8) (c :word8). a - (b - c) = a + c - b : thm
\end{verbatim}\end{session}

It is possible to define concatenation and casting functions by first mapping words to the natural numbers using \ml{w2n} and then constructing words with \ml{n2w}.  The function \ml{SIGN\_EXTEND} is provided in \ml{bits} theory to make it easier to define two's complement conversions.
\begin{session}\begin{verbatim}
- show_types:=false;
> val it = () : unit
- app load ["word8Lib","word4Lib"];
> val it = () : unit
- word4Lib.pp_word_unsigned_bin();
> val it = () : unit
- word8Lib.pp_word_unsigned_bin();
> val it = () : unit
- word4Lib.WORD_CONV ``word8$n2w (SIGN_EXTEND 4 8 (w2n (n2w 12)))``;
<<HOL message: more than one resolution of overloading was possible>>
> val it = |- n2w (SIGN_EXTEND 4 8 (w2n 0b1100w)) = 0b11111100w : thm
\end{verbatim}\end{session}
