(* -*-sml-*- *)
app load
["bossLib", "CoderTheory"];

open HolKernel boolLib Parse bossLib simpLib
     EncodeTheory DecodeTheory CoderTheory;

val _ = new_theory "EncodeVar";

infix 0 THEN |->;
infixr 1 --> by;

(*---------------------------------------------------------------------------
     Fixed size encodings---necessary for encoding variables.
 ---------------------------------------------------------------------------*)

val fixed_width_def =
  Define `fixed_width n c = !x. domain c x ==> (LENGTH (encoder c x) = n)`;

local
  val th = prove
    (``?of_length. !(l : 'a list) n. l IN of_length n = (LENGTH l = n)``,
     EXISTS_TAC ``\n (l : 'a list). LENGTH l = n`` THEN
     SIMP_TAC bool_ss [IN_DEF]);
in
  val of_length_def = new_specification ("of_length_def", ["of_length"], th);
end;

val fixed_width_univ = store_thm
  ("fixed_width_univ",
   ``!(phi : 'a -> bool) c n.
       fixed_width n c ==>
       (!x :: domain c. phi x) =
       !w :: of_length n. phi (decoder c w)``,
   SIMP_TAC bool_ss
   [RES_FORALL_DEF, fixed_width_def, of_length_def, domain_def,
    decode_def] THEN
   REPEAT (STRIP_TAC ORELSE EQ_TAC) THENL
   [ASM_SIMP_TAC bool_ss [o_THM, THE_DEF, FST] THEN
    ASM_MESON_TAC [],
    (Q_TAC KNOW_TAC `x = (FST o THE o d) w` THEN1
     ASM_SIMP_TAC bool_ss [o_THM, THE_DEF, FST]) THEN
    DISCH_THEN (fn th => ONCE_REWRITE_TAC [th]) THEN
    Q.PAT_ASSUM `!x. P x` (MP_TAC o Q.SPEC `w`) THEN
    ASM_REWRITE_TAC [] THEN
    DISCH_THEN MATCH_MP_TAC THEN
    MESON_TAC []]);

val of_length_univ_suc = store_thm
  ("of_length_univ_suc",
   ``!phi n.
       (!w :: of_length (SUC n). phi (w : 'a list)) =
       (!x. !w :: of_length n. phi (x :: w))``,
   SIMP_TAC bool_ss [RES_FORALL_DEF, of_length_def] THEN
   REPEAT (STRIP_TAC ORELSE EQ_TAC) THENL
   [Q.PAT_ASSUM `!x. Q x` MATCH_MP_TAC THEN
    ASM_SIMP_TAC arith_ss [LENGTH],
    MP_TAC (ISPEC ``x : 'a list`` list_CASES) THEN
    STRIP_TAC THENL
    [FULL_SIMP_TAC arith_ss [LENGTH],
     FULL_SIMP_TAC arith_ss [LENGTH]]]);

val of_length_univ_zero = store_thm
  ("of_length_univ_zero",
   ``!phi. (!w :: of_length 0. phi w) = phi ([] : 'a list)``,
   SIMP_TAC bool_ss [RES_FORALL_DEF, of_length_def, LENGTH_NIL]);

val fixed_width_exists = store_thm
  ("fixed_width_exists",
   ``!(phi : 'a -> bool) d n.
       (?x :: fixed_width d n. phi x) =
       ?w :: of_length n. w IN domain d /\ phi (decode d w)``,
   SIMP_TAC bool_ss
   [RES_EXISTS_DEF, fixed_width_def, of_length_def, domain_def,
    decode_def] THEN
   REPEAT (STRIP_TAC ORELSE EQ_TAC) THENL
   [Q.EXISTS_TAC `w` THEN
    ASM_SIMP_TAC bool_ss [o_THM, THE_DEF, FST] THEN
    ASM_MESON_TAC [],
    Q.EXISTS_TAC `y` THEN
    (Q_TAC KNOW_TAC `y = (FST o THE o d) x` THEN1
     ASM_SIMP_TAC bool_ss [o_THM, THE_DEF, FST]) THEN
    DISCH_THEN (fn th => ONCE_REWRITE_TAC [th]) THEN
    ASM_REWRITE_TAC [] THEN
    Q.EXISTS_TAC `x` THEN
    ASM_SIMP_TAC bool_ss [o_THM, THE_DEF, FST]]);

val of_length_exists_suc = store_thm
  ("of_length_exists_suc",
   ``!phi n.
       (?w :: of_length (SUC n). phi (w : 'a list)) =
       (?x. ?w :: of_length n. phi (x :: w))``,
   SIMP_TAC bool_ss [RES_EXISTS_DEF, of_length_def, UNIT_DEF] THEN
   REPEAT (STRIP_TAC ORELSE EQ_TAC) THENL
   [MP_TAC (ISPEC ``x:'a list`` list_CASES) THEN
    (STRIP_TAC THEN1 FULL_SIMP_TAC arith_ss [LENGTH]) THEN
    FULL_SIMP_TAC arith_ss [LENGTH] THEN
    EXISTS_TAC ``h : 'a`` THEN
    EXISTS_TAC ``t : 'a list`` THEN
    ASM_SIMP_TAC bool_ss [],
    EXISTS_TAC ``(x : 'a) :: x'`` THEN
    ASM_SIMP_TAC arith_ss [LENGTH]]);

val of_length_exists_zero = store_thm
  ("of_length_exists_zero",
   ``!phi. (?w :: of_length 0. phi w) = phi ([] : 'a list)``,
   SIMP_TAC bool_ss [RES_EXISTS_DEF, of_length_def, LENGTH_NIL]);

(*---------------------------------------------------------------------------
        Booleans
 ---------------------------------------------------------------------------*)

val bool_fixed_width = store_thm
  ("bool_fixed_width",
   ``fixed_width_type decode_bool 1``,
   SIMP_TAC arith_ss [fixed_width_type_def, fixed_width_def] THEN
   GEN_TAC THEN
   Q.EXISTS_TAC `[x]` THEN
   SIMP_TAC arith_ss [LENGTH, decode_bool_def]);

(*---------------------------------------------------------------------------
        Pairs
 ---------------------------------------------------------------------------*)

val wf_parser' = Define
  `wf_parser' p =
   !l l' x.
     (p l = SOME (x, l')) ==>
     ?t. (APPEND t l' = l) /\ (p t = SOME (x, []))`;

val x = prove
  (``!p. wf_parser' p ==>
       (!y l l' x.
          (p l = SOME (x, l')) ==>
          (p (APPEND l y) = SOME (x, APPEND l' y)))``,
   RW_TAC bool_ss [wf_parser'] THEN
   RES_TAC THEN
   

val prod_fixed_width = prove
  (``!dx dy nx ny.
       fixed_width_type dx nx /\ fixed_width_type dy ny ==>
       fixed_width_type (decode_prod dx dy) (nx + ny)``,
   SIMP_TAC arith_ss [fixed_width_type_def, fixed_width_def] THEN
   REPEAT STRIP_TAC THEN
   Cases_on `x` THEN
   Q.PAT_ASSUM `!x. P x` (STRIP_ASSUME_TAC o Q.SPEC `r`) THEN
   Q.PAT_ASSUM `!x. P x` (STRIP_ASSUME_TAC o Q.SPEC `q`) THEN
   Q.EXISTS_TAC `APPEND w' w` THEN
   ASM_SIMP_TAC arith_ss [LENGTH_APPEND, decode_prod_def]

, LENGTH_APPEND, prod_to_bool_def]);

(*---------------------------------------------------------------------------
        Sums
 ---------------------------------------------------------------------------*)

val sum_to_bool_def =
  TotalDefn.Define
  `(sum_to_bool xb yb (INL (x : 'a)) : bool list = APPEND ^encInl (xb x)) /\
   (sum_to_bool xb yb (INR (y : 'b)) = APPEND ^encInr (yb y))`;

(* Don't know exactly what this should be...
val sum_fixed_width = prove
  (``!xb yb n x y.
       x IN fixed_width xb n /\ y IN fixed_width yb n ==>
       (x, y) IN fixed_width (prod_to_bool xb yb) (m + n)``,
   SIMP_TAC arith_ss [fixed_width_def, LENGTH_APPEND, prod_to_bool_def]);
*)

(*---------------------------------------------------------------------------
        Options
 ---------------------------------------------------------------------------*)

val option_to_bool_def =
  TotalDefn.Define
  `(option_to_bool xb NONE = ^encNone) /\
   (option_to_bool xb (SOME x) = APPEND ^encSome (xb x))`;

(*---------------------------------------------------------------------------
        Lists
 ---------------------------------------------------------------------------*)

val list_to_bool_def = 
  TotalDefn.Define
  `(list_to_bool xb [] = ^encNil) /\
   (list_to_bool xb (x::xs) =
    APPEND ^encCons (APPEND (xb x) (list_to_bool xb xs)))`;

(*---------------------------------------------------------------------------
        Nums (Norrish numeral encoding)
 ---------------------------------------------------------------------------*)

val (num_to_bool_def, num_to_bool_ind) =
  Defn.tprove
  (Defn.Hol_defn "num_to_bool"
   `num_to_bool (n:num) = 
    if n = 0 then ^encZ
    else if EVEN n then APPEND ^encB2 (num_to_bool ((n-2) DIV 2))
    else APPEND ^encB1 (num_to_bool ((n-1) DIV 2))`,
   TotalDefn.WF_REL_TAC `$<` THEN
   REPEAT STRIP_TAC THEN
   (KNOW_TAC (Term`?j. n = SUC j`) THEN1 ASM_MESON_TAC [num_CASES]) THEN
   STRIP_TAC THEN
   IMP_RES_TAC EVEN_EXISTS THEN
   ASM_SIMP_TAC arith_ss
   [SUC_SUB1,MULT_DIV,DIV_LESS_EQ,
    EQT_ELIM (ARITH_CONV (Term `2n*m - 2n = (m-1n)*2n`)),
    EQT_ELIM (ARITH_CONV (Term `x < SUC y = x <= y`))]);

val _ = save_thm ("num_to_bool_def", num_to_bool_def);
val _ = save_thm ("num_to_bool_ind", num_to_bool_ind);
  
  (*--------------------------------------------------------------------
       Termination proof can also go: 

           WF_REL_TAC `$<` THEN intLib.COOPER_TAC

       but then we'd need integers.
   ----------------------------------------------------------------------*)

(*---------------------------------------------------------------------------
      The unit type is cool because it consumes no space in the
      target list: the type has all the information!
 ---------------------------------------------------------------------------*)

val one_to_bool_def =
  TotalDefn.Define `one_to_bool (_ : one) : bool list = []`;

val _ = export_theory ();
