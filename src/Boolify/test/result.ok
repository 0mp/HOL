
-----------------------------------------------------------------
       HOL [Kananaskis 2 (built Wed Jul  3 16:52:10 2002)]

       For introductory HOL help, type: help "hol";
-----------------------------------------------------------------

[closing file "/local/scratch/jeh1004/binaries/hol98/tools/end-init.sml"]
- - > val it = () : unit
- > val 'a first_token = fn : 'a frag list -> string
- > val size_of = fn : string -> (term * thm) option
- > val boolify_of = fn : string -> (term * thm) option
- > val Hol_datatype = fn :
  hol_type frag list -> string * (term * thm) option * (term * thm) option
- > val boolify = fn : term -> thm
- <<HOL message: Defined type: "NumBool0">>
runtime: 0.220s,    gctime: 0.030s,     systime: 0.000s.
Axioms asserted: 0.
Definitions made: 9.
Oracle invocations: 0.
Theorems loaded from disk: 0.
HOL primitive inference steps: 1515.
Total: 1524.
> val it =
    ("NumBool0",
     SOME(``NumBool0_size``,
          |- (!a. NumBool0_size (Num0 a) = 1 + a) /\
             !a. NumBool0_size (Bool0 a) = 1 + case a of T -> 0 || F -> 0),
     SOME(``NumBool0_to_bool``,
          |- (!a. NumBool0_to_bool (Num0 a) = APPEND [T] (num_to_bool a)) /\
             !a. NumBool0_to_bool (Bool0 a) = APPEND [F] (bool_to_bool a))) :
  string * (term * thm) option * (term * thm) option
- <<HOL message: Defined type: "NumBoolNums">>
runtime: 0.330s,    gctime: 0.040s,     systime: 0.000s.
Axioms asserted: 0.
Definitions made: 11.
Oracle invocations: 0.
Theorems loaded from disk: 0.
HOL primitive inference steps: 2401.
Total: 2412.
> val it =
    ("NumBoolNums",
     SOME(``NumBoolNums_size``,
          |- (!a. NumBoolNums_size (Num a) = 1 + a) /\
             (!a. NumBoolNums_size (Bool a) = 1 + case a of T -> 0 || F -> 0) /\
             !a. NumBoolNums_size (Nums a) = 1 + list_size (\x. x) a),
     SOME(``NumBoolNums_to_bool``,
          |- (!a. NumBoolNums_to_bool (Num a) = APPEND [T; T] (num_to_bool a)) /\
             (!a.
                NumBoolNums_to_bool (Bool a) = APPEND [T; F] (bool_to_bool a)) /\
             !a.
               NumBoolNums_to_bool (Nums a) =
               APPEND [F; T] (list_to_bool num_to_bool a))) :
  string * (term * thm) option * (term * thm) option
- <<HOL message: Defined type: "NTree">>
runtime: 0.690s,    gctime: 0.110s,     systime: 0.010s.
Axioms asserted: 0.
Definitions made: 12.
Oracle invocations: 0.
Theorems loaded from disk: 0.
HOL primitive inference steps: 3435.
Total: 3447.
> val it =
    ("NTree",
     SOME(``NTree_size``,
          |- (!a. NTree_size (Tree a) = 1 + NTree1_size a) /\
             (NTree1_size [] = 0) /\
             !a0 a1. NTree1_size (a0::a1) = 1 + (NTree_size a0 + NTree1_size a1)),
     SOME(``NTree_to_bool``,
          |- (!a. NTree_to_bool (Tree a) = NTree1_to_bool a) /\
             (NTree1_to_bool [] = [T]) /\
             !a0 a1.
               NTree1_to_bool (a0::a1) =
               APPEND [F] (APPEND (NTree_to_bool a0) (NTree1_to_bool a1)))) :
  string * (term * thm) option * (term * thm) option
- <<HOL message: Defined type: "List">>
runtime: 0.280s,    gctime: 0.070s,     systime: 0.000s.
Axioms asserted: 0.
Definitions made: 9.
Oracle invocations: 0.
Theorems loaded from disk: 0.
HOL primitive inference steps: 1830.
Total: 1839.
> val it =
    ("List",
     SOME(``List_size``,
          |- (!f. List_size f Nil = 0) /\
             !f a0 a1. List_size f (Cons a0 a1) = 1 + (f a0 + List_size f a1)),
     SOME(``List_to_bool``,
          |- (!f. List_to_bool f Nil = [T]) /\
             !f a0 a1.
               List_to_bool f (Cons a0 a1) =
               APPEND [F] (APPEND (f a0) (List_to_bool f a1)))) :
  string * (term * thm) option * (term * thm) option
- <<HOL message: Defined type: "tri">>
runtime: 0.110s,    gctime: 0.000s,     systime: 0.000s.
Axioms asserted: 0.
Definitions made: 8.
Oracle invocations: 0.
Theorems loaded from disk: 0.
HOL primitive inference steps: 1708.
Total: 1716.
> val it =
    ("tri", SOME(``tri_size``, |- !x. tri_size x = 0),
     SOME(``tri_to_bool``,
          |- (tri_to_bool ONE = [T; T]) /\ (tri_to_bool TWO = [T; F]) /\
             (tri_to_bool THREE = [F; T]))) :
  string * (term * thm) option * (term * thm) option
- <<HOL message: Defined types: "command", "expression">>
runtime: 8.600s,    gctime: 1.660s,     systime: 0.010s.
Axioms asserted: 0.
Definitions made: 36.
Oracle invocations: 0.
Theorems loaded from disk: 0.
HOL primitive inference steps: 18930.
Total: 18966.
> val it =
    ("command",
     SOME(``command_size``,
          |- (!a. command_size (Assignment a) = 1 + command2_size a) /\
             (!a. command_size (Sequence a) = 1 + command1_size a) /\
             (!a. expression_size (Numeral a) = 1 + a) /\
             (!a. expression_size (Plus a) = 1 + command3_size a) /\
             (!a. expression_size (Valof a) = 1 + command_size a) /\
             (command1_size [] = 0) /\
             (!a0 a1.
                command1_size (a0::a1) =
                1 + (command_size a0 + command1_size a1)) /\
             (!a0 a1.
                command2_size (a0,a1) =
                1 + (list_size (\x. x) a0 + command4_size a1)) /\
             (!a0 a1.
                command3_size (a0,a1) =
                1 + (expression_size a0 + expression_size a1)) /\
             (command4_size [] = 0) /\
             !a0 a1.
               command4_size (a0::a1) =
               1 + (expression_size a0 + command4_size a1)),
     SOME(``command_to_bool``,
          |- (!a.
                command_to_bool (Assignment a) =
                APPEND [T] (command2_to_bool a)) /\
             (!a.
                command_to_bool (Sequence a) = APPEND [F] (command1_to_bool a)) /\
             (!a.
                expression_to_bool (Numeral a) = APPEND [T; T] (num_to_bool a)) /\
             (!a.
                expression_to_bool (Plus a) =
                APPEND [T; F] (command3_to_bool a)) /\
             (!a.
                expression_to_bool (Valof a) =
                APPEND [F; T] (command_to_bool a)) /\
             (command1_to_bool [] = [T]) /\
             (!a0 a1.
                command1_to_bool (a0::a1) =
                APPEND [F] (APPEND (command_to_bool a0) (command1_to_bool a1))) /\
             (!a0 a1.
                command2_to_bool (a0,a1) =
                APPEND (list_to_bool num_to_bool a0) (command4_to_bool a1)) /\
             (!a0 a1.
                command3_to_bool (a0,a1) =
                APPEND (expression_to_bool a0) (expression_to_bool a1)) /\
             (command4_to_bool [] = [T]) /\
             !a0 a1.
               command4_to_bool (a0::a1) =
               APPEND [F] (APPEND (expression_to_bool a0) (command4_to_bool a1))))
     : string * (term * thm) option * (term * thm) option
- <<HOL message: Defined types: "exp", "bexp">>
runtime: 4.060s,    gctime: 0.580s,     systime: 0.000s.
Axioms asserted: 0.
Definitions made: 29.
Oracle invocations: 0.
Theorems loaded from disk: 0.
HOL primitive inference steps: 16472.
Total: 16501.
> val it =
    ("exp",
     SOME(``exp_size``,
          |- (!f f1 a. exp_size f f1 (VAR a) = 1 + f a) /\
             (!f f1 a0 a1 a2.
                exp_size f f1 (IF a0 a1 a2) =
                1 +
                (bexp_size f f1 a0 + (exp_size f f1 a1 + exp_size f f1 a2))) /\
             (!f f1 a0 a1.
                exp_size f f1 (APP a0 a1) = 1 + (f1 a0 + exp1_size f f1 a1)) /\
             (!f f1 a0 a1.
                bexp_size f f1 (EQ a0 a1) =
                1 + (exp_size f f1 a0 + exp_size f f1 a1)) /\
             (!f f1 a0 a1.
                bexp_size f f1 (LEQ a0 a1) =
                1 + (exp_size f f1 a0 + exp_size f f1 a1)) /\
             (!f f1 a0 a1.
                bexp_size f f1 (AND a0 a1) =
                1 + (bexp_size f f1 a0 + bexp_size f f1 a1)) /\
             (!f f1 a0 a1.
                bexp_size f f1 (OR a0 a1) =
                1 + (bexp_size f f1 a0 + bexp_size f f1 a1)) /\
             (!f f1 a. bexp_size f f1 (NOT a) = 1 + bexp_size f f1 a) /\
             (!f f1. exp1_size f f1 [] = 0) /\
             !f f1 a0 a1.
               exp1_size f f1 (a0::a1) =
               1 + (exp_size f f1 a0 + exp1_size f f1 a1)),
     SOME(``exp_to_bool``,
          |- (!f f1 a. exp_to_bool f f1 (VAR a) = APPEND [T; T] (f a)) /\
             (!f f1 a0 a1 a2.
                exp_to_bool f f1 (IF a0 a1 a2) =
                APPEND [T; F]
                  (APPEND (bexp_to_bool f f1 a0)
                     (APPEND (exp_to_bool f f1 a1) (exp_to_bool f f1 a2)))) /\
             (!f f1 a0 a1.
                exp_to_bool f f1 (APP a0 a1) =
                APPEND [F; T] (APPEND (f1 a0) (exp1_to_bool f f1 a1))) /\
             (!f f1 a0 a1.
                bexp_to_bool f f1 (EQ a0 a1) =
                APPEND [T; T; T]
                  (APPEND (exp_to_bool f f1 a0) (exp_to_bool f f1 a1))) /\
             (!f f1 a0 a1.
                bexp_to_bool f f1 (LEQ a0 a1) =
                APPEND [T; T; F]
                  (APPEND (exp_to_bool f f1 a0) (exp_to_bool f f1 a1))) /\
             (!f f1 a0 a1.
                bexp_to_bool f f1 (AND a0 a1) =
                APPEND [T; F; T]
                  (APPEND (bexp_to_bool f f1 a0) (bexp_to_bool f f1 a1))) /\
             (!f f1 a0 a1.
                bexp_to_bool f f1 (OR a0 a1) =
                APPEND [T; F; F]
                  (APPEND (bexp_to_bool f f1 a0) (bexp_to_bool f f1 a1))) /\
             (!f f1 a.
                bexp_to_bool f f1 (NOT a) =
                APPEND [F; T; T] (bexp_to_bool f f1 a)) /\
             (!f f1. exp1_to_bool f f1 [] = [T]) /\
             !f f1 a0 a1.
               exp1_to_bool f f1 (a0::a1) =
               APPEND [F] (APPEND (exp_to_bool f f1 a0) (exp1_to_bool f f1 a1))))
     : string * (term * thm) option * (term * thm) option
- > val it =
    |- list_to_bool
         (prod_to_bool num_to_bool
            (prod_to_bool num_to_bool
               (prod_to_bool num_to_bool num_to_bool)))
         [(1,2,3,4); (5,6,7,8)] =
       [T; T; F; T; T; F; T; T; T; F; T; F; T; T; F; T; F; T; T; T; T; F; F;
        T; T; F; F; T; T; T; F; T; F; T; F; T; T; F; T; F; T; F; T; T; F] : thm
- > val it =
    |- prod_to_bool (option_to_bool bool_to_bool)
         (prod_to_bool num_to_bool (list_to_bool bool_to_bool))
         (SOME F,123,[F; T]) =
       [T; F; T; F; T; F; F; F; F; F; T; T; T; F; T; T; F] : thm
- > val it = |- list_to_bool num_to_bool [] = [F] : thm
- > val it =
    |- list_to_bool num_to_bool [1; 2; 3] =
       [T; T; F; T; T; T; F; T; T; T; T; F; T; F; T; T; F] : thm
- > val it =
    |- prod_to_bool NumBoolNums_to_bool NumBoolNums_to_bool
         (Num 1,Nums [2; 3]) =
       [T; T; T; F; T; T; F; T; T; F; T; T; T; T; F; T; F; T; T; F] : thm
- > val it =
    |- NTree_to_bool (Tree [Tree []; Tree [Tree []; Tree []]; Tree []]) =
       [F; T; F; F; T; F; T; T; F; T; T] : thm
- > val it =
    |- list_to_bool (sum_to_bool tri_to_bool NumBool0_to_bool)
         [INL TWO; INR (Bool0 T)] =
       [T; T; T; F; T; F; F; T; F] : thm
- > val it =
    |- command_to_bool (Assignment ([1; 2],[Numeral 1])) =
       [T; T; T; F; T; T; T; F; T; T; F; F; T; T; T; F; T; T; T] : thm
- 
