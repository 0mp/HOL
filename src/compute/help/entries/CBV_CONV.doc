\DOC CBV_CONV

\TYPE {CBV_CONV : comp_rws -> conv}

\SYNOPSIS
Call by value rewriting.

\LIBRARY compute

\DESCRIBE
The conversion {CBV_CONV} expects an simplification set (ss) and a term. Its
term argument is rewritten using the equations added in the ss. The strategy
used is somewhat similar to ML's, that is call-by-value (arguments of
constants are completely reduced before the rewrites associated to the
constant are applied) with weak reduction (no reduction of the function body
before the function is applied). The main differences are that beta-redexes
are reduced with a call-by-name strategy (the argument is not reduced), and
reduction under binders occurs when it occurs in a position where it cannot
be substituted.

The simplification sets are mutable objects, this means they are extended
by side-effect. The function {new_rws} will create a new empty ss. Theorems
can be added to a ss with function {add_thms}. The boolean tells if the
theorem must be added as provided (true), or if it should be "lazyfied"
(false), i.e. have pattern variables on the left hand side turned into
abstractions on the right hand side. A typical example is {COND_CLAUSES}:

  (COND T a b = a) /\ (COND F a b = b)

This is very inefficient because both a and b are evaluated, regardless of
the value of the boolean expression. It is better to use {COND_CALUSES}
with the form above

  (COND T = \a b. a) /\ (COND F = \a b. b)

The call-by-name evaluation of beta_redexes avoids computing the unused
branch of the conditional.

Function {from_list} simply combines {new_rws} and {add_thms}.

It is also possible to add conversions to a ss with {add_conv}. The only
restriction is that a constant (c) and an arity (n) must be provided. The
conversion will be called only on terms in which c is applied to n arguments.


\EXAMPLE
{
- val rws = from_list (false,[COND_CLAUSES]);
> val rws = RWS<hash_table> : comp_rws;

- CBV_CONV rws (--` (\x.x) ((\x.x) if T then 0 else 10) `--);
> val it = |- (\x. x) ((\x. x) if T then 0 else 10) = 0 : Thm.thm
}

\FAILURE
Should never fail. Nonetheless, using rewrites with assumptions may cause
problems when rewriting under abstractions. The following example
illustrates that issue.

\EXAMPLE
{
- val th = ASSUME(--`0=x`--);
- val tm = --`\(x:num).x=0`--;
- val rws = from_list(true,[th]);
- CBV_CONV rws tm;
}

This fails because the 0 is replaced by x, making the assumption 0=x. Then,
the abstraction cannot be rebuilt since x appears free in the assumptions.

\ENDDOC

