<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.01">
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>
 
[1]<hr />
<font size="+4"><tt>
<title>HolBddLib</title>

HolBddLib</tt> Version 2<br />
Documentation</font>


<p>
<hr />
<br /><br /><font size="+2"><b>Mike Gordon</b></font>

<p>
Nov  5, 2001


<p>
<table align="left" border="1"><tr><td width="0" align="center">

<a href="kananaskis_small.ps">Figure</a> <font size="+4"><b>&nbsp;&nbsp;&nbsp;+&nbsp;</b></font> 
<a href="scratchBDD.ps">Figure</a>
</td></tr></table><!--hbox-->
<br clear="all" />

<p>

<h2>Preface</h2>

<p>
The development of <tt>HolBddLib</tt> has gone through two phases.  The
first phase consisted in experiments with different ways of linking
higher order logic (HOL) terms to binary decision diagrams (BDDs).
These are described in the paper <i>Reachability programming in
HOL98 using BDDs </i> []. The first release of
<tt>HolBddLib</tt>, called now Version&nbsp;1, consisted of an ad hoc collection
of tools developed for these experiments.  The positive results of
Hasan Amjad [] have lead us to adopt an
approaches based on a protected type of `BDD representation
judgements', analogous to the LCF protected type of theorems.  The goal
of <tt>HolBddLib</tt> Version&nbsp;2, described here, is to use a kernel of representation
judgement rules to provide core infrastructure for building
`fully-expansive' or `LCF-style' combinations of HOL theorem proving
and BDD-based symbolic calculation algorithms, like model checkers.

<p>
Version&nbsp;1 of <tt>HolBddLib</tt> was more elaborate than Version&nbsp;2
because it mixed together code from a number of experiments.
Version&nbsp;2 narrows attention to the representation judgement approach,
and provides a fixed set of `inference rules' that link terms to
BDDs. All higher level tools, such as model checkers, are programmed
in ML as `derived rules'.

<p>
The primitive inference rules for representation judgements are in the structure
<tt>PrimitiveBddRules</tt>. A few example derived rules are in the
structure <tt>DerivedBddRules</tt>. Currently the only derived rules are
ones to compute reachable states and find sequences of transitions to
states with given properties.  It is hoped to soon add a module for
checking properties expressed in the modal <font face="symbol">m</font
>-calculus (and hence CTL).

<p>
In <tt>HolBddLib</tt> Version&nbsp;1 there was a function, called
<tt>termToBdd</tt>, that tried to represent a HOL term as a BDD
using a dynamically extendable global table mapping HOL terms to
BDDs.  <tt>TermToBdd</tt> constructed the BDD of a term t using any
BDDs of subterms of t that were stored in the global table.
<tt>HolBddLib</tt> Version&nbsp;2 has jettisoned this imperative style
in favour of purely functional rules. Some of
the ideas of BDD tables are likely to return in the future, but as
contexts, similar to HOL simpsets, that are passed functionally,
rather than as a single global state held in references.

<p>
<tt>HolBddLib</tt> Version&nbsp;1 only supported a single variable
ordering, held in a global variable map. In Version&nbsp;2, each
representation judgement carries its own variable ordering, so that local
scopes are possible. For convenience, <tt>DerivedBddRules</tt>
provides a way of storing a default variable ordering in a global
variable, but this is just a derived facility, not part of the kernel.

<p>
<tt>HolBddLib</tt> Version&nbsp;2 adds assumptions to representation judgements
analogous to assumptions of HOL theorems. This enables
Coudert, Berthet and Madre simplification to be represented as a primitive
rule (see the rule <tt>BddSimplify</tt> in 
Section&nbsp;). 
It also allows the term part
of a representation judgements to be simplified using equations with assumptions
(see the rule <tt>BddEqMp</tt> in Section&nbsp;).

<p>
<tt>HolBddLib</tt> uses J&#248;rn Lind-Nielsen's BuDDy package as a BDD
engine. The interface from BuDDy to Moscow ML, called MuDDy, is
due to Ken Friis Larsen and Jakob Lichtenberg, and is described in Part&nbsp;.
<tt>HolBddLib</tt> is built on top of MuDDy and
is described in Part&nbsp;.

<p>
Some of the material in this document derives from University of
Cambridge Computer Laboratory Technical Report No.&nbsp;481, December 1999,
by Mike Gordon and Ken Friis Larsen []. Although this
report has examples that might be of tutorial use, it has much
obsolete material and methodology deriving for early experiments
pre-dating the release of <tt>HolBddLib</tt> Version&nbsp;1.

<p>

<h3>Overview</h3>

<p>
In the LCF approach, theorems are represented by an abstract type
whose primitive operations are the axioms and inference rules of a
logic.  Theorem proving tools are implemented by composing together
the inference rules using ML programs.

<p>
This idea can be generalised to computing valid judgements that
represent other kinds of information. In particular, consider
judgements (a,<font face="symbol">r</font
>,t,b), where a is a set of boolean terms
(assumptions) that are assumed true, <font face="symbol">r</font
> represents a variable
order, t is a boolean term all of whose free variables are boolean
and b is a BDD. Such a judgement is valid if under the assumptions
a, the BDD representing t with respect to <font face="symbol">r</font
> is b, and we
will write a&nbsp;<font face="symbol">r</font
>&nbsp;t&nbsp;<font face="symbol">®</font
>&nbsp;b when this is the case.

<p>
The derivation of `theorems' like a&nbsp;<font face="symbol">r</font
>&nbsp;t&nbsp;<font face="symbol">®</font
>&nbsp;b can be viewed
as `proof' in the style of LCF by defining an abstract type <tt>term_bdd</tt>
that models
judgements <span class="roman">a</span>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span> analogously
to the way the type <tt>thm</tt> models theorems \vdash t.

<p>
<tt>HolBddLib</tt> currently contains two main structures: <tt>PrimitiveBddRules</tt>
which defines a protected type <tt>term_bdd</tt>and rules for generating
values of this type, and <tt>DerivedBddRules</tt> that contains derived
rules for performing simple fixed-point calculations.  There is also a
theory <tt>DerivedBddRulesTheory</tt> containing the theorems on
reachability and fixed points needed by the derived rules,
and two small subsidiary structures <tt>Varmap</tt> and <tt>PrintBdd</tt>.

<p>

<h3>Relation to the Voss system<a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a></h3><a name="related">
</a>

<p>
The Voss system [] has strongly influenced and inspired
the ideas described here. Voss consists of a lazy
ML-like functional language, called FL, with BDDs as a built-in datatype.
Quantified boolean formulae can be input and are parsed to BDDs.
The normal boolean operations <font face="symbol">Ø</font
>, <font face="symbol">Ù</font
>, <font face="symbol">Ú</font
>,  <font face="symbol">º</font
> ,
<font face="symbol">"</font
>, <font face="symbol">$</font
> are interpreted as BDD operations.  
Algorithms for model checking are easily programmed.

<p>
Joyce and Seger interfaced an early HOL system (HOL88) to Voss and in
a pioneering paper showed how to verify complex systems by a
combination of theorem proving deduction and symbolic trajectory
evaluation (STE) []. The HOL-Voss system integrates HOL88
deduction with BDD computations.  BDD tools are programmed in FL and
can then be invoked by HOL-Voss tactics, which can make external
calls into the Voss system, passing subgoals via a translation between
the HOL88 and Voss term representations.

<p>
In later work Lee, Seger and Greenstreet []
showed how various optimised BDD algorithms could be programmed in FL.

<p>
The early experiments with HOL-Voss suggested that a lighter theorem
proving component was sufficient, since all that was really needed was
a way of combining results obtained from STE. A system based on this
idea, called VossProver, was developed by Carl Seger and his student
Scott Hazelhurst. It provides operations in FL for combining
assertions generated by Voss using proof rules corresponding to the
laws of composition of the temporal logic assertions verified by STE
[].  
VossProver was used to verify
impressive integer and floating-point examples (see the DAC98
paper by Aagaard, Jones and Seger [] for further
discussion and references). 

<p>
After Seger and Aagaard moved to Intel, the development of the Voss and
VossProver systems evolved into a new system called Forte.  Only partial details
of this are in the public domain
[,], but a key idea is that FL is
used both as a specification language and as an LCF-style
metalanguage. The connection between symbolic trajectory evaluation
and proof is obtained via a tactic <tt>Eval_tac</tt> that converts the
result of executing an FL program performing STE into a theorem in the
logic. Theorem proving in Forte is used both to split goals into
smaller subgoals that are tractable for model checking, and to
transform formulae so that they can be checked more efficiently.

<p>
The combination of HOL and BuDDy in Version&nbsp;1 of
<tt>HolBddLib</tt> provides a somewhat similar programming environment
to Voss's FL (though with eager rather than lazy evaluation and no
special support for STE). BuDDy provides BDD operations
corresponding to <font face="symbol">Ø</font
>, <font face="symbol">Ù</font
>, <font face="symbol">Ú</font
>,  <font face="symbol">º</font
> , <font face="symbol">"</font
>,
<font face="symbol">$</font
> and the HOL term parser plus <tt>termToBdd</tt> provides a
way of using these to create BDDs from logical terms.  Voss enables
efficient computations on BDDs using functional programming. So does
<tt>HolBddLib</tt>. However, in addition it allows FL-like BDD programming
in ML to be intimately mixed with HOL deduction, so that, for
example, theorem proving tools (e.g.&nbsp;simplifiers) can be directly
applied to terms to optimise them for BDD purposes (e.g.&nbsp;disjunctive
partitioning).  This is in line with future developments discussed by
Joyce and Seger [] and it appears that the Forte system
has similar capabilities.

<p>
<tt>HolBddLib</tt> Version&nbsp;2 provides a less developed interactive
programming environment than Version&nbsp;1. It is more oriented to
providing a clean and simple API allowing implementers to create their
own `fully-expansive' combinations of model checking and theorem
proving. Such a combination could be a Voss-like verification
platform.

<p>
 <br /><h1>Part 1   <br />MuDDy</h1><br /><a name="muddy">
</a>

<p>
MuDDyis the Moscow
ML interface to BuDDy. It provides ML functions for constructing and
manipulating BDDs via three structures:

<p>

<ul><p>
<li> <tt>bdd</tt> defines the ML type
<tt>bdd</tt> representing BDDs and associated operations derived from BuDDy;</li>
<p>
<li> <tt>fdd</tt> provides support for blocks of BDD variables
used to encode values representing elements of finite domains;</li>
<p>
<li> <tt>bvec</tt> provides support for Boolean vectors.</li>
</ul>

<p>
The current <tt>HolBddLib</tt> system only uses <tt>bdd</tt> and so
the documentation of <tt>fdd</tt> and <tt>bvec</tt> provided here is minimal
(see Sections&nbsp; and  below).

<p>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Initialisation, termination and tuning sessions</h2><a name="init">
</a>

<p>
The BuDDy package must be initialised before any BDD operations are done.
Initialisation is done with the ML function

<p>

<pre>
   init : int -&#62; int -&#62; unit

</pre>MLbn]<tt>init</tt>

<p>
Evaluating <tt>init</tt>&nbsp;m&nbsp;n initialises BuDDy with m nodes in the
nodetable and a cachesize of n.  
The library <tt>HolBddLib</tt> (Part&nbsp;) 
initialises the nodetable to 1000000 and cachesize to
be 10000. The following is a quotation from the BuDDy documentation [].

<p>

<blockquote><font size="-2">Good initial values are

<p>

<table>
<tr><td><b>Example</b> </td><td align="right"><b>nodenum</b> </td><td align="right"><b>cachesize</b> </td></tr>
<tr><td>Small test examples   </td><td align="right">1000    </td><td align="right">100</td></tr>
<tr><td>Small examples        </td><td align="right">10000   </td><td align="right">1000 </td></tr>
<tr><td>Medium sized examples </td><td align="right">100000  </td><td align="right">10000</td></tr>
<tr><td>Large examples        </td><td align="right">1000000 </td><td align="right">10000
</td></tr></table>


<p>
Too few nodes will only result in reduced performance and this
increases the number of garbage collections needed. If the package
needs more nodes, then it will automatically increase the size of the
node table.
</font></blockquote>

<p>
The initial number of nodes is not critical for any BDD operation
as the table will be resized whenever there are too few nodes left
after a garbage collection.  But it does have some impact on the
efficiency of the operations.

<p>
The function

<p>

<pre>
   done : unit -&#62; unit

</pre>MLbn]<tt>done</tt>

<p>
frees all memory used by BuDDy and resets the
package to its initial state. 

<p>
The functions <tt>init</tt> and <tt>done</tt> should only be called once per session.

<p>
The function

<p>

<pre>
   isRunning : unit -&#62; bool

</pre>MLbn]<tt>isRunning</tt>

<p>
tests whether
BuDDy is running (i.e.&nbsp;<tt>init</tt> has been called and <tt>done</tt> has not been called). It is
useful for checking if initialialisation is needed.

<p>
The functions <tt>init</tt> and <tt>done</tt> should only be called once in a session.

<p>
Statistical information from BuDDy is available
using the function <tt>stats</tt>

<p>

<pre>
   stats : unit -&#62; {produced     : int,
                    nodenum      : int,
                    maxnodenum   : int,
                    freenodes    : int,
                    minfreenodes : int,
                    varnum       : int,
                    cachesize    : int,
                    gbcnum       : int}

</pre>MLbn]<tt>stats</tt>

<p>
The meaning of the values of the various named fields in the record returned by
evaluating <tt>stats()</tt> are

<p>
<br />
<table border="1">
<tr><td><b>Field name</b></td><td><b>Meaning</b>                                              </td></tr><tr><td>
<tr><td><tt>produced</tt>     </td><td>total number of new nodes ever produced                     </td></tr>
<tr><td><tt>nodenum</tt>      </td><td>currently allocated number of BDD nodes                     </td></tr>
<tr><td><tt>maxnodenum</tt>   </td><td>user defined maximum number of BDD nodes                    </td></tr>
<tr><td><tt>freenodes</tt>    </td><td>number of currently free BDD nodes                          </td></tr>
<tr><td><tt>minfreenodes</tt> </td><td>minimum number of nodes left after a BDD garbage collection </td></tr>
<tr><td><tt>varnum</tt>       </td><td>number of defined BDD variables                             </td></tr>
<tr><td><tt>cachesize</tt>    </td><td>number of cache entries                                     </td></tr>
<tr><td><tt>gbcnum</tt>       </td><td>number of BDD garbage collections done                      </td></tr></table>


<p>
<br />The management of the node table and internal caches can be tuned
using the following functions

<p>

<pre>
   setMaxincrease : int -&#62; int
   setCacheratio  : int -&#62; int

</pre>MLbn]<tt>setMaxincrease</tt>MLbn]<tt>setCacheratio</tt>

<p>
Evaluating <tt>setMaxincrease&nbsp;n</tt> tells BuDDythat the maximum of new nodes added
when doing an expansion of the nodetable should be n.  The previous maximum is returned.

<p>
Evaluating <tt>setCacheratio&nbsp;n</tt> sets the cache ratio to n.  
For example, if n is 4 then the internal caches will a quarter the size of the
nodetable.

<p>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;BDDs representing <tt>true</tt> and <tt>false</tt></h2>

<p>
The atomic BDDs representing the two truthvalues are bound to the ML
identifiers <tt>TRUE</tt> and <tt>FALSE</tt>, both of type <tt>bdd</tt>.

<p>
Functions for mapping from ML Booleans to BDDs and vice versa are, respectively

<p>

<pre>
   fromBool : bool -&#62; bdd
   toBool   : bdd  -&#62; bool

</pre>MLbn]<tt>fromBool</tt>MLbn]<tt>toBool</tt>

<p>
The function <tt>toBool</tt> returns <tt>true</tt> on TRUE and <tt>false</tt> on FALSE.
It raises the exception <tt>Domain</tt> on non-atomic BDDs.

<p>

<pre>
   equal : bdd -&#62; bdd -&#62; bool

</pre>MLbn]<tt>equal</tt>

<p>
tests the equality of two BDDs. Thus <tt>TRUE</tt> is <tt>equal</tt> to <tt>fromBool(true)</tt> and 
<tt>FALSE</tt> is <tt>equal</tt> to <tt>fromBool(false)</tt>.

<p>
 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Variables</h2>

<p>
In BuDDy, BDD variables are encoded as integers (type <tt>int</tt> in ML) and the BDD variable ordering
is the numerical ordering. Thus to build a BDD to represent a HOL term with a
particular variable ordering it is necessary to map HOL variables to
integers so that the numerical order corresponds to the desired
variable order.

<p>
The number of variables in use must be declared using

<p>

<pre>
   setVarnum : int -&#62; unit

</pre>MLbn]<tt>setVarnum</tt>

<p>
Evaluating <tt>setVarnum</tt>&nbsp;n declares that the n variables 0,
1, <font face="symbol">¼</font
> , n<font face="symbol">-</font
>1 are available for use. The number of variables
can be increased dynamically during a session by calling <tt>setVarnum</tt>
with a larger number. The number of variables cannot be decreased
dynamically. The function

<p>

<pre>
   getVarnum : unit -&#62; int

</pre>MLbn]<tt>getVarnum</tt>

<p>
returns the number of variables in use (i.e.&nbsp;the argument of the last
application of <tt>setVarnum</tt>).

<p>
The function

<p>

<pre>
   ithvar : int -&#62; bdd

</pre>MLbn]<tt>ithvar</tt>

<p>
maps an ML integer to a BDD that consists of just the variable
corresponding to the integer and

<p>

<pre>
   nithvar : int -&#62; bdd

</pre>MLbn]<tt>nithvar</tt>

<p>
maps
an integer to the BDD representing the negation of the variable.

<p>
Note that evaluating <tt>ithvar</tt>&nbsp;n or <tt>nithvar</tt>&nbsp;n will raise the exception
<tt>Fail</tt> (with string argument <tt>&#220;nknown variable"</tt>)
if n has not been declared as in use, i.e.&nbsp;if
<tt>setVarnum</tt>&nbsp;m has not been previously evaluated for some m
greater than n.

<p>
 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Sets of variables and quantification</h2><a name="varSet">
</a>

<p>
BuDDy provides operations on BDDs for quantifying with respect to sets
of variables. The module  <tt>bdd</tt> provides a type <tt>varSet</tt> to represent such
sets with, respectively, a constructor and two destructors:

<p>

<pre>
   makeset : int list -&#62; varSet
   scanset : varSet   -&#62; int vector
   fromSet : varSet   -&#62; bdd

</pre>MLbn]<tt>makeset</tt>MLbn]<tt>scanset</tt>MLbn]<tt>fromSet</tt>

<p>
The destructor <tt>scanset</tt> returns a vector of the variables in the
set and the destructor <tt>fromSet</tt> returns a BDD representing the
conjunction of the variables in the set.

<p>
The following functions quantify BDDs with respect to sets of variables:

<p>

<pre>
   forall : varSet -&#62; bdd -&#62; bdd
   exist  : varSet -&#62; bdd -&#62; bdd

</pre>MLbn]<tt>forall</tt>MLbn]<tt>exist</tt>

<p>
 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Assignments, composition, replacement and restriction</h2><a name="replace">
</a>

<p>
MuDDyprovides a function for general purpose simultaneous
substitution of arbitrary BDDs for variables in a given BDD (<tt>veccompose</tt>). It also
provides and three optimised special cases: substituting for a single
variable (<tt>compose</tt>), renaming variables (<tt>replace</tt>) and
substituting with boolean constants (<tt>restrict</tt>).

<p>
The operation <tt>veccompose</tt> performs the simultaneous substitution 
of BDDs for variables in a BDD. The argument of <tt>veccompose</tt>
is a value of type <tt>composeSet</tt>MLty]<tt>composeSet</tt> 
(created with a constructor <tt>composeSet</tt>)
that specifies a list if pairs <tt>[</tt>((n<sub>1</sub>,b<sub>1</sub>),<font face="symbol">¼</font
>,, where BDD variable n is to be pre

<p>

<pre>
   composeSet : (int * bdd) list -&#62; composeSet
   veccompose : composeSet -&#62; bdd -&#62; bdd

</pre>MLbn]<tt>composeSet</tt>MLbn]<tt>veccompose</tt>

<p>
A single variable can be replaced with a BDD using

<p>

<pre>
   compose : bdd -&#62; bdd -&#62; int -&#62; bdd

</pre>MLbn]<tt>compose</tt>

<p>
Evaluating <tt>compose&nbsp;b<sub>1</sub>&nbsp;b<sub>2</sub>&nbsp;n</tt> substitutes b<sub>2</sub> for the
variable n in b<sub>1</sub>.

<p>
Variables can be renamed using the function <tt>replace</tt> that takes
an argument of type <tt>pairSet</tt>MLty]<tt>pairSet</tt> representing sets of pairs of variables
(with constructor <tt>makepairSet</tt>)

<p>

<pre>
   makepairSet : (int * int)list -&#62; pairSet
   replace     : bdd -&#62; pairSet -&#62; bdd

</pre>MLbn]<tt>makepairSet</tt>MLbn]<tt>replace</tt>

<p>
Evaluating <tt>makepairSet[(x<sub>1</sub>,x<sub>1</sub><font face="symbol">¢</font
>), <font face="symbol">¼</font
> , (x<sub>n</sub>,x<sub>n</sub><font face="symbol">¢</font
>)]</tt>
creates a set of pairs specifying that x<sub>i</sub><font face="symbol">¢</font
> be substituted for x<sub>i</sub>
(for 1 <font face="symbol">£</font
> i <font face="symbol">£</font
> n).  A renaming with <tt>replace</tt> will fail if it
would result in distinct variables being identified (i.e.&nbsp;if the shape of the BDD would change).

<p>
BDDs can be restricted by instantiating variables to <tt>TRUE</tt> or
<tt>FALSE</tt> using the function <tt>restrict</tt> that takes
as argument a value of type <tt>assignment</tt>MLty]<tt>assignment</tt> 
(which has a constructor <tt>assignment</tt> and destructor <tt>getAssignment</tt>).

<p>

<pre>
   assignment    : (int * bool)list -&#62; assignment
   getAssignment : assignment -&#62; (int * bool) list
   restrict      : bdd -&#62; assignment -&#62; bdd

</pre>MLbn]<tt>restrict</tt>MLbn]<tt>assignment</tt>MLbn]<tt>getAssignment</tt>

<p>
Evaluating <tt>assignment[(v<sub>1</sub>,t<sub>1</sub>), <font face="symbol">¼</font
> , (v<sub>n</sub>,t<sub>n</sub>)]</tt>
creates an assignment specifying that each v<sub>i</sub> be instantiated to
<tt>fromBool</tt><tt>(</tt>t<sub>i</sub><tt>)</tt> (for 1 <font face="symbol">£</font
> i <font face="symbol">£</font
> n). 

<p>
 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;Finding satisfying assignments</h2>

<p>
An assignment satisfying a BDD can be computed via BuDDyusing

<p>

<pre>
   satone : bdd -&#62; assignment

</pre>MLbn]<tt>makeset</tt>MLbn]<tt>scanset</tt>MLbn]<tt>fromSet</tt>

<p>
The exception <tt>Domain</tt> is raised if the argument to <tt>satone</tt> is unsatisfiable.

<p>
Alternatively, a model can be computed by an ML program such as:

<p>

<pre>
   val findSat =
    let fun findSatAux bdd = 
         if bdd.equal bdd bdd.TRUE
          then []
          else
           if bdd.equal bdd bdd.FALSE
            then raise Domain
            else
             ((bdd.var bdd,true) :: findSatAux(bdd.high bdd) 
              handle Domain =&#62;
              (bdd.var bdd, false) :: findSatAux(bdd.low bdd))
    in
     assignment o findSatAux
    end;

</pre>

<p>
The functions <tt>satOne</tt> and <tt>findSat</tt> do not necessarily find the
same satisfying assignment, if more than one exists. Also,
<tt>findSat</tt> stops when it has found enough variable bindings to
satisfy the BDD, so may not return an assignment giving values to all
the variables.

<p>
 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;Boolean operations on BDDs</h2><a name="app">
</a>

<p>
The structure <tt>bdd</tt> introduces a type <tt>bddop</tt>
corresponding to Boolean operations on BDDs. 
The ML function

<p>

<pre>
   apply : bdd -&#62; bdd -&#62; bddop -&#62; bdd

</pre>MLbn]<tt>apply</tt>

<p>
applies a BDD operation to BDD values.

<p>
BuDDy provides functions for calculating in a single step the
result of performing a Boolean operation and then quantifying the
result with respect to several variables.

<p>

<pre>
   appall : bdd -&#62; bdd -&#62; bddop -&#62; varSet -&#62; bdd
   appex  : bdd -&#62; bdd -&#62; bddop -&#62; varSet -&#62; bdd

</pre>MLbn]<tt>appall</tt>MLbn]<tt>appex</tt>

<p>
The function <tt>appall</tt> universally quantifies the result of the
Boolean operation and <tt>appex</tt> existentially quantifies it.

<p>
MuDDy provides ten operations of type <tt>bddop</tt> and for each of
these an ML infix, pre-defined using <tt>apply</tt>, of type <tt>bdd&nbsp;*&nbsp;bdd&nbsp;-&#62;&nbsp;bdd</tt>.

<p>

<center>
<table border="1">
<tr><td><tt>bddop</tt>MLbn]<tt>bddop</tt> </td><td><tt>bdd&nbsp;*&nbsp;bdd&nbsp;-&#62;&nbsp;bdd</tt> </td><td>Result of applying to (b<sub>1</sub>,b<sub>2</sub>)</td></tr><tr><td>
<tr><td><tt>And</tt>MLbn]<tt>And</tt> </td><td><tt>AND</tt> </td><td>b<sub>1</sub><font face="symbol">Ù</font
>b<sub>2</sub> </td></tr>
<tr><td><tt>Nand</tt>MLbn]<tt>Nand</tt> </td><td><tt>NAND</tt> </td><td><font face="symbol">Ø</font
>(b<sub>1</sub><font face="symbol">Ù</font
>b<sub>2</sub>) </td></tr>
<tr><td><tt>Or</tt>MLbn]<tt>Or</tt>  </td><td><tt>OR</tt> </td><td>b<sub>1</sub><font face="symbol">Ú</font
>b<sub>2</sub> </td></tr>
<tr><td><tt>Nor</tt>MLbn]<tt>Nor</tt> </td><td><tt>NOR</tt> </td><td><font face="symbol">Ø</font
>(b<sub>1</sub><font face="symbol">Ú</font
>b<sub>2</sub>) </td></tr>
<tr><td><tt>Biimp</tt>MLbn]<tt>Biimp</tt> </td><td><tt>BIIMP</tt> </td><td>b<sub>1</sub> = b<sub>2</sub> </td></tr>
<tr><td><tt>Xor</tt>MLbn]<tt>Xor</tt> </td><td><tt>XOR</tt> </td><td><font face="symbol">Ø</font
>(b<sub>1</sub>=b<sub>2</sub>) </td></tr>
<tr><td><tt>Imp</tt>MLbn]<tt>Imp</tt> </td><td><tt>IMP</tt> </td><td>b<sub>1</sub><font face="symbol">Þ</font
>b<sub>2</sub> </td></tr>
<tr><td><tt>Invimp</tt>MLbn]<tt>Invimp</tt> </td><td><tt>INVIMP</tt> </td><td>b<sub>2</sub><font face="symbol">Þ</font
>b<sub>1</sub> </td></tr>
<tr><td><tt>Lessth</tt>MLbn]<tt>Lessth</tt> </td><td><tt>LESSTH</tt> </td><td><font face="symbol">Ø</font
>b<sub>1</sub><font face="symbol">Ù</font
>b<sub>2</sub> </td></tr>
<tr><td><tt>Diff</tt>MLbn]<tt>Diff</tt> </td><td><tt>DIFF</tt> </td><td>b<sub>1</sub><font face="symbol">Ù</font
><font face="symbol">Ø</font
>b<sub>2</sub> </td></tr></table>
<a name="bddops">
</a>

<p>
</center>MuDDy also provides a unary negation operator and ternary conditional operator.

<p>

<pre>
   NOT : bdd -&#62; bdd
   ITE :  bdd -&#62; bdd -&#62; bdd -&#62; bdd

</pre>MLbn]<tt>NOT</tt>MLbn]<tt>ITE</tt>

<p>
<tt>NOT</tt>&nbsp;b is the BDD corresponding to  `<font face="symbol">Ø</font
>b' and <tt>ITE</tt>&nbsp;b&nbsp;b<sub>1</sub>&nbsp;b<sub>2</sub> is the BDD corresponding
to `if&nbsp;b&nbsp;then&nbsp;b<sub>1</sub>&nbsp;else&nbsp;b<sub>2</sub>'.

<p>
 <h2><a name="tth_sEc8">
8</a>&nbsp;&nbsp;Inspecting and counting nodes and states</h2>

<p>
The integer labelling a BDD node and the BDDs corresponding to the high
(i.e.&nbsp;<tt>true</tt>) and low (i.e.&nbsp;<tt>false</tt>) nodes are obtained,
respectively, with

<p>

<pre>
   var  : bdd -&#62; int
   high : bdd -&#62; bdd
   low  : bdd -&#62; bdd

</pre>MLbn]<tt>var</tt>MLbn]<tt>high</tt>MLbn]<tt>low</tt>

<p>
Thus if b is the BDD of ``<i>if</i>&nbsp;x&nbsp;<i>then</i>&nbsp;t<sub>1</sub>&nbsp;<i>else</i>&nbsp;t<sub>2</sub>''
then <tt>var</tt>&nbsp;b will return the number representing variable x,
<tt>high</tt>&nbsp;b will return the BDD of t<sub>1</sub> and <tt>low</tt>&nbsp;b will return
the BDD of t<sub>2</sub>.

<p>
Note that <tt>var</tt>, <tt>high</tt> and <tt>low</tt> raise an exception if applied
to <tt>TRUE</tt> or <tt>FALSE</tt>.

<p>
The entire BuDDy node table of a BDD can be copied into ML using

<p>

<pre>
   nodetable : bdd -&#62; int * (int * int * int)vector

</pre>MLbn]<tt>nodetable</tt>

<p>
The integer returned as the first component of the pair is a pointer
(starting from 0) into the second component, a vector of node
descriptors. This pointer points to the root node. Each node
descriptor is a triple of integers (v,l,h), where v is the node
label (i.e.&nbsp;a number representing a variable), l points to the low
(<tt>false</tt>) node in the vector and h points to the high
(<tt>true</tt>) node. The first two nodes in the vector are special:
they represent <tt>true</tt> and <tt>false</tt>, respectively, and arbitrarily have
the structure (0,0,0).

<p>
The number of nodes in a BDD is computed by the function

<p>

<pre>
   nodecount : bdd -&#62; int

</pre>MLbn]<tt>nodecount</tt>

<p>
This could be defined by

<p>

<pre>
   fun nodecount bdd = Vector.length(snd(nodetable bdd));

</pre>

<p>
However, <tt>nodecount</tt> defined this way is likely to run out of space
on large BDDs (since it involves copying the argument BDD from
BuDDy's representation into an ML vector).  Thus the ML function
provided by MuDDy invokes BuDDy's <tt>nodecount</tt> function directly
and so is space-efficient.

<p>
The number of assignments <i>to all variables in use in the current
session </i> that satisfy a BDD (i.e.&nbsp;make it true) is given by the ML
function

<p>

<pre>
   satcount : bdd -&#62; real

</pre>MLbn]<tt>satcount</tt>

<p>
The answer is exact until the result is too big to be represented as a
Moscow ML integer. Real numbers are used so that results can be
returned when this happens.

<p>
The function

<p>

<pre>
   support : bdd -&#62; varSet

</pre>MLbn]<tt>support</tt>

<p>
gives the variables that a BDD depends on. 

<p>
An application is to define
a function that counts the number of valuations of a BDD using
<tt>satcount</tt>.

<p>

<pre>
   statecount : bdd -&#62; real

</pre>MLbn]<tt>statecount</tt>

<p>
The
definition of <tt>statecount</tt> is

<p>

<pre>
fun statecount bdd =
 let val sat    = satcount bdd
     val total  = Real.fromInt(getVarnum())
     val sup    = scanset(support bdd)
     val numsup = Real.fromInt(Vector.length sup)
     val free   = total - numsup
 in 
  if equal bdd TRUE 
   then 0.0
   else sat / Math.pow(2.0, free)
 end

</pre>

<p>
If a BDD is representing a set of states, then <tt>statecount</tt> gives
the number of states in the set (hence the name).

<p>
 <h2><a name="tth_sEc9">
9</a>&nbsp;&nbsp;Coudert, Berthet &amp; Madre simplification</h2>

<p>
The ML function

<p>

<pre>
   simplify : bdd -&#62; bdd -&#62; bdd

</pre>MLbn]<tt>simplify</tt>

<p>
simplifies its second argument under the assumption that the first
argument is true. Thus evaluating
<tt>simplify&nbsp;b<sub>1</sub>&nbsp;b<sub>2</sub></tt> results in a BDD b<sub>2</sub><font face="symbol">¢</font
>, hopefully simpler than b<sub>2</sub>, such that
b<sub>1</sub> <font face="symbol">Þ</font
>(b<sub>2</sub> = b<sub>2</sub><font face="symbol">¢</font
>) or, equivalently, b<sub>1</sub> <font face="symbol">Ù</font
>b<sub>2</sub> = b<sub>1</sub> <font face="symbol">Ù</font
>b<sub>2</sub><font face="symbol">¢</font
>.
More precisely,
the relationship between b<sub>1</sub>, b<sub>2</sub> and b<sub>2</sub><font face="symbol">¢</font
> is that
the BDD <tt>IMP(b<sub>1</sub>,BIIMP(b<sub>2</sub>,b<sub>2</sub><font face="symbol">¢</font
>))</tt> is the BDD <tt>TRUE</tt>
(or, equivalently, that <tt>AND(b<sub>1</sub>,b<sub>2</sub>)</tt> and <tt>AND(b<sub>1</sub>,b<sub>2</sub><font face="symbol">¢</font
>)</tt>
are <tt>equal</tt>, i.e.&nbsp;the same BDD).

<p>
For more details see Henrik Reif Andersen's lecture
notes on BDDs [], where
the algorithm underlying <tt>simplify</tt> is described and attributed to a paper by
Coudert, Berthet and Madre [].

<p>
 <h2><a name="tth_sEc10">
10</a>&nbsp;&nbsp;Saving, hashing and printing BDDs</h2><a name="printing">
</a>

<p>
BDDs can be saved on disk with the functions

<p>

<pre>
   bddSave : string -&#62; bdd -&#62; unit
   bddLoad : string -&#62; bdd

</pre>MLbn]<tt>bddSave</tt>MLbn]<tt>bddLoad</tt>

<p>
The string argument is a file name.

<p>
BuDDy provides two ways of printing BDDs: (i) as the set of paths from
the root node to the <i>true</i> node and (ii) to the format used by
the <tt>dot</tt> graph drawing
program<a href="#tthFtNtAAC" name="tthFrefAAC"><sup>2</sup></a>.

<p>
The function

<p>

<pre>
   hash : bdd -&#62; int

</pre>MLbn]<tt>hash</tt>

<p>
hashes a bdd to an integer.

<p>
The functions for printing BDDs are;

<p>

<pre>
   printset   : bdd -&#62; unit
   printdot   : bdd -&#62; unit
   fnprintset : string -&#62; bdd -&#62; unit
   fnprintdot : string -&#62; bdd -&#62; unit

</pre>MLbn]<tt>printset</tt>MLbn]<tt>printdot</tt>MLbn]<tt>fnprintset</tt>MLbn]<tt>fnprintdot</tt>

<p>
<tt>printset</tt> and <tt>printdot</tt> print to standard output, whilst
<tt>fnprintset</tt> and <tt>fnprintdot</tt> print to a file with the supplied
name.

<p>
<tt>printset</tt> and <tt>fnprintset</tt> print out a sequence of paths, each one having the form

<p>
&nbsp; &lt; m<sub>0</sub><tt>:</tt>n<sub>0</sub><tt>,</tt> <font face="symbol">¼</font
><tt>,</tt> m<sub>l</sub><tt>:</tt>n<sub>l</sub> &gt; 

<p>
where the n<sub>0</sub>, <font face="symbol">¼</font
> , n<sub>l</sub> after the colon (<tt>:</tt>) are <tt>0</tt> or
<tt>1</tt> and indicate that the next node in the path is reached by
following the low (<tt>false</tt>) or high (<tt>true</tt>) pointer,
respectively. 

<p>
For
example, evaluating

<p>
&nbsp;<tt>printset&nbsp;(AND(ithvar&nbsp;0,&nbsp;OR(ithvar&nbsp;1,&nbsp;NOT(ithvar&nbsp;2))))</tt>

<p>
results in

<p>
&nbsp;<tt>&lt;0:1,&nbsp;1:0,&nbsp;2:0&#62;&lt;0:1,&nbsp;1:1&#62;</tt>

<p>
which is best understood by looking at the diagram of the BDD drawn by
<tt>dot</tt> that appears below.

<p>
To illustrate printing to <tt>dot</tt> format,  the same BDD can be
printed to a file <tt>ex</tt> by evaluating

<p>
&nbsp;<tt>fnprintdot&nbsp;&#235;x"&nbsp;(AND(ithvar&nbsp;0,&nbsp;OR(ithvar&nbsp;1,&nbsp;NOT(ithvar&nbsp;2))))</tt>

<p>
executing &nbsp;<tt>dot&nbsp;-Tps&nbsp;ex&nbsp;&#62;&nbsp;ex.ps</tt> (in Unix) results in
the following Postscript diagram of a BDD

<p>

<center><table border="0"><tr><td></td><td><table border="0"><tr><td><a href="ex.ps">Figure</a>
</td></tr></table><!--vbox-->
</td><td> 
</td></tr></table><!--hboxt--></center>

<p>
 <h2><a name="tth_sEc11">
11</a>&nbsp;&nbsp;Dynamic variable reordering</h2>

<p>
BuDDy provides functions for dynamic variable reordering using a variety of methods.
See the BuDDy documentation [] for further details. The dynamic reordering
types and functions provided in ML via MuDDy are in the structure <tt>bdd</tt> and are

<p>
<font size="-2">
<pre>
    eqtype fixed
    FIXED            : fixed
    FREE             : fixed

    addvarblock      : varnum -&#62; varnum -&#62; fixed -&#62; unit
    clrvarblocks     : unit -&#62; unit

    eqtype method
    WIN2             : method
    WIN2ITE          : method
    SIFT             : method
    SIFTITE          : method
    RANDOM           : method
    REORDER_NONE     : method

    reorder          : method -&#62; unit
    autoReorder      : method -&#62; method
    autoReorderTimes : method -&#62; int -&#62; method

    getMethod        : unit -&#62; method
    getTimes         : unit -&#62; int

    disableReorder   : unit -&#62; unit
    enableReorder    : unit -&#62; unit

    varToLevel       : varnum -&#62; int
    varAtLevel       : int -&#62; varnum

</pre></font>

<p>
 <h2><a name="tth_sEc12">
12</a>&nbsp;&nbsp;The MuDDy structure <tt>fdd</tt></h2><a name="fdd">
</a>

<p>
The structure <tt>fdd</tt> provides functions for manipulating values of finite domains.
Functions are provided to allocate blocks of BDD variables to represent integer values instead
of only Booleans.

<p>
Encoding is done with the least significant bits first in the BDD ordering. For example, if variables
v<sub>0</sub>, v<sub>1</sub>, v<sub>2</sub>, v<sub>3</sub> are used to encode 12, then the encoding would yield
v<sub>0</sub>=0, v<sub>1</sub>=0, v<sub>2</sub>=1 and v<sub>3</sub>=1.

<p>
See the BuDDy documentation [] for further details. See the ML structure <tt>fdd</tt>
for the BuDDy facilities provides in ML via MuDDy:

<p>
<font size="-2">
<pre>
   type fddvar

   extDomain  : int list -&#62; fddvar list
   clearAll   : unit -&#62; unit
   domainNum  : unit -&#62; int
   domainSize : fddvar -&#62; int
   varNum     : fddvar -&#62; int
   vars       : fddvar -&#62; bdd.varnum list
   ithSet     : fddvar -&#62; bdd.varSet
   domain     : fddvar -&#62; bdd.bdd
   setPairs   : (fddvar * fddvar) list -&#62; bdd.pairSet

</pre></font>

<p>
 <h2><a name="tth_sEc13">
13</a>&nbsp;&nbsp;The MuDDy structure <tt>bvec</tt></h2><a name="bvec">
</a>

<p>
The structure <tt>bvec</tt> provides tools for encoding integers as arrays
of BDDs, where each BDD represents one bit of an expression.

<p>
See the BuDDy documentation [] for further details. See the ML structure <tt>bvec</tt>
for the BuDDy facilities provides in ML via MuDDy.

<p>
<font size="-2">
<pre>
   type bvec

   bvectrue    : fdd.precision -&#62; bvec 
   bvecfalse   : fdd.precision -&#62; bvec 
   con         : fdd.precision -&#62; int -&#62; bvec
   var         : fdd.precision -&#62; bdd.varnum -&#62; int -&#62; bvec
   varfdd      : fdd.fddvar -&#62; bvec

   coerce      : fdd.precision -&#62; bvec -&#62; bvec

   isConst     : bvec -&#62; bool
   getConst    : bvec -&#62; int
   lookupConst : bvec -&#62; int option

   add         : bvec * bvec -&#62; bvec
   sub         : bvec * bvec -&#62; bvec
   mul         : bvec * bvec -&#62; bvec
   mulfixed    : bvec * int -&#62; bvec
   div         : bvec * bvec -&#62; bvec * bvec
   divfixed    : bvec * int -&#62; bvec * bvec
   divi        : bvec * bvec -&#62; bvec
   divifixed   : bvec * int -&#62; bvec

   modu        : bvec * bvec -&#62; bvec
   modufixed   : bvec * int -&#62; bvec
   shl         : bvec -&#62; bvec -&#62; bdd.bdd -&#62; bvec
   shlfixed    : bvec -&#62; int -&#62; bdd.bdd -&#62; bvec
   shr         : bvec -&#62; bvec -&#62; bdd.bdd -&#62; bvec
   shrfixed    : bvec -&#62; int -&#62; bdd.bdd -&#62; bvec

   lth         : bvec * bvec -&#62; bdd.bdd
   lte         : bvec * bvec -&#62; bdd.bdd
   gth         : bvec * bvec -&#62; bdd.bdd
   gte         : bvec * bvec -&#62; bdd.bdd
   equ         : bvec * bvec -&#62; bdd.bdd
   neq         : bvec * bvec -&#62; bdd.bdd

</pre></font>

<p>
 <h2><a name="tth_sEc14">
14</a>&nbsp;&nbsp;Storage allocation and garbage collection</h2>
<a name="sec:technical-details">
</a>

<p>
The heart of the MuDDypackage is mostly stub code that mirrors the
BuDDyAPI and takes care of translating C values into SML values and
vice versa.

<p>
The most tricky part is to make the Moscow&nbsp;MLgarbage collector cooperate
with the BuDDygarbage collector (we don't want either collector to
try to collect the other's garbage).  The cooperation is done by using
the <em>finalized values</em> facility of the Moscow&nbsp;MLruntime system.
That is, whenever a <tt>bdd</tt> value is returned from the BuDDy
library, MuDDyregister it as an external root (via
<tt>bdd_addref</tt>) and wraps it into a finalized value.  

<p>
A finalized value, in the Moscow&nbsp;MLruntime system, is a pair where the
first component is the <em>destructor</em> (a function pointer) and the
second component is the <em>data</em> (typicaly a pointer).  When the
Moscow&nbsp;MLcollector collect a finalized value it apply the destructor on
the data.  In the case of the MuDDypackage the destructor is
<tt>bdd_delref</tt> and the data is the node-index returned by BuDDy.

<p>
Output showing the activation of the BuDDygarbage collector can be generated
using the function

<p>

<pre>
   verbosegc : (string * string) option -&#62; unit

</pre>MLbn]<tt>verbosegc</tt>

<p>
Evaluating <tt>verbosegc(SOME(pregc,postgc))</tt> instructs BuDDy to print
pregc when a BuDDy GC is initiated and print postgc when the
BuDDyGC is completed.

<p>
<br /><h1>Part 2   <br />Description of <tt>HolBddLib</tt></h1><br /><a name="HolBddLib">
</a>

<p>
<tt>HolBddLib</tt> currently consists of five modules

<p>

<ol type="1"><p>
<li> <tt>Varmap</tt> defines the ML type <tt>varmap</tt> that represents mappings,
often denoted by <font face="symbol">r</font
>,
from HOL variables to BDD variables;</li>
<p>
<li> <tt>PrintBdd</tt> provides rudimentary facilities for printing
BDDs with respect to a varmap;</li>
<p>
<li> <tt>PrimitiveBddRules</tt> defines the protected type <tt>term_bdd</tt>
representing BDD representation judgements a&nbsp;<font face="symbol">r</font
>&nbsp;t&nbsp;<font face="symbol">®</font
>&nbsp;b
with the semantics that under assumptions a, term t is represented by BDD b with respect to
varmap <font face="symbol">r</font
>;</li>
<p>
<li> <tt>DerivedBddRules</tt> defines some derived rules for computing
the representation of the reachable states of a transition system,
and also for finding shortest paths to states  satisfying a given property;</li>
<p>
<li> <tt>DerivedBddRulesTheory</tt> contains HOL reachability and fixedpoint theorems needed
for the derived rules in  <tt>DerivedBddRules</tt>.</li>
</ol>

<p>
Executing

<p>

<pre>
   load "HolBddLib";

</pre>

<p>
loades these five modules and
initialises BuDDy with a nodesize of 1000000
and cachesize of 10000.  

<p>
If you want to perform your own BuDDy initialisation with different
values, then instead of loading <tt>HolBddLib</tt>, load <tt>bdd</tt> and then
call <tt>bdd.init</tt> with the parameters you want (see
Section&nbsp;<a href="#init">1</a>).  <tt>PrimitiveBddRulesTheory</tt> and/or
<tt>DerivedBddRulesTheory</tt> etc.&nbsp;can  then be loaded.

<p>
 <h2><a name="tth_sEc15">
15</a>&nbsp;&nbsp;The structure <tt>Varmap</tt></h2><a name="Varmap">
</a>

<p>
The type <tt>varmap</tt> is defined by

<p>

<pre>
   type varmap = (string, int) Binarymap.dict

</pre>MLty]<tt>varmap</tt>

<p>
Strings are the names of HOL boolean variables and the integers associated with them
are the corresponding BDD variables.

<p>
The following operations and predicates on varmaps are provided:

<p>

<pre>
   empty   : varmap
   insert  : string * int -&#62; varmap -&#62; varmap
   remove  : string -&#62; varmap -&#62; varmap
   peek    : varmap -&#62; string -&#62; int option
   dest    : varmap -&#62; (string * int) list
   eq      : varmap * varmap -&#62; bool
   size    : varmap -&#62; int
   extends : varmap -&#62; varmap -&#62; bool

</pre>MLbn]<tt>Varmap.empty</tt>MLbn]<tt>Varmap.insert</tt>MLbn]<tt>Varmap.remove</tt>MLbn]<tt>Varmap.peek</tt>MLbn]<tt>Varmap.dest</tt>MLbn]<tt>Varmap.eq</tt>
MLbn]<tt>Varmap.size</tt>MLbn]<tt>Varmap.extends</tt>
<p>
with the semantics

<p>
<br /><br />
<table border="1">
<tr><td><tt>Varmap.empty</tt> </td><td>the empty varmap </td></tr>
<tr><td><tt>Varmap.insert</tt> </td><td>add an entry </td></tr>
<tr><td><tt>Varmap.remove</tt> </td><td>delete an entry for a variable </td></tr>
<tr><td><tt>Varmap.peek</tt> </td><td>lookup the value of a variable </td></tr>
<tr><td><tt>Varmap.dest</tt> </td><td>convert to a list of pairs </td></tr>
<tr><td><tt>Varmap.eq</tt> </td><td>pointer equality of varmaps (<i>not</i> general equality) </td></tr>
<tr><td><tt>Varmap.size</tt> </td><td>number of entries </td></tr>
<tr><td><tt>Varmap.extends</tt> </td><td>test if first argument included in second argument</td></tr></table>


<p>
 <h2><a name="tth_sEc16">
16</a>&nbsp;&nbsp;The structure <tt>PrintBdd</tt></h2><a name="PrintBdd">
</a>

<p>
<tt>PrintBdd</tt> builds on top of MuDDy's support for drawing BDDs using the <tt>dot</tt>
program (see Section&nbsp;<a href="#printing">10</a>). Three functions are provided.

<p>

<pre>
   dotBdd             : string -&#62; string -&#62; bdd -&#62; bdd
   dotLabelledTermBdd : string -&#62; string -&#62; term_bdd -&#62; unit
   dotTermBdd         : term_bdd -&#62; unit

</pre>MLbn]<tt>dotBdd</tt>MLbn]<tt>dotLabelledTermBdd</tt>MLbn]<tt>dotTermBdd</tt>
<p>

<dl compact="compact">
 <dt><b><tt>dotBdd</tt>&nbsp;file&nbsp;label&nbsp;bdd</b></dt>
	<dd><br />
prints the BDD bdd to file<tt>.dot</tt> with
the label being the string label. The BDD variables are printed as the numbers used by BuDDy.
The <tt>dot</tt> program is then invoked to create 
a postscript file file<tt>.ps</tt>. The argument BDD is returned.</dd>
 <dt><b><tt>dotLabelledTermBdd</tt>&nbsp;file&nbsp;label&nbsp;tb</b></dt>
	<dd><br />
prints the
BDD part of <tt>term_bdd</tt>tb with the nodes labelled with
the variables specified in the varmap part of tb. A file file<tt>.ps</tt>
is created, and the BDD is labelled with the string label.</dd>
 <dt><b><tt>dotTermBdd</tt>&nbsp;tb</b></dt>
	<dd><br />
prints the
BDD part of <tt>term_bdd</tt>tb with the nodes labelled with
the variables specified in the varmap part of tb. A file <tt>ScratchBdd.ps</tt>
is created, and the BDD is labelled by default with a representation
of the term part of tb. The default labels
can be suppressed (i.e. set to be always the empty string) by assigning <tt>false</tt>
to the global reference <tt>dotTermBddFlag</tt>.</dd>
</dl>

<p>
 <h2><a name="tth_sEc17">
17</a>&nbsp;&nbsp;The structure <tt>PrimitiveBddRules</tt></h2><a name="PrimitiveBddRules">
</a>

<p>
The structure <tt>PrimitiveBddRules</tt> defines the type <tt>term_bdd</tt> by

<p>

<pre>
   type assums = term HOLset.set;
   datatype term_bdd = TermBdd of assums * varmap * term * bdd;

</pre>MLty]<tt>term_bdd</tt>MLty]<tt>assums</tt>

<p>
The constructor <tt>TermBdd</tt> is not exported, so the only way to construct
values of type <tt>term_bdd</tt>is using the following inference rules
(which are described in more detail in the rest of this section).

<p>
<font size="-2">
<pre>
   BddExtendVarmap           : term_bdd-&#62;varmap-&#62;term_bdd
   BddFreevarsContractVarmap : term-&#62;term_bdd-&#62;term_bdd
   BddSupportContractVarmap  : term-&#62;term_bdd-&#62;term_bdd
   BddVar                    : bool-&#62;varmap-&#62;term-&#62;term_bdd
   BddCon                    : bool-&#62;varmap-&#62;term_bdd
   BddNot                    : term_bdd-&#62;term_bdd
   BddIte                    : term_bdd*term_bdd*term_bdd-&#62;term_bdd
   BddOp                     : bddop*term_bdd*term_bdd-&#62;term_bdd
   BddForall                 : term list-&#62;term_bdd-&#62;term_bdd
   BddExists                 : term list-&#62;term_bdd-&#62;term_bdd
   BddAppall                 : term list-&#62;bddop*term_bdd*term_bdd-&#62;term_bdd
   BddAppex                  : term list-&#62;bddop*term_bdd*term_bdd-&#62;term_bdd
   BddCompose                : term_bdd*term_bdd-&#62;term_bdd-&#62;term_bdd
   BddListCompose            : (term_bdd*term_bdd)list-&#62;term_bdd-&#62;term_bdd
   BddRestrict               : (term_bdd*term_bdd)list-&#62;term_bdd-&#62;term_bdd
   BddReplace                : (term_bdd*term_bdd)list-&#62;term_bdd-&#62;term_bdd
   BddEqMp                   : thm-&#62;term_bdd-&#62;term_bdd
   BddSimplify               : term_bdd*term_bdd-&#62;term_bdd

</pre></font>

<p>
Destructor functions <tt>dest_term_bdd</tt>, <tt>getAssums</tt>, <tt>getVarmap</tt>, <tt>getTerm</tt>
and <tt>getBdd</tt> for values of type <tt>term_bdd</tt>are described in Section&nbsp;

<p>
There is also a single oracle function
<tt>BddThmOracle</tt> that derives the HOL theorem a \vdash t
from the representation judgement a&nbsp;<font face="symbol">r</font
>&nbsp;t&nbsp;<font face="symbol">®</font
>&nbsp;<tt>TRUE</tt>
(details are in Section&nbsp;).

<p>
Many of the rules assume that the varmaps in their <tt>term_bdd</tt>
arguments are all equal. To apply these rules to hypotheses with
different varmaps it may be possible to use <tt>BddExtendVarmap</tt>,
<tt>BddFreevarsContractVarmap</tt> or <tt>BddSupportContractVarmap</tt> to make
the varmaps equal.  It is expected that derived rules to enable
judgements with different varmaps to be combined will be implemented,
however, as the soundness conditions for these are potentially subtle,
such rules have not been included in the `trusted kernel'.

<p>
Currently we have no formal treatment of notions of soundness or
completeness for the rules in <tt>PrimitiveBddRules</tt>, though this is
being thought about. We think the rules are `obviously sound', but
such intuitions are known to be unreliable! Our intuition about
completeness is weaker: it is probable that as more experience with
derived rules is obtained, the need for additional primitive rules
will appear. Support for `local scopes' (combining judgements with
different variable orders) is an area that may reveal incompleteness
in the current rules.

<p>
     <h3><a name="tth_sEc17.1">
17.1</a>&nbsp;&nbsp;Rules for generating representation judgements</h3><a name="term-bdd-rules">
</a>

<p>
The notation a<sub>1</sub> <font face="symbol">È</font
>a<sub>2</sub> denotes the union of a<sub>1</sub> and a<sub>2</sub> 
Assumptions of
representation judgements are identified up to <font face="symbol">a</font
>-conversion (as
are assumptions of HOL theorems).
The implementation is a<sub>1</sub> <font face="symbol">È</font
>a<sub>2</sub>&nbsp;=&nbsp;<tt>HOLset</tt><tt>.</tt><tt>union</tt>&nbsp;a<sub>1</sub>&nbsp;a<sub>2</sub>. 
The empty set of assumptions is denoted by <font size="-2">{\xspace}</font>, a set of
assumptions containing terms t<sub>1</sub>, <font face="symbol">¼</font
>,t<sub>n</sub> is denoted by
<font size="-2">{<span class="roman">t</span><sub><span class="roman">1</span></sub><span class="roman">,</span> <font face="symbol">¼</font
><span class="roman">,</span><span class="roman">t</span><sub><span class="roman">n</span></sub>}</font>\xspace  and 
<font size="-2">{\xspace}</font>\xspace&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span> is abbreviated to
&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span>.

<p>

<h4>Extending and contracting the varmap</h4>

<p>
 <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>
<tt>BddExtendVarmap : term_bdd -&gt; varmap -&gt; term_bdd </tt>



<p>
 
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span>&nbsp;<font face="symbol">r</font
><sub><span class="roman">1</span></sub>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font size="-2"><tt>Varmap</tt><tt>.</tt><tt>extends</tt></font>&nbsp;<font face="symbol">r</font
><sub>1</sub>&nbsp;<font face="symbol">r</font
><sub>2</sub></td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span>&nbsp;<font face="symbol">r</font
><sub><span class="roman">2</span></sub>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span></td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>



<p>
 Raises <tt>BddExtendVarmapError</tt> if <font face="symbol">r</font
><sub>2</sub> doesn not extend <font face="symbol">r</font
><sub>1</sub>


</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>BddExtendVarmap</tt>

<p>
<br /><br /> <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>
<tt>BddFreevarsContractVarmap : term -&gt; term_bdd -&gt; term_bdd </tt>



<p>
 
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="roman">v</span> <span class="roman">not</span> <span class="roman">free</span> <span class="roman">in</span> <span class="roman">t</span></td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span>&nbsp;<span class="roman">(</span><font size="-2"><tt>Varmap</tt><tt>.</tt><tt>remove</tt>&nbsp;"</font><span class="roman">v</span><font size="-2">"</font>&nbsp;<font face="symbol">r</font
><span class="roman">)</span>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span></td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>



<p>
 Raises <tt>BddFreevarsContractVarmapError</tt> if v not free in t


</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>BddFreevarsContractVarmap</tt>

<p>
<br /><br /> <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>
<tt>BddSupportContractVarmap : term -&gt; term_bdd -&gt; term_bdd </tt>



<p>
 
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font face="symbol">r</font
><span class="roman">(</span><span class="roman">v</span><span class="roman">)</span> <span class="roman">does</span> <span class="roman">occur</span> <span class="roman">in</span> <span class="roman">b</span></td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span>&nbsp;<span class="roman">(</span><font size="-2"><tt>Varmap</tt><tt>.</tt><tt>remove</tt>&nbsp;"</font><span class="roman">v</span><font size="-2">"</font>&nbsp;<font face="symbol">r</font
><span class="roman">)</span>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span></td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>



<p>
 Raises <tt>BddSupportContractVarmapError</tt> if <font face="symbol">r</font
>(v) not in the support of b


</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>BddSupportContractVarmap</tt>

<p>

<h4>Variables and constants</h4>

<p>
 <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>
<tt>BddVar : bool -&gt; varmap -&gt; term -&gt; term_bdd  </tt>



<p>
 
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<font face="symbol">r</font
>(v)=n</td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">v</span>&nbsp;<font face="symbol">®</font
>&nbsp;<font size="-2"><tt>ithvar</tt></font>&nbsp;<span class="roman">n</span></td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
 &nbsp;<font size="-2"><tt>BddVar</tt>&nbsp;<tt>true</tt></td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<font face="symbol">r</font
>(v)=n</td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">v</span>&nbsp;<font face="symbol">®</font
>&nbsp;<font size="-2"><tt>nithvar</tt></font>&nbsp;<span class="roman">n</span></td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
&nbsp; <font size="-2"><tt>BddVar</tt>&nbsp;<tt>false</tt></font></td></tr></table></td></tr></font></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>



<p>
 Raises <tt>BddVarError</tt> if v not in the domain of <font face="symbol">r</font
>


</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>BddVar</tt>

<p>
<br /><br /> <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>
<tt>BddCon : bool -&gt; varmap -&gt; term_bdd  </tt>



<p>
 
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
</td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">r</font
>&nbsp;<font size="-2"><tt>T</tt></font>&nbsp;<font face="symbol">®</font
>&nbsp;<font size="-2"><tt>TRUE</tt></font></td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
 &nbsp;<font size="-2"><tt>BddCon</tt>&nbsp;<tt>true</tt></td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
</td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
&nbsp;<font face="symbol">r</font
>&nbsp;<font size="-2"><tt>F</tt></font>&nbsp;<font face="symbol">®</font
>&nbsp;<font size="-2"><tt>FALSE</tt></font>&nbsp;<span class="roman">n</span></td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
&nbsp; <font size="-2"><tt>BddCon</tt>&nbsp;<tt>false</tt></font></td></tr></table></td></tr></font></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>



<p>
 Always succeeds


</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>BddCon</tt>

<p>

<h4>Boolean operations</h4>

<p>
 <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>
<tt>BddNot : term_bdd -&gt; term_bdd </tt>



<p>
 
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span></td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span>&nbsp;<font face="symbol">r</font
>&nbsp;<font face="symbol">Ø</font
><span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<font size="-2"><tt>NOT</tt></font>&nbsp;<span class="roman">b</span></td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>



<p>
 Always succeeds


</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>BddNot</tt>

<p>
<br /><br /> <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>
<tt>BddIte : term_bdd * term_bdd * term_bdd -&gt; term_bdd </tt>



<p>
 
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="roman">a</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">1</span></sub> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="roman">a</span><sub><span class="roman">2</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span><sub><span class="roman">2</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">2</span></sub></td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span> <font face="symbol">È</font
><span class="roman">a</span><sub><span class="roman">1</span></sub> <font face="symbol">È</font
><span class="roman">a</span><sub><span class="roman">2</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<font size="-2"><tt>(</tt><tt>if</tt>&nbsp;<span class="roman">t</span>&nbsp;<span class="roman">then</span>&nbsp;<span class="roman">t</span><sub><span class="roman">1</span></sub>&nbsp;<span class="roman">else</span>&nbsp;<span class="roman">t</span><sub><span class="roman">2</span></sub><span class="roman">)</span></font>&nbsp;<font face="symbol">®</font
>&nbsp;<font size="-2"><tt>ITE</tt></font>&nbsp;<span class="roman">b</span>&nbsp;<span class="roman">b</span><sub><span class="roman">1</span></sub>&nbsp;<span class="roman">b</span><sub><span class="roman">2</span></sub></td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>



<p>
 Raises <font size="-2"><tt>BddIteError</tt></font> if the varmaps of the hypotheses are not all 
pointer equal


</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>BddIte</tt>

<p>
<br /><br /> <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>
<tt>BddOp : bddop * term_bdd * term_bdd -&gt; term_bdd </tt>



<p>
 
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">1</span></sub> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="roman">a</span><sub><span class="roman">2</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span><sub><span class="roman">2</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">2</span></sub></td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span><sub><span class="roman">1</span></sub><font face="symbol">È</font
><span class="roman">a</span><sub><span class="roman">2</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<font size="-2"><tt>(</tt><tt>termApply</tt></font>&nbsp;<span class="roman">t</span><sub><span class="roman">1</span></sub>&nbsp;<span class="roman">t</span><sub><span class="roman">2</span></sub>&nbsp;<span class="roman">bddop</span><font size="-2"><tt>)</tt></font>&nbsp;<font face="symbol">®</font
>&nbsp;<font size="-2"><tt>apply</tt></font>&nbsp;<span class="roman">b</span><sub><span class="roman">1</span></sub>&nbsp;<span class="roman">b</span><sub><span class="roman">2</span></sub>&nbsp;<span class="roman">bddop</span></td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>



<p>
 <tt>termApply&nbsp;t<sub>1</sub>&nbsp;t<sub>2</sub>&nbsp;bddop</tt> applies
the HOL operation
corresponding to the BuDDyBDD operation bddop to terms t<sub>1</sub> and t<sub>2</sub>
(see Section&nbsp;). The exception 
<font size="-2"><tt>BddOpError</tt></font> is raised if the varmaps of the hypotheses are not pointer equal


</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>BddOp</tt>

<p>

<h4>Quantification</h4>

<p>
 <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>
<tt>BddForall : term list -&gt; term_bdd -&gt; term_bdd </tt>



<p>
 
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font face="symbol">r</font
>(v<sub>1</sub>)=n<sub>1</sub>,&nbsp; <font face="symbol">¼</font
>&nbsp;,&nbsp; <font face="symbol">r</font
>(v<sub>i</sub>)=n<sub>i</sub></td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">(</span><font size="-2"><font face="symbol">"</font
></font> <span class="roman">v</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">¼</font
>&nbsp;<span class="roman">v</span><sub><span class="roman">i</span></sub><span class="roman">.</span>&nbsp;<span class="roman">t</span><span class="roman">)</span>&nbsp;<font face="symbol">®</font
>&nbsp;<font size="-2"><tt>forall</tt>&nbsp;<tt>(</tt><tt>makeset</tt><tt>[</tt></font><span class="roman">n</span><sub><span class="roman">1</span></sub><span class="roman">,</span><font face="symbol">¼</font
><span class="roman">,</span><span class="roman">n</span><sub><span class="roman">i</span></sub><font size="-2"><tt>]</tt><tt>)</tt></font>&nbsp;<span class="roman">b</span></td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>



<p>
 Raises <tt>BddForallError</tt> if any of the terms in the term list argument
are not boolean variables in the domain of <font face="symbol">r</font
>,
or occur free in any assumption


</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>BddForall</tt>

<p>
<br /><br /> <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>
<tt>BddExists : term list -&gt; term_bdd -&gt; term_bdd </tt>



<p>
 
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font face="symbol">r</font
>(v<sub>1</sub>)=n<sub>1</sub>,&nbsp; <font face="symbol">¼</font
>&nbsp;,&nbsp; <font face="symbol">r</font
>(v<sub>i</sub>)=n<sub>i</sub></td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">(</span><font size="-2"><font face="symbol">$</font
></font> <span class="roman">v</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">¼</font
>&nbsp;<span class="roman">v</span><sub><span class="roman">i</span></sub><span class="roman">.</span>&nbsp;<span class="roman">t</span><span class="roman">)</span>&nbsp;<font face="symbol">®</font
>&nbsp;<font size="-2"><tt>exist</tt>&nbsp;<tt>(</tt><tt>makeset</tt><tt>[</tt></font><span class="roman">n</span><sub><span class="roman">1</span></sub><span class="roman">,</span><font face="symbol">¼</font
><span class="roman">,</span><span class="roman">n</span><sub><span class="roman">i</span></sub><font size="-2"><tt>]</tt><tt>)</tt></font>&nbsp;<span class="roman">b</span></td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>



<p>
 Raises <tt>BddExistsError</tt> if any of the terms in the term list argument
are not boolean variables in the domain of <font face="symbol">r</font
>,
or occur free in any assumption


</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>BddExists</tt>

<p>
<br /><br /> <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>
<tt>BddAppall : term list -&gt; bddop * term_bdd * term_bdd -&gt; term_bdd</tt>



<p>
 
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">1</span></sub> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="roman">a</span><sub><span class="roman">2</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span><sub><span class="roman">2</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">2</span></sub> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font face="symbol">r</font
>(v<sub>1</sub>)=n<sub>1</sub>,&nbsp; <font face="symbol">¼</font
>&nbsp;,&nbsp; <font face="symbol">r</font
>(v<sub>i</sub>)=n<sub>i</sub></td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
a<sub>1</sub> <font face="symbol">È</font
>a<sub>2</sub>&nbsp;<font face="symbol">r</font
>&nbsp;(<font size="-2"><font face="symbol">"</font
></font> v<sub>1</sub>&nbsp;<font face="symbol">¼</font
>&nbsp;v<sub>i</sub>.&nbsp;<font size="-2"><tt>termApply</tt></font>&nbsp;t<sub>1</sub>&nbsp;t<sub>2</sub>&nbsp;bddop)</td></tr></table></td></tr>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<font face="symbol">®</font
></td></tr></table></td></tr>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<font size="-2"><tt>appall</tt></font>&nbsp;b<sub>1</sub>&nbsp;b<sub>2</sub>&nbsp;bddop&nbsp;<font size="-2"><tt>(</tt><tt>makeset</tt><tt>[</tt></font>n<sub>1</sub>,<font face="symbol">¼</font
>,n<sub>i</sub><font size="-2"><tt>]</tt><tt>)</tt></font>&nbsp;b</td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>



<p>
 Raises <tt>BddAppallError</tt> if the varmaps in the hypotheses are not pointer equal, or
if any of the terms in the term list argument
are not boolean variables in the domain of <font face="symbol">r</font
>,
or occur free in any assumption


</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>BddAppall</tt>

<p>
<br /><br /> <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>
<tt>BddAppex : term list -&gt; bddop * term_bdd * term_bdd -&gt; term_bdd</tt>



<p>
 
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">1</span></sub> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="roman">a</span><sub><span class="roman">2</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span><sub><span class="roman">2</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">2</span></sub> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font face="symbol">r</font
>(v<sub>1</sub>)=n<sub>1</sub>,&nbsp; <font face="symbol">¼</font
>&nbsp;,&nbsp; <font face="symbol">r</font
>(v<sub>i</sub>)=n<sub>i</sub></td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
a<sub>1</sub> <font face="symbol">È</font
>a<sub>2</sub>&nbsp;<font face="symbol">r</font
>&nbsp;(<font size="-2"><font face="symbol">$</font
></font> v<sub>1</sub>&nbsp;<font face="symbol">¼</font
>&nbsp;v<sub>i</sub>.&nbsp;<font size="-2"><tt>termApply</tt></font>&nbsp;t<sub>1</sub>&nbsp;t<sub>2</sub>&nbsp;bddop)</td></tr></table></td></tr>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<font face="symbol">®</font
></td></tr></table></td></tr>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<font size="-2"><tt>appex</tt></font>&nbsp;b<sub>1</sub>&nbsp;b<sub>2</sub>&nbsp;bddop&nbsp;<font size="-2"><tt>(</tt><tt>makeset</tt><tt>[</tt></font>n<sub>1</sub>,<font face="symbol">¼</font
>,n<sub>i</sub><font size="-2"><tt>]</tt><tt>)</tt></font>&nbsp;b</td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>



<p>
 Raises <tt>BddAppexError</tt> if the varmaps of the hypotheses are not pointer equal, or
if any of the terms in the term list argument
are not boolean variables in the domain of <font face="symbol">r</font
>,
or occur free in any assumption


</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>BddAppex</tt>

<p>

<h4>Composition, repacement and restriction</h4>

<p>
 <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>
<tt>BddCompose : term_bdd * term_bdd -&gt; term_bdd -&gt; term_bdd </tt>



<p>
 
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
(<span class="roman">a</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">v</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">1</span></sub>,&nbsp;&nbsp; <span class="roman">a</span><sub><span class="roman">2</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">1</span></sub><font face="symbol">¢</font
>) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="roman">a</span>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span> </td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span><sub><span class="roman">1</span></sub> <font face="symbol">È</font
><span class="roman">a</span><sub><span class="roman">2</span></sub> <font face="symbol">È</font
><span class="roman">a</span>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">(</span><font size="-2"><tt>subst</tt><tt>[</tt><span class="roman">v</span><sub><span class="roman">1</span></sub> <font face="symbol">|</font
><font face="symbol">-</font
> &gt;  <span class="roman">t</span><sub><span class="roman">1</span></sub><span class="roman">]</span> <span class="roman">t</span></font><span class="roman">)</span>&nbsp;<font face="symbol">®</font
>&nbsp;<font size="-2"><tt>compose</tt><tt>(</tt><tt>var</tt> <span class="roman">b</span><sub><span class="roman">1</span></sub><span class="roman">,</span> <span class="roman">b</span><sub><span class="roman">1</span></sub><font face="symbol">¢</font
><span class="roman">)</span> <span class="roman">b</span></font></td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>



<p>
 Raises <tt>BddComposeError</tt> if varmaps in the hypotheses are not pointer equal,
or the term v<sub>1</sub> is not a variable


</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>BddCompose</tt>

<p>
<br /><br /> <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>
<tt>BddListCompose :  (term_bdd * term_bdd) list -&gt; term_bdd -&gt; term_bdd </tt>



<p>
 
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<font size="-2"><tt>[</tt></font> (<span class="roman">a</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">v</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">1</span></sub>,&nbsp;&nbsp; <span class="roman">a</span><sub><span class="roman">1</span></sub><font face="symbol">¢</font
>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">1</span></sub><font face="symbol">¢</font
>), </td></tr></table></td></tr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
:</td></tr></table></td></tr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
(<span class="roman">a</span><sub><span class="roman">i</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">v</span><sub><span class="roman">i</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">i</span></sub>,&nbsp;&nbsp;&nbsp;&nbsp; <span class="roman">a</span><sub><span class="roman">i</span></sub><font face="symbol">¢</font
>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span><sub><span class="roman">i</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">i</span></sub><font face="symbol">¢</font
>)<font size="-2"><tt>]</tt></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="roman">a</span>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span> </td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
a<sub>1</sub> <font face="symbol">È</font
>a<sub>1</sub><font face="symbol">¢</font
>&nbsp;<font face="symbol">È</font
>&nbsp;<font face="symbol">¼</font
>&nbsp;<font face="symbol">È</font
>&nbsp;a<sub>i</sub> <font face="symbol">È</font
>a<sub>i</sub><font face="symbol">¢</font
><font face="symbol">È</font
>a</td></tr></table></td></tr>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<font face="symbol">r</font
></td></tr></table></td></tr>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<font size="-2"><tt>subst</tt><tt>[</tt><tt>v</tt><sub><tt>1</tt></sub> <font face="symbol">|</font
><font face="symbol">-</font
> &gt;  <tt>t</tt><sub><tt>1</tt></sub><tt>,</tt>&nbsp;<font face="symbol">¼</font
>&nbsp;<tt>,</tt>&nbsp;<tt>v</tt><sub><tt>i</tt></sub> <font face="symbol">|</font
><font face="symbol">-</font
> &gt;  <tt>t</tt><sub><tt>i</tt></sub><tt>]</tt> <tt>t</tt></font></td></tr></table></td></tr>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<font face="symbol">®</font
></td></tr></table></td></tr>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<font size="-2"><tt>veccompose</tt><tt>(</tt><tt>composeSet</tt><tt>[</tt><tt>(</tt><tt>var</tt> <tt>b</tt><sub><tt>1</tt></sub><tt>,</tt> <tt>b</tt><sub><tt>1</tt></sub><font face="symbol">¢</font
><tt>)</tt><tt>,</tt>&nbsp;<font face="symbol">¼</font
>&nbsp;<tt>,</tt>&nbsp;<tt>(</tt><tt>var</tt> <tt>b</tt><sub><tt>i</tt></sub><tt>,</tt> <tt>b</tt><sub><tt>i</tt></sub><font face="symbol">¢</font
><tt>)</tt><tt>]</tt><tt>)</tt><tt>b</tt></font></td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>



<p>
 Raises <tt>BddListComposeError</tt> if the varmaps in the hypotheses are not all pointer equal,
or if any of the terms v<sub>1</sub>,<font face="symbol">¼</font
>,v<sub>i</sub> are repeated or are not variables


</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>BddListCompose</tt>

<p>
<br /><br /> <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>
<tt>BddRestrict :  (term_bdd * term_bdd) list -&gt; term_bdd -&gt; term_bdd </tt>



<p>
 
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<font size="-2"><tt>[</tt></font> (<span class="roman">a</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">v</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">1</span></sub>,&nbsp;&nbsp; <span class="roman">a</span><sub><span class="roman">1</span></sub><font face="symbol">¢</font
>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">c</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">1</span></sub><font face="symbol">¢</font
>), </td></tr></table></td></tr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
:</td></tr></table></td></tr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
(<span class="roman">a</span><sub><span class="roman">i</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">v</span><sub><span class="roman">i</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">i</span></sub>,&nbsp;&nbsp;&nbsp;&nbsp; <span class="roman">a</span><sub><span class="roman">i</span></sub><font face="symbol">¢</font
>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">c</span><sub><span class="roman">i</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">i</span></sub><font face="symbol">¢</font
>)<font size="-2"><tt>]</tt></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="roman">a</span>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span> </td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
a<sub>1</sub> <font face="symbol">È</font
>a<sub>1</sub><font face="symbol">¢</font
>&nbsp;<font face="symbol">È</font
>&nbsp;<font face="symbol">¼</font
>&nbsp;<font face="symbol">È</font
>&nbsp;a<sub>i</sub> <font face="symbol">È</font
>a<sub>i</sub><font face="symbol">¢</font
><font face="symbol">È</font
>a</td></tr></table></td></tr>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<font face="symbol">r</font
></td></tr></table></td></tr>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<font size="-2"><tt>subst</tt><tt>[</tt><tt>v</tt><sub><tt>1</tt></sub> <font face="symbol">|</font
><font face="symbol">-</font
> &gt;  <tt>c</tt><sub><tt>1</tt></sub><tt>,</tt>&nbsp;<font face="symbol">¼</font
>&nbsp;<tt>,</tt>&nbsp;<tt>v</tt><sub><tt>i</tt></sub> <font face="symbol">|</font
><font face="symbol">-</font
> &gt;  <tt>c</tt><sub><tt>i</tt></sub><tt>]</tt> <tt>t</tt></font></td></tr></table></td></tr>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<font face="symbol">®</font
></td></tr></table></td></tr>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<font size="-2"><tt>restrict</tt>&nbsp;<tt>b</tt>&nbsp;<tt>(</tt><tt>assignment</tt><tt>[</tt><tt>(</tt><tt>var</tt> <tt>b</tt><sub><tt>1</tt></sub><tt>,</tt> [^(<tt>c</tt><sub><tt>1</tt></sub>)]<tt>)</tt><tt>,</tt>&nbsp;<font face="symbol">¼</font
>&nbsp;<tt>,</tt>&nbsp;<tt>(</tt><tt>var</tt> <tt>b</tt><sub><tt>i</tt></sub><tt>,</tt> [^(<tt>c</tt><sub><tt>i</tt></sub>)]<tt>)</tt><tt>]</tt><tt>)</tt></font></td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>



<p>
 Where each of c<sub>1</sub>,<font face="symbol">¼</font
>,c<sub>i</sub> is either the constant <tt>F</tt> or the constant <tt>F</tt>,
and [^(<tt>T</tt>)] denotes the ML value <tt>true</tt> and
[^(<tt>F</tt>)] denotes <tt>false</tt>. The exception
<tt>BddRestrictError</tt> is raised if the varmaps in the hypotheses are not all pointer equal,
or if any of the terms v<sub>1</sub>,<font face="symbol">¼</font
>,v<sub>i</sub> are repeated or are not variables,
or if any of c<sub>1</sub>,<font face="symbol">¼</font
>,c<sub>i</sub> are not equal to <tt>T</tt> or <tt>F</tt>


</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>BddRestrict</tt>

<p>
<br /><br /> <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>
<tt>BddReplace :  (term_bdd * term_bdd) list -&gt; term_bdd -&gt; term_bdd </tt>



<p>
 
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<font size="-2"><tt>[</tt></font> (<span class="roman">a</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">v</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">1</span></sub>,&nbsp;&nbsp; <span class="roman">a</span><sub><span class="roman">1</span></sub><font face="symbol">¢</font
>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">v</span><sub><span class="roman">1</span></sub><font face="symbol">¢</font
>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">1</span></sub><font face="symbol">¢</font
>), </td></tr></table></td></tr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
:</td></tr></table></td></tr>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
(<span class="roman">a</span><sub><span class="roman">i</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">v</span><sub><span class="roman">i</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">i</span></sub>,&nbsp;&nbsp;&nbsp;&nbsp; <span class="roman">a</span><sub><span class="roman">i</span></sub><font face="symbol">¢</font
>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">v</span><sub><span class="roman">i</span></sub><font face="symbol">¢</font
>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">i</span></sub><font face="symbol">¢</font
>)<font size="-2"><tt>]</tt></font>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="roman">a</span>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span> </td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
a<sub>1</sub> <font face="symbol">È</font
>a<sub>1</sub><font face="symbol">¢</font
>&nbsp;<font face="symbol">È</font
>&nbsp;<font face="symbol">¼</font
>&nbsp;<font face="symbol">È</font
>&nbsp;a<sub>i</sub> <font face="symbol">È</font
>a<sub>i</sub><font face="symbol">¢</font
><font face="symbol">È</font
>a</td></tr></table></td></tr>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<font face="symbol">r</font
></td></tr></table></td></tr>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<font size="-2"><tt>subst</tt><tt>[</tt><tt>v</tt><sub><tt>1</tt></sub> <font face="symbol">|</font
><font face="symbol">-</font
> &gt;  <tt>v</tt><sub><tt>1</tt></sub><font face="symbol">¢</font
><tt>,</tt>&nbsp;<font face="symbol">¼</font
>&nbsp;<tt>,</tt>&nbsp;<tt>v</tt><sub><tt>i</tt></sub> <font face="symbol">|</font
><font face="symbol">-</font
> &gt;  <tt>v</tt><sub><tt>i</tt></sub><font face="symbol">¢</font
><tt>]</tt> <tt>t</tt></font></td></tr></table></td></tr>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<font face="symbol">®</font
></td></tr></table></td></tr>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<font size="-2"><tt>replace</tt>&nbsp;<tt>b</tt>&nbsp;<tt>(</tt><tt>makepairSet</tt><tt>[</tt><tt>(</tt><tt>var</tt> <tt>b</tt><sub><tt>1</tt></sub><tt>,</tt> <tt>var</tt> <tt>b</tt><sub><tt>1</tt></sub><font face="symbol">¢</font
><tt>)</tt><tt>,</tt>&nbsp;<font face="symbol">¼</font
>&nbsp;<tt>,</tt>&nbsp;<tt>(</tt><tt>var</tt> <tt>b</tt><sub><tt>i</tt></sub><tt>,</tt> <tt>var</tt> <tt>b</tt><sub><tt>i</tt></sub><font face="symbol">¢</font
><tt>)</tt><tt>]</tt><tt>)</tt></font></td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>



<p>
 Raises <tt>BddReplaceError</tt> if the varmaps in the hypotheses are not all pointer equal,
or if any of the terms v<sub>1</sub>,<font face="symbol">¼</font
>,v<sub>i</sub> are repeated or are not variables,
or if any of the terms v<sub>1</sub><font face="symbol">¢</font
>,<font face="symbol">¼</font
>,v<sub>i</sub><font face="symbol">¢</font
> are repeated or are not variables


</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>BddReplace</tt>

<p>

<h4>Coudert, Berthet &amp; Madre simplification</h4><a name="BddSimplify">
</a>

<p>
 <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>
<tt>BddSimplify : term_bdd * term_bdd -&gt; term_bdd </tt>



<p>
 
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">1</span></sub> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="roman">a</span><sub><span class="roman">2</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span><sub><span class="roman">2</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span><sub><span class="roman">2</span></sub></td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span><sub><span class="roman">1</span></sub><font face="symbol">È</font
><span class="roman">a</span><sub><span class="roman">2</span></sub><font face="symbol">È</font
><font size="-2"></font>{<span class="roman">t</span><sub><span class="roman">1</span></sub>}\xspace&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span><sub><span class="roman">2</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<font size="-2"><tt>simplify</tt></font>&nbsp;<span class="roman">b</span><sub><span class="roman">1</span></sub>&nbsp;<span class="roman">b</span><sub><span class="roman">2</span></sub></td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>



<p>
 The exception 
<font size="-2"><tt>BddSimplifyError</tt></font> is raised if the varmaps in the hypotheses are not pointer equal


</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>BddSimplify</tt>

<p>
     <h3><a name="tth_sEc17.2">
17.2</a>&nbsp;&nbsp;Linking representation judgements to theorems</h3><a name="oracle">
</a>

<p>
 <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>
<tt>BddThmOracle : term_bdd -&gt; thm</tt>

<p>
 
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<tt>TRUE</tt></td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<tt>[</tt><tt>oracles</tt><tt>:</tt>&nbsp;<tt>HolBdd</tt><tt>]</tt>&nbsp; a \vdash t</td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>



<p>
 Allows HOL theorems to be `proved' by BDD calculation using BuDDy.
Such theorems, and any theorems deduced from them, are tagged with
<tt>HolBdd</tt> and so can be easily identified.


</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>BddThmOracle</tt>

<p>
<br /><br /> <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>
<tt>BddEqMp : thm -&gt; term_bdd -&gt; term_bdd</tt>

<p>
 
<br clear="all" /><table border="0" width="100%"><tr><td>
<table align="center"><tr><td nowrap="nowrap" align="center">
</td><td nowrap="nowrap" align="center">
<table>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
a<sub>1</sub> \vdash t<sub>1</sub>=t<sub>2</sub> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span class="roman">a</span><sub><span class="roman">2</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span><sub><span class="roman">1</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </td></tr></table></td></tr>
<tr><td align="center"><table border="0"><tr><td nowrap="nowrap" align="center">
<span class="roman">a</span><sub><span class="roman">1</span></sub> <font face="symbol">È</font
><span class="roman">a</span><sub><span class="roman">2</span></sub>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span><sub><span class="roman">2</span></sub>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span></td></tr></table></td></tr></table>
</td><td nowrap="nowrap" align="center">
</td></tr></table>
</td></tr></table>

<a name="BddEqMp">
</a>

<p>
 Enables the term part of a representation judgement to be replaced
by a logically equivalent term. Raises <tt>BddEqMpError</tt>
if the left hand side of the equation
isn't <font face="symbol">a</font
>-convertable to the term part of the representation judgement


</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>BddEqMp</tt>

<p>
     <h3><a name="tth_sEc17.3">
17.3</a>&nbsp;&nbsp;Miscellaneous functions</h3><a name="misc">
</a>

<p>

<p>
 <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>

<pre>
dest_term_bdd : term_bdd -&#62; assums * varmap * term * bdd
getAssums     : term_bdd -&#62; assums
getVarmap     : term_bdd -&#62; varmap
getTerm       : term_bdd -&#62; term
getBdd        : term_bdd -&#62; bdd

</pre>



<p>
 
<table>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<tt>dest</tt><tt>_</tt><tt>term</tt><tt>_</tt><tt>bdd</tt>&nbsp;(<span class="roman">a</span>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span>)</td></tr></table></td><td><table border="0"><tr><td nowrap="nowrap" align="center">
=&nbsp;(<font face="symbol">r</font
>, t, b)</td></tr></table></td></tr>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<tt>getVarmap</tt>&nbsp;(<span class="roman">a</span>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span>)</td></tr></table></td><td><table border="0"><tr><td nowrap="nowrap" align="center">
=&nbsp;<font face="symbol">r</font
></td></tr></table></td></tr>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<tt>getTerm</tt>&nbsp;(<span class="roman">a</span>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span>)</td></tr></table></td><td><table border="0"><tr><td nowrap="nowrap" align="center">
=&nbsp;t</td></tr></table></td></tr>
<tr><td><table border="0"><tr><td nowrap="nowrap" align="center">
<tt>getBdd</tt>&nbsp;(<span class="roman">a</span>&nbsp;<font face="symbol">r</font
>&nbsp;<span class="roman">t</span>&nbsp;<font face="symbol">®</font
>&nbsp;<span class="roman">b</span>)</td></tr></table></td><td><table border="0"><tr><td nowrap="nowrap" align="center">
=&nbsp;b</td></tr></table></td></tr></table>



</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>destructors</tt>

<p>
<br /><br /> <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>
<tt>inSupport : int -&gt; bdd -&gt; bool </tt>



<p>
 <tt>inSupport</tt>&nbsp;n&nbsp;b checks if the BDD variable n occurs in the BDD b


</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>inSupport</tt>

<p>
<br /><br /> <table border="0"><tr><td></td><td><table border="0"><tr><td> 

<p>
<tt>termApply : term -&gt; term -&gt; bddop -&gt; term</tt>



<p>
 <tt>termApply</tt>&nbsp;t<sub>1</sub>&nbsp;t<sub>2</sub>&nbsp;bddop applies the HOL operation
corresponding to bddop to t<sub>1</sub> and t<sub>2</sub>.

<p>

<pre>
   fun termApply t1 t2 bddop =
    case bddop of
       And    =&#62; mk_conj(t1,t2)
     | Biimp  =&#62; mk_eq(t1,t2)
     | Diff   =&#62; mk_conj(t1, mk_neg t2)
     | Imp    =&#62; mk_imp(t1,t2)
     | Invimp =&#62; mk_imp(t2,t1)
     | Lessth =&#62; mk_conj(mk_neg t1, t2)
     | Nand   =&#62; mk_neg(mk_conj(t1,t2))
     | Nor    =&#62; mk_neg(mk_disj(t1,t2))
     | Or     =&#62; mk_disj(t1,t2)
     | Xor    =&#62; mk_neg(mk_eq(t1,t2));

</pre>


</td></tr></table><!--vbox-->
</td><td></td></tr></table><!--hboxt--><table align="left" border="1"><tr><td width="0" align="center">
</td></tr></table><!--hbox-->
<br clear="all" />MLbn]<tt>termApply</tt>

<p>
 <h2><a name="tth_sEc18">
18</a>&nbsp;&nbsp;The structure <tt>DerivedBddRules</tt></h2><a name="DerivedBddRules">
</a>

<p>
The documentation is this section is preliminary, reflecting the
current status of the module <tt>PrimitiveBddRules</tt>. What follows is an edited
copy of the source file <tt>PrimitiveBddRules.sml</tt> in which the comments
are preserved, but most of the ML source code has been eliminated
(some is left, if it is thought to be of
pedagogical or documentation value).

<p>
<font size="-2">
<pre>

(*****************************************************************************)
(* Test equality of BDD component of two term_bdds and return true or false  *)
(*****************************************************************************)

fun BddEqualTest tb1 tb2 = bdd.equal (getBdd tb1) (getBdd tb2);

(*****************************************************************************)
(* Test if the BDD part is TRUE or FALSE                                     *)
(*****************************************************************************)

fun isTRUE  tb = bdd.equal (getBdd tb) bdd.TRUE
and isFALSE tb = bdd.equal (getBdd tb) bdd.FALSE;

(*****************************************************************************)
(* Count number of states (code from Ken Larsen)                             *)
(*****************************************************************************)

statecount : bdd -&#62; real

(*****************************************************************************)
(* Destruct a term corresponding to a BuDDY BDD binary operation (bddop).    *)
(* Fail if not such a term.                                                  *)
(*****************************************************************************)

exception dest_BddOpError;

dest_BddOp : term -&#62; bddop * term * term

(*****************************************************************************)
(* Scan a term and construct a term_bdd using the primitive operations       *)
(* when applicable, and a supplied function on leaves when all else fails    *)
(*****************************************************************************)

GenTermToTermBdd : (term -&#62; term_bdd) -&#62; varmap -&#62; term -&#62; term_bdd

(*****************************************************************************)
(* Extend a varmap with a list of variables                                  *)
(* (allocating new BDD variables, if necessary)                              *)
(*****************************************************************************)

extendVarmap : term list -&#62; varmap -&#62; varmap





(*****************************************************************************)
(* Convert a BDD to a nested conditional term with respect to a varmap       *)
(*****************************************************************************)

exception bddToTermError;

bddToTerm : varmap -&#62; bdd -&#62; term

(*****************************************************************************)
(*               ass vm tm |--&#62; b                                            *)
(*  -----------------------------------------------                          *)
(*  [oracles: HolBdd] ass |- tm = ^(bddToTerm vm b)                          *)
(*****************************************************************************)

TermBddToEqThm : term_bdd -&#62; thm

(*****************************************************************************)
(* Global assignable varmap                                                  *)
(*****************************************************************************)

val global_varmap = ref(Varmap.empty);

fun showVarmap () = Varmap.dest(!global_varmap);

(*****************************************************************************)
(* Add variables to global_varmap and then call GenTermToTermBdd             *)
(* using the global function !termToTermBddFun on leaves                     *)
(*****************************************************************************)

exception termToTermBddError;

val termToTermBddFun = 
 ref(fn (tm:term) =&#62; (raise termToTermBddError));

fun termToTermBdd tm =
 let val vl = rev(all_vars tm)     (* all_vars returns vars in reverse order *)
     val vm = extendVarmap vl (!global_varmap)
     val _  = global_varmap := vm
 in
  GenTermToTermBdd (!termToTermBddFun) vm tm
 end;



(*****************************************************************************)
(* MkIterThms ReachBy_rec``R((v1,...,vn),(v1',...,vn'))`` ``B(v1,...,vn)`` = *)
(*  ([|- ReachBy R B 0 (v1,...,vn) = B(v1,...,vn),                           *)
(*    |- !n. ReachBy R B (SUC n) (v1,...,vn) =                               *)
(*                ReachBy R B n (v1,...,vn)                                  *)
(*                \/                                                         *)
(*                ?v1'...vn'. ReachBy R B n (v1',...,vn')                    *)
(*                            /\                                             *)
(*                            R ((v1',...,vn'),(v1,...,vn))]                 *)
(*                                                                           *)
(* MkIterThms ReachIn_rec``R((v1,...,vn),(v1',...,vn'))`` ``B(v1,...,vn)`` = *)
(*  ([|- ReachIn R B 0 (v1,...,vn) = B(v1,...,vn),                           *)
(*    |- !n. ReachIn R B (SUC n) (v1,...,vn) =                               *)
(*                ?v1'...vn'. ReachIn R B n (v1',...,vn')                    *)
(*                            /\                                             *)
(*                            R ((v1',...,vn'),(v1,...,vn))]                 *)
(*****************************************************************************)

MkIterThms : thm -&#62; term -&#62; term -&#62; thm * thm

(*****************************************************************************)
(* Perform disjunctive partitioning. Assume R is of the form                 *)
(*                                                                           *)
(*  R((x,y,z),(x',y',z'))=                                                   *)
(*       ((x' = E1(x,y,z)) /\ (y' = y)         /\ (z' = z))                  *)
(*    \/ ((x' = x)         /\ (y' = E2(x,y,z)) /\ (z' = z))                  *)
(*    \/ ((x' = x)         /\ (y' = y)         /\ (z' = E3(x,y,z)))          *)
(*                                                                           *)
(* Then, for example, the equation:                                          *)
(*                                                                           *)
(*   ReachBy R B (SUC n) (x,y,z) =                                           *)
(*     ReachBy R B n (x,y,z)                                                 *)
(*     \/                                                                    *)
(*     (?x_ y_ z_. ReachBy n R B (x_,y_,z_) /\ R((x_,y_,z_),(x,y,z))))       *)
(*                                                                           *)
(* is simplified to:                                                         *)
(*                                                                           *)
(*   ReachBy R B (SUC n) (x,y,z) =                                           *)
(*     ReachBy R B n (x,y,z)                                                 *)
(*     \/ (?x_. ReachBy R B n (x_,y,z) /\ (x = E1(x_,y,z))                   *)
(*     \/ (?y_. ReachBy R B n (x,y_,z) /\ (y = E2(x,y_,z))                   *)
(*     \/ (?z_. ReachBy R B n (x,y,z_) /\ (z = E3(x,y,z_))                   *)
(*****************************************************************************)

val MakeSimpRecThm = SIMP_RULE bool_ss [LEFT_AND_OVER_OR,EXISTS_OR_THM]);

(*****************************************************************************)
(*  asl |- t1 = t2   ass vm t1' |--&#62; b                                       *)
(*  ----------------------------------                                       *)
(*      (asl U ass) vm t2' |--&#62; b'                                           *)
(*                                                                           *)
(* where t1 can be instantiated to t1' and t2' is the corresponding          *)
(* instance of t2                                                            *)
(*****************************************************************************)

fun BddApThm th tb =
 let val (_,vm,t1',b) = dest_term_bdd tb
 in
  BddEqMp (REWR_CONV th t1') tb 
   handle HOL_ERR _ =&#62; hol_err "REWR_CONV failed" "BddApthm"
 end;

(*****************************************************************************)
(*  ass vm t |--&#62; b                                                          *)
(*  ----------------                                                         *)
(*  ass vm tm |--&#62; b'                                                        *)
(*                                                                           *)
(* where boolean variables in t can be renamed to get tm and b' is           *)
(* the corresponding replacement of BDD variables in b                       *)
(*****************************************************************************)

exception BddApReplaceError;

BddApReplace : term_bdd -&#62; term -&#62; term_bdd

(*****************************************************************************)
(* BddSubst applies a substitution [(oldtb1,newtb1),...,(oldtni,newtbi)]     *)
(* to a term_bdd, where oldtbp (1 &lt;= p &lt;= i) must be of the form             *)
(* ass vm vp |--&#62; bp where vp is a variable, and the varmaps are distinct    *)
(*                                                                           *)
(* The preliminary version below separates the substitution into a           *)
(* restriction (variables mapped to T or F) followed by a variable           *)
(* renaming (replacement).  A more elaborate scheme will be implemented      *)
(* using BuDDy's bdd_veccompose.                                             *)
(*****************************************************************************)





(*****************************************************************************)
(* Split a substitution                                                      *)
(*                                                                           *)
(*   [(oldtb1,newtb1),...,(oldtni,newtbi)]                                   *)
(*                                                                           *)
(* into a restriction and variable renaming, failing if this isn't possible  *)
(*****************************************************************************) 

val split_subst =
 List.partition 
  (fn (tb,tb')=&#62;
    let val tm' = getTerm tb'
    in (tm'=T) orelse (tm'=F) end);

(*****************************************************************************)
(*                    [(ass1 vm v1 |--&#62; b1 , ass1' vm tm1 |--&#62; b1'),         *)
(*                                    .                                      *)
(*                                    .                                      *)
(*                                    .                                      *)
(*                     (assi vm vi |--&#62; bi , assi' vm tmi |--&#62; bi')]         *)
(*                    ass vm tm |--&#62; b                                       *)
(*  ------------------------------------------------------------------------ *)
(*   (as1 U ass1' U ... U assi U assi' U ass)                                *)
(*   vm                                                                      *)
(*   (subst[v1 |-&#62; tm1, ... , vi |-&#62; tmi]tm)                                 *)
(*   |--&#62;                                                                    *)
(*   &lt;BDD resulting from restrict followed by replace&#62;                       *)
(*****************************************************************************)

fun BddSubst tbl tb =
 let val (res,rep) = split_subst tbl
 in BddReplace rep (BddRestrict res tb) end;

(*****************************************************************************)
(*  ass vm t |--&#62; b                                                          *)
(*  -----------------                                                        *)
(*  ass vm tm |--&#62; b'                                                        *)
(*                                                                           *)
(* where boolean variables in t can be instantiated to get tm and b' is      *)
(* the corresponding replacement of BDD variables in b                       *)
(*****************************************************************************)

exception BddApSubstError;

BddApSubst = fn : term_bdd -&#62; term -&#62; term_bdd

(*****************************************************************************)
(*          asl |- t1 = t2                                                   *)
(*   ------------------------------                                          *)
(*   (addList ass [])  vm t1 |--&#62; b                                          *)
(*                                                                           *)
(* Fails if t2 is not built from variables using bddops                      *)
(*****************************************************************************)

fun eqToTermBdd leaffn vm th =
 let val th' = SPEC_ALL th
     val tm  = rhs(concl th')
 in BddEqMp (SYM th') (GenTermToTermBdd leaffn vm tm) end;

(*****************************************************************************)
(* Convert an ml positive integer to a HOL numeral                           *)
(*****************************************************************************)

fun intToTerm n = numSyntax.mk_numeral(Arbnum.fromInt n);

(*****************************************************************************)
(*  ass vm tm |--&#62; b   conv tm  =  asl |- tm = tm'                           *)
(*  ----------------------------------------------                           *)
(*         (addList ass asl) vm tm' |--&#62; b                                   *)
(*****************************************************************************)

fun BddApConv conv tb = BddEqMp (conv(getTerm tb)) tb;

(*****************************************************************************)
(* Iterate a function f : int -&#62; 'a -&#62; 'a                                    *)
(* from an initial value, applying it successively to 0,1,2,... until        *)
(*                                                                           *)
(*   p : 'a -&#62; bool                                                          *)
(*                                                                           *)
(* is true (at least one iteration is always performed)                      *)
(*****************************************************************************)

fun iterate p f =
 let fun iter n x =
      let val x'  = f n x
      in if p x' then x' else iter (n+1) x' end
 in iter 0 end;



(*****************************************************************************)
(*   |- f 0 s = ... s ...     |- !n. f (SUC n) s = ... f n ... s ...         *)
(*   ---------------------------------------------------------------         *)
(*                     vm ``f i s`` |--&#62; bi                                  *)
(*                                                                           *)
(* where i is the first number such that |- f (SUC i) s = f i s              *)
(* and the function report is applied to the iteration level and current     *)
(* term_bdd and can be used for tracing.                                     *)
(*                                                                           *)
(* A state of the iteration is a pair (tb,tb') consisting of the             *)
(* previous term_bdd tb and the current one tb'. The initial state           *)
(* is (somewhat arbitarily) taken to be (tb0,tb0).                           *)
(*****************************************************************************)

exception computeFixedpointError;

computeFixedpoint : (int -&#62; term_bdd -&#62; 'a) -&#62; varmap -&#62; thm * thm -&#62; term_bdd

(*****************************************************************************)
(*              ass vm tm |--&#62; b                                             *)
(*  ----------------------------------------------                           *)
(*  [((ass1 vm v1 |--&#62; b1),(ass1' vm c1 |--&#62; b1')),                          *)
(*                        .                                                  *)
(*                        .                                                  *)
(*                        .                                                  *)
(*   ((assi vm vi |--&#62; bi),(assi' vm ci |--&#62; bi')]                           *)
(*                                                                           *)
(* with the property that                                                    *)
(*                                                                           *)
(* BddRestrict [((ass1 vm v1 |--&#62; b1),(ass1' vm c1 |--&#62; b1')),               *)
(*                                   .                                       *)
(*                                   .                                       *)
(*                                   .                       ,               *)
(*              ((assi vm vi |--&#62; bi),(assi' vm ci |--&#62; bi'))]               *)
(*             (ass vm tm |--&#62; b)                                            *)
(* =                                                                         *)
(* (ass1 U ass1' U ... U assi U assi' U ass)                                 *)
(* vm                                                                        *)
(* (subst[v1|-&#62;ci,...,vi|-&#62;ci]tm)                                            *)
(* |--&#62; TRUE                                                                 *)
(*****************************************************************************)

exception BddSatoneError;

BddSatone : term_bdd -&#62; (term_bdd * term_bdd) list

(*****************************************************************************)
(*         |- p s = ... s ...                                                *)
(*         |- f 0 s  = ... s ...                                             *)
(*         |- f (SUC n) s = ... f n ... s ...                                *)
(*  ---------------------------------------------------------                *)
(*  [{} vm ``f i s`` |--&#62; bi,  ... , {} vm ``f 1 s`` |--&#62; b1]                *)
(*                                                                           *)
(* where i is the first number such that |- f i s ==&#62; p s                    *)
(*****************************************************************************)

exception computeTraceError;

computeTrace : (int -&#62; term_bdd -&#62; 'a) 
                -&#62; varmap -&#62; thm -&#62; thm * thm -&#62; term_bdd list

(*****************************************************************************)
(*  TraceBack vm                                                             *)
(*   [{} vm ``f i s`` |--&#62; bi,  ... , {} vm ``f 0 s`` |--&#62; b0]               *)
(*   (|- p s = ... s ...)                                                    *)
(*   (|- R((v1,...,vn),(v1',...,vn')) = ...)                                 *)
(*                                                                           *)
(* computes a list of pairs of the form (with j = 0,1,...,i-1)               *)
(*                                                                           *)
(* ((vm ``ReachIn R B j s_vec /\ Prev R (Eq c_vec) (v1,...,vn)`` |--&#62; bdd),  *)
(*  [((vm v1 |--&#62; b1),(vm c1 |--&#62; b1')),                                     *)
(*                   .                                                       *)
(*                   .                                                       *)
(*                   .                 ,                                     *)
(*   ((vm vn |--&#62; bn),(vm cn |--&#62; bn'))])                                    *)
(*                                                                           *)
(* where s_vec = (v1,...,vn) and c_vec = (c1,...,cn) where ci is T or F      *)
(* and the second element specifies a state satisfying the first element     *)
(* and in which state variable vj has value cj (0 &lt;= j &lt;= n).                *)
(* The last element of the list has the form                                 *)
(* (({} vm ``ReachIn R B j s_vec /\ p(v1,...,vn)`` |--&#62; bdd),                *)
(*  [(({} vm v1 |--&#62; b1),{} vm c1 |--&#62; b1')),                                *)
(*                      .                                                    *)
(*                      .                                                    *)
(*                      .                   ,                                *)
(*   (({} vm vn |--&#62; bn),({} vm cn |--&#62; bn'))])                              *)
(*                                                                           *)
(* If [s0,...,si] is the sequence of states, then                            *)
(* R(s0,s1), R(s1,s2),...,R(s(i-1),sj) and sj satisfies bj and p si          *)
(*****************************************************************************)

TraceBack : varmap 
             -&#62; term_bdd list 
             -&#62; thm -&#62; thm -&#62; (term_bdd * (term_bdd * term_bdd) list) list

</pre></font>

<p>
 <h2><a name="tth_sEc19">
19</a>&nbsp;&nbsp;The structure <tt>DerivedBddRulesTheory</tt></h2><a name="DerivedBddRulesTheory">
</a>

<p>
The theory <tt>DerivedBddRulesTheory</tt> contained the HOL theoremes used
by the derived rules in <tt>DerivedBddRules</tt>. The signature file
(slightly edited) is given below.

<p>
<font size="-2">
<pre>
  (*  Definitions  *)
    val Eq_def : thm
    val Next_def : thm
    val Prev_def : thm
    val ReachBy_def : thm
    val ReachIn_def : thm
    val Reachable_def : thm
  
  (*  Theorems  *)
    val ReachBy_ReachIn : thm
    val ReachBy_fixedpoint : thm
    val ReachBy_rec : thm
    val ReachIn_rec : thm
    val Reachable_ReachBy : thm

   [list] Parent theory of "DerivedBddRules"
   
   [Eq_def]
   Definition
   |- !state0 state. Eq state0 state = (state0 = state)
   
   [Next_def]
   Definition
   |- !R B state. Next R B state = ?state_. B state_ /\ R (state_,state)
   
   [Prev_def]
   Definition
   |- !R Q state. Prev R Q state = ?state'. R (state,state') /\ Q state'
   
   [ReachBy_def]
   Definition
   |- !R B n state. ReachBy R B n state = ?m. m &lt;= n /\ ReachIn R B m state
   
   [ReachIn_def]
   Definition
   |- (!R B. ReachIn R B 0 = B) /\
      !R B n. ReachIn R B (SUC n) = Next R (ReachIn R B n)
   
   [Reachable_def]
   Definition
   |- !R B state. Reachable R B state = ?n. ReachIn R B n state
   
   [ReachBy_ReachIn]
   Theorem
   |- (!R B state. ReachBy R B 0 state = B state) /\
      !R B n state.
        ReachBy R B (SUC n) state =
        ReachBy R B n state \/ ReachIn R B (SUC n) state
   
   [ReachBy_fixedpoint]
   Theorem
   |- !R B n.
        (ReachBy R B n = ReachBy R B (SUC n)) ==&#62;
        (Reachable R B = ReachBy R B n)
   
   [ReachBy_rec]
   Theorem
   |- (!R B state. ReachBy R B 0 state = B state) /\
      !R B n state.
        ReachBy R B (SUC n) state =
        ReachBy R B n state \/
        ?state_. ReachBy R B n state_ /\ R (state_,state)
   
   [ReachIn_rec]
   Theorem
   |- (!R B state. ReachIn R B 0 state = B state) /\
      !R B n state.
        ReachIn R B (SUC n) state =
        ?state_. ReachIn R B n state_ /\ R (state_,state)
   
   [Reachable_ReachBy]
   Theorem
   |- Reachable R B state = ?n. ReachBy R B n state

</pre></font>

<p>

<h2>Acknowledgements</h2>

<p>
<tt>HolBddLib</tt> would not have been possible without BuDDyfrom
J&#248;rn Lind-Nielsen and MuDDyfrom Ken Friis Larsen and Jakob Lichtenberg.

<p>
This research was initially supported by EPSRC grant
GR/K57343 <em>Checking Equivalence Between Synthesised Logic and
Non-Synthesisable Behavioural Prototypes</em>, EPSRC grant GR/L35973
entitled <i>A Hardware Compilation Workbench </i>, EPSRC grant
GR/L74262 entitled <i>A uniform semantics for Verilog and VHDL
suitable for both simulation and formal verification </i> and ESPRIT
Framework IV LTR 26241 project Prosper (<em>Proof and Specification
Assisted Design Environments</em>). Currently the research is supported by
EPSRC grant GR/R27105/01 entitled <i>Fully Expansive Proof and
Algorithmic Verification </i><a href="#tthFtNtAAD" name="tthFrefAAD"><sup>3</sup></a>.

<p>
At the beginning of the research, data from Atanas Parashkevov
and Bill Roscoe on the BDD and state space sizes arising from Peg Solitaire
was useful for evaluating and testing the first version of <tt>HolBddLib</tt>.

<p>
Michael Norrish and Konrad Slind have provided invaluable help with
Hol98, which they are currently developing. 

<p>
Mark Aagaard provided some
of the information on Voss and its successors described in
the preface.

<p>
Paul Jackson, Jesper M&#248;ller and Konrad Slind provided detailed
comments and suggestions on a first draft of the University of
Cambridge Computer Laboratory Technical Report No.&nbsp;481.

<p>
  <a name="tth_sEcindex"></a>

<h2> Index </h2>
[MLty]

<p>
<a name="tth_sEcindex"></a>

<h2> Index </h2>
[MLbn]

<p>
<hr /><h3>Footnotes:</h3>

<p>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>Adapted from 
<i>Reachability programming in HOL using BDDs</i>
[]
<p>
<a name="tthFtNtAAC"></a><a href="#tthFrefAAC"><sup>2</sup></a><tt>http://www.research.att.com/sw/tools/graphviz/</tt>
<p>
<a name="tthFtNtAAD"></a><a href="#tthFrefAAD"><sup>3</sup></a><tt>http://www.cl.cam.ac.uk/&nbsp;mjcg/HolCheck/</tt>
<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 3.01.<br />On  5 Nov 2001, 17:21.</small>
</html>
