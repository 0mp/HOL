val _ = quietdec := true;


(* ----------------------------------------------------------------------
    Establish the basic environment and bring in the HOL kernel
   ---------------------------------------------------------------------- *)

val _ = app load
  ["Mosml", "Process", "Path", "boolLib", "proofManagerLib", "Arbrat"];

open HolKernel Parse boolLib proofManagerLib;

(* Loading HolKernel installs the "standard" set of infixes, which are
   set up in src/0/Overlay.sml *)

(*---------------------------------------------------------------------------*
 *   Install prettyprinters                                                  *
 *---------------------------------------------------------------------------*)

local
  fun with_pp ppfn pps x =
      Parse.respect_width_ref Globals.linewidth ppfn pps x handle e => Raise e
  fun pp_from_stringfn sf pps x = PP.add_string pps (sf x)
in
  val _ = installPP (with_pp (Kind.pp_qkind))
  val _ = installPP (with_pp (Parse.term_pp_with_delimiters Hol_pp.pp_term))
  val _ = installPP (with_pp (Parse.type_pp_with_delimiters Hol_pp.pp_type))
  val _ = installPP (with_pp Hol_pp.pp_thm)
  val _ = installPP (with_pp Hol_pp.pp_theory)
  val _ = installPP (with_pp kind_grammar.prettyprint_grammar)
  val _ = installPP (with_pp type_grammar.prettyprint_grammar)
  val _ = installPP (with_pp term_grammar.prettyprint_grammar)
  val _ = installPP (with_pp proofManagerLib.pp_proof)
  val _ = installPP (with_pp proofManagerLib.pp_proofs)
  val _ = installPP (with_pp Rewrite.pp_rewrites)
  val _ = installPP (with_pp TypeBasePure.pp_tyinfo)
  val _ = installPP (with_pp DefnBase.pp_defn)
  val _ = installPP (with_pp Arbnum.pp_num)
  val _ = installPP (with_pp Arbint.pp_int)
  val _ = installPP (with_pp Arbrat.pp_rat)
end;


(*---------------------------------------------------------------------------*
 * Set up the help paths.                                                    *
 *---------------------------------------------------------------------------*)

local
  open Path
  fun HELP s = toString(fromString(concat(HOLDIR, concat("help",s))))
  val SIGOBJ = toString(fromString(concat(HOLDIR, "sigobj")))
in
  val () = indexfiles := HELP "HOL.Help" :: !indexfiles
  val () = helpdirs   := HOLDIR :: SIGOBJ :: !helpdirs
  val () = Help.specialfiles :=
             {file = "help/Docfiles/README.Hol98",
              term = "hol", title = "Hol98 Overview"}
             :: !Help.specialfiles
end


(*---------------------------------------------------------------------------*
 *  Set parameters for parsing and help.                                     *
 *---------------------------------------------------------------------------*)

val _ = quotation := true
val _ = Help.displayLines := 60;

(*---------------------------------------------------------------------------*
 *  Set up compile_theory function                                           *
 *---------------------------------------------------------------------------*)

fun compile_theory () = let
  val name = current_theory()
  val signame = name^"Theory.sig"
  val smlname = name^"Theory.sml"
  fun readable f = FileSys.access(f, [FileSys.A_READ])
in
  if readable signame andalso readable smlname then let
  in
     Meta.compileStructure ["Overlay"] signame;
     Meta.compileStructure ["Overlay"] smlname;
     print ("Compiled "^name^" theory files.\n")
  end
  else
     print "No theory files on disk; perhaps export_theory() required.\n"
end

(* ----------------------------------------------------------------------
    Set interactive flag to true
   ---------------------------------------------------------------------- *)

val _ = Globals.interactive := true;

(*---------------------------------------------------------------------------*
 * Print a banner.                                                           *
 *---------------------------------------------------------------------------*)

val build_stamp =
 let open TextIO Path
     val stampstr = openIn (concat(HOLDIR, concat("tools", "build-stamp")))
     val stamp = inputAll stampstr before closeIn stampstr
 in
     stamp
 end handle _ => "";

val _ =
TextIO.output(TextIO.stdOut,
  "\n-----------------------------------------------------------------\n"
  ^"    HOL-Omega ["
  ^Globals.release^" "^Lib.int_to_string(Globals.version)^build_stamp
  ^"]\n\n    For introductory HOL help, type: help \"hol\";\n"
  ^"-----------------------------------------------------------------\n\n");

(* ----------------------------------------------------------------------
    if present, look at a Holmakefile in the current directory to see
    if we should extend the loadPath
   ---------------------------------------------------------------------- *)

local
  open Path
in
  val _ = loadPath := concat (HOLDIR, concat ("tools", "Holmake")) :: !loadPath
  val _ = load "ReadHMF.uo"
  val _ = loadPath := tl (!loadPath)
end;

val _ = if FileSys.access ("Holmakefile", [FileSys.A_READ]) then let
            open Holmake_types
            fun base_env s =
                case s of
                  "HOLDIR" => [LIT HOLDIR]
                | "SIGOBJ" => [VREF "HOLDIR", LIT "/sigobj"]
                | _ => (case Process.getEnv s of
                          NONE => [LIT ""]
                        | SOME v => [LIT v])
            val toks = ReadHMF.read "Holmakefile"
            val env = extend_env toks base_env
            fun envlist id =
                map dequote (tokenize (perform_substitution env [VREF id]))
            val hmake_includes = envlist "INCLUDES"
          in
            case hmake_includes of
              [] => ()
            | _ =>
              (print "[extending loadPath with Holmakefile INCLUDES variable]\n";
               loadPath := !loadPath @ hmake_includes)
          end handle e => (print "[bogus Holmakefile in current directory \
                                 \- ignoring it]\n";
                           TextIO.flushOut TextIO.stdErr;
                           ())
        else ()

structure HOL_Interactive : sig val toggle_quietdec : unit -> bool end =
struct
  fun toggle_quietdec () = (Meta.quietdec := not (!Meta.quietdec) ;
                            !Meta.quietdec)
end

(* Local variables: *)
(* mode: sml *)
(* end: *)
