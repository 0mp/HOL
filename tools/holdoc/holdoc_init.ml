(* holdoc_init.ml -- initial settings of various category lists *)
(* Keith Wansbrough 2001 *)

  (* could be autogenerated from Net_typesScript.sml etc *)
let tYPE_LIST = ref
  [ "port"
  ; "ip"
  ; "ipBody"
  ; "msg"
  ; "ifid"
  ; "netmask"
  ; "ifd"
  ; "fd"
  ; "error"
  ; "err"
  ; "sockopt"
  ; "TLang_type"
  ; "TLang"
  ; "hostThreadState"
  ; "flags"
  ; "socket"
  ; "host"
  (* and from Net_hostLTSScript.sml *)
  ; "LIB_interface"
  ; "Lhost0"
  ; "rule_ids"
  ; "rule_cats"
  ] 

  (* could be autogenerated from Net_typesScript.sml etc *)
let cON_LIST = ref
  [ "Port"
  ; "ip"
  ; "UDP"
  ; "ICMP_HOST_UNREACH"
  ; "ICMP_PORT_UNREACH"
  ; "LO"
  ; "ETH"
  ; "NETMASK"
  ; "FD"
  ; "EACCES"
  ; "EADDRINUSE"
  ; "EADDRNOTAVAIL"
  ; "EAGAIN"
  ; "EBADF"
  ; "ECONNREFUSED"
  ; "EHOSTUNREACH"
  ; "EINTR"
  ; "EINVAL"
  ; "EMFILE"
  ; "EMSGSIZE"
  ; "ENFILE"
  ; "ENOBUFS"
  ; "ENOMEM"
  ; "ENOTCONN"
  ; "ENOTSOCK"
  ; "OK"
  ; "FAIL"
  ; "SO_BSDCOMPAT"
  ; "SO_REUSEADDR"
  ; "TLty_int"
  ; "TLty_bool"
  ; "TLty_string"
  ; "TLty_one"
  ; "TLty_pair"
  ; "TLty_list"
  ; "TLty_lift"
  ; "TLty_err"
  ; "TLty_fd"
  ; "TLty_ip"
  ; "TLty_port"
  ; "TLty_error"
  ; "TLty_netmask"
  ; "TLty_ifid"
  ; "TLty_sockopt"
  ; "TL_int"
  ; "TL_bool"
  ; "TL_string"
  ; "TL_one"
  ; "TL_pair"
  ; "TL_list"
  ; "TL_option"
  ; "TL_err"
  ; "TL_fd"
  ; "TL_ip"
  ; "TL_port"
  ; "TL_error"
  ; "TL_netmask"
  ; "TL_ifid"
  ; "TL_sockopt"
  ; "Run"
  ; "Term"
  ; "Ret"
  ; "Sendto2"
  ; "Recvfrom2"
  ; "Select2"
  ; "Print2"
  ; "Flags"  (* not a real constructor, but an xDefined one; etc *)
  ; "Sock"
  (* and from Net_hostLTSScript.sml *)
  ; "Lh_call"
  ; "Lh_return"
  ; "Lh_sendmsg"
  ; "Lh_recvmsg"
  ; "Lh_console"
  ; "Lh_tau"
  (* rule_ids and rule_cats omitted *)
  (* added by hand for comments etc *)
  ; "EWOULDBLOCK"
  ; "EDESTADDRREQ"
]

let fIELD_LIST = ref
  [ "src"
  ; "dest"
  ; "body"
  ; "ifid"
  ; "ipset"
  ; "primary"
  ; "netmask"
  ; "bsdcompat"
  ; "reuseaddr"
  ; "fd"
  ; "is1"
  ; "ps1"
  ; "is2"
  ; "ps2"
  ; "es"
  ; "f"
  ; "mq"
  ; "ifds"
  ; "t"
  ; "s"
  ; "oq"
  ; "oqf"
  ] 

let lIB_LIST = ref
  [ "socket"
  ; "bind"
  ; "connect"
  ; "disconnect"
  ; "getsockname"
  ; "getpeername"
  ; "sendto"
  ; "recvfrom"
  ; "geterr"
  ; "getsockopt"
  ; "setsockopt"
  ; "close"
  ; "select"
  ; "port_of_int"
  ; "ip_of_string"
  ; "getifaddrs"
  ; "print_endline_flush"
  ; "exit"
  ]

let aUX_LIST = ref  (* based on Net_auxfnsScript.sml *)
  [ "enqueue"
  ; "dequeue"
  ; "outroute"
  ; "dosend"
  ; "unused"
  ; "ephemeral"
  ; "ephemeralErrors"
  ; "privileged"
  ; "socklist_context"
  ; "scs1"
  ; "scs2"
  ; "F_context"
  ; "fc_sc"
  ; "fc_oq"
  ; "fc_oqf"
  ; "lookup"
  (* omit SC_unused, FC_unused as overloaded on unused *)
  ; "autobind"
  ; "socks"
  (* and Net_oksScript.sml *)
  ; "netmask_ok"
  ; "num_of_mask"
  ; "mask"
  ; "LOOPBACK"
  ; "MULTICAST"
  ; "BADCLASS"
  ; "ZERONET"
  ; "MARTIAN"
  ; "body_ips"
  ; "martian"
  ; "loopback"
  ; "ifd_set_ok"
  ; "UDPpayloadMax"
  ; "msg_ok"
  ; "msg_oq_ok"
  ; "socket_srcdest_ok"
  ; "socket_ok"
  ; "sockfds"
  ; "sock_with_fd"
  ; "host_ok"
  ; "valid_ip_string"
  ; "ipstr_to_ip"
  ; "localhost"
  (* Net_host_safetyScript.sml *)
  ; "OP2"
  (* added by hand *)
  ; "string_size"
  ; "OP"
  ] 

let aUX_INFIX_LIST = ref
  [ "with"
  ]

let vAR_PREFIX_LIST = ref
  [
  ]

let hOL_OP_LIST = ref
  [ "IMAGE"
  ; "APPEND"
  ; "FILTER"
  ; "MEM"
  ; "LIST_TO_SET"
  ; "CARD"
  ; "LENGTH"
  ; "Num"
  ] 

let hOL_SYM_ALIST = ref
  [ ("/\\","\\Mwedge ")
  ; ("\\/","\\Mvee ")
  ; ("<|","\\Mlrec ")
  ; ("|>","\\Mrrec ")
  ; ("!","\\forall ")
  ; ("?","\\exists ")
  ; ("?!","\\Mexunq ")
  ; ("==>","\\implies ")
  ; ("<==","\\impliedby ")
  ; ("<=","\\leq ")
  ; (">=","\\geq ")
  ; ("<>","\\neq ")
                             (* Mquotedstring *)
  ; ("->","\\Mtotype ")
  ; ("<=>","\\iff ")
  ; (":=","\\Mass ")
  ; ("::","\\Mcons ")
  ; ("[]","[\,]")
  ; ("()","()")
  ; ("\\","\\lambda ")
  ]

let hOL_ID_ALIST = ref
  [ ("SOME","\\Msome ")
  ; ("NONE","*")
  ; ("IN","\\in ")
  ; ("INTER","\\cap ")
  ; ("UNION","\\cup ")
  ; ("EMPTY","\\emptyset ")
  ; ("one","()")
  ; ("SUBSET","\\subseteq ")
  ; ("T","\\Mtrue ")
  ; ("F","\\Mfalse ")
  ; ("if","\\Mif ")
  ; ("then","\\Mthen ")
  ; ("else","\\Melse ")
  ; ("EXP","\\Mexp ")
  ] 

open Hollex
exception BadDirective

let dir_proc n ts =
  let rec go ts =
    match ts with
      (White(_)::ts)   -> go ts
    | (Comment(_)::ts) -> go ts
    | (Ident(s,_)::ts) -> s :: go ts
    | (_::ts)          -> raise BadDirective
    | []               -> []
  in
  let rec go2 ts =
    match ts with
      (White(_)::ts)   -> go2 ts
    | (Comment(_)::ts) -> go2 ts
    | (Ident(s1,_)::White(_)::Str(s2)::ts) -> (s1,s2) :: go2 ts
    | (_::ts)          -> raise BadDirective
    | []               -> []
  in
  match n with
    "TYPE_LIST"       -> tYPE_LIST       := (go ts)  @ !tYPE_LIST
  | "CON_LIST"        -> cON_LIST        := (go ts)  @ !cON_LIST
  | "FIELD_LIST"      -> fIELD_LIST      := (go ts)  @ !fIELD_LIST
  | "LIB_LIST"        -> lIB_LIST        := (go ts)  @ !lIB_LIST
  | "AUX_LIST"        -> aUX_LIST        := (go ts)  @ !aUX_LIST
  | "AUX_INFIX_LIST"  -> aUX_INFIX_LIST  := (go ts)  @ !aUX_INFIX_LIST
  | "VAR_PREFIX_LIST" -> vAR_PREFIX_LIST := (go ts)  @ !vAR_PREFIX_LIST
  | "HOL_OP_LIST"     -> hOL_OP_LIST     := (go ts)  @ !hOL_OP_LIST
  | "HOL_SYM_ALIST"   -> hOL_SYM_ALIST   := (go2 ts) @ !hOL_SYM_ALIST
  | "HOL_ID_ALIST"    -> hOL_ID_ALIST    := (go2 ts) @ !hOL_ID_ALIST
  | _                 -> ()

