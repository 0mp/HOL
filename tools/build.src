(*---------------------------------------------------------------------------
                An ML script for building HOL
 ---------------------------------------------------------------------------*)

(* The following lines are written at configuration time. *)

val LN_S = _;
val HOLDIR = _;
val DEPDIR = _;
val SRCDIRS = _;
val GNUMAKE = _;

val SIGOBJ = Path.concat(HOLDIR, "sigobj");

fun normPath s = Path.toString(Path.fromString s)
fun itstrings f [] = raise Fail "itstrings: empty list"
  | itstrings f [x] = x
  | itstrings f (h::t) = f h (itstrings f t);
fun fullPath slist = normPath
   (itstrings (fn chunk => fn path => Path.concat (chunk,path)) slist);

fun quote s = String.concat["\"", s, "\""];

local val Holmake_path = fullPath [HOLDIR, "bin/Holmake"]
in
fun Holmake dir =
  if Process.system Holmake_path = Process.success
  then ()
  else (print ("Build failed in directory "^dir^"\n");
        raise Fail "Couldn't make directory")
end;


fun gnumake dir =
  if Process.system GNUMAKE = Process.success
  then ()
  else (print ("Build failed in directory "^dir
                ^" ("^GNUMAKE^" failed).\n");
        raise Fail "Couldn't make directory");

(*---------------------------------------------------------------------------
           Compile a HOL directory in place. Some libraries,
           e.g., the robdd libraries, need special treatment.
 ---------------------------------------------------------------------------*)

fun build_dir dir =
  let val _ = FileSys.chDir dir
      val _ = print ("Working in directory "^dir^"\n")
      val d = #file(Path.splitDirFile dir)
  in
   if (d = "robdd" orelse d = "muddy")
   then let val buddy_dir = Path.concat(dir,
                  if d="robdd" then "buddy16" else "buddy17")
        in
             FileSys.chDir buddy_dir;
             print ("Working in directory "^buddy_dir^"\n");
             gnumake buddy_dir;
             FileSys.chDir dir;
             print ("Working in directory "^dir^"\n");
             Holmake dir;
             gnumake dir
        end handle _ => print(String.concat["\n", d,
                 "Lib has NOT been built!! (continuing anyway).\n\n"])
   else Holmake dir
  end handle OS.SysErr(s, erropt) =>
    (print ("OS error: "^s^" - "^
            (case erropt of SOME s' => OS.errorMsg s' | _ => "") ^ "\n");
     Process.exit Process.failure)

(*
fun build_dir dir =
  let val _ = FileSys.chDir dir
      val _ = print ("Working in directory "^dir^"\n")
  in
    case Path.splitDirFile dir
     of {file="robdd",...} =>
          (let val buddy_dir = Path.concat(dir,"buddy16")
           in
             FileSys.chDir buddy_dir;
             print ("Working in directory "^buddy_dir^"\n");
             gnumake buddy_dir;
             FileSys.chDir dir;
             print ("Working in directory "^dir^"\n");
             Holmake dir;
             gnumake dir
           end handle _ =>
             print"\nrobddLib has NOT been built!! (continuing anyway).\n\n")
      | otherwise => Holmake dir
  end
*)

(*---------------------------------------------------------------------------
      Arrange for all executables and relevant .sig files
      to reside in a common directory.
 ---------------------------------------------------------------------------*)

fun map_dir f dir =  (* map a function over the files in a directory *)
  let val dstrm = FileSys.openDir dir
      fun loop() =
        case FileSys.readDir dstrm
         of NONE => FileSys.closeDir dstrm
          | SOME file => (f (dir,file) ; loop())
  in loop()
  end handle OS.SysErr(s, erropt) =>
    (print ("OS error: "^s^" - "^
            (case erropt of SOME s' => OS.errorMsg s' | _ => "") ^ "\n");
     Process.exit Process.failure);


fun copy file path =  (* Dead simple file copy *)
 let open TextIO
     val (istrm,ostrm) = (openIn file, openOut path)
     fun loop() =
       case input1 istrm
        of SOME ch => (output1(ostrm,ch) ; loop())
         | NONE    => (closeIn istrm; flushOut ostrm; closeOut ostrm)
  in loop()
  end;

fun link s1 s2 =
  let open Process
  in if system (String.concat[LN_S," ",s1," ",s2]) = success then ()
     else (print ("Unable to link file "^quote s1^" to file "^quote s2^".\n");
           raise Fail "link")
  end;

fun transfer_file symlink targetdir (df as (dir,file)) =
  let val cp = if symlink then link else copy
      fun mv s1 s2 =
        let val s1' = normPath s1
            val s2' = normPath s2
        in
          if symlink then link s1' s2' else FileSys.rename {old=s1', new=s2'}
        end
      fun transfer f (dir,file) = f (fullPath [dir,file])
                                    (fullPath [targetdir,file])
  in
   case Path.ext file
    of SOME"ui"  => transfer mv df
     | SOME"uo"  => transfer mv df
     | SOME"so"  => transfer mv df   (* for robddLib *)
     | SOME"sig" => transfer cp df
     |    _      => ()
  end;

(*---------------------------------------------------------------------------
        Transport a compiled directory to another location. The
        symlink argument says whether this is via a symbolic link,
        or by copying. The ".uo", ".ui", ".so", and ".sig" files are
        transported.
 ---------------------------------------------------------------------------*)

fun upload (src,target,symlink) =
  (print ("Uploading files to "^target^"\n");
   map_dir (transfer_file symlink target) src)
        handle OS.SysErr(s, erropt) =>
          (print ("OS error: "^s^" - "^
                  (case erropt of SOME s' => OS.errorMsg s' | _ => "") ^ "\n");
           Process.exit Process.failure)


(*---------------------------------------------------------------------------
    For each element in SRCDIRS, build it, then upload it to SIGOBJ.
    This allows us to have the build process only occur w.r.t. SIGOBJ
    (thus requiring only a single place to look for things).
 ---------------------------------------------------------------------------*)
fun build_src symlink =
   List.app (fn s => (build_dir s; upload(s,SIGOBJ,symlink)))
            SRCDIRS;

fun rem_file f =
 FileSys.remove f
   handle _ => (print ("Trouble with removing file "^f^"?\n"); ());


fun clean_sigobj() =
  let val _ = print ("Cleaning out "^SIGOBJ^"\n")
  in
    map_dir (rem_file o normPath o Path.concat) SIGOBJ
  end;

fun build_hol symlink =
  let val _ = clean_sigobj()
      val _ = build_src symlink
  in
    print "\nHol built successfully.\n"
  end;


(*---------------------------------------------------------------------------
       Get rid of compiled code and dependency information.
 ---------------------------------------------------------------------------*)

local val lenScript = String.size "Script"
      val lenTheory_ext = String.size "Theory.sig"
in
fun suffixCheck s =
 let val len = String.size s
 in (("Script" = String.extract(s,len-lenScript,NONE)) orelse raise Subscript)
    handle Subscript
    =>  let val suffix = String.extract(s,len - lenTheory_ext, NONE)
        in (len > 10
            andalso ((suffix = "Theory.sig") orelse (suffix = "Theory.sml")))
           orelse raise Subscript
         end
        handle Subscript => false
  end
end;

fun cleandir dir =
  let fun efile s =
        case Path.ext s
         of SOME "ui" => true
          | SOME "uo" => true
          | SOME "so" => true         (* for robddLib *)
          | SOME "o"  => true         (* for robddLib *)
          |    _      => suffixCheck s
      fun del (d,f) = if efile f then rem_file (fullPath [d,f]) else ()
  in
    map_dir del dir
  end;

fun cleanAlldir dir = (* clean directory d and also remove d/DEPDIR *)
  let val _ = cleandir dir
      val depdir = Path.concat(dir,DEPDIR)
  in
    if (FileSys.isDir depdir handle _ => false)
    then (map_dir (rem_file o normPath o Path.concat) depdir;
          FileSys.rmDir depdir handle e
           => (print ("Unable to remove directory "^depdir^".\n"); ()))
    else ()
  end;

fun clean_dirs f = clean_sigobj() before List.app f SRCDIRS;

fun errmsg s = TextIO.output(TextIO.stdErr, s ^ "\n");
val help_mesg = "Usage: build\n\
                                \  or: build -symlink\n\
                                \  or: build -clean\n\
                                \  or: build -cleanAll.";
val _ =
  case Mosml.argv ()
   of [_]             => build_hol false (* no symbolic linking *)
    | [_,"-symlink"]  => build_hol true  (*    symbolic linking *)
    | [_,"-clean"]    => clean_dirs cleandir
    | [_,"-cleanAll"] => clean_dirs cleanAlldir
    |     _           => errmsg help_mesg
