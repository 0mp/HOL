(* The run-time library for lexers generated by mosmllex *)

(* read .lex file into a single string *)

structure LexBuffer : LEX_BUFFER =
struct

(* buffer is whole input; all positions are absolute *)
datatype 'a lexbuf =      (* 'a is return type of lastAction *)
  LEXBUF of
   {size :       int,
    buffer :     string,  (* the whole thing! *)
    startPos :   int ref,
    currPos :    int ref,
    lastPos :    int ref,
    lastAction : (unit -> 'a) ref}

fun sub(LEXBUF{buffer,...},n) : char = String.sub(buffer,n)
fun substring(LEXBUF{buffer,...},i,len) : string = String.substring(buffer,i,len)

fun setLastAction (LEXBUF{lastAction,...}) f : unit =
    lastAction := f

fun resetLastPos (LEXBUF{lastPos,currPos,...}) =
    lastPos := !currPos

fun resetStartPos (LEXBUF{startPos,currPos,...}) =
    startPos := !currPos

fun dummyAction x = raise Fail "lexing: empty token";

fun createLexbuf (s: string) =
    LEXBUF
     {size = size s,
      buffer = s,
      startPos = ref 0,
      currPos =  ref 0,
      lastPos =  ref 0,
      lastAction = ref dummyAction}

fun getLexeme (LEXBUF{buffer,currPos,startPos,...}) : string =
    let val startPos = !startPos
     in String.substring(buffer,startPos,!currPos - startPos)
    end

fun getLexemeChar (LEXBUF{buffer,startPos,...}) i =
    String.sub(buffer, !startPos + i)

fun backtrack (lb as LEXBUF{currPos,lastPos,lastAction,...}) =
    (currPos := !lastPos;
     !lastAction ())

fun getLexemeStart (LEXBUF{startPos,...}) =
    !startPos

fun getLexemeEnd (LEXBUF{currPos,...}) =
    !currPos

fun getNextChar (lb as LEXBUF{size,currPos,buffer,...}) : char =
    if !currPos >= size
    then #"\000"
    else (String.sub(buffer,!currPos) before
	  currPos := !currPos + 1)

end (* structure LexBuffer *)
