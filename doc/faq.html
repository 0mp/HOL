<html>
<head><title>HOL Frequently Asked Questions</title></head>
<BODY BGCOLOR="#fbf2e7">

<h1>HOL Frequently Asked Questions</h1>
<p>
<h2>Contents</h2>

<UL>
<li> <a href = "#Build">Build failures and warnings</a>
<li> <a href = "#Quotes">Quotes and Antiquotes</a>
<li> <a href = "#Parsing">Parsing</a>
<li> <a href = "#Assumptions">Manipulating Hypotheses</strong>
<li> <a href = "#HOL_ERR"><code>HOL_ERR</code></a>
<li> <a href = "#Locating">Locating things</a>
<li> <a href = "#Misc">Miscellaneous</a>
</UL>

<p><hr><p>

<h2><a name = "Build"> Build Failures and Warnings</a> </h2>

<dl>
<dt>
<strong>HOL is failing to complete the build process.  It stops when trying
 to create the HolBdd theory.  Why is this, and what should I do?</strong>
<dd> The problem is almost certainly that your copy of MoscowML hasn't
     been built with dynamic linking correctly enabled.  This in turn
     means that the Muddy BDD package that HolBdd uses can't load.
     You can test that this is the problem by running hol, and then
     trying
<pre>   - load "HolBdd";
</pre>
     This should fail with an error message about not being able to
     load <code>muddy.so</code>.
<p>
     If you decide you do want HolBdd (there is nothing else in HOL
     that depends on dynamic linking) you will probably need to build
     Moscow ML yourself.  Binaries from the central site in Denmark
     don't seem to work.  However the install.txt file in the
     distribution does talk about things you need to do to binaries in
     order to get dynamic linking to work for them, and it would be
     interesting to hear that someone had got this to work.  In any
     case, to build from sources, you must make sure that you alter
     the src/Makefile.inc in the MoscowML distribution in line with
     the instructions in the comments there.
<p><p>
     This advice seems to solve this problem for 90% of the people
     reporting it.  If it doesn't in your case, please get back to us.
<p>
<dt>
<strong> Are error messages during the build like the following a
source for concern? </strong>
<pre>   &gt; File "Term.sml", line 1328, characters 10-42:
   &gt; !   let val {const=Const(r1,_),theory,place} = const_decl name
   &gt; !           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   &gt; ! Warning: pattern matching is not exhaustive
</pre>
<p>
<dd> No.  Nor is the following sort of output, when configuring the
system before building:
<pre>   &gt; /local/scratch/kxs/144/bin/mosmlyac: 4 shift/reduce conflicts.
</pre>
<p>
</dl>

<p><hr><p>
<h2><a name = "Quotes">Quotes and Antiquotes</a></h2>

<dl>
<dt><strong>How do I antiquote types?</strong>

<dd> Antiquoting types works as you would expect when parsing types,
     so that it is fine to write:
<pre>   - val ty = Type`:bool`;
</pre>
     and then
<pre>   - Type`:num -&gt; ^ty`;
</pre>
     However, you may wish to also introduce type antiquotations into
     term parses (as a type constraint on a variable for example).
     The problem is that you can't just write <code>^ty</code> in this
     context, because the parsing function's type insists that all
     antiquotes be of type term.  You must use the
     <code>ty_antiq</code> function, which magically makes a type
     appear as a term:
<pre>   - val antity = ty_antiq ty;
   &gt; val antity = `(ty_antiq(`:bool`))` : term
</pre>
     Then:
<pre>   - val x = Term `x:^antity`;
</pre>
     It's quite easy to figure out when and why <code>ty_antiq</code>
     is required if one understands the type of the parsing functions.
     For example, <code>Term</code> and <code>(fn q =&gt; -- q --)</code>
     have type
<pre>   term frag list -&gt; term
</pre>
     While <code>Type</code> and <code>(fn q =&gt; == q ==)</code> have type
<pre>   hol_type frag list -&gt; hol_type
</pre>
     The <code>frag list</code> refers to the fact that there is a
     quotation being consumed.  A quotation is something that appears
     between back-quotes.  A quotation consists of strings and
     antiquotations.  A <code>term frag list</code> must have
     antiquotations that are of type <code>term</code>.  A
     <code>hol_type frag list</code> must have antiquotations that are
     of type <code>hol_type</code>.  Thus, if you use
     <code>Term</code> to parse a term, you can't directly antiquote
     in types, because this would violate the typing rules (you can
     only antiquote in terms if you call <code>Term</code>, because it
     requires a <code>term frag list</code>).
<p>
     So, in order to antiquote types into terms there is a bit of
     magic called <code>ty_antiq</code>, which if you look at its type
     (<code>hol_type -&gt; term</code>) turns a type into a term.  The
     term formed is completely bogus in a logical sense (it's actually
     a variable with a special name and the given type), but can be
     pushed into the parsing function <code>Term</code> so as to give
     the effect of antiquoting a type.
</p><p>
     The function <code>Hol_datatype</code> takes a <code>hol_type
     frag list</code>, so if you want to antiquote a type into the
     quotations it takes, you will not need to use
     <code>ty_antiq</code>.
</dl>
<P>
<HR>
<h2><a name = "Parsing">Parsing</a></h2>

<dl>
<dt><strong>Why can't I write <code>``MAP ~ x``</code>?</strong>
<dd> When you attempt this, you will get the error message
<pre>   No rule for [~]
</pre>
     meaning that the parser wants to do a reduction involving just
     the special symbol <code>~</code>, and it can't find a rule that
     allows this. The rule in the grammar is
<pre>   TM ::= ~ TM
</pre>
<p>
     <code>~</code> is treated specially, and not just as a function
     that you'd apply to arguments normally, for two reasons:
<p>
<ul>
<li> it can have precedence weaker than just function
          application.  This means that when you write <code>~f
          x</code>, this is parsed as <code>~(f x)</code>.
<p>
<li> it can group without needing extra parentheses, so you can
          write <code>~~b</code>; you don't need to write
          <code>~(~b)</code>.
</ul>
<p>
     To make <code>~</code> lose its special status, you should prefix
     it with a <code>$</code>.  <code>``MAP $~ x``</code> will work in
     the example, assuming that <code>x</code> has type <code>:bool
     list</code>.
<p>

<dt><strong> I'd like to use MEM as an infix, not a Prefix.</strong>
<p>
<dd> Use grammar manipulation functions such as
     <code>set_fixity</code> to alter its parsing information.
     These changes can be made to persist when the current
     theory is exported.  For example: 
<pre>   - load "listTheory";
   - set_fixity "MEM" (Infixr 450);
   &gt; val it = () : unit
   - listTheory.MEM;
   &gt; val it =
           |- (!x. x MEM [] = F) /\ !x h t. x MEM (h::t) = (x = h) \/ x MEM t
           : thm
</pre>

<dt><strong>I want to have the parser transform the concrete syntax
<code>``P[e/v]``</code> into <code>``(\v. P) e``</code>.</strong>

<dd>
First a warning: this is not likely to do  what you want. For example, 
you wouldn't get any nice way of stating the Hoare assignment axiom.
<pre>   { P[e/v] } v := e { P }
</pre>
In order to state the above, you'd need to actually write
<pre>   { (P v)[e/v] } v := e { P v }
</pre>
to make it clear that v might exist in the post-condition.<p>

And given this, you might as well write:
</p><pre>   { P e } v := e { P v }
</pre>
(The problem boils down to the fact that the literal HOL term
<pre>   ``(\v. P) x``
</pre>
where P is a variable, reduces under beta-conversion to <code>P</code>.)<p>

Incidentally, if this is the sort of thing you are doing, you might be
interested in looking at Peter Homeier's Sunrise system which
implements a VCG in HOL.  This is available 
<a href="http://www.cis.upenn.edu/%7Ehol/sunrise/index.html">here</a>.
<p>
If you really do want to implement your parsing trick above (turning
<code>``P[e/v]``</code> into <code>``(\v. P) e``</code>), you could do
this by implementing your own parser.  Moreover, this might not be
impossibly difficult, because the various phases of the existing
parser can be called independently.  Here's a sketch of what you'd
need to do:

</p><ol>
<li>  add a rule to the grammar corresponding to your concrete syntax
      above.  Map the syntax to some arbitrary identifier, "foo" say
      (see the Reference entry for <code>add_rule</code>).  Note that
      your particular choice of syntax, involving square brackets and
      / will conflict with the use of these symbols in the theories of
      lists and integers.  The best way around these problems is to
      explicitly load these theories, remove their syntax (see
      <code>remove_termtok</code>), and then install your own. This
      will ensure that things won't break if someone loads your
      theory/library and then later loads lists and/or integers.

</li><li> The first phase of your new parser will be to call
    <code>Absyn</code>, which
      will turn <code>P[e/v]</code> into abstract syntax corresponding
      to
        <blockquote><code>``foo P e v``</code></blockquote>
      You then traverse the term looking for this pattern and turning
      it into <code>(\v. P) e</code>.  You would also raise an error
      at this stage if <code>v</code> wasn't a variable.

</li><li>  You would then pass your modified abstract syntax "term" onto
      the next stages of the built-in parser (type-checking etc).  To
      do this, you would use
         <blockquote><pre>   Parse.absyn_to_term (term_grammar())
         </pre></blockquote>
</li></ol>

I hope this makes sense.  The definition of the standard parser from
Parse.sml is just

<pre>   fun Term q = absyn_to_term (term_grammar()) (Absyn q)
</pre>

So all you are doing is inserting an extra phase into the process
after calling <code>Absyn</code>, but before calling
<code>absyn_to_term</code>. 
</dl>
<p><hr><p>
<h2><a name = "Assumptions">Manipulating Hypotheses</a></h2>
<dl>
<dt><strong>How do I put HOL in a state so that theorem assumptions are
   printed?</strong>

<dd> Use
<pre>   show_assums := true;
</pre>
<p>
     This flag, along with several others that control HOL behaviour can
     be found in the <code>Globals</code> structure.
<P>

<dt><strong>How do I select assumptions in proof steps?</strong>
<dd>
This has been a much-discussed topic by HOL users over the
years. The info-hol archives have the details. The received opinion
seemed to be that numbered assumptions were great at proof-creation
time, but had potential for being a nightmare when existing proofs had
to be changed. 
<P>
In any case, the assumptions have to be dealt with. My current favourite
approach is to use "PAT_ASSUM", as follows:
<PRE>
  PAT_ASSUM tm MATCH_MP_TAC, or

  Q.PAT_ASSUM q MATCH_MP_TAC
</PRE>

PAT_ASSUM is like UNDISCH_THEN in that it removes an assumption and
makes it available as a theorem. However, it is better than UNDISCH_THEN
since the quotation argument it takes is treated as a pattern to match
against. The free variables of the goal to help constrain the match. It
is often the case that very complex assumptions can be singled out by
giving quite simple patterns to PAT_ASSUM. 

<P>

If you are unsatisfied with the way hypotheses are handled in proofs,
numbered (or named) assumptions can be added in a number of ways. Perhaps
the simplest is to write a version of UNDISCH_THEN, call it UNDISCH_NTH
having type
<PRE>
    int -> (thm -> tactic) -> tactic
</PRE>
UNDISCH_NTH k ttac grabs the kth assumption, converts it to a theorem
thk, and applies ttac to thk to get the desired tactic.
Here's one way to define it:
<PRE>
   fun UNDISCH_NTH k ttac (g as (asl,_)) =
       UNDISCH_THEN (Lib.el (k+1)(rev asl)) ttac g;
</PRE>
</dl>

<P><HR><P>

<h2><a name = "HOL_ERR">HOL_ERR</a></h2>

<dl>
<dt><strong> How can I find out more information about a HOL_ERR
exception?</strong>

<dd> If expression <code>M</code> is causing the grief, then write
<pre>     (M) handle e =&gt; Raise e
</pre>
Often the parentheses around <code>M</code> will not be required. 
<P>
It is sometimes convenient to use the <code>try</code> function as
well. It takes a function and an argument, applies the function to the
argument, and (on success) returns the result or (on failure) prints the
exception. Note however, that <code>try f x</code> will not catch errors
arising from the evaluations that lead to <code>f</code> or
<code>x</code>.

</dl>

<P><HR><P>

<h2><a name = "Locating">Locating Things</a></h2>

<dl>
<dt><strong> How do I get a datatype's axiom after using
             Hol_datatype?</strong>

<dd> 
Use <pre>   TypeBase.axiom_of (valOf (TypeBase.read "mytypename"))
</pre> Hopefully you won't need to do this very much because many of the
     contexts in which you previously needed the axiom will be dealt
     with more smoothly.  For example, cases, induction, one-one and
     distinctness theorems are now proved automatically, and are
     available from the TypeBase.  For example,
<pre>   TypeBase.one_one_of (valOf (TypeBase.read "mytypename"))
</pre>
<p>

<dt><strong> Is there documentation on
<code>computeLib.add_convs</code></strong>?
<dd>  
Best thing currently is to look at the implementation of
<code>REDUCE_CONV</code>, which uses add_convs to deal with
<code>DIV</code> and <code>MOD</code>: the invocation 
<pre>   add_conv (M,n,c) compset
</pre>

means (roughly):
   "when you see constant M applied to n subterms (i.e., M is
    fully applied to its arguments), apply conversion c".

<p>
<dt><strong> I can't find help on <code>IN</code>. What theory defined
is it defined in?</strong> 
<dd> 
<code>IN</code> is declared in <code>boolTheory</code>. <code>IN</code>
is not an ML identifier, so we don't index it. Perhaps we could index
constants to their place of definition though. 
<p>
You can always figure out the originating theory by

<pre>  dest_thy_const : term -&gt; {Theory : string, Name : string, Ty : hol_type}
</pre>
<p>
Using <code>decls name</code> will give you all the declared constants that
have the given name.

</dl>
<P><HR><P>
<h2><a name = "Misc">Miscellaneous</a></h2>

<dl>
<dt><strong>How do I create theories in more than one directory?</strong>
<dd> Both the <code>Holmake</code> program and the various <code>hol</code>
scripts take <code>-I &lt;dir&gt;</code> flags to indicate that the
system should look in the specified directories for object files
(whether theories or libraries).  You can rebuild theories in later
directories by calling <code>Holmake</code> with the appropriate
<code>-I</code> flags.

<p>

<dt><strong> How to rewrite with a theorem the other way round?</strong>
<dd> Use <code>GSYM</code>.
<p>

<dt><strong> How do I prove strings equal or inequal?</strong>

<dd> Use <code>stringLib.string_EQ_CONV</code>, which reduces
equalities over string literals to either T or F.  For example, to
demonstrate that <code>``(if "foo" = "bar" then 3 else 1) = 1``</code>, you
could write:
<pre>   - val t = ``(if "foo" = "bar" then 3 else 1)``;
   &gt; val t = ``(if "foo" = "bar" then 3 else 1)`` : Term.term
   - (DEPTH_CONV stringLib.string_EQ_CONV THENC REWRITE_CONV []) t;
   &gt; val it = |- (if "foo" = "bar" then 3 else 1) = 1 : Thm.thm
</pre>

<p>

<dt><strong> What's with all this "cut looping" stuff?</strong>

<dd> It's the simplifier, and it's turned off in Taupo releases
     onwards unless you set the trace level to one or higher.
<p>
</dl>
<p><HR><P>
<center>
<font size="-1">
<!-- Source file: faq.html<BR> !-->
Page last updated on Mon Jun 24 11:57:24 BST 2002 by Konrad Slind
<br>
Maintained by Konrad Slind
 (<a href="mailto:slind@cs.utah.edu">slind@cs.utah.edu</a>)</font><br>
</center>
</body>
</html>
