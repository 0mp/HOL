Q. Are error messages during the build like the following a source for
   concern? (2)

   > File "Term.sml", line 1328, characters 10-42:
   > !   let val {const=Const(r1,_),theory,place} = const_decl name
   > !           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   > ! Warning: pattern matching is not exhaustive

  -- No.  Nor is the following sort of output, when configuring the
     system before building:

     > /local/scratch/kxs/144/bin/mosmlyac: 4 shift/reduce conflicts.

Q. How do I prove strings equal or inequal? (1)

  -- Use stringLib.string_EQ_CONV, which reduces equalities over
     string literals to either T or F.  For example, to demonstrate
     that ``(if "foo" = "bar" then 3 else 1) = 1``, you could write:

     - val t = ``(if "foo" = "bar" then 3 else 1)``;
     > val t = ``(if "foo" = "bar" then 3 else 1)`` : Term.term
     - (DEPTH_CONV stringLib.string_EQ_CONV THENC REWRITE_CONV []) t;
     > val it = |- (if "foo" = "bar" then 3 else 1) = 1 : Thm.thm

Q. How do I antiquote types? (1)

  -- Antiquoting types works as you would expect when parsing types,
     so that it is fine to write:
       - val ty = Type`:bool`;
     and then
       - Type`:num -> ^ty`;
     However, you may wish to also introduce type antiquotations into
     term parses (as a type constraint on a variable for example).
     The problem is that you can't just write ^ty in this context,
     because the parsing function's type insists that all antiquotes
     be of type term.  You must use the ty_antiq function, which
     magically makes a type appear as a term:
       - val antity = ty_antiq ty;
       > val antity = `(ty_antiq(`:bool`))` : Term.term
     Then:
       - val x = Term`x:^antity`;

Q. I'd like to use MEM as an infix, not a Prefix.  Can I do this? (1)

  -- Yes!  Use grammar manipulation functions such as set_fixity to
     alter its parsing information.  These changes can be made to
     persist when the current theory is exported.  For example:

       - load "listTheory";
       - set_fixity "MEM" (Infixr 450);
       > val it = () : unit
       - listTheory.MEM;
       > val it =
           |- (!x. x MEM [] = F) /\ !x h t. x MEM (h::t) = (x = h) \/ x MEM t
           : Thm.thm

Q. How do I get a datatype's axiom after using Hol_datatype? (1)

  -- Use TypeBase.axiom_of (valOf (TypeBase.read "mytypename")).
     Hopefully you won't need to do this very much because many of the
     contexts in which you previously needed the axiom will be dealt
     with more smoothly.  For example, cases, induction, one-one and
     distinctness theorems are now proved automatically, and are
     available from the TypeBase.  For example,
        TypeBase.one_one_of (valOf (TypeBase.read "mytypename"))

Q. How to rewrite with a theorem the other way round? (0)

  -- Use GSYM

Q. What's with all this "cut looping" stuff? (0)

  -- It's the simplifier, and it's turned off in Taupo releases
     onwards unless you set the trace level to one or higher.

Q. How can I find out more information about a HOL_ERR <poly>
   exception? (0)

  -- If expression e is causing the grief, then write
        (e) handle E => raise E
     (Often the parentheses around e will not be required.)


