Release Notes for the Kananaskis-1 release of the HOL system.
-------------------------------------------------------------

Documentation
--------------

There is an improved interface to documentation:

   * The A single HTML page gives organized access to
      * libraries (source)
      * theories (proved theorems and scripts)
      * proof support (documentation and source)
      * an index of all identifiers in the system, with pointers to
        source

   * Much new documentation has been written, especially for heavily
     used proof tools.

* There are several important kernel differences between Kananaskis and
  Taupo, although we have striven to ensure that old code still runs.

   - separate namespaces
   - improved Holmake
   - improved installation


New proof tools
----------------

  * Another complete decision procedure for Presburger arithmetic over
    the integers and natural numbers, the Omega Test, has been
    implemented.  It is usually faster than Cooper's algorithm, but
    problems that require significant work in converting the input
    problem to DNF can cause it to take much longer.  The Omega Test
    is available in intLib as intLib.ARITH_CONV.


New libraries
--------------

  * The library HolSatLib (http://www.cl.cam.ac.uk/~mjcg/HolSatLib/)
    provides a very simple harness for invoking SAT solvers on HOL
    terms. Currently SATO, GRASP and ZCHAFF are supported. These solvers
    all require input in the standard DIMACS format for conjunctive normal
    form (CNF). It should be straightforward to add other DIMACS
    compatible SAT solvers.  The purpose of HolSatLib is to provide a
    platform for experimenting with combinations of theorem proving and
    SAT. HOL can be used to deductively manipulate terms into CNF as
    required for SAT analysis, and then the results of the analysis can be
    reimported into HOL and either checked or just trusted.  HolSatLib has
    only been tested under Linux, though it should be possible to run it
    under Windows.

  * The library word32Lib, which mainly comprises word32Theory (see below),
    plus an evaluation conversion "WORD_CONV".


New theories
-------------

  * Laurent Thery's theories of divisibility, primality, and gcd are
    now part of the system, under the name dividesTheory, primeTheory
    and gcdTheory.

  * A theory of 32-bit machine arithmetic, due to Anthony Fox,
    available under the name word32Theory.  The theory defines many
    of the `integer' operations found in computer architectures.  It
    was developed in modelling the ARM instruction set.  The operations
    can be grouped as follows:

    - Bit-field testing and extraction;
    - Arithmetic: Addition, Subtraction, Multiplication and Two's
      Complement;
    - Logical: One's Complement, Bitwise And, Or and Exclusive Or;
    - Shifts: Logical Right, Arithmetic Right, Rotate Right, and
      Rotate Right One Place with Carry Extension.

    Theorems are provided for reasoning about bit-fields, as well as
    arithmetic (Commutative Ring properties) and the logical
    operations (Boolean Algebra properties).  A number of rewrite
    rules are also provided, and these support fairly efficient term
    evaluation using WORD_CONV.

    Although the word size and operations are fixed, the script
    src/word32/word32Script.sml can be used as a basis for defining
    bespoke word theories.  (The word length is given by a constant, WL.)

  * A new theory of strings over an alphabet of (256) characters has
    been provided. String literals are no longer an infinite set of
    constants, given meaning by mk_thm; instead, they are constructed
    terms. This removes the last use of mk_thm in the HOL system. Of
    course, mk_oracle_thm is still available for users.


New features
-------------

  * relationTheory now defines the constants RTC and RC (reflexive and
    transitive closure, and reflexive closure) and proves a variety of
    properties about them.

  * Holmake will now read and act under the supervision of make-files.
    These files can be used to control construction of object files in
    languages other than SML, and also have a number of other
    convenient functions.  The basic format of the make-files read by
    Holmake is very much like that of standard make-files, but there
    is no support for patterns.  For more documentation of this, see
    the Holmake section of the DESCRIPTION.

  * Term and type constants in the logic now enjoy per-theory
    name-spaces.  This means that multiple theories can share
    constants with the same names.  If two term constants of the same
    name are part of the logical context, the parser treats that name
    as if it were overloaded to both constants.  Constants can be
    unambigously specified by prepending the theory name and "$".
    Thus

       ``bool$/\``

    is the conjunction operator in boolTheory, and

       ``:num$num``

    is the num type from numTheory.  There are also new functions in
    the kernel's ML API for building and pulling apart constants with
    theory information included.  For example, the function
    mk_thy_const has the following type

        {Name : string, Thy : string, Ty : hol_type} -> term

    and the function dest_thy_const inverts this.  mk_const remains in
    the system, but its behaviour is unspecified when two or more
    constants have the same name.

  * Type abbreviations are now possible, using the function
    Parse.type_abbrev.  When a type abbreviation is made, both the
    abbreviation and the abbreviation's RHS can be used to specify
    types.  When printed, types do not include abbreviations.
    Variables that occur in the RHS become parameters of the "new"
    type operator.  Thus

        type_abbrev("set", ``:'a -> bool``)

    is used in pred_setTheory to establish set as an abbreviation for
    functions of type alpha to bool.  After issuing this command, one
    can write  ``NS:num set`` and ``:'b set``.

  * Syntax for ML style case expressions is now enabled.  The same
    patterns supported by Define are supported.  Some examples of the
    syntax:

        case n of 0 -> x || SUC n -> n + 1

    and

        case p of (x, []) -> x + 1
               || (y, h::t) -> y + h

  * An easier way of augmenting the built-in pretty-printer is now
    possible.  Previously we allowed for the built-in printer to be
    completely replaced by a new function.  Now, users can also
    specify new functions to augment the existing code, with the new
    functions called on terms of specified types.  For more details,
    see the documentation for Parse.add_user_printer in the REFERENCE.


Behaviours changed:
-------------------

  * There are now four (4!) hol executables.  They are:
      hol, hol.bare, hol.unquote, and hol.bare.unquote
    all found in the bin/ directory.  We recommend hol.unquote as the
    standard starting point.

    In more detail, the ".unquote" suffix means that the ``...``
    preprocessor is enabled.  The ".bare" indicates that the
    executable starts up with a minimal logical context (just
    boolTheory, the goal-stack and the 'standard' tactics and
    conversions loaded).  This is like the old behaviour of the hol
    and hol.unquote executables.  The absence of the ".bare" indicates
    an executable that loads "bossLib" as it starts.  This provides a
    much richer logical environment (lists, natural numbers, pairs,
    options, disjoint sums), with additional tools too (arithmetic
    decision procedure, definition principles).

  * Overloading now works slightly differently.  Constants are
    automatically overloaded to "themselves".  Thus, if you define a
    constant called "foo", and then another called "bar", and want to
    have "bar" overload to "foo", then you need only call
        overload_on ("foo", ``bar``);

  * The names of record fields are not now overloaded to the accessor
    function.  This function needs to be accessed as the constant
      ``<rcd-type-name>_<fldname>``
    E.g.,
      ``rcd_fld``
    If you really like the 'dot' syntax, you can always write
      ``\r. r.fld``
    which eta-converts to the above.

  * Hol_datatype's definition of large "enumerated types" (data types
    with only nullary constructors) is now a lot more efficient than
    it used to be.

  * We have rationalised the ML API.  By default, just about all
    functions use "paired" syntax, rather than "record" syntax.  So,
    mk_var has type

      (string * hol_type) -> term

    rather than

      {Name : string, Ty : hol_type} -> term

    A consistently "record-ised" view of the world is still available
    if the structure Rsyntax is opened.  Even in the default view of
    the world, some functions still take records.  These exceptions
    are for functions where we feel that the order of arguments of the
    same type is not always obvious.  This is exemplified by the
    universal adoption of the {redex,residue} datatype for
    substitutions and instantiations.  (Remember also that the infix
    |-> function can be used to construct such records.)

  * The parser now lets you create an ambiguous grammar for terms'
    concrete syntax.  In doing so, it will warn you that you have done
    so, but will otherwise attempt to do its best to parse inputs.
    The system's parsing and printing behaviour may become
    unpredictable, but generous uses of parentheses should allow most
    reasonable uses of the parser.

Bugs fixed:
-----------

  * Muddy wouldn't build on Linux if the binary distribution of Moscow
    ML was being used because of a lack of header files in an expected
    place.  Thanks to Hasan Amjad for reporting this bug.

  * Define_type.define_type wouldn't work.  This code is deprecated
    with a capital 'D', but we've provided a fix anyway.  Thanks to
    Viktor Sabelfeld for the report of the bug.  It was caused by the
    now correct behaviour of constant hiding that wasn't correct prior
    to Taupo-6.

