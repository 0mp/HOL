<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/x
html1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type"
      content="text/html ; charset=US-ASCII" />
<title>Release Notes for Kananaskis-4 version of HOL 4</title>
</head>

<body>
<h1>Notes on HOL 4, Kananaskis-4 release</h1>

<h2 id="contents">Contents</h2>
<ul>
  <li> <a href="#new-features">New features</a> </li>
  <li> <a href="#bugs-fixed">Bugs fixed</a> </li>
  <li> <a href="#new-theories">New theories</a> </li>
  <li> <a href="#new-tools">New tools</a> </li>
  <li> <a href="#new-examples">New examples</a> </li>
  <li> <a href="#incompatibilities">Incompatibilities</a> </li>
</ul>



<h2 id="new-features">New features:</h2>

<ul>
  <li> There is a new unambiguous notation for set comprehensions that
  allows one to specify exactly what variables can &ldquo;vary&rdquo;
  to generate the set.  For example, the current notation interprets
<pre>
         { x + y | x &lt; y }
</pre>
      as the set that takes all pairs of numbers such that the first
      component is less than the other, and then sums them (generating
      the set of all non-zero numbers).  The new notation allows one
      to specify that only the <code>x</code> should vary by writing
<pre>
         { x + y | x | x &lt; y }
</pre>
      This denotes the set of numbers from <code>y</code> up to but not
      including <code>2&nbsp;*&nbsp;y</code>.  To express the first set
      in the new notation, one would write
<pre>
         { x + y | x,y | x &lt; y }
</pre>
      The parser accepts both notations.  The pretty-printer prefers
      the old notation unless it can not express the set being
      printed.  Further details are in the Description.  Thanks to
      John Harrison for discussion leading to the adoption of this
      syntax. </li>

  <li> <p> The syntax of string and character literals is now the same as
      that accepted by SML.  This means that escapes such as
      <code>\n</code> (for the linefeed character) and
      <code>\^E</code> (for ASCII character no.&nbsp;5) can be used
      inside string and character literals.</p>

      <p> The SML syntax which allows strings to be broken over
      new-lines by using back-slashes is also supported.  This means
      that one can write </p>
<pre>
         ``mystring = "the quick brown fox jumps over \
                      \the lazy dog"``
</pre>
      <p> and have the actual string value generated exclude the
      white-space appearing between the back-slashes.</p>
      </li>


  <li> <p> It is possible to include both <code>^</code> (caret) and
      <code>`</code> back-tick characters inside quotations.  Usually
      these characters have special meaning inside quotations: caret
      is used to introduce an antiquotation, and the back-tick is used
      to end a quotation (singly or doubly, depending on the sort of
      quotation).  The caret character can be used <em>as is</em> if a
      sequence of them is followed by white-space.  Otherwise, it
      needs to be &ldquo;escaped&rdquo; by preceding it with another
      caret character.  Similarly, the backquote character can be
      written by escaping it with a caret. For example, writing</p>
<pre>
         ``s1 ^ s2``
</pre>
      <p> will result in the string <code>s1 ^ s2</code> being passed
      to the HOL parser.  This string will then be treated in the
      standard fashion.  E.g., if <code>^</code> is an infix, a
      function application with it as the head operator will be
      created.  If one wrote <code>``s1 ^^ s2``</code> this would also
      pass through unchanged.  However, if one wrote </p>
<pre>
         ``s1 ^s2``
</pre>
      <p> this would be taken as an anti-quotation of SML variable
      <code>s2</code>.  One should write </p>
<pre>
         ``s1 ^^s2``
</pre>
      <p> to get the single caret passed to the underlying lexer.</p>

      <p> Note that the back-quote character always needs to be
      escaped by a caret, and that caret-escapes need to be applied
      even within string literals and comments that occur inside
      quotations.</p></li>
</ul>

<h2 id="bugs-fixed">Bugs fixed:</h2>

<ul>
  <li> <p> The <code>muddyC/muddy.c</code> file would not build with
      <code>gcc-4</code>. </p>
  </li>

  <li> <p> The implementation of <code>Q.EXISTS</code> was incorrect
      (would only work with witnesses of type <code>:bool</code>).
      Thanks to Eunsuk Kang for the report of this bug. </p> </li>

  <li> <p> The natural number and integer decision procedures were not
      normalising multiplicative expressions as much as they should,
      causing obvious goals to not get proved.  Thanks to Alexey
      Gotsman for the report of this bug. </p> </li>

  <li> <p> The theory and identifier indexes in the help pages were
      generated with bogus links.  Thanks to Hasan Amjad for the
      report of this bug. </p> </li>

  <li> <p> Expressions using <code>case</code>-expressions with
      function-types and applied to arguments failed to parse
      correctly. </p> </li>

  <li> <p> The implementation of <code>Holmake</code>&rsquo;s
      <code>--rebuild_deps</code> (or <code>-r</code>) option was
      faulty.  Thanks to Tom Ridge for the report of this bug. </p>
      </li>

  <li> <p> The implementation of <code>stringLib.string_EQ_CONV</code>
      failed if one of the string arguments was the empty string.
      Thanks to Mike Gordon for the report of this bug. </p> </li>

</ul>


<h2 id="new-theories">New theories:</h2>
<ul>
  <li> <p> A theory of the rational numbers, thanks to Jens
  Brandt.</p> </li>

</ul>

<h2 id="new-tools">New tools:</h2>

<h2 id="new-examples">New examples:</h2>

<h2 id="incompatibilities">Incompatibilities:</h2>

<ul>

  <li> <p> The <code>std_ss</code> simpset has become more powerful,
      picking up a set of &ldquo;obvious&rdquo; rewrites that used to
      be in <code>arith_ss</code>.  Now the latter simpset adds just
      the decision procedure for Presburger arithmetic.</p> </li>

  <li> <p> Functions such as <code>induction_of</code> in the
      <code>TypeBase</code> structure that used to take a string (the
      name of a type operator), now take a type.  Thus, instead of</p>
<pre>
         TypeBase.induction_of "num"
</pre> use
<pre>
         TypeBase.induction_of ``:num``
</pre>
</li>

  <li> The normalisation of arithmetic terms performed by
      the <code>ARITH_ss</code> simpset fragment (and thus, the
      simpset <code>bossLib.arith_ss</code>) is more aggressive.  This
      can break proofs.  The <code>bossLib</code> library now exports
      <code>old_arith_ss</code> and <code>old_ARITH_ss</code>
      entry-points if users wish to avoid having to adjust their
      proofs.</li>
</ul>


<hr />

<p> <em><a href="http://hol.sourceforge.net">HOL 4, Kananaskis-4</a></em> </p>

</body> </html>
