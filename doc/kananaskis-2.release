Bugs fixed:
-----------

  * Hol_datatype would fail if called on to define a type with a
    single nullary constructor.

  * pred_setLib.UNION_CONV (and other functions in this library)
    failed to work as advertised.  (Thanks to Lockwood Morris for the
    report of this bug.)

  * It was too easy to do significant parser things before a
    new_theory declaration, causing these effects not to persist with
    the export of the theory.  Now, attempting to do this causes a
    strong warning to be issued.

  * let terms with bodies that were abstractions didn't print
    correctly.

  * The type grammar didn't print stored type abbreviations
    correctly.

  * Adding a user-supplied pretty-printer caused polymorphic terms to
    fail to print.

  * DECIDE_TAC didn't pay attention to goal assumptions.

  * A bug in ARITH_CONV's handling of conditional expressions caused
    some quantified goals to fail to be proved.

  * The lexer got confused if a token made up of non-aggregating
    characters (e.g., including ";") was used, but not as part of
    special concrete syntax.  I.e., ;; was OK as an infix, but not as
    a normal constant.  (Thanks to Klaus Schneider for the report of
    this bug.)

  * SPEC_VAR and theory export caused bound variables with the same
    name as constants to get changed.  (Thanks to Lockwood Morris for
    the report of this bug.)

  * Many, many documentation typos and bugs were fixed.  (Thanks to
    Carl Witty for the report of most of these.)

  * Two fixes for the simplifier's implementation of congruence rules.
    With deep nesting, congruence rules could lead to an exponential
    increase in time taken.  Also, terms that included variables used
    in a rule's statement could cause the rule to fail to fire.

New features:
-------------

  * The term and type parsers now report errors with an indication as
    to where in the parse they have occurred.  If the error is found
    during a run of Holmake, the location includes the line number in
    the file where the error is.  Pragma comments of the form
    (*#loc 100 5*) allow the line and column numbers to be overridden,
    a la C's #line directive.  (Many thanks to Keith Wansbrough for
    the implementation of this feature.)  The lexer is also much
    faster than it used to be.

  * The system better distinguishes interactive and non-interactive
    use (the latter occurs with building things with Holmake).
    Diagnostic output is now rather different in non-interactive
    mode.  Holmake comes with a new -i or --interactive flag to flip
    the underlying flag back to interactive, if you want to see
    "interactive mode" output.

  * Holmake now supports the use of user-specified variables, in a
    manner analogous to that done by traditional make implementations.
    For example, one can define a variable OBJS,
      OBJS = foo bar baz
    and then refer to this variable elsewhere by writing
      $(OBJS)
    Holmake also provides some functions like those in GNU make for
    manipulating text (performing pattern-based substitutions, for
    example).

  * Performance when defining large record types (where the number of
    fields is greater than 10), is now much improved.

  * In addition to the traditional $-prefix for making identifiers
    ignore their status as special forms in the grammar, HOL now
    supports the Caml method of enclosing identifiers in parentheses.
    Thus, instead of
       $/\ p
    one can also write
       (/\) p
    By default, the pretty-printer continues to print using the old
    $-syntax.  This can be changed by setting the trace variable
    "pp_dollar_escapes".

  * Configuration of the system is easier.  Instead of having to edit
    configure.sml yourself, just pipe tools/smart-configure into mosml
    as the first step of installation (before build):

       mosml < tools/smart-configure.sml

New theories:
-------------

  * A theory of co-inductive (possibly infinite) labelled transition
    paths in pathTheory.


New tools:
----------

  * A new first-order proof tactic (called METIS_TAC) that uses
    ordered resolution and paramodulation, specifically tailored for
    subgoals that require equality reasoning.

  * A 'boolification' tool that automatically defines functions that map
    datatypes to boolean vectors. These kind of functions are needed
    for sending HOL subgoals to a model-checker or SAT solver.

Incompatibilities:
------------------

  * Changes to the term lexer mean that comment tokens "(*" and "*)"
    that appear within terms can need to be more carefully separated
    from other symbolic and 'aggregating' characters such as other
    brackets.  In particular, strings like "((*" and "[(*" will no
    longer be tokenised so as to reveal comment tokens.

  * Rewrite rules for arithmeticTheory's MIN and MAX constants have
    been made more general; they will now match more often.  For
    example, MIN_LE has changed from
       m <= MIN m n = m <= n
    to
       p <= MIN m n = p <= m /\ p <= n

  * For reasons of efficiency, all conversions in the system may now
    potentially raise the special exception Conv.UNCHANGED to indicate
    that they haven't changed the input term, and that they should be
    treated as if they had returned the theorem |- t = t, for input t.
    Conversion connectives (such as THENC, ORELSEC and TRY_CONV) all
    do the appropriate thing in the presence of this exception.
    Previously, sub-systems such as the simplifier, rewriter and
    arithmetic decision procedures have used this idea to make them
    work faster, but couldn't share information about unchangedness.

    For interactive use, CONV_RULE and CONV_TAC handle the exception
    appropriately, and the new function QCONV (of type : conv -> conv)
    can make any conversion handle UNCHANGED.  QCONV's implementation
    is

       fun QCONV c t = c t handle UNCHANGED => REFL t

    If you have code implementing conversions of your own, you may
    need to fix code if it uses the following idiom:

       fun myconv t =
         let val th = someconv t
             val ..  = <fiddle with th>
         in
             <resulting theorem>
         end

    If someconv raises UNCHANGED, then myconv will too, causing
    expressions such as

      myconv THENC <something else>

    to treat myconv as if it hadn't done anything (because the <fiddle
    with th> code never got called).

    This can be relatively difficult to track down, but the fix is
    simple enough: change "someconv t" to "QCONV someconv t".
