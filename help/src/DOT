(* ------------------------------------------------------------------------- *
 *     Automatic generation of clickable image maps of the                   *
 *     HOL theory hierarchy.                                                 *
 *                                                                           *
 * The algorithm works as follows:                                           *
 *                                                                           *
 *   1. Generate the dependencies from the current theory hierarchy          *
 *   2. Write them to a file ready for processing by "dot"                   *
 *   3. Invoke dot once to generate the "gif"-format image                   *
 *   4. Invoke dot again to generate the theory coodinates                   *
 *   5. Parse the results of (4) and generate the desired html file.         *
 *   6. Generate the html files for each segment in the current theory       *
 *      hierarchy.                                                           *
 *                                                                           *
 * Before loading this file, you might need to tell "dot" where the          *
 * TrueType fonts that it needs are. On my Linux system, this used to be:    *
 *                                                                           *
 *     DOTFONTPATH=/dosc/windows/fonts; export DOTFONTPATH                   *
 *                                                                           *
 * ------------------------------------------------------------------------- *)

app load ["Substring","Int","FileSys", "Process"];

val HTML_DIR   = Path.toString(Path.fromString(Path.concat
                    (Globals.HOLDIR,"help/theorygraph")));
val SIGOBJ_DIR = Path.toString(Path.fromString(Path.concat
                    (Globals.HOLDIR,"sigobj")));
(* val BASE_URL   = "http://www.cl.cam.ac.uk/ftp/hvg/hol98/HTML"; *)

(*---------------------------------------------------------------------------
     Extract dot-friendly digraph from HOL theory graph.
 ---------------------------------------------------------------------------*)

fun node thy = map (fn p => (p,thy)) (parents thy);

local fun leq (s:string,_) (t,_) = s <= t
in
fun ancestor_nodes thy = 
  let val thys = ancestry thy
      val pairs = sort leq (flatten (map node thys))
  in (thys, pairs)
  end
end;

fun pp_dot_file {size,ranksep,nodesep} (dom,pairs) ppstrm =
 let open Portable 
     val {add_string,add_break,begin_block,end_block,
          add_newline,flush_ppstream,...} = with_ppstream ppstrm
     fun pp_thy s =
       (begin_block CONSISTENT 2;
        add_string s; add_break (1,0);
        add_string "[URL ="; add_break(1,0); 
        add_string (quote (s^"Theory.html"));
        add_string "]";
        end_block())
     fun pp_pair (x,y) =
       (begin_block CONSISTENT 0;
        add_string x;
        add_string " -> ";
        add_string y;
        end_block())
 in
  begin_block CONSISTENT 0;
  begin_block CONSISTENT 5;
  add_string "digraph G {";
  add_break (1,0);

  add_string "ratio = compress"; add_break(1,0);
  add_string "size = ";    add_string (quote size); add_break(1,0);
  add_string "ranksep = "; add_string ranksep;      add_break(1,0);
  add_string "nodesep = "; add_string nodesep;      add_break(1,0);
  add_string "node [fontcolor = darkgreen fontsize=30 fontname=Helvetica]"; 
  add_break(1,0);
  add_newline();
  begin_block CONSISTENT 0;
   pr_list pp_thy (fn () => ()) add_newline dom;
  end_block();
  add_newline(); add_newline();
  begin_block CONSISTENT 0;
   pr_list pp_pair (fn () => ()) add_newline pairs;
  end_block();
  end_block();
  add_newline(); add_string "}"; add_newline();
  end_block()
 end;

fun gen_dotfile file node_info =
 let open TextIO
     val ostrm = openOut file
 in  PP.with_pp {consumer=fn s => output(ostrm,s),linewidth=75,
                 flush=fn () => flushOut ostrm}
        (pp_dot_file {size="10,16.5",ranksep="1.0",nodesep="0.30"} node_info); 
     closeOut ostrm
 end;

(*---------------------------------------------------------------------------
       Parse theory coordinates generated by dot -Timap. Note that
       these come (i,j) (p,q), but it seems that they should be 
       transformed to (i,q) (p,j) ... and so that's what we do!
 ---------------------------------------------------------------------------*)

val comma_sp = "," and qdelim = "\"";

val splitter = 
  let val test = Char.contains "(,)"
  in fn c => Char.isSpace c orelse test c
  end;

fun translate s A = 
  case String.tokens splitter s
   of "rect"::nm::n1::n2::n3::n4::_ => String.concat
        ["<AREA shape=\"rect\" COORDS= ",
         qdelim, n1,comma_sp, n4,comma_sp, n3,comma_sp, n2,qdelim,
         " href=", qdelim, nm,qdelim, ">"]
       ::A
    | other => A;

fun parse_imap_file file = 
  let val strm = TextIO.openIn file
      fun loop A =
         case TextIO.inputLine strm 
          of "" => A
           | line =>  loop (translate line A)
  in 
       loop [] before TextIO.closeIn strm
  end;


fun gen_map_file dot node_info name =
 let open TextIO
     val dotfile   = name^".dot"
     val giffile   = name^".gif"
     val jpegfile  = name^".jpeg"
     val imapfile  = name^".imap"
     val mapfile   = name^".html"
     val gifurl    = name^".gif"
     val psfile    = name^".ps"
     val  _        = gen_dotfile dotfile node_info
     val cmd0 = String.concat[dot," -Tgif ",  dotfile, " > ", giffile]
     val cmd1 = String.concat[dot," -Tjpeg ",  dotfile, " > ", jpegfile]
     val cmd2 = String.concat[dot," -Timap ", dotfile, " > ", imapfile]
     val cmd3 = String.concat[dot," -Tps ",   dotfile, " > ", psfile]
 in if Process.system cmd0 = Process.success andalso
       Process.system cmd1 = Process.success andalso
       Process.system cmd2 = Process.success andalso
       Process.system cmd3 = Process.success
    then let val ostrm = openOut mapfile
             fun out s = output(ostrm, s^"\n")
         in
             out "<HTML>";
             out "<HEAD><TITLE>HOL Theory Hierarchy</TITLE></HEAD>";
             out "<BODY bgcolor=linen text=crimson>";
             out "<H1>HOL Theory Hierarchy</H1>";
             out (String.concat 
                  ["<IMG src = \"",jpegfile,"\"",
                      " usemap=\"#theorymap\"", 
                      " alt=\"HOL Theory Map\">"]);
             out "<MAP name=\"theorymap\">";
             List.app out (parse_imap_file imapfile); 
             out "</MAP>";
             out "</BODY>";
             out "</HTML>";
             closeOut ostrm
         end
    else raise Fail "gen_map_file: failed "
 end;

fun dir_theories dir = 
 let open Substring FileSys
     val dstrm = openDir dir
     fun thys () =
       case readDir dstrm
        of NONE => []
         | SOME file => 
            let val (ss1,ss2) = position "Theory.sig" (all file)
            in if isEmpty ss1 orelse isEmpty ss2
               then thys()
               else string ss1 :: thys()
            end
 in thys()
 end;


fun load_theories thyl = app (load o C concat "Theory") thyl;

fun isThm (_,(_,DB.Thm)) = true | isThm _ = false;
fun isAxm (_,(_,DB.Axm)) = true | isAxm _ = false;
fun isDef (_,(_,DB.Def)) = true | isDef _ = false;

fun bind ((thy,s),(th,cl)) = (s,th);

fun dest_theory s =
 let val name = if s="-" then current_theory() else s
     val thms = DB.thy name
 in {parents = parents name,
     type_constants = types name,
     term_constants = constants name,
     axioms      = map bind (gather isAxm thms),
     definitions = map bind (gather isDef thms),
     theorems    = map bind (gather isThm thms)}
 end;

fun theory_to_html ppstrm theory_name =
 let open Portable
     val {parents,type_constants, term_constants, 
          axioms, definitions, theorems} = dest_theory theory_name
       val {add_string,add_break,begin_block,end_block,
            add_newline,flush_ppstream,...} = with_ppstream ppstrm
       val pp_thm  = pp_thm ppstrm
       val pp_type = pp_type ppstrm
       fun colour thing col = 
          String.concat["<font color=\"",col,"\">",thing,"</font>"];
       fun strong s = 
        (add_string"<STRONG>"; 
         add_string (String.concat["<font color=\"black\">",s,"</font>"]); 
         add_string"</STRONG>")
       fun STRONG s = 
        (add_string"<STRONG>"; 
         add_string 
            (String.concat["<font size=+3 color=\"black\">",s,"</font>"]); 
         add_string"</STRONG>")
       fun title s = add_string(String.concat
                      ["<H1><font color=\"black\">",s,"</font></H1>"]);
       fun link (l,s) = 
        (add_string("<A HREF = "^Lib.quote l^">");
                         strong s;
                         add_string"</A>")
       fun HR() = (add_newline();add_string"<HR>";add_newline());

       fun pblock(ob_pr, obs) =
             ( begin_block CONSISTENT 4;
               STRONG "Parents";
               add_string "&nbsp;&nbsp;&nbsp;&nbsp;";
               add_break (1,0);
               pr_list ob_pr (fn () => ()) (fn () => add_break (2,0)) obs;
               end_block();
               add_newline();
               add_newline())

       fun sig_block(ob_pr1, obs1, ob_pr2,obs2) =
           if null type_constants andalso null term_constants then ()
           else
             ( title "Signature"; add_newline();
               begin_block CONSISTENT 4;
               begin_block CONSISTENT 0;
                add_string "<center>"; add_newline(); 
                add_string "<table BORDER=4 CELLPADDING=10 CELLSPACING=1>"; 
                           add_newline();
               end_block();
               add_newline();
               if null type_constants then () else
               (begin_block CONSISTENT 0;
                 add_string "<tr>"; add_break (1,0);
                 add_string "<th>"; add_break (1,0);
                 add_string (colour"Type" "crimson"); add_break (1,0);
                 add_string "<th>"; add_break (1,0);
                 add_string (colour"Arity" "crimson");
                end_block();
                pr_list (fn x => (add_string"<tr>"; ob_pr1 x))
                           (fn () => ()) add_newline obs1;
                add_newline())
               ;
               if null term_constants then () else
               (begin_block CONSISTENT 0;
                 add_string "<tr>"; add_break (1,0);
                 add_string "<th>"; add_break (1,0);
                 add_string (colour"Constant" "crimson"); add_break (1,0);
                 add_string "<th>"; add_break (1,0);
                 add_string (colour"Type" "crimson");
                end_block();
                pr_list (fn x => (add_string"<tr>"; ob_pr2 x))
                           (fn () => ()) add_newline obs2;
                add_newline())
               ;
               end_block(); add_newline(); 
               begin_block CONSISTENT 0;
                   add_string "</table>"; add_newline();
                   add_string "</center>"; add_newline();
                   end_block();
               add_newline())

       fun dl_block(header, ob_pr, obs) =
             ( begin_block CONSISTENT 0;
               title header;
               add_newline();
               add_string"<DL>"; add_newline();
               pr_list 
                (fn (x,ob) => 
                     (begin_block CONSISTENT 0;
                      add_string"<DT>"; strong x; add_newline();
                      add_string"<DD>"; add_newline();
                      ob_pr ob;
                      end_block()))
                (fn () => ()) add_newline obs;
               add_newline();
               add_string"</DL>";
               end_block();
               add_newline();
               add_newline())

       fun pr_thm (heading, ths) = dl_block(heading, 
           (fn th => (begin_block CONSISTENT 0;
                      add_string"<PRE>";
                      add_newline();
                      pp_thm th;
                      add_newline();
                      add_string"</PRE>";
                      add_newline();
                      end_block())),    ths)
   in begin_block CONSISTENT 0;
         add_string "<HTML>"; add_newline();
         add_string("<HEAD><TITLE>Theory: "^theory_name^"</TITLE></HEAD>");
         add_newline();
         add_string "<BODY bgcolor=linen text=midnightblue>";
         add_newline();
         title ("Theory \""^theory_name^"\"");
         add_newline()
         ;
         if null parents then () else
         pblock ((fn n => link(n^"Theory.html",n)), parents)
         ;
         sig_block(
             (fn (Name,Arity) => 
                   (begin_block CONSISTENT 0;
                    add_string"<td>"; add_break(1,0); strong Name; 
                    add_break(1,0);
                    add_string"<td>"; add_break(1,0); 
                    add_string (Lib.int_to_string Arity); end_block())),
                   rev type_constants,
             (fn const =>
                 let val {Name,Thy,Ty} = Term.dest_thy_const const
                 in begin_block CONSISTENT 0;
                    add_string"<td>"; add_break(1,0); strong Name; 
                    add_break(1,0);
                    add_string"<td>"; add_break(1,0); pp_type Ty;
                    end_block()
                  end), rev term_constants)
         ; 
         if null axioms then () else pr_thm ("Axioms", rev axioms)
         ;
         if null definitions then () 
         else (if null axioms then () else (HR();HR()); 
               pr_thm ("Definitions", rev definitions))
         ;
         if null theorems then () 
         else (if null axioms andalso null definitions then () 
               else (HR();HR());
               pr_thm ("Theorems", rev theorems));
         add_newline();
         HR();
         add_string "</BODY>"; add_newline();
         add_string "</HTML>"; add_newline();
       end_block()
   end;

fun html_theory path s = 
   let val name = (case s of "-" => current_theory() | other => s)
       val ostrm = Portable.open_out (Path.concat(path,name)^"Theory.html")
   in
     PP.with_pp {consumer = Portable.outputc ostrm, linewidth = 78,
                 flush = fn () => Portable.flush_out ostrm}
        (Lib.C theory_to_html name)
     handle e => (Portable.close_out ostrm; raise e);
     Portable.close_out ostrm
   end;

(* 
  val sys_theories = dir_theories SIGOBJ_DIR;
  load_theories sys_theories;
  map (html_theory HTML_DIR) ("min"::sys_theories);
  val ancs = ancestor_nodes "-";

  (* invoke gen_map_file in help/theorygraph *)

  (* The following works on W2K with dot version 1.84 *)

  gen_map_file "c:/cygwin/home/slind/graphviz/184/Graphviz/bin/dot.exe" 
               ancs "theories";

*)
