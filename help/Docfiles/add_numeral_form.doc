\DOC add_numeral_form

\TYPE {Parse.add_numeral_form : (char * string option) -> unit}

\SYNOPSIS
Adds support for numerals of differing types to the parser/pretty-printer.

\KEYWORDS
Parsing, pretty-printing.

\LIBRARY Parse

\DESCRIBE
This function allows the user to extend HOL's parser and
pretty-printer so that they recognise and print numerals.  A numeral
in this context is a string of digits.  Each such string corresponds
to a natural number (i.e., the HOL type {num}) but {add_numeral_form}
allows for numerals to stand for values in other types as well.

A call to {add_numeral_form(c,s)} augments the global term grammar in
two ways.  Firstly, in common with the function
{add_bare_numeral_form} (q.v.), it allows the user to write a single
letter suffix after a numeral (the argument {c}).  The presence of
this character specifies {s} as the ``injection function'' which is to
be applied to the natural number denoted by the preceding digits.

Secondly, the constant denoted by the {s} argument is overloaded to be
one of the possible resolutions of the overloaded operator {fromNum}.
When a numeral doesn't have a character suffix, this means that it has
been made an argument to the function {fromNum}, and so might take on
different types, depending on the context.

\FAILURE
Fails if {arithmeticTheory} is not loaded, as this is where the basic
constants implementing natural number numerals are defined.  Also
fails if there is no constant with the given name, or if it doesn't
have type {`:num -> 'a`} for some {'a}.  Fails if
{add_bare_numeral_form} would also fail on this input.

\EXAMPLE
The natural numbers are given numeral forms as follows:
{
   val _ = add_numeral_form (#"n", NONE);
}
\noindent This is done in {arithmeticTheory} so that after it is
loaded, one can write numerals and have them parse (and print) as
natural numbers.  However, later in the development, in
{integerTheory}, numeral forms for integers are also introduced:
{
   val _ = add_numeral_form(#"i", SOME "&");
}
\noindent The string {&} is the name of the function which injects
natural numbers into integers.  After this call is made, numeral strings
can be treated as integers or natural numbers, depending on the
context.
{
   - load "integerTheory";
   > val it = () : unit
   - Term`3`;
   <<HOL message: more than one resolution of overloading was possible.>>
   > val it = `3` : Term.term
   - type_of it;
   > val it = `:int` : Type.hol_type
}
\noindent The parser has chosen to give the string ``3'' integer type
(generally, it will prefer the most recently specified possibility, in
common with much overloading, but this probably shouldn't be relied
on).  However, numerals can appear with natural number type in
appropriate contexts:
{
   - Term`(SUC 3, 4 + ~x)`;
   > val it = `(SUC 3,4 + ~x)` : Term.term
   - type_of it;
   > val it = `:num # int` : Type.hol_type
}
\noindent Moreover, one can always use the character suffixes to
absolutely specify the type of the numeral form:
{
   - Term`f 3 /\ p`;
   <<HOL message: more than one resolution of overloading was possible.>>
   > val it = `f 3 /\ p` : Term.term
   - Term`f 3n /\ p`;
   > val it = `f 3 /\ p` : Term.term
}

\COMMENTS
Overloading on too many numeral forms is a sure recipe for confusion.


\SEEALSO
add_bare_numeral_form, show_numeral_types

\ENDDOC