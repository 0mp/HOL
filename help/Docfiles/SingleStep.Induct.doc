\DOC Induct

\TYPE {Induct : tactic}

\SYNOPSIS
Performs tactical proof by induction over the type of the goal's
outermost universally quantified variable.

\KEYWORDS
tactic, induction

\LIBRARY
SingleStep.

\DESCRIBE
Given a universally quantified goal, {Induct} attempts to perform an
induction on the leading universally quantified variable.  The
induction theorem to be used is looked up in the {TypeBase} database
of theorems about the system's defined types.

\FAILURE
{Induct} fails if the goal is not universally quantified, or if the
type of the variable universally quantified does not have an induction
theorem in the {TypeBase} database (as necessarily happens, for
example, with all variable types).

\EXAMPLE
If attempting to prove
{
   !list. LENGTH (REVERSE list) = LENGTH list
}
one can apply {Induct} to begin a proof by induction on {list}.
{
   - e Induct;
}
This results in the base and step cases of the induction as new goals.
{
   ?- LENGTH (REVERSE []) = LENGTH []

   LENGTH (REVERSE list) = LENGTH list
   ?- !h. LENGTH (REVERSE (h::list)) = LENGTH (h::list)
}
The same tactic can be used for induction over numbers. For example
expanding the goal
{
   ?- !n. n > 2 ==> !x y z. ~(x EXP n + y EXP n = z EXP n)
}
with {Induct} yields the two goals
{
   ?- 0 > 2 ==> !x y z. ~(x EXP 0 + y EXP 0 = z EXP 0)

   n > 2 ==> !x y z. ~(x EXP n + y EXP n = z EXP n)
   ?- SUC n > 2 ==> !x y z. ~(x EXP SUC n + y EXP SUC n = z EXP SUC n)
}

\SEEALSO
SingleStep.Induct_on, SingleStep.completeInduct_on, 
SingleStep.measureInduct_on, Prim_rec.INDUCT_THEN, SingleStep.Cases,
goalstackLib.e, goalstackLib.expand.

\ENDDOC
