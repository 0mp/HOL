\DOC Induct

\TYPE {bossLib.Induct : tactic}

\SYNOPSIS
Performs tactical proof by induction over the type of the goal's
outermost universally quantified variable.

\KEYWORDS
tactic, induction

\LIBRARY bossLib

\DESCRIBE
Given a universally quantified goal, {Induct} attempts to perform an
induction on the variable that is universally quantified.  The
induction theorem to be used is looked up in the {TypeBase} database
of theorems about the system's defined types.


\FAILURE
{Induct} fails if the goal is not universally quantified, or if the
type of the variable universally quantified does not have an induction
theorem in the {TypeBase} database (as necessarily happens, for
example, with all variable types).


\EXAMPLE
If attempting to prove that
{
   ``!list. LENGTH (REVERSE list) = LENGTH list``
}
\noindent one can begin the proof by doing an induction on the list,
thus:
{
   - Induct ([], ``!list. LENGTH (REVERSE list) = LENGTH list``);
   > val it =
        ([([], `LENGTH (REVERSE []) = LENGTH []`),
          ([`LENGTH (REVERSE list) = LENGTH list`],
           `!h. LENGTH (REVERSE (CONS h list)) =
                  LENGTH (CONS h list)`)],
         fn)
     : goal list * validation
}
\noindent where the two subgoals in the list above are the base case
and step case respectively of the induction theorem for lists.

The same tactic can be used for induction over numbers, thus:
{
    - Induct ([], ``!n. n > 2 ==>
                        !x y z. ~(x EXP n + y EXP n = z EXP n)``);
    > val it =
         ([([], `0 > 2 ==> !x y z. ~(x EXP 0 + y EXP 0 = z EXP 0)`),
           ([`n > 2 ==> !x y z. ~(x EXP n + y EXP n = z EXP n)`],
            `SUC n > 2 ==>
             !x y z. ~(x EXP SUC n + y EXP SUC n = z EXP SUC n)`)],
          fn)
      : goal list * validation
}

\SEEALSO
Induct_on, completeInduct_on, measureInduct_on

\ENDDOC