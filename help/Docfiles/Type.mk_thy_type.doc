\DOC mk_thy_type

\BLTYPE
mk_thy_type 
       : {Thy:string, Tyop:string, Args:hol_type list} -> hol_type
\ELTYPE

\SYNOPSIS
Constructs a type.

\DESCRIBE
If {s} is a string that has been previously declared to be a type
with arity type {n} in theory {thy}, and the length of {tyl} is equal
to {n}, then {mk_thy_type{Tyop=s, Thy=thy, Args=tyl}} returns the
requested compound type.

\FAILURE
Fails if {s} is not the name of a type in theory {thy}, if {thy} is 
not in the ancestry of the current theory, or if {n} is not 
the length of {tyl}.

\EXAMPLE
{
- mk_thy_type {Tyop="fun", Thy="min", Args = [alpha,bool]};
> val it = `:'a -> bool` : hol_type

- try mk_thy_type {Tyop="bar", Thy="foo", Args = []};
 
Exception raised at Type.mk_thy_type:
"foo$bar" not found
}


\COMMENTS
In general, {mk_thy_type} is to be preferred over {mk_type} because 
HOL provides a fresh namespace for each theory ({mk_type} is a holdover
from a time when there was only one namespace shared by all theories).

{mk_thy_type} is deprecated in HOL-Omega because the type system now
includes type applications, type abstractions, and universal types. 

\SEEALSO
Type.mk_type, Type.mk_vartype_opr, Type.-->,
Type.mk_thy_con_type, Type.mk_con_type, Type.mk_app_type,
Type.list_mk_app_type, Type.mk_abs_type, Type.mk_univ_type,
Type.dest_thy_type, Term.mk_const, Term.mk_thy_const, decls, op_arity.
\ENDDOC
