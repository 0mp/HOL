
quietdec := true;



loadPath := 
            (concat [Globals.HOLDIR, "/examples/separationLogic/src"]) :: 
            (concat [Globals.HOLDIR, "/examples/separationLogic/src/smallfoot"]) :: 
            !loadPath;

open HolKernel Parse boolLib bossLib

open smallfoot_pp_print generalHelpersTheory
     smallfootSyntax BoolExtractShared
     ConseqConv smallfootTheory
     smallfootParser
     smallfootLib 





quietdec := false;







(*use a specific pretty printer*)
temp_add_smallfoot_pp();

(*turn it on*)
use_smallfoot_pretty_printer := true;

(*or off
use_smallfoot_pretty_printer := false;
*)







(*set an input file*)
(*lets do mergesort for example*)

val examplesDir = concat [Globals.HOLDIR, "/examples/separationLogic/src/smallfoot/EXAMPLES/"]
val file = concat [examplesDir, "mergesort.sf"];



(*just parsing the file as a start*)
val t = parse_smallfoot_file file;

(*the result is a term stating the correctness of all specifications
  in the input file*)


(*lets prove this specification, 
  this may take some time, on a Intel Core 2 Quad 2.4 GHz
  it takes about 16 seconds*)

val thm = prove (t, SMALLFOOT_SPECIFICATION_TAC THEN
          SMALLFOOT_SOLVE_TAC);

(*
SMALLFOOT_SPECIFICATION_TAC does initial preprocessing and
SMALLFOOT_SOLVE_TAC does the main work

The initial preprocessing eliminates function calls and loops
by replacing them with their specification.
*)


(*for automatic proving one can use smallfoot_auto_prove which
  combines parsing with the call above*)
val thm = smallfoot_verbose_auto_prove file;




(*interactive prove may be useful as well, but first the meaning of terms
  is explained.
  

The following tries to give an intuitive idea about the semantics of
the most important terms. Since this explanation should be easily
understandable, it ignores some details.




SMALLFOOT_COND_HOARE_TRIPLE penv pre prog post
----------------------------------------------
A normal HOARE_TRIPLE, which is classically written as
{pre} prog {post}. penv is an environment, which contains 
function definitions. Since all function calls have been eliminated,
it can safely be ignored. 
Notice that this predicate describes partial correctness!.

Technically, pre and post and tuples of a boolean condition and
the actual separation location formulas. The triple holds
trivially, if these boolean conditions are not satisfied. Moreover,
the triple requires implicitly that the set of defined stack-variables and
their permissions does not change. However, the value of these
variables may of course change.




smallfoot_prop (wpb,rpb) fb
----------------------------------------------
This the standard form of a separation logic formula used by the tool.
A state (st,h) consisting of a stack st and a heap h satisfies this
formula, iff
  - st contains write-permissions for all variables in wpb
  - st contains read-permissions for all variables in rpb
  - (st,h) satisfies the combination of all elements of fb by *
    so for fb = {|f1;f2;f3|}) it satisfies f1 * f2 * f3

That's the intuitive meaning. Technically, it carries the derived information,
that all variables in wpb and rpb are pairwise distinct and that
the all formulas in fb possess some nice properties as well. 




SMALLFOOT_PROP_IMPLIES strong_flag (wpb,rpb) (wpb')
                       sfb_context sfb_split sfb_imp
                       sfb_frameP
-----------------------------------------------------

This formula is used to deduce frames for function
calls / while loops and also to solve entailments.
It intuitively states that 
sbf_split can be splitted into sfb_split_imp and sfb_frame
such that

(1) s |= smallfoot_prop (wpb,rpb) (BAG_UNION sfb_context sfb_split) ==>
    s |= smallfoot_prop (wpb,rpb) (BAG_UNION sfb_context sfb_split_imp sfb_frame)
(2) sfb_frame satisfies the predicate sfb_frameP
(3) sfb_frame does not use the variables in wpb'

The intention is that in the context of sfb_context, 
sfb_split_imp entails sfb_imp and sfb_frame remains of sfb_imp.

Lets say "smallfoot_prop (wpb,rpb) sfb_split" holds and a function
with precondition "smallfoot_prop (wpb',rpb') sfb_imp" should be
called. That's possible, if there are sufficient variable read- and
write-permissions (wpb' SUBBAG wpb, rpb' SUBBAG (BAG_UNION wpb rpb))
and sfb_split entails sfb_imp plus some frame sfb_frame. Since the
function call requires write_permissions, i.e.  exclusive access, for
the variables in wpb', the frame is not allowed to even read them.
The definition of SMALLFOOT_PROP_IMPLIES is tailor-made to deduce
sfb_frame for this situation. Just set sfb_context to EMPTY_BAG and
sfb_frameP to the HOARE_TRIPLE after the function call.

sfb_context is useful for actually deducing a frame. Identical terms
can be removed from sfb_split and sbf_imp by moving them to
sfb_context. Storing them in sfb_context avoids loosing information.


The same mechanism of SMALLFOOT_PROP_IMPLIES can be used to entailments.
So given the Hoare triple {pre} skip {post} one needs to show that
pre entails post. To this end one can use SMALLFOOT_PROP_IMPLIES with
wpb' set to empty and the requirement that the resulting frame is 
basically empty (speaking in Smallfoot terms, 
it may contain pure formulae, but not spatial ones).

However, there is one difference between function calls and entailments. For
function calls the deduced frame should be as strong as possible. So,
if for example an equation could be added one would like to do so to preserve this
information over the function call. Contrary, for entailments, the frame
should be empty if possible, i.e. as weak  as possible. The flag
strong_flag has no formal semantics. It's just used a hind to the specialised
tactics whether a strong or weak frame is required.





SMALLFOOT_PROP_IMPLIES___FALSE_PRECOND (wpb,rpb) (wpb')
                       sfb_context sfb_split sfb_imp
----------------------------------------------------- 


A specialised version of SMALLFOOT_PROP_IMPLIES that tries to show
that the combination of sfb_context with sfb_split is not satisfiable
and therefore the SMALLFOOT_PROP_IMPLIES statement is trivially true.


SMALLFOOT_PROP_IMPLIES strong_flag (wpb,rpb) (wpb')
                       sfb_context sfb_split {| |}
                       sfb_frameP

is simplified to 

sfb_frameP sfb_split /\
SMALLFOOT_PROP_IMPLIES___FALSE_PRECOND (wpb,rpb) (wpb')
                       sfb_context sfb_split sfb_imp


Most of the time sfb_frameP sfb_split is the intended solution. However,
the other possibility needs exploring as well. It is for example
necessary to verify the function list_filter in list.sf

*)


set_trace "Unicode" 1

(*parse it, set the goal and do the preprocessing 
  (about 2 s)*)
smallfoot_set_goal file;

(*or*)


set_goal([],parse_smallfoot_file file)
SMALLFOOT_SPECIFICATION_TAC

REPEAT STRIP_TAC THENL [
   (*perform one step, a step is either 
     the evaluation of a program statement, a
     simplification of the overall structure (moving quantifiers etc.),
     or deducing a frame*)
   SMALLFOOT_STEP_TAC THEN
   CONJ_TAC THENL [
      NTAC 2 SMALLFOOT_STEP_TAC THEN

      (*a frame can be deduced stepwise*)
      SMALLFOOT_MINI_STEP_TAC THEN
      SMALLFOOT_MINI_STEP_TAC THEN (*...*)
      (*or all in one step*)
      SMALLFOOT_STEP_TAC THEN
      
      (*general simplifications are done as well by STEP_TAC*)
      SMALLFOOT_STEP_TAC,



      (*if a goal is uninteresting, it can be solved completely via
        SOLVE_TAC*)
      SMALLFOOT_SOLVE_TAC
   ],


   (*Sometimes you may want to avoid case splits during this automation.
     This is useful if the goal can't be solved completely.*)
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC,


   SMALLFOOT_STEP_TAC THEN
   CONJ_TAC THEN1 SMALLFOOT_SOLVE_TAC THEN

   (*Function calls got replaced during preprocessing. The
     resulting statements are ugly to read and therefore
     the pretty printer just states "... abstracted code pre post ..."
     In most cases that's sufficient for the user. However, there are
     hidden conditions on the read/write permissions and 
     for parallel function calls there is also a hidden condition related to
     race freedom.
     Turn off the pretty printer to see these conditions

     use_smallfoot_pretty_printer := false

     use_smallfoot_pretty_printer := true
   *)
   SMALLFOOT_STEP_TAC THEN
   SMALLFOOT_STEP_TAC THEN
   SMALLFOOT_STEP_TAC THEN
   SMALLFOOT_MINI_STEP_TAC
   SMALLFOOT_SOLVE_TAC
]







(*
Other examples. The measured times are not very accurate. However,
they should give a rough impression. The were measured at an
Intel Core 2 Quad 2.4 GHz processor.
*)


temp_add_smallfoot_pp();
use_smallfoot_pretty_printer := true;

val examplesDir = concat [Globals.HOLDIR, "/examples/separationLogic/src/smallfoot/EXAMPLES/"]


(* 16.0 s *) val file = concat [examplesDir, "mergesort.sf"]; 
val thm = smallfoot_verbose_auto_prove file;
(*  2.0 s *) val file = concat [examplesDir, "parallel_tree_deallocate.sf"]; 
val thm = smallfoot_verbose_auto_prove file;
(* 14.5 s *) val file = concat [examplesDir, "parallel_mergesort.sf"]; 
val thm = smallfoot_verbose_auto_prove file;
(* 43.5 s *) val file = concat [examplesDir, "list.sf"]; 
val thm = smallfoot_verbose_auto_prove file;
(*  9.5 s *) val file = concat [examplesDir, "tree.sf"]; 
val thm = smallfoot_verbose_auto_prove file;
(*  0.7 s *) val file = concat [examplesDir, "passive_stack_race.sf"]; (*semantics differs from smallfoot!*)
val thm = smallfoot_verbose_auto_prove file;
(*  2.3 s *) val file = concat [examplesDir, "business1.sf"];
val thm = smallfoot_verbose_auto_prove file;
(*  2.7 s *) val file = concat [examplesDir, "pointer_transferring_buffer.sf"]; 
val thm = smallfoot_verbose_auto_prove file;
(*  2.0 s *) val file = concat [examplesDir, "pointer_non_transferring_buffer.sf"];
val thm = smallfoot_verbose_auto_prove file;
(*  6.2 s *) val file = concat [examplesDir, "mm_buf.sf"];
val thm = smallfoot_verbose_auto_prove file;
(*  3.7 s *) val file = concat [examplesDir, "memory_manager.sf"];
val thm = smallfoot_verbose_auto_prove file;
(* 27.5 s *) val file = concat [examplesDir, "split_binary_semaphore.sf"];
val thm = smallfoot_verbose_auto_prove file;
(* 53.5 s *) val file = concat [examplesDir, "mm_non_blocking.sf"];
val thm = smallfoot_verbose_auto_prove file;


val thm = smallfoot_auto_prove file;
val thm = smallfoot_verbose_auto_prove file;




(*examples that are designed to fail for various reasons*)
val file = concat [examplesDir, "not_solvable/heap_race.sf"]; 
val file = concat [examplesDir, "not_solvable/stack_race.sf"]; 
val file = concat [examplesDir, "not_solvable/business2.sf"];

val file = concat [examplesDir, "dummy.sf"];

(*automatic proof just fails*)
val thm = smallfoot_auto_prove file;


use_smallfoot_pretty_printer := false
(*interactive one gives insight into the problem*)
val t = parse_smallfoot_file file;

set_goal([],parse_smallfoot_file file);


SMALLFOOT_SPECIFICATION_TAC THEN

REPEAT STRIP_TAC THEN

REPEAT SMALLFOOT_STEP_TAC
SMALLFOOT_MINI_STEP_TAC
ESMALLFOOT_SOLVE_TAC
SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC
SMALLFOOT_NO_CASE_SPLIT_STEP_TAC
SMALLFOOT_NO_CASE_SPLIT_MINI_STEP_TAC
SMALLFOOT_PROP_IMPLIES___EQ_CASE_SPLIT_TAC
SMALLFOOT_STEP_TAC
....

REPEAT STRIP_TAC THEN
SMALLFOOT_STEP_TAC




(*Some examples can just be handled interactively*)


(*The circular list example needs some user interaction to
  guess existential witnesses*)


val examplesDir = concat [Globals.HOLDIR, "/examples/separationLogic/src/smallfoot/EXAMPLES/"]
val file = concat [examplesDir, "circular_list.sf"]; 

print_file file    

smallfoot_set_goal file;

(*or*)

val thm = smallfoot_verbose_prove( file,

(*Handle procedures separately*)
REPEAT STRIP_TAC THENL [
   (*push works fine*)
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC,

   (*enqueue need as little help*)
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC THEN
   SMALLFOOT_CLEAN_TAC THEN
   Q.EXISTS_TAC `r_const` THEN
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC,

   (*works fine*)
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC,

   (*works as well, but needs a case split*)
   SMALLFOOT_SOLVE_TAC
]);




val examplesDir = concat [Globals.HOLDIR, "/examples/separationLogic/src/smallfoot/EXAMPLES/"]
val file = concat [examplesDir, "circular_list___logical_vars.sf"]; 

print_file file    
val t = parse_smallfoot_file file
smallfoot_set_goal file;



(*or*)

val thm = smallfoot_verbose_prove( file,

(*Handle procedures separately*)
REPEAT STRIP_TAC THENL [
   (*push works fine*)
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC,

   (*enqueue need as little help*)
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC THEN
   SMALLFOOT_CLEAN_TAC THEN
   Q.EXISTS_TAC `r_const` THEN
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC,

   (*works fine*)
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC,

   (*works as well, but needs a case split*)
   SMALLFOOT_SOLVE_TAC
]);






val examplesDir = concat [Globals.HOLDIR, "/examples/separationLogic/src/smallfoot/EXAMPLES/"]
val file = concat [examplesDir, "reverse_data.sf"]; 

print_file file    
val t = parse_smallfoot_file file
smallfoot_set_goal file;

set_goal ([], t)
SMALLFOOT_SPECIFICATION_TAC
(*or*)

val thm = smallfoot_verbose_prove( file,

(*Handle procedures separately*)
REPEAT STRIP_TAC THENL [
   (*push works fine*)
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC THEN
   REPEAT STRIP_TAC THEN
   Q.EXISTS_TAC `idata_hd::pdata` THEN
   Q.EXISTS_TAC `idata_tl` THEN
   ASM_SIMP_TAC list_ss [APPEND_ASSOC_CONS] THEN
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC,


   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC THEN
   REPEAT STRIP_TAC THEN
   Q.EXISTS_TAC `data` THEN
   REPEAT STRIP_TAC THEN
   Q.EXISTS_TAC `[]` THEN
   Q.EXISTS_TAC `data` THEN
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC
]);




open sortingTheory relationTheory

val examplesDir = concat [Globals.HOLDIR, "/examples/separationLogic/src/smallfoot/EXAMPLES/"]
val file = concat [examplesDir, "mergesort_data.sf"]; 

print_file file    
parse_smallfoot_file file
smallfoot_set_goal file;





val thm = smallfoot_verbose_prove( file,

(*Handle procedures separately*)
REPEAT STRIP_TAC THENL [
   (*merge*)
   SMALLFOOT_STEP_TAC THEN
   CONJ_TAC THEN1 (
      (*case q = NULL*)
      SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC THEN
      REPEAT STRIP_TAC THEN
      Q.EXISTS_TAC `pdata` THEN
      ASM_SIMP_TAC list_ss [PERM_REFL] THEN
      SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC
   ) THEN
   SMALLFOOT_STEP_TAC THEN
   CONJ_TAC THEN1 (
      (*case p = NULL*)
      SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC THEN
      REPEAT STRIP_TAC THEN
      Q.EXISTS_TAC `qdata` THEN
      ASM_SIMP_TAC list_ss [PERM_REFL] THEN
      SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC
   ) THEN
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC THEN
   REPEAT STRIP_TAC THENL [
      (*case q_data < p_data*)
      (*merge is called with p and the tail of q,
        therefore, for the recursive call:
	pdata' := pdata
	qdata' := tl qdata 
        To prove the precondition of merge,
        one needs to infer that qdata' is sorted*)   	   
      Q.EXISTS_TAC `pdata` THEN
      Q.EXISTS_TAC `qdata_tl` THEN
      `SORTED $<= (qdata_tl:num list)` by ALL_TAC THEN1 (
         Cases_on `qdata_tl` THEN
	 FULL_SIMP_TAC std_ss [SORTED_DEF]
      ) THEN
      ASM_SIMP_TAC list_ss [] THEN
      SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC THEN

      SMALLFOOT_CLEAN_TAC THEN
      REPEAT STRIP_TAC THEN

      (*after the merge we know that r points to a list
        containing some data "rdata" and that this
        data is the sorted content of pdata and qdata_tl.
        We then need to show that qdata_hd :: rdata is 
	sorted and contains the same elements as pdata, qdata.*)				     
      Q.EXISTS_TAC `qdata_hd::rdata` THEN
      ASM_SIMP_TAC list_ss [] THEN
      Tactical.REVERSE (`SORTED $<= (qdata_hd::rdata) /\
           PERM (pdata_hd::(pdata_tl ++ qdata_hd::qdata_tl))
             (qdata_hd::rdata)` by ALL_TAC) THEN1 (
         ASM_SIMP_TAC std_ss [] THEN
         SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC
      ) THEN
      REPEAT STRIP_TAC THENL [
         `transitive (($<=):num -> num -> bool)` by ALL_TAC THEN1 (
	    SIMP_TAC arith_ss [transitive_def]
         ) THEN
	 Q.PAT_ASSUM `qdata = X` ASSUME_TAC THEN
         FULL_SIMP_TAC list_ss [SORTED_EQ] THEN
	 REPEAT STRIP_TAC THEN
         `MEM y (pdata_hd::(pdata_tl ++ qdata_tl))` by METIS_TAC[PERM_MEM_EQ] THEN
	 POP_ASSUM MP_TAC THEN
	 ASM_SIMP_TAC list_ss [DISJ_IMP_THM] THEN
	 REPEAT STRIP_TAC THEN
	 `pdata_hd <= y` by RES_TAC THEN
         DECIDE_TAC,


         Q.PAT_ASSUM `PERM X rdata` MP_TAC THEN
         REPEAT (POP_ASSUM (K ALL_TAC)) THEN
	 Tactical.REVERSE (`PERM (pdata_hd::(pdata_tl ++ qdata_hd::qdata_tl)) 
                                 (qdata_hd::pdata_hd::(pdata_tl ++ qdata_tl))` by ALL_TAC) THEN1 (
            PROVE_TAC[PERM_TRANS, PERM_MONO]
         ) THEN
	 Tactical.REVERSE (`PERM (pdata_tl ++ qdata_hd::qdata_tl) 
                                 (qdata_hd::(pdata_tl ++ qdata_tl))` by ALL_TAC) THEN1 (
            PROVE_TAC[PERM_TRANS, PERM_MONO, PERM_SWAP_AT_FRONT,  PERM_REFL]
         ) THEN
         PROVE_TAC[CONS_PERM, PERM_REFL, PERM_SYM]
      ],






      (*case q_data >= p_data*)
      (*merge is called with q and the tail of p,
        therefore, for the recursive call:
	pdata' := tl pdata
	qdata' := qdata 
        To prove the precondition of merge,
        one needs to infer that pdata' is sorted*)   	   
      Q.EXISTS_TAC `pdata_tl` THEN
      Q.EXISTS_TAC `qdata` THEN
      `SORTED $<= (pdata_tl:num list)` by ALL_TAC THEN1 (
         Cases_on `pdata_tl` THEN
	 FULL_SIMP_TAC std_ss [SORTED_DEF]
      ) THEN
      ASM_SIMP_TAC list_ss [] THEN
      SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC THEN

      SMALLFOOT_CLEAN_TAC THEN
      REPEAT STRIP_TAC THEN

      (*after the merge we know that r points to a list
        containing some data "rdata" and that this
        data is the sorted content of pdata_tl and qdata.
        We then need to show that pdata_hd :: rdata is 
	sorted and contains the same elements as pdata, qdata.*)				     
      Q.EXISTS_TAC `pdata_hd::rdata` THEN
      ASM_SIMP_TAC list_ss [] THEN
      Tactical.REVERSE (`SORTED $<= (pdata_hd::rdata) /\
           PERM (pdata_hd::(pdata_tl ++ qdata_hd::qdata_tl))
             (pdata_hd::rdata)` by ALL_TAC) THEN1 (
         ASM_SIMP_TAC std_ss [] THEN
         SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC
      ) THEN
      REPEAT STRIP_TAC THENL [
         `transitive (($<=):num -> num -> bool)` by ALL_TAC THEN1 (
	    SIMP_TAC arith_ss [transitive_def]
         ) THEN
	 Q.PAT_ASSUM `qdata = X` ASSUME_TAC THEN
         FULL_SIMP_TAC list_ss [SORTED_EQ] THEN
	 REPEAT STRIP_TAC THEN
         `MEM y (pdata_tl ++ qdata_hd::qdata_tl)` by METIS_TAC[PERM_MEM_EQ] THEN
	 POP_ASSUM MP_TAC THEN
	 ASM_SIMP_TAC list_ss [DISJ_IMP_THM] THEN
	 REPEAT STRIP_TAC THEN
	 `qdata_hd <= y` by RES_TAC THEN
         DECIDE_TAC,


	 MATCH_MP_TAC PERM_MONO THEN
         ASM_REWRITE_TAC[]
      ]
   ],



   

   (*split*)
   SMALLFOOT_STEP_TAC THEN
   CONJ_TAC THEN1 (
      (*case p = NULL, both lists _pdata, _rdata are empty*)
      SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC THEN
      REPEAT STRIP_TAC THEN
      Q.EXISTS_TAC `[]` THEN
      Q.EXISTS_TAC `[]` THEN
      ASM_SIMP_TAC list_ss [PERM_REFL] THEN
      SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC
   ) THEN
   SMALLFOOT_STEP_TAC THEN
   SMALLFOOT_STEP_TAC THEN
   SMALLFOOT_STEP_TAC THEN
   REPEAT STRIP_TAC THEN1 (
      (*case t1 = NULL, this means a single element 
        and everything goes to _pdata*)
      SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC THEN
      REPEAT STRIP_TAC THEN
      Q.PAT_ASSUM `data = X` ASSUME_TAC THEN
      Q.EXISTS_TAC `[]` THEN
      Q.EXISTS_TAC `data` THEN
      ASM_SIMP_TAC list_ss [PERM_REFL] THEN
      SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC
   ) THEN

   (* there are at least two elements *)
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC THEN
   REPEAT STRIP_TAC THEN
   (*the data for the recursive call is the
     original data without the first two entries*)
   Q.EXISTS_TAC `data_tl_tl` THEN
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC THEN
   SMALLFOOT_CLEAN_TAC THEN
   REPEAT STRIP_TAC THEN

   (*the resulting values for _pdata, _rdata in
     the postcondition are the ones returned by
     the recursive call with the two first
     elements added again. It remains to be shown
     that is really a permutation of the orginal data*)
   Q.EXISTS_TAC `data_tl_hd::rdata` THEN
   Q.EXISTS_TAC `data_hd::pdata` THEN

   Tactical.REVERSE (
      `PERM (data_hd::(pdata ++ data_tl_hd::rdata))
            (data_hd::data_tl_hd::data_tl_tl)` by ALL_TAC) THEN1 (
      ASM_SIMP_TAC list_ss [] THEN
     SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC
   ) THEN

   MATCH_MP_TAC PERM_MONO THEN
   ONCE_REWRITE_TAC[PERM_SYM] THEN
   MATCH_MP_TAC CONS_PERM THEN
   PROVE_TAC [PERM_SYM],




   (*mergesort*)
   SMALLFOOT_STEP_TAC THEN
   CONJ_TAC THEN1 (
      (*case p = NULL*)
      SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC THEN
      REPEAT STRIP_TAC THEN
      (*if the input is empty, then _rdata is empty as well*)
      Q.EXISTS_TAC `[]` THEN
      ASM_SIMP_TAC std_ss [PERM_REFL, SORTED_DEF] THEN
      SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC
   ) THEN
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC THEN
   REPEAT STRIP_TAC THEN
   (*call of split, data passed is the original one*)
   Q.EXISTS_TAC `data` THEN


   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC THEN
   SMALLFOOT_CLEAN_TAC THEN
   REPEAT STRIP_TAC THEN
   (*first call to mergesort, data is the one 
     returned by split and stored in q*)
   Q.EXISTS_TAC `rdata` THEN

   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC THEN
   SMALLFOOT_CLEAN_TAC THEN
   REPEAT STRIP_TAC THEN
   (*second call to mergesort, data is the one 
     returned by split and stored in p*)
   Q.EXISTS_TAC `pdata` THEN


   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC THEN
   SMALLFOOT_CLEAN_TAC THEN
   REPEAT STRIP_TAC THEN
   (*call to mergesort, data is the sorted data from
     before. Notice that it is sorted*)
   Q.EXISTS_TAC `rdata''` THEN
   Q.EXISTS_TAC `rdata'` THEN
   ASM_SIMP_TAC std_ss [] THEN


   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC THEN
   SMALLFOOT_CLEAN_TAC THEN
   REPEAT STRIP_TAC THEN
   (*show that the postcondition holds.
     the data there is the one returned by merge*)
   Q.EXISTS_TAC `rdata'''` THEN

   `PERM data rdata'''` by ALL_TAC THEN1 (
      REPEAT (Q.PAT_ASSUM `PERM X Y` MP_TAC) THEN
      REPEAT (POP_ASSUM (K ALL_TAC)) THEN
      REPEAT STRIP_TAC THEN
      Tactical.REVERSE (` PERM (pdata ++ rdata) (rdata'' ++ rdata')` by ALL_TAC) THEN1 (
         PROVE_TAC[PERM_TRANS, PERM_SYM]
      ) THEN
      PROVE_TAC [PERM_CONG]
   ) THEN
   ASM_SIMP_TAC std_ss [] THEN
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC
]);







SMALLFOOT_SPECIFICATION_TAC

SMALLFOOT_STEP_TAC THEN
SMALLFOOT_MINI_STEP_TAC THEN
REPEAT STRIP_TAC THEN

use_smallfoot_pretty_printer := true
SMALLFOOT_SOLVE_TAC THEN
CONJ_TAC
rotate 1

