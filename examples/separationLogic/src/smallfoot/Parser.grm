%{ (* header *)

(*
loadPath := 
            ("/auto/homes/tt291/Downloads/smallfoot/mosml/") :: 
            !loadPath;

load "Parsetree"
load "Binaryset"
*)

open Parsetree


fun mkexp d = d;
fun mkstm d = d;


exception Not_distinct;

fun check_distinct il =
  let
	val is = ref (Binaryset.empty String.compare)
	fun f i = if Binaryset.member (!is,i) then
			raise Not_distinct
		     else
			is := Binaryset.add (!is, i)
  in
	List.app f il
  end;


fun mk_formal_params (rl,vl) =
  (check_distinct (rl@vl); (rl,vl));

exception Parameters_not_variables
fun mk_ref_params cel =
  let
	fun check_par (Pexp_ident i) = i |
	      check_par _ = raise Parameters_not_variables
        val il = List.map check_par cel
  in
  (check_distinct il; il)
  end;


exception Parse_error;
(* implicitly called when no grammar rules apply *)
fun parse_error _ = raise Parse_error;

(* default component tags *)
val list_data_tag = "hd";
val data_list_tag = "dta";
val list_link_tag = "tl"
val tree_data_tag = "d"
val tree_link_tags = ("l", "r")
val (dl_Llink_tag,dl_Rlink_tag) = tree_link_tags


%} /* declarations */

/* tokens */

%token AMPERAMPER
%token BANGEQUAL
%token BARBAR
%token COLON
%token COMMA
%token DISPOSE
%token DLSEG
%token ELSE
%token EMPTY
%token EOF
%token EQUAL
%token EQUALEQUAL
%token FF
%token <string> IDENT
%token <string> QIDENT
%token IF
%token <string> HOL_TERM
%token <string> INFIXOP1
%token <string> INFIXOP2
%token <string> INFIXOP3
%token LBRACE
%token LBRACKET
%token LIST
%token LISTSEG
%token DATA_LIST
%token DATA_LISTSEG
%token LOCAL
%token LPAREN
%token MINUSGREATER
%token <int> NAT
%token NEW
%token POINTSTO
%token RBRACE
%token RBRACKET
%token RESOURCE
%token RPAREN
%token SEMI
%token STAR
%token THEN
%token TREE
%token TT
%token WHEN
%token WHILE
%token WITH
%token XLSEG
%token XOR

/* precedences (increasing) and associativities for expressions */

%nonassoc below_ELSE
%nonassoc ELSE
%left STAR AMPERAMPER
%left EQUALEQUAL BANGEQUAL
%left INFIXOP1 EQUAL
%left INFIXOP2
%left INFIXOP3 XOR POINTSTO
%nonassoc unary_prefix

/* entry points */

%type <Parsetree.p_program> program
%type <Parsetree.a_proposition> a_proposition

%type <Parsetree.p_item list> program_item_star
%type <Parsetree.p_item> program_item fun_decl resource_decl
%type <string list> ident_decl ident_seq ident_notempty_seq local_decls
%type <string list * string list> formal_params;
%type <string list * Parsetree.p_expression list> actual_params;
%type <Parsetree.a_proposition option> invariant;
%type <Parsetree.p_statement list> statement_star;
%type <Parsetree.p_statement> statement;
%type <Parsetree.p_expression> expression;
%type <Parsetree.p_expression list> expression_seq expression_notempty_seq;
%type <Parsetree.a_expression> a_expression;
%type <Parsetree.a_space_pred> a_space_pred;
%type <(string * Parsetree.a_expression) list> a_component_expression_seq a_component_expression_notempty_seq;
%type <string> data_list_exp;

%start program
%start ident_decl
%start program_item

%% /* rules */

/* entry points */
program:
    program_item_star
      { Pprogram ([list_data_tag, list_link_tag,
		   tree_data_tag,
		   #1 tree_link_tags, #2 tree_link_tags],
		  $1) }
  | ident_decl program_item_star { Pprogram ($1,$2) }
;
program_item_star:
    /* empty */            { [] }
  | EOF { [] }
  | program_item program_item_star { $1::$2 }
;
program_item:
    fun_decl { $1 }
  | resource_decl {$1 }
;
fun_decl:
    IDENT LPAREN formal_params RPAREN invariant LBRACE local_decls statement_star RBRACE invariant
      { Pfundecl($1,$3,$5,$7,$8,$10) }
;
resource_decl:
    RESOURCE IDENT LPAREN ident_seq RPAREN LBRACKET a_proposition RBRACKET
      { Presource($2,$4,$7) }
;
ident_decl:
    ident_seq SEMI { $1 }
;
ident_seq:
    /* empty */      { [] }
  | ident_notempty_seq { $1 }
;
ident_notempty_seq:
    IDENT            { [$1] }
  | IDENT COMMA ident_notempty_seq { $1::$3 }
;
local_decls:
    /* empty */              { [] }
  | LOCAL ident_notempty_seq SEMI local_decls { $2 @ $4 }
;
statement_star:
    /* empty */              { [] }
  | statement statement_star { $1::$2 }
;
statement:
    IDENT EQUAL expression SEMI
	  { mkstm(Pstm_assign($1, $3)) }
  | IDENT EQUAL expression MINUSGREATER IDENT SEMI
	  { mkstm(Pstm_fldlookup($1, $3, $5)) }
  | expression MINUSGREATER IDENT EQUAL expression SEMI
	  { mkstm(Pstm_fldassign($1, $3, $5)) }
  | IDENT EQUAL NEW LPAREN RPAREN SEMI
	  { mkstm(Pstm_new($1)) }
  | DISPOSE expression SEMI
          { mkstm(Pstm_dispose($2)) }
  | LBRACE statement_star RBRACE
	  { mkstm(Pstm_block($2)) }
  | IF LPAREN expression RPAREN statement %prec below_ELSE
	  { mkstm(Pstm_if($3, $5, mkstm(Pstm_block []))) }
  | IF LPAREN expression RPAREN statement ELSE statement
	  { mkstm(Pstm_if($3, $5, $7)) }
  | WHILE LPAREN expression RPAREN invariant statement
	  { mkstm(Pstm_while($5, $3, $6)) }
  | WITH IDENT WHEN LPAREN expression RPAREN statement
          { mkstm(Pstm_withres($2,$5,$7)) }
  | IDENT LPAREN actual_params RPAREN SEMI
          { mkstm(Pstm_fcall($1,$3)) }
  | IDENT LPAREN actual_params RPAREN
    BARBAR
    IDENT LPAREN actual_params RPAREN SEMI
          { mkstm(Pstm_parallel_fcall($1,$3,$6,$8)) }

;
invariant:
    /* empty */
          { NONE }
  | LBRACKET a_proposition RBRACKET
          { SOME $2 }
;
expression:
    IDENT
	  { mkexp(Pexp_ident($1)) }
  | QIDENT
	  { mkexp(Pexp_ident($1)) }
  | NAT
	  { mkexp(Pexp_num($1)) }
  | TT
          { mkexp(Pexp_infix("==", mkexp(Pexp_num(0)), mkexp(Pexp_num(0)))) }
  | FF
          { mkexp(Pexp_infix("!=", mkexp(Pexp_num(0)), mkexp(Pexp_num(0)))) }
  | LPAREN expression RPAREN
	  { $2 }
  | INFIXOP2 expression %prec unary_prefix
	  { mkexp(Pexp_prefix($1, $2)) }
  | expression AMPERAMPER expression
	  { mkexp(Pexp_infix("&&", $1, $3)) }
  | expression STAR expression
	  { mkexp(Pexp_infix("*", $1, $3)) }
  | expression XOR expression
	  { mkexp(Pexp_infix("^", $1, $3)) }
  | expression EQUALEQUAL expression
	  { mkexp(Pexp_infix("==", $1, $3)) }
  | expression BANGEQUAL expression
	  { mkexp(Pexp_infix("!=", $1, $3)) }
  | expression INFIXOP1 expression
	  { mkexp(Pexp_infix($2, $1, $3)) }
  | expression INFIXOP2 expression
	  { mkexp(Pexp_infix($2, $1, $3)) }
  | expression INFIXOP3 expression
	  { mkexp(Pexp_infix($2, $1, $3)) }
;
expression_seq:
    /* empty */      { [] }
  | expression_notempty_seq { $1 }
;
expression_notempty_seq:
    expression            { [$1] }
  | expression COMMA expression_notempty_seq { $1::$3 }
;
formal_params:
    ident_seq { mk_formal_params ([],$1) }
  | ident_seq SEMI ident_seq { mk_formal_params ($1,$3) }
;
actual_params:
    expression_seq { ([],$1) }
  | expression_seq SEMI expression_seq { (mk_ref_params $1, $3) }
;
a_component_expression_seq:
    /* empty */      { [] }
  | a_component_expression_notempty_seq { $1 }
;
a_component_expression_notempty_seq:
    IDENT COLON a_expression            { [($1,$3)] }
  | IDENT COLON a_expression COMMA a_component_expression_notempty_seq { ($1,$3)::$5 }

a_space_pred:
    LIST LPAREN IDENT SEMI a_expression RPAREN
	  { Aspred_list($3,$5) }
  | LIST LPAREN a_expression RPAREN
	  { Aspred_list(list_link_tag, $3) }
  | DATA_LIST LPAREN IDENT SEMI a_expression COMMA data_list_exp RPAREN
	  { Aspred_data_list($3,$5,data_list_tag,$7) }
  | DATA_LIST LPAREN a_expression COMMA data_list_exp RPAREN
	  { Aspred_data_list(list_link_tag,$3,data_list_tag,$5) }
  | DATA_LIST LPAREN IDENT SEMI a_expression COMMA IDENT COLON data_list_exp RPAREN
	  { Aspred_data_list($3,$5,$7,$9) }
  | DATA_LIST LPAREN a_expression COMMA IDENT COLON data_list_exp RPAREN
	  { Aspred_data_list(list_link_tag,$3,$5,$7) }
  | LISTSEG LPAREN IDENT SEMI a_expression COMMA a_expression RPAREN
	  { Aspred_listseg($3,$5,$7) }
  | LISTSEG LPAREN a_expression COMMA a_expression RPAREN
	  { Aspred_listseg(list_link_tag, $3, $5) }
  | DATA_LISTSEG LPAREN IDENT SEMI a_expression COMMA data_list_exp COMMA a_expression RPAREN
	  { Aspred_data_listseg($3,$5,$7,data_list_tag,$9) }
  | DATA_LISTSEG LPAREN IDENT SEMI a_expression COMMA IDENT COLON data_list_exp COMMA a_expression RPAREN
	  { Aspred_data_listseg($3,$5,$9,$7,$11) }
  | DATA_LISTSEG LPAREN a_expression COMMA data_list_exp COMMA a_expression RPAREN
	  { Aspred_data_listseg(list_link_tag,$3,$5,data_list_tag,$7) }
  | DATA_LISTSEG LPAREN a_expression COMMA INDENT COLON data_list_exp COMMA a_expression RPAREN
	  { Aspred_data_listseg(list_link_tag,$3,$7,$5,$9) }
  | DLSEG LPAREN IDENT SEMI IDENT SEMI a_expression COMMA a_expression COMMA a_expression COMMA a_expression RPAREN
	  { Aspred_dlseg(DL,$3,$7,$9,$5,$11,$13) }
  | DLSEG LPAREN a_expression COMMA a_expression COMMA a_expression COMMA a_expression RPAREN
	  { Aspred_dlseg(DL, dl_Rlink_tag, $3, $5, dl_Llink_tag,$7, $9) }
  | XLSEG LPAREN IDENT SEMI IDENT SEMI a_expression COMMA a_expression COMMA a_expression COMMA a_expression RPAREN
	  { Aspred_dlseg(XL,$3,$7,$9,$5,$11,$13) }
  | XLSEG LPAREN a_expression COMMA a_expression COMMA a_expression COMMA a_expression RPAREN
	  { Aspred_dlseg(XL, dl_Llink_tag, $3, $5, dl_Llink_tag,$7, $9) }
  | TREE LPAREN IDENT SEMI IDENT SEMI a_expression RPAREN
          { Aspred_tree($3,$5,$7) }
  | TREE LPAREN a_expression RPAREN
          { Aspred_tree(#1 tree_link_tags, #2 tree_link_tags,
			$3) }
  | EMPTY
          { Aspred_empty }
  | HOL_TERM
          { Aspred_hol $1 }
  | a_expression POINTSTO a_component_expression_seq
          { Aspred_pointsto($1,$3) }
  | a_expression POINTSTO a_expression
          { Aspred_pointsto($1,[(list_link_tag, $3)]) }
  | a_expression POINTSTO a_expression COMMA a_expression
          { Aspred_pointsto($1,[(#1 tree_link_tags, $3),
				(#2 tree_link_tags, $5)]) }
;

a_proposition:
    LPAREN a_proposition RPAREN
	  { $2 }
  | a_expression EQUALEQUAL a_expression
	  { Aprop_equal($1,$3) }
  | a_expression BANGEQUAL a_expression
	  { Aprop_not_equal($1,$3) }
  | FF
	  { Aprop_false }
  | a_proposition STAR a_proposition
          { Aprop_star($1,$3) }
  | IF a_proposition THEN a_proposition ELSE a_proposition
      { Aprop_ifthenelse($2,$4,$6) }
  | 
  | a_space_pred
          { Aprop_spred $1 }
;
a_expression:
    LPAREN a_expression RPAREN            { $2 }
  | a_expression XOR a_expression         { Aexp_infix("^",$1,$3) }
  | IDENT                                 { Aexp_ident($1) }
  | QIDENT                                { Aexp_ident($1) }
  | NAT                                   { Aexp_num($1) }
;
data_list_exp:
    IDENT                                 { $1 }
  | HOL_TERM                              { $1 }
;


%% (* trailer *)
