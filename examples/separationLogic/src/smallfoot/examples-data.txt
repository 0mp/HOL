(* This file contains HOL 4 - proof scripts to proof 
   full functional specifications of the examples 
   (*.dsf*)

   These proof scripts use a Smallfoot-formalisation in HOL 4.
   HOL 4 can be found at http://hol.sourceforge.net/,
   the Smallfoot-formalisation in the examples directory.
   Please use the most recent version from the Subversion-repository.

   If you have any questions, please contanct Thomas Tuerk
   (email: tt291@cl.cam.ac.uk)
*)



quietdec := true;



loadPath := 
            (concat [Globals.HOLDIR, "/examples/separationLogic/src"]) :: 
            (concat [Globals.HOLDIR, "/examples/separationLogic/src/smallfoot"]) :: 
            !loadPath;








open HolKernel Parse boolLib bossLib;

open smallfoot_pp_print generalHelpersTheory
     smallfootSyntax BoolExtractShared
     ConseqConv smallfootTheory
open smallfootParser listTheory rich_listTheory;
open sortingTheory relationTheory permLib
open smallfootLib
open quantHeuristicsLib;






quietdec := false;




(*use a specific pretty printer*)
temp_add_smallfoot_pp();
use_smallfoot_pretty_printer := true;

(*or off for debugging
use_smallfoot_pretty_printer := false;
*)


(*please adapt the examples directory *)
val examplesDir = concat [Globals.HOLDIR, "/examples/separationLogic/src/smallfoot/EXAMPLES/"]


(*test the directory*)
val file = concat [examplesDir, "append.sf"];
val t = parse_smallfoot_file file




(*Till here the initialisation took place. This means loading libraries etc.
  Now we can start using Smallfoot. However, initialisation takes quite some time
  using PolyML. Therefore, it is useful to save the current state.
  (please adapt filename)*)

PolyML.SaveState.saveState "/home/tt291/Smallfoot";


(*In further sessions it is sufficient to just load this saved state instead of
  add the libraries and theories above*)
PolyML.SaveState.loadState "/home/tt291/Smallfoot";


(*Smallfoot comes with an extension to HOL-mode. This extension resides in
  smallfoot.el. It can be loaded by

(load "/home/tt291/hol98/examples/separationLogic2/src/smallfoot/smallfoot")

  Please, either add this to your ".emacs" after adapting the path or
  load it manualy by moving the cursor behind the last parentesis and pressing "M-x M-e".
  
  This adds a new menu with the common Smallfoot commands. This makes using
  Smallfoot much easier and possible for people not knowing HOL well.

  The initialise command in this menu loads the state saved above. Before using
  the initialise, please save the state somewhere and adapt the path in
  smallfoot.el, line 5.
*) 



(***************************************************************************
 * COPY 
 ***************************************************************************)

(*the specification without data can be proofed automatically*)
val file = concat [examplesDir, "copy.sf"];
val thm = smallfoot_verbose_auto_prove file;



(*the specification with data works as well, but takes much longer
  about 10 sec on my maschine against 3 without data*)
val file = concat [examplesDir, "copy.dsf"]; 
val thm = smallfoot_verbose_auto_prove file;



(***************************************************************************
 * LIST_LENGTH
 ***************************************************************************)

(*the specification without data can be proofed automatically*)
val file = concat [examplesDir, "list_length.sf"];
val thm = smallfoot_verbose_auto_prove file;


(*the specification with data works as well*)
val file = concat [examplesDir, "list_length.dsf"]; 
val thm = smallfoot_verbose_auto_prove file;




(***************************************************************************
 * REMOVE
 ***************************************************************************)

(*the specification without data can be proofed automatically*)
val file = concat [examplesDir, "remove.sf"];
val thm = smallfoot_verbose_auto_prove file;



(*the specification with data needs the specifically defined function.
  Moreover, a function REMOVE is sepcifically defined for this
  verification*)
val file = concat [examplesDir, "remove.dsf"]; 


val REMOVE_def = Define `
   (REMOVE x [] = []) /\
   (REMOVE x (v::vs) = if (x = v) then vs else v::(REMOVE x vs))` 


val thm = smallfoot_verbose_thm_auto_prove [REMOVE_def] file;







(***************************************************************************
 * REVERSE
 ***************************************************************************)

(*the specification without data can be proofed automatically*)
val file = concat [examplesDir, "reverse.sf"];
val thm = smallfoot_verbose_auto_prove file;



(*the specification with data works as well*)
val file = concat [examplesDir, "reverse.dsf"]; 
val thm = smallfoot_verbose_auto_prove file;














(***************************************************************************
 * MERGESORT
 ***************************************************************************)

(*the specification without data can be proofed automatically*)
val file = concat [examplesDir, "mergesort.sf"];
val file = concat [examplesDir, "mergesort_parallel.sf"]; 
val thm = smallfoot_verbose_auto_prove file;



(*for the full functional verification open some
  libraries first*)
open sortingTheory relationTheory permLib

(*The tools is strong enough to abstract automatically from
  the differences between parallel and sequential mergesort.
  The proof-script is exactly the same!*)

val file = concat [examplesDir, "mergesort.dsf"]; 
val file = concat [examplesDir, "mergesort_parallel.dsf"]; 

(*
val t = parse_smallfoot_file file;
set_goal ([], t);
e (SMALLFOOT_SPECIFICATION_TAC);


smallfoot_set_goal file;
*)



val thm = smallfoot_verbose_prove( file,
(*generate verification conditions*)
SMALLFOOT_VC_TAC THEN
(*All the program is gone, only theorems about
  permutations and sorted lists need to be still
  proved*)
ASM_SIMP_TAC (arith_ss++PERM_ss) 
    [SORTED_EQ, SORTED_DEF, transitive_def] THEN
REPEAT STRIP_TAC THEN (
   IMP_RES_TAC PERM_MEM_EQ THEN
   FULL_SIMP_TAC list_ss [] THEN
   RES_TAC THEN ASM_SIMP_TAC arith_ss []
));


(*Let's cheat and simplify the proof by a sideproof*)

val MERGE_DATA_THM = prove (``
 (!e. MEM e l1 ==> e1 <= e) /\
 (!e. MEM e l2 ==> e2 <= e)  ==>
 ((((e2:num >= e1:num) /\ PERM (e2::(l1++l2)) l) ==> !e:num. MEM e l ==> e1 <= e) /\
  (((e2:num < e1:num) /\ PERM (e1::(l1++l2)) l) ==> !e:num. MEM e l ==> e2 <= e))
``,
REPEAT STRIP_TAC THEN
IMP_RES_TAC PERM_MEM_EQ THEN
FULL_SIMP_TAC list_ss [] THEN
RES_TAC THEN ASM_SIMP_TAC arith_ss []
);



val thm = smallfoot_verbose_prove( file,
(*generate verification conditions*)
SMALLFOOT_VC_TAC THEN
(*All the program is gone, only theorems about
  permutations and sorted lists need to be still
  proved*)
ASM_SIMP_TAC (arith_ss++PERM_ss) 
    [SORTED_EQ, SORTED_DEF, transitive_def] THEN
REPEAT STRIP_TAC THEN 
IMP_RES_TAC MERGE_DATA_THM);
 








(***************************************************************************
 * APPEND 
 *****************************************************************************)

(*the specification without data can be proofed automatically*)
val file = concat [examplesDir, "append.sf"];
val thm = smallfoot_verbose_auto_prove file;


(*the specification with data is much more complicated *)
val file = concat [examplesDir, "append.dsf"]; 

(*
for interactive use

val t = parse_smallfoot_file file;
set_goal ([], t);
e (SMALLFOOT_SPECIFICATION_TAC);


or 

smallfoot_set_goal file;

*)

val thm = smallfoot_verbose_prove( file,

(*Handle while-loop separately*)
REPEAT STRIP_TAC THENL [
   (* while loop *)
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC [],


   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC [] THEN
   SMALLFOOT_STRICT_CLEAN_TAC THEN
   `(if LENGTH xdata1 = 0 then
       xdata_h::(xdata_t ++ ydata)
    else
       DROP (LENGTH xdata1 - 1) (xdata_t ++ ydata)) =
    tdate::ydata` by ALL_TAC THEN1 (

      Cases_on `xdata1` THEN (
         FULL_SIMP_TAC list_ss [BUTFIRSTN_LENGTH_APPEND,
			        APPEND_ASSOC_CONS]
      )
   ) THEN
   `xdata_h::(xdata_t ++ ydata) =
    xdata1 ++ (tdate::ydata)` by ALL_TAC THEN1 (
      ASM_SIMP_TAC std_ss [GSYM APPEND, APPEND_ASSOC_CONS] THEN
      SIMP_TAC list_ss []
   ) THEN
   ASM_SIMP_TAC list_ss [] THEN
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC []
]);



















(***************************************************************************
 * FILTER
 ***************************************************************************)

(*the specification without data can be proofed automatically*)
val file = concat [examplesDir, "filter.sf"];
val thm = smallfoot_verbose_auto_prove file;



(* the verification of filter is tricky. Let's
   start with the much simpler recursive version *)
val file = concat [examplesDir, "filter_rec.dsf"]; 
val thm = smallfoot_verbose_auto_prove file;





(*The orginal version has a very complicated
  loop invariant. Therefore the proof is quite
  long: *)
val file = concat [examplesDir, "filter.dsf"]; 

(*
for interactive use

val t = parse_smallfoot_file file;
set_goal ([], t);
e (SMALLFOOT_SPECIFICATION_TAC);


or 

SMALLFOOT_NO_CASE_SPLIT_NO_GUESS_STEP_TAC []


set_trace "QUANT_INSTANTIATE_HEURISTIC" 1
SMALLFOOT_STEP_TAC []

smallfoot_set_goal file;

REPEAT STRIP_TAC

val file = concat [examplesDir, "reverse.dsf"]; 
val file = concat [examplesDir, "reverse.sf"]; 
val thm = smallfoot_verbose_auto_prove file;
*)

val thm = smallfoot_verbose_prove( file,

(*Handle while-loop separately*)
REPEAT STRIP_TAC THENL [
   (* while loop *)
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC [] THEN
   REPEAT STRIP_TAC THENL [
      SMALLFOOT_VC_TAC THEN
      GEN_TAC THEN
      Q.EXISTS_TAC `data_fc ++ [fc]` THEN
      FULL_SIMP_TAC list_ss [APPEND_11, APPEND_ASSOC_CONS],


      SMALLFOOT_VC_TAC THEN
      REPEAT GEN_TAC THEN
      Q.EXISTS_TAC `data_fc` THEN
      ASM_SIMP_TAC list_ss [FILTER_EQ_NIL] THEN
      REPEAT STRIP_TAC THEN
      Q.EXISTS_TAC `[]` THEN
      SIMP_TAC list_ss [],


      SMALLFOOT_PROP_IMPLIES___EQ_CASE_SPLIT_TAC ``l_const:num`` ``n:num`` THEN
      SMALLFOOT_VC_TAC THEN
      REPEAT STRIP_TAC THEN
      Q.EXISTS_TAC `data1` THEN
      REPEAT STRIP_TAC THEN
      Q.EXISTS_TAC `[]` THEN
      Q.EXISTS_TAC `data_fc ++ [fc]` THEN
      FULL_SIMP_TAC list_ss [APPEND_ASSOC_CONS,
			     BUTFIRSTN_LENGTH_NIL],



      SMALLFOOT_PROP_IMPLIES___EQ_CASE_SPLIT_TAC ``l_const:num`` ``n:num`` THEN
      SMALLFOOT_VC_TAC THEN
      REPEAT STRIP_TAC THEN
      Q.EXISTS_TAC `data1 ++ date::data_fc` THEN
      REPEAT STRIP_TAC THEN
      ASM_SIMP_TAC list_ss [FILTER_APPEND, BUTFIRSTN_LENGTH_APPEND,
			    FILTER_EQ_NIL] THEN
      Q.EXISTS_TAC `[]` THEN
      SIMP_TAC list_ss [APPEND_ASSOC_CONS]
   ],



   (*main*)
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC [] THEN
   REPEAT STRIP_TAC THEN
   Q.EXISTS_TAC `[]` THEN
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC [] THEN
   SMALLFOOT_STRICT_CLEAN_TAC THEN
   SMALLFOOT_PROP_IMPLIES___EQ_CASE_SPLIT_TAC ``l_const:num`` ``0:num`` THEN
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC [] THEN
   
   SIMP_TAC list_ss [FILTER_EQ_NIL, FILTER_APPEND,
		     BUTFIRSTN_LENGTH_APPEND] THEN
   SMALLFOOT_NO_CASE_SPLIT_SOLVE_TAC []
]);










