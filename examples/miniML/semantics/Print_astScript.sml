(* generated by Lem from print_ast.lem *)
open bossLib Theory Parse res_quanTheory
open finite_mapTheory listTheory pairTheory pred_setTheory integerTheory
open set_relationTheory sortingTheory stringTheory wordsTheory

val _ = new_theory "Print_ast"

open MiniMLTheory

(*open MiniML*)

val _ = Hol_datatype `
 stree = S of string | A of stree => stree`;


(*val (^^) : stree -> stree -> stree*)

(*val stree_to_string : stree -> string -> string*)
 val stree_to_string_defn = Hol_defn "stree_to_string" `

(stree_to_string (S s) acc = STRCAT  s  acc)
/\
(stree_to_string (A s1 s2) acc = stree_to_string s1 (stree_to_string s2 acc))`;

val _ = Defn.save_defn stree_to_string_defn;

(* TODO: use a built-in int_to_string *)

 val pos_int_to_string_defn = Hol_defn "pos_int_to_string" `
 (pos_int_to_string n =
  if int_gt n (& 0) then
    let n' = int_mod n (& 10) in A 
      (pos_int_to_string (int_div n (& 10))) 
      (if n' = & 0 then S"0"
       else if n' = & 1 then S"1"
       else if n' = & 2 then S"2"
       else if n' = & 3 then S"3"
       else if n' = & 4 then S"4"
       else if n' = & 5 then S"5"
       else if n' = & 6 then S"6"
       else if n' = & 7 then S"7"
       else if n' = & 8 then S"8"
       else S"9")
  else
    S"")`;

val _ = Defn.save_defn pos_int_to_string_defn;

(*val int_to_sml : Int.int -> stree*)
val _ = Define `
 (int_to_sml n =
  if n = & 0 then
    S"0"
  else if int_gt n (& 0) then
    pos_int_to_string n
  else A 
    (S"~")  (pos_int_to_string ((int_sub) (& 0) n)))`;


val _ = Define `
 sml_infixes = ["="; "+"; "-"; "*"; "div"; "mod"; "<"; ">"; "<="; ">="]`;


(*val join_strings : string -> stree list -> stree*)
 val join_strings_defn = Hol_defn "join_strings" `

(join_strings sep [] = S"")
/\
(join_strings sep [x] = x)
/\
(join_strings sep (x::y::l) = A 
  x (A   (S sep) (A   y  (join_strings sep l))))`;

val _ = Defn.save_defn join_strings_defn;

val _ = Define `
 (lit_to_sml l = (case l of
  (* Rely on the fact that true and false cannot be rebound in SML *)
    Bool T => S"true"
  | Bool F => S"false"
  | IntLit n => int_to_sml n
))`;


val _ = Define `
 (var_to_sml v =
  if MEM v sml_infixes then A 
    (S"op ")  (S v)
  else
    S v)`;


 val pat_to_sml_defn = Hol_defn "pat_to_sml" `

(pat_to_sml (Pvar v) = var_to_sml v)
/\
(pat_to_sml (Plit l) = lit_to_sml l)
/\
(pat_to_sml (Pcon NONE ps) = A  
  (S"(") (A   (join_strings "," (MAP pat_to_sml ps))  (S")")))
/\
(pat_to_sml (Pcon (SOME c) []) =
  var_to_sml c)
/\
(pat_to_sml (Pcon (SOME c) ps) = A 
  (S"(") (A   (var_to_sml c) (A   
    (S"(") (A   (join_strings "," (MAP pat_to_sml ps)) (A   (S")")  (S")"))))))`;

val _ = Defn.save_defn pat_to_sml_defn;

 val exp_to_sml_defn = Hol_defn "exp_to_sml" `

(exp_to_sml (Raise r) =
  S"(raise Bind)")
/\
(exp_to_sml (Val (Lit l)) =
  lit_to_sml l)
/\
(exp_to_sml (Val _) =
  (* TODO: this shouldn't happen in source *)
  S"")
/\
(exp_to_sml (Con NONE es) = A  
  (S"(") (A   (join_strings "," (MAP exp_to_sml es))  (S")")))
/\
(exp_to_sml (Con (SOME c) []) =
  var_to_sml c)
/\
(exp_to_sml (Con (SOME c) es) = A 
  (S"(") (A   (var_to_sml c) (A   
    (S"(") (A   (join_strings "," (MAP exp_to_sml es)) (A   (S")")  (S")"))))))
/\
(exp_to_sml (Var v) =
  var_to_sml v)
/\
(exp_to_sml (Fun v e) = A 
  (S"(fn ") (A   (var_to_sml v) (A   (S" => ") (A   (exp_to_sml e)  (S")")))))
/\
(exp_to_sml (App Opapp e1 e2) = A 
  (S"(") (A   (exp_to_sml e1) (A   (S" ") (A   (exp_to_sml e2)  (S")")))))
/\
(exp_to_sml (App Equality e1 e2) = A 
  (* Rely on the fact (?) that = cannot be rebound in SML *)
  (S"(") (A   (exp_to_sml e1) (A   (S" = ") (A   (exp_to_sml e2)  (S")")))))
/\
(exp_to_sml (App (Opn o0) e1 e2) =
  let s = (case o0 of
      Plus => "+"
    | Minus => "-"
    | Times => "*"
    | Divide => "div"
    | Modulo => "mod"
  )
  in
    if MEM s sml_infixes then A 
      (S"(") (A   (exp_to_sml e1) (A   (S" ") (A   (S s) (A   (S" ") (A   (exp_to_sml e2)  (S")"))))))
    else A 
      (S"(") (A   (S s) (A   (S" ") (A   (exp_to_sml e1) (A   (S" ") (A   (exp_to_sml e2)  (S")")))))))
/\
(exp_to_sml (App (Opb o') e1 e2) =
  let s = (case o' of
      Lt => "<"
    | Gt => ">"
    | Leq => "<="
    | Geq => ">"
  )
  in
    if MEM s sml_infixes then A 
      (S"(") (A   (exp_to_sml e1) (A   (S" ") (A   (S s) (A   (S" ") (A   (exp_to_sml e2)  (S")"))))))
    else A 
      (S"(") (A   (S s) (A   (S" ") (A   (exp_to_sml e1) (A   (S" ") (A   (exp_to_sml e2)  (S")")))))))
/\
(exp_to_sml (Log lop e1 e2) = A 
  (S"(") (A   (exp_to_sml e1) (A   (if lop = And then S" andalso " else S" orelse ") (A  
  (exp_to_sml e2)  (S")")))))
/\
(exp_to_sml (If e1 e2 e3) = A 
  (S"(if ") (A   (exp_to_sml e1) (A   (S" then ") (A   (exp_to_sml e2) (A   (S" else ") (A  
  (exp_to_sml e3)  (S")")))))))
/\
(exp_to_sml (Mat e pes) = A 
  (S"(case ") (A   (exp_to_sml e) (A   (S" of ") (A  
  (join_strings " | " (MAP pat_exp_to_sml pes))  (S")")))))
/\
(exp_to_sml (Let v e1 e2) = A 
  (S"let val ") (A   (var_to_sml v) (A   (S" = ") (A   (exp_to_sml e1) (A   (S" in ") (A  
  (exp_to_sml e2)  (S" end")))))))
/\
(exp_to_sml (Letrec funs e) = A 
  (S"let fun ") (A   (join_strings " and " (MAP fun_to_sml funs)) (A   (S" in ") (A  
  (exp_to_sml e)  (S" end")))))
/\
(pat_exp_to_sml (p,e) = A 
  (pat_to_sml p) (A   (S" => ")  (exp_to_sml e)))
/\
(fun_to_sml (v1,v2,e) = A 
  (var_to_sml v1) (A   (S" ") (A   (var_to_sml v2) (A   (S" = ")  (exp_to_sml e)))))`;

val _ = Defn.save_defn exp_to_sml_defn;

 val type_to_sml_defn = Hol_defn "type_to_sml" `

(type_to_sml (Tvar tn) =
  S tn)
/\
(type_to_sml (Tapp ts tn) =
  if ts = [] then
    S tn
  else A 
    (S"(") (A   (join_strings "," (MAP type_to_sml ts)) (A   (S")")  (S tn))))
/\
(type_to_sml (Tfn t1 t2) = A 
  (S"(") (A   (type_to_sml t1) (A   (S" -> ") (A   (type_to_sml t2)  (S")")))))
/\
(type_to_sml Tnum =
  (* TODO: Get the numeric types sorted *)
  S"int")
/\
(type_to_sml Tbool =
  S"bool")`;

val _ = Defn.save_defn type_to_sml_defn;

val _ = Define `
 (variant_to_sml (c,ts) = A 
  (var_to_sml c) (A   (if ts = [] then S"" else S" of ") 
  (join_strings " * " (MAP type_to_sml ts))))`;


(*val typedef_to_sml : tvarN list * typeN * (conN * t list) list -> stree*)
val _ = Define `
 (typedef_to_sml (tvs, name, variants) = A 
  (if tvs = [] then S"" else A  (S"(") (A   (join_strings "," (MAP S tvs))  (S")"))) (A  
  (S name) (A   (S" = ")  (join_strings " | " (MAP variant_to_sml variants)))))`;


val _ = Define `
 (dec_to_sml d =
  (case d of
      Dlet p e => A 
        (S"val ") (A   (pat_to_sml p) (A   (S" = ")  (exp_to_sml e)))
    | Dletrec funs => A 
        (S"fun ")  (join_strings " and " (MAP fun_to_sml funs))
    | Dtype types => A 
        (S"datatype ")  (join_strings " and " (MAP typedef_to_sml types))
  ))`;


val _ = Define `
 (dec_to_sml_string d = stree_to_string (dec_to_sml d) "")`;

val _ = export_theory()

