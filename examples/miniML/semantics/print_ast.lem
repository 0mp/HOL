open MiniML

type stree = S of string | A of stree * stree

val (^^) : stree -> stree -> stree
sub [hol] (^^) x y = A x y
sub [ocaml] (^^) x y = A x y

val stree_to_string : stree -> string -> string
let rec
stree_to_string (S s) acc = s ^ acc
and
stree_to_string (A s1 s2) acc = stree_to_string s1 (stree_to_string s2 acc)

(* TODO: use a built-in int_to_string *)

let rec pos_int_to_string n =
  if Int.(>) n (i 0) then
    let n' = Int.(%) n (i 10) in
      pos_int_to_string (Int.(/) n (i 10)) ^^
      (if n' = i 0 then S"0"
       else if n' = i 1 then S"1"
       else if n' = i 2 then S"2"
       else if n' = i 3 then S"3"
       else if n' = i 4 then S"4"
       else if n' = i 5 then S"5"
       else if n' = i 6 then S"6"
       else if n' = i 7 then S"7"
       else if n' = i 8 then S"8"
       else S"9")
  else
    S""

val int_to_sml : Int.int -> stree
let int_to_sml n =
  if n = i 0 then
    S"0"
  else if Int.(>) n (i 0) then
    pos_int_to_string n
  else
    S"~" ^^ pos_int_to_string (Int.(-) (i 0) n)

let sml_infixes = ["="; "+"; "-"; "*"; "div"; "mod"; "<"; ">"; "<="; ">="]

val join_strings : string -> stree list -> stree
let rec
join_strings sep [] = S""
and
join_strings sep [x] = x
and
join_strings sep (x::y::l) =
  x ^^ S sep ^^ y ^^ join_strings sep l

let lit_to_sml l = match l with
  (* Rely on the fact that true and false cannot be rebound in SML *)
  | Bool true -> S"true"
  | Bool false -> S"false"
  | IntLit n -> int_to_sml n
end

let var_to_sml v =
  if List.mem v sml_infixes then
    S"op " ^^ S v
  else
    S v

let rec
pat_to_sml (Pvar v) = var_to_sml v
and
pat_to_sml (Plit l) = lit_to_sml l
and
pat_to_sml (Pcon None ps) = 
  S"(" ^^ join_strings "," (List.map pat_to_sml ps) ^^ S")"
and
pat_to_sml (Pcon (Some c) []) =
  var_to_sml c
and
pat_to_sml (Pcon (Some c) ps) =
  S"(" ^^ var_to_sml c ^^ 
    S"(" ^^ join_strings "," (List.map pat_to_sml ps) ^^ S")" ^^ S")"

let rec
exp_to_sml (Raise r) =
  S"(raise Bind)"
and
exp_to_sml (Val (Lit l)) =
  lit_to_sml l
and
exp_to_sml (Val _) =
  (* TODO: this shouldn't happen in source *)
  S""
and
exp_to_sml (Con None es) = 
  S"(" ^^ join_strings "," (List.map exp_to_sml es) ^^ S")"
and
exp_to_sml (Con (Some c) []) =
  var_to_sml c
and
exp_to_sml (Con (Some c) es) =
  S"(" ^^ var_to_sml c ^^ 
    S"(" ^^ join_strings "," (List.map exp_to_sml es) ^^ S")" ^^ S")"
and
exp_to_sml (Var v) =
  var_to_sml v
and
exp_to_sml (Fun v e) =
  S"(fn " ^^ var_to_sml v ^^ S" => " ^^ exp_to_sml e ^^ S")"
and
exp_to_sml (App Opapp e1 e2) =
  S"(" ^^ exp_to_sml e1 ^^ S" " ^^ exp_to_sml e2 ^^ S")"
and
exp_to_sml (App Equality e1 e2) =
  (* Rely on the fact (?) that = cannot be rebound in SML *)
  S"(" ^^ exp_to_sml e1 ^^ S" = " ^^ exp_to_sml e2 ^^ S")"
and
exp_to_sml (App (Opn o) e1 e2) =
  let s = match o with
    | Plus -> "+"
    | Minus -> "-"
    | Times -> "*"
    | Divide -> "div"
    | Modulo -> "mod"
  end
  in
    if List.mem s sml_infixes then
      S"(" ^^ exp_to_sml e1 ^^ S" " ^^ S s ^^ S" " ^^ exp_to_sml e2 ^^ S")"
    else
      S"(" ^^ S s ^^ S" " ^^ exp_to_sml e1 ^^ S" " ^^ exp_to_sml e2 ^^ S")"
and
exp_to_sml (App (Opb o') e1 e2) =
  let s = match o' with
    | Lt -> "<"
    | Gt -> ">"
    | Leq -> "<="
    | Geq -> ">"
  end
  in
    if List.mem s sml_infixes then
      S"(" ^^ exp_to_sml e1 ^^ S" " ^^ S s ^^ S" " ^^ exp_to_sml e2 ^^ S")"
    else
      S"(" ^^ S s ^^ S" " ^^ exp_to_sml e1 ^^ S" " ^^ exp_to_sml e2 ^^ S")"
and
exp_to_sml (Log lop e1 e2) =
  S"(" ^^ exp_to_sml e1 ^^ (if lop = And then S" andalso " else S" orelse ") ^^
  exp_to_sml e2 ^^ S")"
and
exp_to_sml (If e1 e2 e3) =
  S"(if " ^^ exp_to_sml e1 ^^ S" then " ^^ exp_to_sml e2 ^^ S" else " ^^
  exp_to_sml e3 ^^ S")"
and
exp_to_sml (Mat e pes) =
  S"(case " ^^ exp_to_sml e ^^ S" of " ^^
  join_strings " | " (List.map pat_exp_to_sml pes) ^^ S")"
and
exp_to_sml (Let v e1 e2) =
  S"let val " ^^ var_to_sml v ^^ S" = " ^^ exp_to_sml e1 ^^ S" in " ^^
  exp_to_sml e2 ^^ S" end"
and
exp_to_sml (Letrec funs e) =
  S"let fun " ^^ join_strings " and " (List.map fun_to_sml funs) ^^ S" in " ^^
  exp_to_sml e ^^ S" end"
and
pat_exp_to_sml (p,e) =
  pat_to_sml p ^^ S" => " ^^ exp_to_sml e
and
fun_to_sml (v1,v2,e) =
  var_to_sml v1 ^^ S" " ^^ var_to_sml v2 ^^ S" = " ^^ exp_to_sml e

let rec
type_to_sml (Tvar tn) =
  S tn
and
type_to_sml (Tapp ts tn) =
  if ts = [] then
    S tn
  else
    S"(" ^^ join_strings "," (List.map type_to_sml ts) ^^ S")" ^^ S tn
and
type_to_sml (Tfn t1 t2) =
  S"(" ^^ type_to_sml t1 ^^ S" -> " ^^ type_to_sml t2 ^^ S")"
and
type_to_sml Tnum =
  (* TODO: Get the numeric types sorted *)
  S"int"
and
type_to_sml Tbool =
  S"bool"

let variant_to_sml (c,ts) =
  var_to_sml c ^^ (if ts = [] then S"" else S" of ") ^^
  join_strings " * " (List.map type_to_sml ts)

val typedef_to_sml : tvarN list * typeN * (conN * t list) list -> stree
let typedef_to_sml (tvs, name, variants) =
  (if tvs = [] then S"" else S"(" ^^ join_strings "," (List.map S tvs) ^^ S")") ^^
  S name ^^ S" = " ^^ join_strings " | " (List.map variant_to_sml variants)

let dec_to_sml d =
  match d with
    | Dlet p e ->
        S"val " ^^ pat_to_sml p ^^ S" = " ^^ exp_to_sml e
    | Dletrec funs ->
        S"fun " ^^ join_strings " and " (List.map fun_to_sml funs)
    | Dtype types ->
        S"datatype " ^^ join_strings " and " (List.map typedef_to_sml types)
  end

let dec_to_sml_string d = stree_to_string (dec_to_sml d) ""
