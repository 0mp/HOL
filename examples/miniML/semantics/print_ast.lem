open MiniML

val Num : Int.int -> num
sub [hol] Num = Num

val CHR : num -> string
sub [hol] CHR n = STRING (CHR n) ""

val string_first : string -> string
sub [hol] string_first s = STRING (SUB (s,0)) ""

val string_last : string -> string
sub [hol] string_last s = STRING (SUB (s,STRLEN s - 1)) ""

val (%) : num -> num -> num
sub [hol] (%) = MOD

type token =
  | NewlineT
  | WhitespaceT of num
  | IntlitT of int
  | IdentT of string
  | TvT of string

  | AndT | AndalsoT | CaseT | DatatypeT | ElseT | EndT | FnT | FunT | IfT 
  | InT | LetT | OfT | OpT | OrelseT | RecT | ThenT | ValT | Open_parenT
  | Close_parenT | CommaT | SemiT | BarT | EqT | EqarrowT | MinusarrowT | StarT

(* OCaml additions *)
  | MatchT | TypeT | WithT | AmpampT | BarbarT | SemisemiT

let rec num_to_string n acc =
  if n = 0 then
    acc
  else
    num_to_string (n / 10) (CHR (n % 10 + 48) ^ acc)

val int_to_string : bool -> Int.int -> string
let int_to_string sml n =
  if n = i 0 then
    "0"
  else if Int.(>) n (i 0) then
    num_to_string (Num n) ""
  else
    (if sml then "~" else "-") ^ num_to_string (Num (Int.(-) (i 0) n)) ""

val spaces : num -> string -> string
let rec 
spaces n s =
  if (n:num) = 0 then
    s
  else
    " " ^ spaces (n - 1) s

let space_append s1 s2 =
  if s2 = "" then
    s1
  else 
    let f = string_first s2 in
      if f = ")"  || f = " " || f = "," then
    s1 ^ s2
  else
    s1 ^ " " ^ s2

let rec
tok_to_string sml NewlineT s = "\n" ^ s
and
tok_to_string sml (WhitespaceT n) s = spaces n s
and
tok_to_string sml (IntlitT i) s = space_append (int_to_string sml i) s
and
tok_to_string sml (IdentT id) s = space_append id s
and
tok_to_string sml (TvT tv) s = space_append ("'" ^ tv) s
and
tok_to_string sml AndT s = "and " ^ s
and
tok_to_string sml AndalsoT s = "andalso " ^ s
and
tok_to_string sml CaseT s = "case " ^ s
and
tok_to_string sml DatatypeT s = "datatype " ^ s
and
tok_to_string sml ElseT s = "else " ^ s
and
tok_to_string sml EndT s = "end " ^ s
and
tok_to_string sml FnT s = "fn " ^ s
and
tok_to_string sml FunT s = "fun " ^ s
and
tok_to_string sml IfT s = "if " ^ s
and
tok_to_string sml InT s = "in " ^ s
and
tok_to_string sml LetT s = "let " ^ s
and
tok_to_string sml OfT s = "of " ^ s
and
tok_to_string sml OpT s = "op " ^ s
and
tok_to_string sml OrelseT s = "orelse " ^ s
and
tok_to_string sml RecT s = "rec " ^ s
and
tok_to_string sml ThenT s = "then " ^ s
and
tok_to_string sml ValT s = "val " ^ s
and
tok_to_string sml Open_parenT s = 
  if s = "" then
    "("
  else if string_first s = "*" then
    "( " ^ s
  else
    "(" ^ s
and
tok_to_string sml Close_parenT s = space_append ")" s
and
tok_to_string sml CommaT s = ", " ^ s
and
tok_to_string sml SemiT s = ";" ^ s
and
tok_to_string sml BarT s = "| " ^ s
and
tok_to_string sml EqT s = "= " ^ s
and
tok_to_string sml EqarrowT s = "=> " ^ s
and
tok_to_string sml MinusarrowT s = "-> " ^ s
and
tok_to_string sml StarT s = "* " ^ s
and
tok_to_string sml MatchT s = "match " ^ s
and
tok_to_string sml TypeT s = "type " ^ s
and
tok_to_string sml WithT s = "with " ^ s
and
tok_to_string sml AmpampT s = "&& " ^ s
and
tok_to_string sml BarbarT s = "|| " ^ s
and
tok_to_string sml SemisemiT s = ";;" ^ s

let rec 
tok_list_to_string sml [] = ""
and
tok_list_to_string sml (t::l) = 
  tok_to_string sml t (tok_list_to_string sml l)

(*type 'a tree = L of 'a | N of 'a tree * 'a tree*)
type tok_tree = L of token | N of tok_tree * tok_tree

(*val (^^) : forall 'a. 'a tree -> 'a tree -> 'a tree*)
val (^^) : tok_tree -> tok_tree -> tok_tree
sub [hol] (^^) x y = N x y
sub [ocaml] (^^) x y = N x y

(*val tree_to_list : forall 'a. 'a tree -> 'a list -> 'a list*)
val tree_to_list : tok_tree -> token list -> token list
let rec
tree_to_list (L x) acc = x::acc
and
tree_to_list (N x1 x2) acc = tree_to_list x1 (tree_to_list x2 acc)

(* Should include "^", but I don't know how to get that into HOL, since
 * antiquote seem stronger than strings. *)
(* This is very slow
let sml_infixes = 
  ["mod"; "<>"; ">="; "<="; ":="; "::"; "before"; "div"; "o"; "@"; ">";
   "="; "<"; "/"; "-"; "+"; "*"]
 *)

let is_sml_infix s =
  s = "mod" || s = "<>" || s = ">=" || s = "<=" || s = ":=" || s = "::" || 
  s = "before" || s = "div" || s = "o" || s = "@" || s = ">" || s = "=" || 
  s = "<" || s = "/" || s = "-" || s = "+" || s = "*"

let ocaml_infixes = ["="; "+"; "-"; "*"; "/"; "mod"; "<"; ">"; "<="; ">="]

(*val join_trees : forall 'a. 'a tree -> 'a tree list -> 'a tree*)
val join_trees : tok_tree -> tok_tree list -> tok_tree
let rec
join_trees sep [x] = x
and
join_trees sep (x::y::l) =
  x ^^ sep ^^ join_trees sep (y::l)

let rec
lit_to_tok_tree sml (Bool true) = L (IdentT "true")
and
lit_to_tok_tree sml (Bool false) = L (IdentT "false")
and
lit_to_tok_tree sml (IntLit n) = L (IntlitT n)

let pad_start v =
  if string_first v = "*" then
    " " ^ v
  else
    v

let pad_end v =
  if string_last v = "*" then
    v ^ " "
  else
    v

let var_to_tok_tree sml v =
  if sml && is_sml_infix v then
    L OpT ^^ L (IdentT v)
  else if not sml && List.mem v ocaml_infixes then
    L Open_parenT ^^ L (IdentT v) ^^ L Close_parenT
  else
    L (IdentT v)

let rec
pat_to_tok_tree sml (Pvar v) = var_to_tok_tree sml v
and
pat_to_tok_tree sml (Plit l) = lit_to_tok_tree sml l
and
pat_to_tok_tree sml (Pcon c []) = var_to_tok_tree sml c
and
pat_to_tok_tree sml (Pcon c ps) =
  L Open_parenT ^^ var_to_tok_tree sml c ^^ 
    L Open_parenT ^^ join_trees (L CommaT) (List.map (pat_to_tok_tree sml) ps) ^^
    L Close_parenT ^^ L Close_parenT

let inc_indent i = 
  if (i:num) < 30 then
    i + 2
  else
    i

let newline indent = 
  L NewlineT ^^ L (WhitespaceT indent)

let rec
exp_to_tok_tree sml indent (Raise r) =
  if sml then
    L Open_parenT ^^ L (IdentT "raise") ^^ L (IdentT "Bind") ^^ L Close_parenT
  else
    L Open_parenT ^^ L (IdentT "raise") ^^ 
      L Open_parenT ^^ L (IdentT "Match_failure") ^^ 
        L Open_parenT ^^ L (IdentT "string_of_bool") ^^ L (IdentT "true") ^^ 
        L CommaT ^^
        L (IntlitT (i 0)) ^^ L CommaT ^^ L (IntlitT (i 0)) ^^ L Close_parenT ^^
      L Close_parenT ^^
    L Close_parenT
and
exp_to_tok_tree sml indent (Val (Lit l)) =
  lit_to_tok_tree sml l
and
exp_to_tok_tree sml indent (Con c []) =
  var_to_tok_tree sml c
and
exp_to_tok_tree sml indent (Con c es) =
  L Open_parenT ^^
  var_to_tok_tree sml c ^^ 
  L Open_parenT ^^
  join_trees (L CommaT) (List.map (exp_to_tok_tree sml indent) es) ^^ 
  L Close_parenT ^^ L Close_parenT
and
exp_to_tok_tree sml indent (Var v) =
  var_to_tok_tree sml v
and
exp_to_tok_tree sml indent (Fun v e) =
  newline indent ^^
  L Open_parenT ^^
  (if sml then L FnT else L FunT) ^^
  var_to_tok_tree sml v ^^ 
  (if sml then L EqarrowT else L MinusarrowT) ^^ 
  exp_to_tok_tree sml (inc_indent indent) e ^^ 
  L Close_parenT
and
exp_to_tok_tree sml indent (App Opapp e1 e2) =
  L Open_parenT ^^
  exp_to_tok_tree sml indent e1 ^^ 
  exp_to_tok_tree sml indent e2 ^^ 
  L Close_parenT
and
exp_to_tok_tree sml indent (App Equality e1 e2) =
  L Open_parenT ^^
  exp_to_tok_tree sml indent e1 ^^ 
  L EqT ^^ 
  exp_to_tok_tree sml indent e2 ^^ 
  L Close_parenT
and
exp_to_tok_tree sml indent (App (Opn o) e1 e2) =
  let s = match o with
    | Plus -> "+"
    | Minus -> "-"
    | Times -> "*"
    | Divide -> if sml then "div" else "/"
    | Modulo -> "mod"
  end
  in
    L Open_parenT ^^
    exp_to_tok_tree sml indent e1 ^^ 
    L (IdentT s) ^^ 
    exp_to_tok_tree sml indent e2 ^^ 
    L Close_parenT
and
exp_to_tok_tree sml indent (App (Opb o') e1 e2) =
  let s = match o' with
    | Lt -> "<"
    | Gt -> ">"
    | Leq -> "<="
    | Geq -> ">"
  end
  in
    L Open_parenT ^^
    exp_to_tok_tree sml indent e1 ^^ 
    L (IdentT s) ^^ 
    exp_to_tok_tree sml indent e2 ^^ 
    L Close_parenT
and
exp_to_tok_tree sml indent (Log lop e1 e2) =
  L Open_parenT ^^
  exp_to_tok_tree sml indent e1 ^^ 
  (if lop = And then 
     if sml then L AndalsoT else L AmpampT
   else 
     if sml then L OrelseT else L BarbarT) ^^
  exp_to_tok_tree sml indent e2 ^^ 
  L Close_parenT
and
exp_to_tok_tree sml indent (If e1 e2 e3) =
  newline indent ^^
  L Open_parenT ^^
  L IfT ^^
  exp_to_tok_tree sml indent e1 ^^ 
  newline indent ^^
  L ThenT ^^
  exp_to_tok_tree sml (inc_indent indent) e2 ^^
  newline indent ^^
  L ElseT ^^
  exp_to_tok_tree sml (inc_indent indent) e3 ^^ 
  L Close_parenT
and
exp_to_tok_tree sml indent (Mat e pes) =
  newline indent ^^
  L Open_parenT ^^
  (if sml then L CaseT else L MatchT) ^^ 
  exp_to_tok_tree sml indent e ^^ 
  (if sml then L OfT else L WithT) ^^
  newline (inc_indent (inc_indent indent)) ^^
  join_trees (newline (inc_indent indent) ^^ L BarT) 
               (List.map (pat_exp_to_tok_tree sml (inc_indent indent)) pes) ^^ 
  L Close_parenT
and
exp_to_tok_tree sml indent (Let v e1 e2) =
  newline indent ^^
  (if sml then L LetT ^^ L ValT else L Open_parenT ^^ L LetT) ^^ 
  var_to_tok_tree sml v ^^ 
  L EqT ^^
  exp_to_tok_tree sml indent e1 ^^ 
  newline indent ^^
  L InT ^^
  exp_to_tok_tree sml (inc_indent indent) e2 ^^ 
  (if sml then newline indent ^^ L EndT else L Close_parenT)
and
exp_to_tok_tree sml indent (Letrec funs e) =
  newline indent ^^
  (if sml then L LetT ^^ L FunT else L Open_parenT ^^ L RecT) ^^ 
  join_trees (newline indent ^^ L AndT) 
               (List.map (fun_to_tok_tree sml indent) funs) ^^ 
  newline indent ^^
  L InT ^^
  exp_to_tok_tree sml indent e ^^ 
  (if sml then newline indent ^^ L EndT else L Close_parenT)
and
pat_exp_to_tok_tree sml indent (p,e) =
  pat_to_tok_tree sml p ^^ 
  (if sml then L EqarrowT else L MinusarrowT) ^^
  exp_to_tok_tree sml (inc_indent (inc_indent indent)) e
and
fun_to_tok_tree sml indent (v1,v2,e) =
  var_to_tok_tree sml v1 ^^
  var_to_tok_tree sml v2 ^^ 
  L EqT ^^
  exp_to_tok_tree sml (inc_indent indent) e

let rec
type_to_tok_tree (Tvar tn) =
  L (TvT tn)
and
type_to_tok_tree (Tapp ts tn) =
  if ts = [] then
    L (IdentT tn)
  else
    L Open_parenT ^^
    join_trees (L CommaT) (List.map type_to_tok_tree ts) ^^ L Close_parenT ^^ 
    L (IdentT tn)
and
type_to_tok_tree (Tfn t1 t2) =
  L Open_parenT ^^ type_to_tok_tree t1 ^^ L MinusarrowT ^^ type_to_tok_tree t2 ^^ 
  L Close_parenT
and
type_to_tok_tree Tnum =
  L (IdentT "int")
and
type_to_tok_tree Tbool =
  L (IdentT "bool")

let variant_to_tok_tree sml (c,ts) =
  if ts = [] then
    var_to_tok_tree sml c 
  else
    var_to_tok_tree sml c ^^ L OfT ^^ 
    join_trees (L StarT) (List.map type_to_tok_tree ts)

(*val typedef_to_tok_tree : bool -> num -> tvarN list * typeN * (conN * t list) list -> token tree*)
val typedef_to_tok_tree : bool -> num -> tvarN list * typeN * (conN * t list) list -> tok_tree
let typedef_to_tok_tree sml indent (tvs, name, variants) =
  (if tvs = [] then 
     L (IdentT name)
   else 
     L Open_parenT ^^ 
     join_trees (L CommaT) (List.map (fun tv -> L (TvT tv)) tvs) ^^ 
     L Close_parenT ^^
     L (IdentT name)) ^^ 
  L EqT ^^
  newline (inc_indent (inc_indent indent)) ^^
  join_trees (newline (inc_indent indent) ^^ L BarT) 
               (List.map (variant_to_tok_tree sml) variants)

let rec 
dec_to_tok_tree sml indent (Dlet p e) =
  (if sml then L ValT else L LetT) ^^
  pat_to_tok_tree sml p ^^ 
  L EqT ^^
  exp_to_tok_tree sml (inc_indent indent) e ^^
  (if sml then L SemiT else L SemisemiT)
and
dec_to_tok_tree sml indent (Dletrec funs) =
  (if sml then L FunT else L LetT ^^ L RecT) ^^ 
  join_trees (newline indent ^^ L AndT) 
             (List.map (fun_to_tok_tree sml indent) funs) ^^
  (if sml then L SemiT else L SemisemiT)
and
dec_to_tok_tree sml indent (Dtype types) =
  (if sml then L DatatypeT else L TypeT) ^^ 
  join_trees (newline indent ^^ L AndT) 
             (List.map (typedef_to_tok_tree sml indent) types) ^^
  (if sml then L SemiT else L SemisemiT)

let dec_to_sml_string d = 
  tok_list_to_string true (tree_to_list (dec_to_tok_tree true 0 d) [])
let dec_to_ocaml_string d = 
  tok_list_to_string false (tree_to_list (dec_to_tok_tree false 0 d) [])
