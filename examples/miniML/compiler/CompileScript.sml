(* generated by Lem from compile.lem *)
open bossLib Theory Parse res_quanTheory
open finite_mapTheory listTheory pairTheory pred_setTheory integerTheory
open set_relationTheory sortingTheory stringTheory wordsTheory

val _ = new_theory "Compile"

open MiniMLTheory

(*open MiniML*)

(* Remove Gt and Geq *)
(*val remove_Gt_Geq : exp -> exp*)
 val remove_Gt_Geq_defn = Hol_defn "remove_Gt_Geq" `

(remove_Gt_Geq (Raise err) = Raise err)
/\
(remove_Gt_Geq (Val v) = Val v)
/\
(remove_Gt_Geq (Con cn es) = Con cn (MAP remove_Gt_Geq es))
/\
(remove_Gt_Geq (Var vn) = Var vn)
/\
(remove_Gt_Geq (Fun vn e) = Fun vn (remove_Gt_Geq e))
/\
(remove_Gt_Geq (App (Opb Gt) e1 e2) = App (Opb Lt) (remove_Gt_Geq e2) (remove_Gt_Geq e1))
/\
(remove_Gt_Geq (App (Opb Geq) e1 e2) = App (Opb Leq) (remove_Gt_Geq e2) (remove_Gt_Geq e1))
/\
(remove_Gt_Geq (App op e1 e2) = App op (remove_Gt_Geq e1) (remove_Gt_Geq e2))
/\
(remove_Gt_Geq (Log lg e1 e2) = Log lg (remove_Gt_Geq e1) (remove_Gt_Geq e2))
/\
(remove_Gt_Geq (If e1 e2 e3) = If (remove_Gt_Geq e1) (remove_Gt_Geq e2) (remove_Gt_Geq e3))
/\
(remove_Gt_Geq (Mat e pes) = Mat (remove_Gt_Geq e) (MAP (\ (p,e) . (p,remove_Gt_Geq e)) pes))
/\
(remove_Gt_Geq (Let vn e b) = Let vn (remove_Gt_Geq e) (remove_Gt_Geq b))
/\
(remove_Gt_Geq (Letrec defs e) = Letrec (MAP (\ (fn,vn,e) .
  (fn,vn,remove_Gt_Geq e)) defs) (remove_Gt_Geq e))
/\
(remove_Gt_Geq (Proj e n) = Proj (remove_Gt_Geq e) n)`;

val _ = Defn.save_defn remove_Gt_Geq_defn;

(* Remove pattern-matching using continuations *)
(* TODO: more efficient method *)
(*val remove_mat : exp -> exp*)

 val remove_mat_vp_defn = Hol_defn "remove_mat_vp" `

(remove_mat_vp v (Pvar pv) =
  Let pv (Var v) (App Opapp (Var "_sk") (Val (Lit (Bool T)))))
/\
(remove_mat_vp v (Plit l) =
  If (App Equality (Var v) (Val (Lit l)))
    (App Opapp (Var "_sk") (Val (Lit (Bool T))))
    (App Opapp (Var "_fk") (Val (Lit (Bool T)))))
/\
(remove_mat_vp v (Pcon NONE ps) = remove_mat_con v 0 ps)
/\
(remove_mat_con v n [] = App Opapp (Var "_sk") (Val (Lit (Bool T))))
/\
(remove_mat_con v n (p::ps) =
  Let "_sk" (Fun "_" (remove_mat_con v (n+1) ps)) (
    Let "_mat" (Proj (Var v) n) (
      remove_mat_vp "_mat" p)))`;

val _ = Defn.save_defn remove_mat_vp_defn;

 val remove_mat_defn = Hol_defn "remove_mat" `

(remove_mat (Mat (Var v) pes) = remove_mat_var v pes)
/\
(remove_mat (Mat e pes) = Let "_mat" e (remove_mat_var "_mat" pes))
/\
(remove_mat e = e)
/\
(remove_mat_var v [] = Raise Bind_error)
/\
(remove_mat_var v ((p,e)::pes) =
  Let "_sk" (Fun "_" (remove_mat e)) (
    Let "_fk" (Fun "_" (remove_mat_var v pes)) (
      remove_mat_vp v p)))`;

val _ = Defn.save_defn remove_mat_defn;

(* Remove all ML data constructors and replace them with untyped tuples with
 * numeric indices *)
(*val remove_ctors : (conN -> int) -> exp -> exp*)

 val pat_remove_ctors_defn = Hol_defn "pat_remove_ctors" `

(pat_remove_ctors cnmap (Pvar vn) = Pvar vn)
/\
(pat_remove_ctors cnmap (Plit l) = Plit l)
/\
(pat_remove_ctors cnmap (Pcon NONE ps) =
  Pcon NONE (MAP (pat_remove_ctors cnmap) ps))
/\
(pat_remove_ctors cnmap (Pcon (SOME cn) ps) =
  Pcon NONE ((Plit (IntLit (cnmap cn))) :: MAP (pat_remove_ctors cnmap) ps))`;

val _ = Defn.save_defn pat_remove_ctors_defn;

 val remove_ctors_defn = Hol_defn "remove_ctors" `

(remove_ctors cnmap (Raise err) = Raise err)
/\
(remove_ctors cnmap (Val v) = Val (v_remove_ctors cnmap v))
/\
(remove_ctors cnmap (Con NONE es) = Con NONE (MAP (remove_ctors cnmap) es))
/\
(remove_ctors cnmap (Con (SOME cn) es) =
  Con NONE (Val (Lit (IntLit (cnmap cn))) :: MAP (remove_ctors cnmap) es))
/\
(remove_ctors cnmap (Var vn) = Var vn)
/\
(remove_ctors cnmap (Fun vn e) = Fun vn (remove_ctors cnmap e))
/\
(remove_ctors cnmap (App op e1 e2) =
  App op (remove_ctors cnmap e1) (remove_ctors cnmap e2))
/\
(remove_ctors cnmap (Log op' e1 e2) =
  Log op' (remove_ctors cnmap e1) (remove_ctors cnmap e2))
/\
(remove_ctors cnmap (If e1 e2 e3) =
  If (remove_ctors cnmap e1) (remove_ctors cnmap e2) (remove_ctors cnmap e3))
/\
(remove_ctors cnmap (Mat e pes) =
  Mat (remove_ctors cnmap e) (match_remove_ctors cnmap pes))
/\
(remove_ctors cnmap (Let vn e1 e2) =
  Let vn (remove_ctors cnmap e1) (remove_ctors cnmap e2))
/\
(remove_ctors cnmap (Letrec funs e) =
  Letrec (funs_remove_ctors cnmap funs) (remove_ctors cnmap e))
/\
(remove_ctors cnmap (Proj e n) = Proj (remove_ctors cnmap e) n)
/\
(v_remove_ctors cnmap (Lit l) = Lit l)
/\
(v_remove_ctors cnmap (Conv NONE vs) =
  Conv NONE (MAP (v_remove_ctors cnmap) vs))
/\
(v_remove_ctors cnmap (Conv (SOME cn) vs) =
  Conv NONE (Lit (IntLit (cnmap cn)) :: MAP (v_remove_ctors cnmap) vs))
/\
(v_remove_ctors cnmap (Closure envE vn e) =
  Closure (env_remove_ctors cnmap envE) vn (remove_ctors cnmap e))
/\
(v_remove_ctors cnmap (Recclosure envE funs vn) =
  Recclosure (env_remove_ctors cnmap envE) (funs_remove_ctors cnmap funs) vn)
/\
(env_remove_ctors cnmap [] = [])
/\
(env_remove_ctors cnmap ((vn,v)::env) =
  ((vn, v_remove_ctors cnmap v)::env_remove_ctors cnmap env))
/\
(funs_remove_ctors cnmap [] = [])
/\
(funs_remove_ctors cnmap ((vn1,vn2,e)::funs) =
  ((vn1,vn2,remove_ctors cnmap e)::funs_remove_ctors cnmap funs))
/\
(match_remove_ctors cnmap [] = [])
/\
(match_remove_ctors cnmap ((p,e)::pes) =
  (pat_remove_ctors cnmap p, remove_ctors cnmap e)::match_remove_ctors cnmap pes)`;

val _ = Defn.save_defn remove_ctors_defn;

(* Constant folding
val fold_consts : exp -> exp

let rec
fold_consts (Raise err) = Raise err
and
fold_consts (Val v) = Val (v_fold_consts v)
and
fold_consts (Con c es) = Con c (List.map fold_consts es)
and
fold_consts (Var vn) = Var vn
and
fold_consts (Fun vn e) = Fun vn (fold_consts e)
and
fold_consts (App (Opn opn) (Val (Lit (IntLit n1))) (Val (Lit (IntLit n2)))) =
  Val (Lit (IntLit (opn_lookup opn n1 n2)))
and
fold_consts (App (Opb opb) (Val (Lit (IntLit n1))) (Val (Lit (IntLit n2)))) =
  Val (Lit (Bool (opb_lookup opb n1 n2)))
and
fold_consts (App Equality (Val (Lit (IntLit n1))) (Val (Lit (IntLit n2)))) =
  Val (Lit (Bool (n1 = n2)))
and
fold_consts (App Equality (Val (Lit (Bool b1))) (Val (Lit (Bool b2)))) =
  Val (Lit (Bool (b1 = b2)))
and
fold_consts (App op e1 e2) =
  let e1' = fold_consts e1 in
  let e2' = fold_consts e2 in
  if e1 = e1' && e2 = e2' then (App op e1 e2) else
  fold_consts (App op e1' e2')
and
fold_consts (Log And (Val (Lit (Bool true))) e2) =
  fold_consts e2
and
fold_consts (Log Or (Val (Lit (Bool false))) e2) =
  fold_consts e2
and
fold_consts (Log _ (Val (Lit (Bool b))) _) =
  Val (Lit (Bool b))
and
fold_consts (Log log e1 e2) =
  Log log (fold_consts e1) (fold_consts e2)
and
fold_consts (If (Val (Lit (Bool b))) e2 e3) =
  if b then fold_consts e2 else fold_consts e3
and
fold_consts (If e1 e2 e3) =
  If (fold_consts e1) (fold_consts e2) (fold_consts e3)
and
fold_consts (Mat (Val v) pes) =
  fold_match v pes
and
fold_consts (Mat e pes) =
  Mat (fold_consts e) (match_fold_consts pes)
and
fold_consts (Let vn e1 e2) =
  Let vn (fold_consts e1) (fold_consts e2)
and
fold_consts (Letrec funs e) =
  Letrec (funs_fold_consts funs) (fold_consts e)
and
fold_consts (Proj (Val (Conv None vs)) n) =
  Val (List.nth vs n)
and
fold_consts (Proj e n) = Proj (fold_consts e) n
and
v_fold_consts (Lit l) = Lit l
and
v_fold_consts (Conv None vs) =
  Conv None (List.map v_fold_consts vs)
and
v_fold_consts (Closure envE vn e) =
  Closure (env_fold_consts envE) vn (fold_consts e)
and
v_fold_consts (Recclosure envE funs vn) =
  Recclosure (env_fold_consts envE) (funs_fold_consts funs) vn
and
env_fold_consts [] = []
and
env_fold_consts ((vn,v)::env) =
  ((vn, v_fold_consts v)::env_fold_consts env)
and
funs_fold_consts [] = []
and
funs_fold_consts ((vn1,vn2,e)::funs) =
  ((vn1,vn2,fold_consts e)::funs_fold_consts funs)
and
match_fold_consts [] = []
and
match_fold_consts ((p,e)::pes) =
  (p, fold_consts e)::match_fold_consts pes
and
fold_match v [] = Raise Bind_error
and
fold_match (Lit l) ((Plit l',e)::pes) =
  if l = l' then
    fold_consts e
  else
    fold_match (Lit l) pes
and
(* TODO: fold more pattern matching (e.g. to Let)? Need envC? *)
fold_match v pes =
  Mat (Val v) (match_fold_consts pes)
*)
val _ = export_theory()

