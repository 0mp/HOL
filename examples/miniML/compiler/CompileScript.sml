(* generated by Lem from compile.lem *)
open bossLib Theory Parse res_quanTheory
open finite_mapTheory listTheory pairTheory pred_setTheory integerTheory
open set_relationTheory sortingTheory stringTheory wordsTheory

val _ = new_theory "Compile"

open MiniMLTheory

(*open MiniML*)

(* Remove all ML data constructors and replace them with untyped tuples with
 * numeric indices *)
(*val remove_ctors : (conN -> int) -> exp -> exp*)

 val pat_remove_ctors_defn = Hol_defn "pat_remove_ctors" `

(pat_remove_ctors cnmap (Pvar vn) = Pvar vn)
/\
(pat_remove_ctors cnmap (Plit l) = Plit l)
/\
(pat_remove_ctors cnmap (Pcon NONE ps) =
  Pcon NONE (MAP (pat_remove_ctors cnmap) ps))
/\
(pat_remove_ctors cnmap (Pcon (SOME cn) ps) =
  Pcon NONE ((Plit (IntLit (cnmap cn))) :: MAP (pat_remove_ctors cnmap) ps))`;

val _ = Defn.save_defn pat_remove_ctors_defn;

 val remove_ctors_defn = Hol_defn "remove_ctors" `

(remove_ctors cnmap (Raise err) = Raise err)
/\
(remove_ctors cnmap (Val v) = Val (v_remove_ctors cnmap v))
/\
(remove_ctors cnmap (Con NONE es) = Con NONE (MAP (remove_ctors cnmap) es))
/\
(remove_ctors cnmap (Con (SOME cn) es) =
  Con NONE (Val (Lit (IntLit (cnmap cn))) :: MAP (remove_ctors cnmap) es))
/\
(remove_ctors cnmap (Var vn) = Var vn)
/\
(remove_ctors cnmap (Fun vn e) = Fun vn (remove_ctors cnmap e))
/\
(remove_ctors cnmap (App op e1 e2) =
  App op (remove_ctors cnmap e1) (remove_ctors cnmap e2))
/\
(remove_ctors cnmap (Log op' e1 e2) =
  Log op' (remove_ctors cnmap e1) (remove_ctors cnmap e2))
/\
(remove_ctors cnmap (If e1 e2 e3) =
  If (remove_ctors cnmap e1) (remove_ctors cnmap e2) (remove_ctors cnmap e3))
/\
(remove_ctors cnmap (Mat e pes) =
  Mat (remove_ctors cnmap e) (match_remove_ctors cnmap pes))
/\
(remove_ctors cnmap (Let vn e1 e2) =
  Let vn (remove_ctors cnmap e1) (remove_ctors cnmap e2))
/\
(remove_ctors cnmap (Letrec funs e) =
  Letrec (funs_remove_ctors cnmap funs) (remove_ctors cnmap e))
/\
(remove_ctors cnmap (Proj e n) = Proj (remove_ctors cnmap e) n)
/\
(v_remove_ctors cnmap (Lit l) = Lit l)
/\
(v_remove_ctors cnmap (Conv NONE vs) =
  Conv NONE (MAP (v_remove_ctors cnmap) vs))
/\
(v_remove_ctors cnmap (Conv (SOME cn) vs) =
  Conv NONE (Lit (IntLit (cnmap cn)) :: MAP (v_remove_ctors cnmap) vs))
/\
(v_remove_ctors cnmap (Closure envE vn e) =
  Closure (env_remove_ctors cnmap envE) vn (remove_ctors cnmap e))
/\
(v_remove_ctors cnmap (Recclosure envE funs vn) =
  Recclosure (env_remove_ctors cnmap envE) (funs_remove_ctors cnmap funs) vn)
/\
(env_remove_ctors cnmap [] = [])
/\
(env_remove_ctors cnmap ((vn,v)::env) =
  ((vn, v_remove_ctors cnmap v)::env_remove_ctors cnmap env))
/\
(funs_remove_ctors cnmap [] = [])
/\
(funs_remove_ctors cnmap ((vn1,vn2,e)::funs) =
  ((vn1,vn2,remove_ctors cnmap e)::funs_remove_ctors cnmap funs))
/\
(match_remove_ctors cnmap [] = [])
/\
(match_remove_ctors cnmap ((p,e)::pes) =
  (pat_remove_ctors cnmap p, remove_ctors cnmap e)::match_remove_ctors cnmap pes)`;

val _ = Defn.save_defn remove_ctors_defn;

(* Constant folding *)
(*val fold_consts : exp -> exp*)

 val fold_consts_defn = Hol_defn "fold_consts" `

(fold_consts (Raise err) = Raise err)
/\
(fold_consts (Val v) = Val (v_fold_consts v))
/\
(fold_consts (Con c es) = Con c (MAP fold_consts es))
/\
(fold_consts (Var vn) = Var vn)
/\
(fold_consts (Fun vn e) = Fun vn (fold_consts e))
/\
(fold_consts (App (Opn opn) (Val (Lit (IntLit n1))) (Val (Lit (IntLit n2)))) =
  Val (Lit (IntLit (opn_lookup opn n1 n2))))
/\
(fold_consts (App (Opb opb) (Val (Lit (IntLit n1))) (Val (Lit (IntLit n2)))) =
  Val (Lit (Bool (opb_lookup opb n1 n2))))
/\
(fold_consts (App Equality (Val (Lit (IntLit n1))) (Val (Lit (IntLit n2)))) =
  Val (Lit (Bool (n1 = n2))))
/\
(fold_consts (App Equality (Val (Lit (Bool b1))) (Val (Lit (Bool b2)))) =
  Val (Lit (Bool (b1 = b2))))
/\
(fold_consts (App op e1 e2) =
  let e1' = fold_consts e1 in
  let e2' = fold_consts e2 in
  if (e1 = e1') /\ (e2 = e2') then (App op e1 e2) else
  fold_consts (App op e1' e2'))
/\
(fold_consts (Log And (Val (Lit (Bool T))) e2) =
  fold_consts e2)
/\
(fold_consts (Log Or (Val (Lit (Bool F))) e2) =
  fold_consts e2)
/\
(fold_consts (Log _ (Val (Lit (Bool b))) _) =
  Val (Lit (Bool b)))
/\
(fold_consts (Log log e1 e2) =
  Log log (fold_consts e1) (fold_consts e2))
/\
(fold_consts (If (Val (Lit (Bool b))) e2 e3) =
  if b then fold_consts e2 else fold_consts e3)
/\
(fold_consts (If e1 e2 e3) =
  If (fold_consts e1) (fold_consts e2) (fold_consts e3))
/\
(fold_consts (Mat (Val v) pes) =
  fold_match v pes)
/\
(fold_consts (Mat e pes) =
  Mat (fold_consts e) (match_fold_consts pes))
/\
(fold_consts (Let vn e1 e2) =
  Let vn (fold_consts e1) (fold_consts e2))
/\
(fold_consts (Letrec funs e) =
  Letrec (funs_fold_consts funs) (fold_consts e))
/\
(fold_consts (Proj (Val (Conv NONE vs)) n) =
  Val (EL  n  vs))
/\
(fold_consts (Proj e n) = Proj (fold_consts e) n)
/\
(v_fold_consts (Lit l) = Lit l)
/\
(v_fold_consts (Conv NONE vs) =
  Conv NONE (MAP v_fold_consts vs))
/\
(v_fold_consts (Closure envE vn e) =
  Closure (env_fold_consts envE) vn (fold_consts e))
/\
(v_fold_consts (Recclosure envE funs vn) =
  Recclosure (env_fold_consts envE) (funs_fold_consts funs) vn)
/\
(env_fold_consts [] = [])
/\
(env_fold_consts ((vn,v)::env) =
  ((vn, v_fold_consts v)::env_fold_consts env))
/\
(funs_fold_consts [] = [])
/\
(funs_fold_consts ((vn1,vn2,e)::funs) =
  ((vn1,vn2,fold_consts e)::funs_fold_consts funs))
/\
(match_fold_consts [] = [])
/\
(match_fold_consts ((p,e)::pes) =
  (p, fold_consts e)::match_fold_consts pes)
/\
(fold_match v [] = Raise Bind_error)
/\
(fold_match (Lit l) ((Plit l',e)::pes) =
  if l = l' then
    fold_consts e
  else
    fold_match (Lit l) pes)
/\
(* TODO: fold more pattern matching (e.g. to Let)? Need envC? *)
(fold_match v pes =
  Mat (Val v) (match_fold_consts pes))`;

val _ = Defn.save_defn fold_consts_defn;
val _ = export_theory()

