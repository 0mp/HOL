open MiniML

(* Intermediate language for MiniML compiler *)

(* Syntax *)

(* applicative primitives with bytecode counterparts *)
type Cprim2 = CAdd | CSub | CMult | CDiv | CMod | CLt | CEq
(* other primitives *)
type Clprim = CLeq | CIf | CAnd | COr

type Cpat =
  | CPvar of num
  | CPlit of lit
  | CPcon of num * Cpat list

type Cexp =
  | CRaise of error
  | CVar of num
  | CLit of lit
  | CCon of num * Cexp list
  | CTagEq of Cexp * num
  | CProj of Cexp * num
  | CMat of num * (Cpat * Cexp) list
  | CLet of num list * Cexp list * Cexp
  | CLetfun of bool * num list * (num list * Cexp) list * Cexp
  | CFun of num list * Cexp
  | CCall of Cexp * Cexp list
  | CPrim2 of Cprim2 * Cexp * Cexp
  | CLprim of Clprim * Cexp list

(* TODO: move to lem? *)
val range : forall 'a 'b. ('a,'b) Pmap.map -> 'b set
sub [hol] range = FRANGE
val least : (num -> bool) -> num
sub [hol] least = (LEAST)
val replace : forall 'a. 'a -> num -> 'a list -> 'a list
sub [hol] replace = REPLACE_ELEMENT
val num_set_foldl : forall 'a. ('a -> num -> 'a) -> 'a -> num set -> 'a
sub [hol] num_set_foldl = num_set_foldl
val int_to_num : int -> num
sub [hol] int_to_num = Num

let rec
remove_mat_exp (Mat (Var v) pes) =
  let pes = List.fold_right (fun (p,e) pes -> (p, remove_mat_exp e)::pes) pes [] in
  Mat (Var v) pes
and
remove_mat_exp (Mat e pes) =
  let pes = List.fold_right (fun (p,e) pes -> (p, remove_mat_exp e)::pes) pes [] in
  Let "" e (Mat (Var "") pes)
and
remove_mat_exp (Raise err) = Raise err
and
remove_mat_exp (Val u) = Val u
and
remove_mat_exp (Con cn es) = Con cn (List.map remove_mat_exp es)
and
remove_mat_exp (Var v) = Var v
and
remove_mat_exp (Fun v e) = Fun v (remove_mat_exp e)
and
remove_mat_exp (App op e1 e2) = App op (remove_mat_exp e1) (remove_mat_exp e2)
and
remove_mat_exp (Log lg e1 e2) = Log lg (remove_mat_exp e1) (remove_mat_exp e2)
and
remove_mat_exp (If e1 e2 e3) = If (remove_mat_exp e1) (remove_mat_exp e2) (remove_mat_exp e3)
and
remove_mat_exp (Let v e1 e2) = Let v (remove_mat_exp e1) (remove_mat_exp e2)
and
remove_mat_exp (Letrec defs e) =
  Letrec
    (List.map (fun (v1,v2,e) -> (v1,v2,remove_mat_exp e)) defs)
    (remove_mat_exp e)

let rec
remove_Gt_Geq (Raise err) = Raise err
and
remove_Gt_Geq (Val v) = Val v
and
remove_Gt_Geq (Con cn es) = Con cn (List.map remove_Gt_Geq es)
and
remove_Gt_Geq (Var vn) = Var vn
and
remove_Gt_Geq (Fun vn e) = Fun vn (remove_Gt_Geq e)
and
remove_Gt_Geq (App (Opb Gt) e1 e2) = App (Opb Lt) (remove_Gt_Geq e2) (remove_Gt_Geq e1)
and
remove_Gt_Geq (App (Opb Geq) e1 e2) = App (Opb Leq) (remove_Gt_Geq e2) (remove_Gt_Geq e1)
and
remove_Gt_Geq (App op e1 e2) = App op (remove_Gt_Geq e1) (remove_Gt_Geq e2)
and
remove_Gt_Geq (Log lg e1 e2) = Log lg (remove_Gt_Geq e1) (remove_Gt_Geq e2)
and
remove_Gt_Geq (If e1 e2 e3) = If (remove_Gt_Geq e1) (remove_Gt_Geq e2) (remove_Gt_Geq e3)
and
remove_Gt_Geq (Mat e pes) = Mat (remove_Gt_Geq e) (List.map (fun (p,e) -> (p,remove_Gt_Geq e)) pes)
and
remove_Gt_Geq (Let vn e b) = Let vn (remove_Gt_Geq e) (remove_Gt_Geq b)
and
remove_Gt_Geq (Letrec defs e) = Letrec (List.map (fun (fn,vn,e) ->
  (fn,vn,remove_Gt_Geq e)) defs) (remove_Gt_Geq e)

let least_not_in s = least (fun n -> not (n IN s))

type exp_to_Cexp_state =
  <| m : (string,num) Pmap.map
   ; w : (num,string) Pmap.map
   ; n : num
   |>

let extend s vn =
  let m' = Pmap.add vn s.n s.m in
  let w' = Pmap.add s.n vn s.w in
  <| s with m = m'; w = w'; n = s.n+1 |>

let rec
pat_to_Cpat cm (s, Pvar vn) =
  let s' = extend s vn in (s', CPvar s.n)
and
pat_to_Cpat cm (s, Plit l) = (s, CPlit l)
and
pat_to_Cpat cm (s, Pcon cn ps) =
  let (s',ps) = List.fold_right
    (fun p (s,ps) -> let (s',p) = pat_to_Cpat cm (s,p) in (s',p::ps))
         ps (s,[]) in
  (s', CPcon (Pmap.find cn cm) ps)

let rec
exp_to_Cexp d cm (s, Raise err) = (s, CRaise err)
and
exp_to_Cexp d cm (s, Val (Lit l)) = (s, CLit l)
and
exp_to_Cexp d cm (s, Con cn es) =
  (s, CCon (Pmap.find cn cm) (List.map (fun e -> let (_s,e) = exp_to_Cexp false cm (s,e) in e) es))
and
exp_to_Cexp d cm (s, Var vn) = (s, CVar (if d then 0 else Pmap.find vn s.m))
and
exp_to_Cexp d cm (s, Fun vn e) =
  let s' = extend s vn in
  let (s',Ce) = exp_to_Cexp false cm (s', e) in
  (s, CFun [s.n] Ce)
and
exp_to_Cexp d cm (s, App (Opn opn) e1 e2) =
  let (_s,Ce1) = exp_to_Cexp false cm (s, e1) in
  let (_s,Ce2) = exp_to_Cexp false cm (s, e2) in
  (s, CPrim2 (match opn with
              | Plus   -> CAdd
              | Minus  -> CSub
              | Times  -> CMult
              | Divide -> CDiv
              | Modulo -> CMod
              end)
      Ce1 Ce2)
and
exp_to_Cexp d cm (s, App (Opb opb) e1 e2) =
  let (_s,Ce1) = exp_to_Cexp false cm (s, e1) in
  let (_s,Ce2) = exp_to_Cexp false cm (s, e2) in
  (s, match opb with
      | Lt -> CPrim2 CLt Ce1 Ce2
      | Leq -> CLprim CLeq [Ce1;Ce2]
      end)
and
exp_to_Cexp d cm (s, App Equality e1 e2) =
  let (_s,Ce1) = exp_to_Cexp false cm (s, e1) in
  let (_s,Ce2) = exp_to_Cexp false cm (s, e2) in
  (s, CPrim2 CEq Ce1 Ce2)
and
exp_to_Cexp d cm (s, App Opapp e1 e2) =
  let (_s,Ce1) = exp_to_Cexp false cm (s, e1) in
  let (_s,Ce2) = exp_to_Cexp false cm (s, e2) in
  (s, CCall Ce1 [Ce2])
and
exp_to_Cexp d cm (s, Log log e1 e2) =
  let (_s,Ce1) = exp_to_Cexp false cm (s, e1) in
  let (_s,Ce2) = exp_to_Cexp false cm (s, e2) in
  (s, CLprim (match log with
              | And -> CAnd
              | Or  -> COr
              end)
      [Ce1;Ce2])
and
exp_to_Cexp d cm (s, If e1 e2 e3) =
  let (_s,Ce1) = exp_to_Cexp false cm (s, e1) in
  let (_s,Ce2) = exp_to_Cexp d cm (s, e2) in
  let (_s,Ce3) = exp_to_Cexp d cm (s, e3) in
  (s, CLprim CIf [Ce1;Ce2;Ce3])
and
exp_to_Cexp d cm (s, Mat (Var vn) pes) =
  let Cpes = List.fold_right
    (fun (p,e) Cpes -> let (s,Cp) = pat_to_Cpat cm (s,p) in
                       let (_s,Ce) = exp_to_Cexp d cm (s,e) in
                       (Cp,Ce)::Cpes)
          pes  [] in
  (s, CMat (Pmap.find vn s.m) Cpes)
and
exp_to_Cexp d cm (s, Let vn e b) =
  let s' = extend s vn in
  let (_s,Ce) = exp_to_Cexp false cm (s, e) in
  let (_s,Cb) = exp_to_Cexp d cm (s', b) in
  (if d then s' else s, CLet [s.n] [Ce] Cb)
and
exp_to_Cexp d cm (s, Letrec defs b) =
  let (s',fns) = List.fold_right
    (fun (d,_vn,_e) (s,fns) -> (extend s d, s.n::fns))
          defs      (s,[]) in
  let Cdefs = List.fold_right
    (fun (_d,vn,e) Cdefs ->
      let (_s,Ce) = exp_to_Cexp false cm (extend s' vn, e) in
      ([s'.n],Ce)::Cdefs)
          defs     [] in
  let (_s,Cb) = exp_to_Cexp d cm (s',b) in
  (if d then s' else s, CLetfun true fns Cdefs Cb)

(* TODO: semantics *)
(* TODO: simple type system and checker *)

let rec
free_vars (CRaise _) = {}
and
free_vars (CVar n) = {n}
and
free_vars (CLit _) = {}
and
free_vars (CCon _ es) =
  List.fold_left (fun s e -> s union free_vars e) {} es
and
free_vars (CTagEq e _) = free_vars e
and
free_vars (CProj e _) = free_vars e
and
free_vars (CMat v pes) =
  List.fold_left (fun s (p,e) -> s union free_vars e) {v} pes
and
free_vars (CLet xs es e) =
  List.fold_left (fun s e -> s union free_vars e)
  (free_vars e \ Set.from_list xs) es
and
free_vars (CLetfun true ns defs e) =
  List.fold_left (fun s (vs,e) ->
    s union (free_vars e \ (Set.from_list ns union
                            Set.from_list vs)))
  (free_vars e \ Set.from_list ns) defs
and
free_vars (CLetfun false ns defs e) =
  List.fold_left (fun s (vs,e) ->
    s union (free_vars e \ Set.from_list vs))
  (free_vars e \ Set.from_list ns) defs
and
free_vars (CFun xs e) = free_vars e \ (Set.from_list xs)
and
free_vars (CCall e es) =
  List.fold_left (fun s e -> s union free_vars e)
  (free_vars e) es
and
free_vars (CPrim2 _ e1 e2) = free_vars e1 union free_vars e2
and
free_vars (CLprim _ es) =
  List.fold_left (fun s e -> s union free_vars e) {} es

(* Remove pattern-matching using continuations *)
(* TODO: more efficient method *)
val remove_mat : Cexp -> Cexp

let rec
remove_mat_vp fk sk v (CPvar pv) =
  CLet [pv] [CVar v] sk
and
remove_mat_vp fk sk v (CPlit l) =
  CLprim CIf [CPrim2 CEq (CVar v) (CLit l);
    sk; (CCall (CVar fk) [])]
and
remove_mat_vp fk sk v (CPcon cn ps) =
  CLprim CIf [CTagEq (CVar v) cn;
    remove_mat_con fk sk v 0 ps;
    CCall (CVar fk) []]
and
remove_mat_con fk sk v n [] = sk
and
remove_mat_con fk sk v n (p::ps) =
  let v' = least_not_in (Set.add v (free_vars sk)) in
  CLet [v'] [CProj (CVar v) n]
    (remove_mat_vp fk (remove_mat_con fk sk v (n+1) ps) v' p)

let rec
remove_mat (CMat v pes) = remove_mat_var v pes
and
remove_mat (CRaise err) = CRaise err
and
remove_mat (CVar n) = CVar n
and
remove_mat (CLit l) = CLit l
and
remove_mat (CCon n es) = CCon n (List.map remove_mat es)
and
remove_mat (CTagEq e n) = CTagEq (remove_mat e) n
and
remove_mat (CProj e n) = CProj (remove_mat e) n
and
remove_mat (CLet xs es e) = CLet xs (List.map remove_mat es) (remove_mat e)
and
remove_mat (CLetfun b ns defs e) = CLetfun b ns (List.map (fun (vs,e) -> (vs,remove_mat e)) defs) (remove_mat e)
and
remove_mat (CFun ns e) = CFun ns (remove_mat e)
and
remove_mat (CCall e es) = CCall (remove_mat e) (List.map remove_mat es)
and
remove_mat (CPrim2 o2 e1 e2) = CPrim2 o2 (remove_mat e1) (remove_mat e2)
and
remove_mat (CLprim ol es) = CLprim ol (List.map remove_mat es)
and
remove_mat_var v [] = CRaise Bind_error
and
remove_mat_var v ((p,e)::pes) =
  let sk = remove_mat e in
  let fk = least_not_in (Set.add v (free_vars sk)) in
  CLetfun false [fk] [([],(remove_mat_var v pes))]
    (remove_mat_vp fk sk v p)

(* TODO: make clobbered declarations be replaced on the stack *)
(* TODO: collapse nested functions *)
(* TODO: collapse nested lets *)
(* TODO: Letfun introduction and reordering *)
(* TODO: let floating *)
(* TODO: removal of redundant expressions *)
(* TODO: simplification (e.g., constant folding) *)
(* TODO: registers, register allocation, greedy shuffling? *)
(* TODO: bytecode optimizer: repeated Pops, unreachable code (e.g. after a Jump) *)

(* values in compile-time environment *)
type ctbind = CTLet of num | CTArg of num | CTEnv of num | CTRef of num
(* CTLet n means stack[sz - n]
   CTArg n means stack[sz + n]
   CTEnv n means El n of the environment, which is at stack[sz]
   CTRef n means El n of the environment, but it's a ref pointer *)

open Bytecode

type compiler_state =
  <| env: (num,ctbind) Pmap.map
   ; sz: num
   ; code: bc_inst list (* reversed *)
   ; tail: (num * num) option
   ; next_label: num
   (* not modified on return: *)
   ; decl: bool
   ; inst_length: bc_inst -> num
   |>

let i0 = num_to_int 0
let i1 = num_to_int 1
let i2 = num_to_int 2

let rec
error_to_int Bind_error = i0
and
error_to_int Div_error = i1

let rec
prim2_to_bc CAdd = Add
and
prim2_to_bc CSub = Sub
and
prim2_to_bc CMult = Mult
and
prim2_to_bc CDiv = Div2 (* TODO *)
and
prim2_to_bc CMod = Mod2 (* TODO *)
and
prim2_to_bc CLt = Less
and
prim2_to_bc CEq = Equal

let emit = List.fold_left
  (fun s i -> <| s with next_label = s.next_label + s.inst_length i + 1;
                        code = i :: s.code |>)

let rec
compile_varref s (CTLet n) = emit s [Stack (Load (s.sz - n))]
and
compile_varref s (CTArg n) = emit s [Stack (Load (s.sz + n))]
and
compile_varref s (CTEnv n) = emit s [Stack (Load s.sz); Stack (El n)]
and
compile_varref s (CTRef n) = emit (compile_varref s (CTEnv n)) [Deref]

let incsz s = <| s with sz = s.sz + 1 |>
let decsz s = <| s with sz = s.sz - 1 |>
let sdt s = (<| s with decl = false ; tail = None |>, (s.decl, s.tail))
let ldt (d,t) s = <| s with decl = d ; tail = t |>

(* TODO: elsewhere? *)
let rec
find_index y [] _ = None
and
find_index y (x::xs) (n:num) = if x = y then Some n else find_index y xs (n+1)

(* helper for reconstructing closure environments *)
type cebind = CEEnv of num | CERef of num

let rec
emit_ec (CEEnv fv) s = incsz (compile_varref s (Pmap.find fv s.env))
and
emit_ec (CERef j) s = incsz (emit s [Stack (Load (s.sz - j))])

let rec
replace_calls j [_] c = c
and
replace_calls j ((_,lab)::(jl,l)::ls) c =
  replace_calls j ((jl,l)::ls)
    (replace (Call lab) (j - jl) c)

let rec
compile s (CRaise err) =
  incsz (emit s [Stack (PushInt (error_to_int err)); Exception])
and
compile s (CLit (IntLit i)) =
  incsz (emit s [Stack (PushInt i)])
and
compile s (CLit (Bool b)) =
  incsz (emit s [Stack (PushInt (bool_to_int b))])
and
compile s (CVar n) =
  if s.decl then s else
  incsz (compile_varref s (Pmap.find n s.env))
and
compile s (CCon n []) =
  incsz (emit s [Stack (PushInt (num_to_int n))])
and
compile s (CCon n es) =
  let z = s.sz + 1 in
  let (s,dt) = sdt s in
  let s = List.fold_left (fun s e -> compile s e) s es in (* uneta because Hol_defn sucks *)
  let s = emit (ldt dt s) [Stack (Cons n (List.length es))] in
  <| s with sz = z |>
and
compile s (CTagEq e n) =
  let (s,dt) = sdt s in
  ldt dt (emit (compile s e) [Stack (TagEquals n)])
and
compile s (CProj e n) =
  let (s,dt) = sdt s in
  ldt dt (emit (compile s e) [Stack (El n)])
and
compile s (CMat _ _) =
  incsz (emit s [Stack (PushInt i2); Exception])
and
compile s (CLet xs es e) =
  let z = s.sz + 1 in
  let (s,dt) = sdt s in
  let s = List.fold_left (fun s e -> compile s e) s es in (* uneta because Hol_defn sucks *)
  compile_bindings s.env z e 0 (ldt dt s) xs
and
compile s (CLetfun recp ns defs e) =
  let z = s.sz + 1 in
  let s = compile_closures (if recp then Some ns else None) s defs in
  compile_bindings s.env z e 0 s ns
and
compile s (CFun xs e) =
  compile_closures None s [(xs,e)]
and
compile s (CCall e es) =
  let n = List.length es in
  let (s,dt) = sdt s in
  let s = compile s e in
  let s = List.fold_left (fun s e -> compile s e) s es in (* uneta because Hol_defn sucks *)
  (* argn, ..., arg2, arg1, Block 0 [CodePtr c; env], *)
(*
  match s.tail with
  | None ->
*)
    let s = emit s [Stack (Load n); Stack (El 1)] in
    (* env, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    let s = emit s [Stack (Load (n+1)); Stack (El 0)] in
    (* CodePtr c, env, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    let s = emit s [CallPtr] in
    (* before: env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    (* after:  retval, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    (* TODO: want callee to clean up under retval so we can jump for tail calls *)
    let s = emit s [Stack (Pops (n+1))] in
    ldt dt <| s with sz = s.sz - n |>
(*
  | Some (j,k) ->
    (* argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit a s [Stack (Load (n+1+k+1))] in
    (* CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit a s [Stack (Load (n+1)); Stack (El 1)] in
    (* env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit a s [Stack (Load (n+2)); Stack (El 0)] in
    (* CodePtr c, env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
  end
*)
and
compile s (CPrim2 op e1 e2) =
  let (s,dt) = sdt s in
  let s = compile s e1 in
  let s = compile s e2 in
  decsz (ldt dt (emit s [Stack (prim2_to_bc op)]))
and
compile s (CLprim CLeq [e1;e2]) =
  let s = incsz (emit s [Stack (PushInt i1)]) in
  let s = incsz (emit s [Stack (PushInt i0)]) in
  let (s,dt) = sdt s in
  let s = compile s e1 in
  let s = compile s e2 in
  let s = emit s [Stack Sub; Stack Less; Stack Sub] in
  ldt dt <| s with sz = s.sz - 3 |>
and
compile s (CLprim CIf [e1;e2;e3]) =
  let (s,dt) = sdt s in
  let s = ldt dt (compile s e1) in
  let s = emit s [JumpNil 0; Jump 0] in
  let j1 = List.length s.code in
  let n1 = s.next_label in
  let s = compile (decsz s) e2 in
  let s = emit s [Jump 0] in
  let j2 = List.length s.code in
  let n2 = s.next_label in
  let s = compile (decsz s) e3 in
  let n3 = s.next_label in
  let j3 = List.length s.code in
  <| s with code =
      (replace (Jump n3) (j3 - j2)
      (replace (Jump n2) (j3 - j1)
      (replace (JumpNil n1) (j3 - j1 + 1) s.code))) |>
and
compile s (CLprim CAnd [e1;e2]) =
  let (s,dt) = sdt s in
  let s = compile s e1 in
  let s = emit s [JumpNil 0] in
  let j = List.length s.code in
  let s = ldt dt (compile (decsz s) e2) in
  <| s with code =
      replace (JumpNil s.next_label)
      (List.length s.code - j) s.code |>
and
compile s (CLprim COr [e1;e2]) =
  let (s,dt) = sdt s in
  let s = compile s e1 in
  let s = emit s [JumpNil 0; Stack (PushInt i1); Jump 0] in
  let j = List.length s.code in
  let n1 = s.next_label in
  let s = ldt dt (compile (decsz s) e2) in
  let n2 = s.next_label in
  let j3 = List.length s.code in
  <| s with code =
      (replace (Jump n2) (j3 - j)
      (replace (JumpNil n1) (j3 - j - 2) s.code)) |>
and
compile_bindings env0 sz1 e n s [] =
(*
  match s.tail with
  | None ->
*)
    let s = compile s e in
    if s.decl then s else
    let s = emit s [Stack (Pops n)] in
    <| s with env = env0 ; sz = sz1 |>
(*
  | Some (j,k) ->
    let s = <| s with tail = Some (j,k+n) |> in
    let s = compile s e in
    <| s with env = env0 ; sz = sz1 |>
*)
and
compile_bindings env0 sz1 e n s (x::xs) =
  compile_bindings env0 sz1 e
    (n+1) (* parentheses below because Lem sucks *)
    (<| s with env = Pmap.add x (CTLet (sz1 + n)) s.env |>)
    xs
and
compile_closures nso s defs =
  (* calling convention:
   * before: env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
   * thus, since env = stack[sz], argk should be CTArg (2 + n - k)
   * after:  retval,
       PushInt 0, Ref
       ...            (* create RefPtrs for recursive closures *)
       PushInt 0, Ref                       RefPtr 0, ..., RefPtr 0, rest
       PushInt 0                            0, RefPtr 0, ..., RefPtr 0, rest
       Call L1                              0, CodePtr f1, RefPtr 0, ..., RefPtr 0, rest
       ?
       ...      (* function 1 body *)
       Store 0  (* replace env with return value *)
       Return
   L1: Call L2                              0, CodePtr f2, CodePtr f1, RefPtrs, rest
       ?
       ...      (* function 2 body *)
       Store 0
       Return
   L2: Call L3
       ?
       ...      (* more function bodies *)
   ...
       Return
   LK: Call L
       ...
       Return   (* end of last function *)
   L:  Pop                                  CodePtr fk, ..., CodePtr f1, RefPtrs, rest
       Load ?   (* copy code pointer for function 1 *)
       Load ?   (* copy free mutrec vars for function 1 *)
       Load ?   (* copy free vars for function 1 *)
       ...                                  vm1, ..., v1, RefPtr 0, ..., RefPtr 0, CodePtr f1, CodePtr fk, ..., CodePtr f1, RefPtrs, rest
       Cons 0 (m1 + n1)
       Cons 0 2                             Block 0 [CodePtr f1; Block 0 Env], CodePtr fk, ..., CodePtr f1, RefPtrs, rest
       Store ?                              CodePtr fk, ..., CodePtr f2, f1, RefPtrs, rest
       Load ?   (* copy code pointer for function 2 *)
       Load ?   (* copy free mutrec vars for function k-1 *)
       Load ?   (* copy free vars for function k-1 *)
       ...
       Cons 0 (m2 + n2)
       Cons 0 2                             
       Store ?                              CodePtr fk, ..., CodePtr f3, f2, f1, RefPtrs, rest
       ...                                  fk, ..., f2, f1, RefPtrs, rest
       Load ?
       Load 1                               fk, RefPtr 0, fk, f(k-1), ..., RefPtrs, rest
       Update                               fk, f(k-1), ..., f1, RefPtrs, rest
       Load ?
       Load 2
       Update
       ...      (* update RefPtrs with closures *)
       Store ?  (* pop RefPtrs *)           fk, f(k-1), ..., f1, rest
       ...
  *)
  (*
   * - push refptrs and leading 0
   * - for each function (in order), push a Call 0, remember the next label,
   *   calculate its environment, remember the environment, compile its body in
   *   that environment
   * - update Calls
   * - for each environment emit code to load that
   *   environment and build the closure
   * - update refptrs, etc.
   *)
  let (nr,ns) = match nso with None -> (0,[]) | Some ns -> (List.length ns,ns) end in
  let s = List.fold_left (fun s _n -> incsz (emit s [Stack (PushInt i0); Ref])) s ns in
  let s = emit s [Stack (PushInt i0)] in
  let (s,k,labs,ecs) = List.fold_left
    (fun (s,k,labs,ecs) (xs,e) ->
      let az = List.length xs in
      let lab = s.next_label in
      let s = emit s [Call 0] in
      let j = List.length s.code in
      let fvs = free_vars e in
      let bind_fv (n,env,ec) fv =
        match find_index fv xs 1 with
        | Some j -> (n, Pmap.add fv (CTArg (2 + az - j)) env, ec)
        | None -> match find_index fv ns 0 with
          | None -> (n+1, Pmap.add fv (CTEnv n) env, (CEEnv fv::ec))
          | Some j -> if j = k
                      then (n, Pmap.add fv (CTArg (2 + az)) env, ec)
                      else (n+1, Pmap.add fv (CTRef n) env, (CERef j)::ec)
          end
        end in
      let (n,env,ec) = num_set_foldl bind_fv (0,Pmap.empty,[]) fvs in
      let s' = <| s with env = env; sz = 0; decl = false; tail = Some (az,0) |> in
      let s' = compile s' e in
      let s' = emit s' [Stack (Store 0); Return] in
      let s = <| s' with env = s.env; sz = s.sz + 1; decl = s.decl; tail = s.tail |> in
      (s,k+1,(j,lab)::labs,ec::ecs))
    (s,0,[],[]) defs in
  let s = <| s with code =
    replace_calls (List.length s.code) ((0,s.next_label)::labs) s.code |> in
  let s = emit s [Stack Pop] in
  let nk = List.length defs in
  let (s,k) = List.fold_left
    (fun (s,k) ec ->
      let s = incsz (emit s [Stack (Load (nk - k))]) in
      let s = List.fold_right emit_ec ec s in
      let j = List.length ec in
      let s = emit s [Stack (if j = 0 then PushInt i0 else Cons 0 j)] in
      let s = emit s [Stack (Cons 0 2)] in
      let s = decsz (emit s [Stack (Store (nk - k))]) in
      let s = <| s with sz = s.sz - j |> in
      (s,k+1))
    (s,1) ecs in
  let (s,k) = List.fold_left
    (fun (s,k) _n ->
      let s = emit s [Stack (Load (nk + nk - k))] in
      let s = emit s [Stack (Load (nk + 1 - k))] in
      let s = emit s [Update] in
      (s,k+1))
    (s,1) ns in
  let k = nk - 1 in
  List.fold_left
    (fun s _n -> decsz (emit s [Stack (Store k)]))
         s ns

type nt =
  | NTvar of num
  | NTapp of nt list * typeN
  | NTfn
  | NTnum
  | NTbool

let rec
t_to_nt a (Tvar x) = match find_index x a 0 with Some n -> NTvar n end
and
t_to_nt a (Tapp ts tn) = NTapp (List.map (t_to_nt a) ts) tn
and
t_to_nt a (Tfn _ _) = NTfn
and
t_to_nt a Tnum = NTnum
and
t_to_nt a Tbool = NTbool

type repl_state =
  <| cmap : (conN, num) Pmap.map
   ; cpam : (typeN, (num, conN * nt list) Pmap.map) Pmap.map
   ; vmap : (varN, num) Pmap.map
   ; vpam : (num, varN) Pmap.map
   ; nextv : num
   ; cs : compiler_state
   |>

let init_compiler_state =
  <| env = Pmap.empty
   ; code = []
   ; next_label = 1 (* depends on exception handlers *)
   ; sz = 0
   ; inst_length = fun i -> 0 (* TODO: depends on runtime *)
   ; decl = false
   ; tail = None
   |>

let init_repl_state =
  <| cmap = Pmap.empty
   ; cpam = Pmap.empty
   ; vmap = Pmap.empty
   ; vpam = Pmap.empty
   ; nextv = 0
   ; cs = init_compiler_state
   |>

let compile_exp d rs e =
  let e = remove_Gt_Geq e in
  let e = remove_mat_exp e in
  let (s,Ce) = exp_to_Cexp d rs.cmap (<|m = rs.vmap; w = rs.vpam; n = rs.nextv|>, e) in
  let Ce = remove_mat Ce in
  let cs = compile (<|rs.cs with decl = d|>) Ce in (* parens: Lem sucks *)
  <| rs with vmap = s.m; vpam = s.w; nextv = s.n; cs = cs |>

(* TODO: typechecking *)
(* TODO: printing *)

let rec
number_constructors a (cm,cw) (n:num) [] = (cm,cw)
and
number_constructors a (cm,cw) n ((c,tys)::cs) =
  let cm' = Pmap.add c n cm in
  let cw' = Pmap.add n (c, List.map (t_to_nt a) tys) cw in
  number_constructors a (cm',cw') (n+1) cs

let rec
repl_dec rs (Dtype []) = rs
and
repl_dec rs (Dtype ((a,ty,cs)::ts)) =
  let (cm,cw) = number_constructors a (rs.cmap,Pmap.empty) 0 cs in
  repl_dec (<| rs with cmap = cm; cpam = Pmap.add ty cw rs.cpam |>) (Dtype ts) (* parens: Lem sucks *)
and
repl_dec rs (Dletrec defs) =
  compile_exp true rs (Letrec defs (Var ""))
and
repl_dec rs (Dlet p e) =
  compile_exp true rs (Mat e [(p,Var "")])

let repl_exp = compile_exp false

let lookup_conv_ty m ty n = Pmap.find n (Pmap.find ty m)

let rec
inst_arg tvs (NTvar n) = List.nth tvs n
and
inst_arg tvs (NTapp ts tn) = NTapp (List.map (inst_arg tvs) ts) tn
and
inst_arg tvs tt = tt

let rec
bcv_to_v m (NTnum, Number i) = Lit (IntLit i)
and
bcv_to_v m (NTbool, Number i) =
  if i = bool_to_int true then Lit (Bool true) else
    if i = bool_to_int false then Lit (Bool false) else
      Recclosure [] [] "Fail: Number"
and
bcv_to_v m (NTapp _ ty, Number i) =
  Conv (fst (lookup_conv_ty m ty (int_to_num i))) []
and
bcv_to_v m (_, Number _) = Recclosure [] [] "Fail: Number"
and
bcv_to_v m (NTapp tvs ty, Block n vs) =
  let (tag, args) = lookup_conv_ty m ty n in
  let args = List.map (inst_arg tvs) args in
  if List.length args = List.length vs then
  Conv tag
    (List.map (fun (ty,v) -> bcv_to_v m (ty,v)) (List.combine args vs))
    (* can't use map2 because no congruence theorem (for termination) *)
    (* thus this remains uncurried *)
    (* also, uneta: Hol_defn sucks *)
  else Recclosure [] [] "Fail: Block"
and
bcv_to_v m (NTfn, Block 0 _) =Closure [] "" (Var "")
and
bcv_to_v m (_, Block _ _) = Recclosure [] [] "Fail: Block"
and
bcv_to_v m (_, CodePtr _) = Recclosure [] [] "Fail: CodePtr"
and
bcv_to_v m (_, RefPtr _) = Recclosure [] [] "Fail: RefPtr"


(* Constant folding
val fold_consts : exp -> exp

let rec
fold_consts (Raise err) = Raise err
and
fold_consts (Val v) = Val (v_fold_consts v)
and
fold_consts (Con c es) = Con c (List.map fold_consts es)
and
fold_consts (Var vn) = Var vn
and
fold_consts (Fun vn e) = Fun vn (fold_consts e)
and
fold_consts (App (Opn opn) (Val (Lit (IntLit n1))) (Val (Lit (IntLit n2)))) =
  Val (Lit (IntLit (opn_lookup opn n1 n2)))
and
fold_consts (App (Opb opb) (Val (Lit (IntLit n1))) (Val (Lit (IntLit n2)))) =
  Val (Lit (Bool (opb_lookup opb n1 n2)))
and
fold_consts (App Equality (Val (Lit (IntLit n1))) (Val (Lit (IntLit n2)))) =
  Val (Lit (Bool (n1 = n2)))
and
fold_consts (App Equality (Val (Lit (Bool b1))) (Val (Lit (Bool b2)))) =
  Val (Lit (Bool (b1 = b2)))
and
fold_consts (App op e1 e2) =
  let e1' = fold_consts e1 in
  let e2' = fold_consts e2 in
  if e1 = e1' && e2 = e2' then (App op e1 e2) else
  fold_consts (App op e1' e2')
and
fold_consts (Log And (Val (Lit (Bool true))) e2) =
  fold_consts e2
and
fold_consts (Log Or (Val (Lit (Bool false))) e2) =
  fold_consts e2
and
fold_consts (Log _ (Val (Lit (Bool b))) _) =
  Val (Lit (Bool b))
and
fold_consts (Log log e1 e2) =
  Log log (fold_consts e1) (fold_consts e2)
and
fold_consts (If (Val (Lit (Bool b))) e2 e3) =
  if b then fold_consts e2 else fold_consts e3
and
fold_consts (If e1 e2 e3) =
  If (fold_consts e1) (fold_consts e2) (fold_consts e3)
and
fold_consts (Mat (Val v) pes) =
  fold_match v pes
and
fold_consts (Mat e pes) =
  Mat (fold_consts e) (match_fold_consts pes)
and
fold_consts (Let vn e1 e2) =
  Let vn (fold_consts e1) (fold_consts e2)
and
fold_consts (Letrec funs e) =
  Letrec (funs_fold_consts funs) (fold_consts e)
and
fold_consts (Proj (Val (Conv None vs)) n) =
  Val (List.nth vs n)
and
fold_consts (Proj e n) = Proj (fold_consts e) n
and
v_fold_consts (Lit l) = Lit l
and
v_fold_consts (Conv None vs) =
  Conv None (List.map v_fold_consts vs)
and
v_fold_consts (Closure envE vn e) =
  Closure (env_fold_consts envE) vn (fold_consts e)
and
v_fold_consts (Recclosure envE funs vn) =
  Recclosure (env_fold_consts envE) (funs_fold_consts funs) vn
and
env_fold_consts [] = []
and
env_fold_consts ((vn,v)::env) =
  ((vn, v_fold_consts v)::env_fold_consts env)
and
funs_fold_consts [] = []
and
funs_fold_consts ((vn1,vn2,e)::funs) =
  ((vn1,vn2,fold_consts e)::funs_fold_consts funs)
and
match_fold_consts [] = []
and
match_fold_consts ((p,e)::pes) =
  (p, fold_consts e)::match_fold_consts pes
and
fold_match v [] = Raise Bind_error
and
fold_match (Lit l) ((Plit l',e)::pes) =
  if l = l' then
    fold_consts e
  else
    fold_match (Lit l) pes
and
(* TODO: fold more pattern matching (e.g. to Let)? Need envC? *)
fold_match v pes =
  Mat (Val v) (match_fold_consts pes)
*)
