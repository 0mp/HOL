open MiniML

(* Remove all ML data constructors and replace them with untyped tuples with
 * numeric indices *)
val remove_ctors : (conN -> num) -> exp -> exp

let rec
pat_remove_ctors cnmap (Pvar vn) = Pvar vn
and
pat_remove_ctors cnmap (Plit l) = Plit l
and
pat_remove_ctors cnmap (Pcon None ps) =
  Pcon None (List.map (pat_remove_ctors cnmap) ps)
and
pat_remove_ctors cnmap (Pcon (Some cn) ps) =
  Pcon None ((Plit (Num (cnmap cn))) :: List.map (pat_remove_ctors cnmap) ps)

let rec
remove_ctors cnmap (Raise err) = Raise err
and
remove_ctors cnmap (Val v) = Val (v_remove_ctors cnmap v)
and
remove_ctors cnmap (Con None es) = Con None (List.map (remove_ctors cnmap) es)
and
remove_ctors cnmap (Con (Some cn) es) =
  Con None (Val (Lit (Num (cnmap cn))) :: List.map (remove_ctors cnmap) es)
and
remove_ctors cnmap (Var vn) = Var vn
and
remove_ctors cnmap (Fun vn e) = Fun vn (remove_ctors cnmap e)
and
remove_ctors cnmap (App op e1 e2) =
  App op (remove_ctors cnmap e1) (remove_ctors cnmap e2)
and
remove_ctors cnmap (Log op' e1 e2) =
  Log op' (remove_ctors cnmap e1) (remove_ctors cnmap e2)
and
remove_ctors cnmap (If e1 e2 e3) =
  If (remove_ctors cnmap e1) (remove_ctors cnmap e2) (remove_ctors cnmap e3)
and
remove_ctors cnmap (Mat e pes) =
  Mat (remove_ctors cnmap e) (match_remove_ctors cnmap pes)
and
remove_ctors cnmap (Let vn e1 e2) =
  Let vn (remove_ctors cnmap e1) (remove_ctors cnmap e2)
and
remove_ctors cnmap (Letrec funs e) =
  Letrec (funs_remove_ctors cnmap funs) (remove_ctors cnmap e)
and
remove_ctors cnmap (Proj e n) = Proj (remove_ctors cnmap e) n
and
v_remove_ctors cnmap (Lit l) = Lit l
and
v_remove_ctors cnmap (Conv None vs) =
  Conv None (List.map (v_remove_ctors cnmap) vs)
and
v_remove_ctors cnmap (Closure envE vn e) =
  Closure (env_remove_ctors cnmap envE) vn (remove_ctors cnmap e)
and
v_remove_ctors cnmap (Recclosure envE funs vn) =
  Recclosure (env_remove_ctors cnmap envE) (funs_remove_ctors cnmap funs) vn
and
env_remove_ctors cnmap [] = []
and
env_remove_ctors cnmap ((vn,v)::env) =
  ((vn, v_remove_ctors cnmap v)::env_remove_ctors cnmap env)
and
funs_remove_ctors cnmap [] = []
and
funs_remove_ctors cnmap ((vn1,vn2,e)::funs) =
  ((vn1,vn2,remove_ctors cnmap e)::funs_remove_ctors cnmap funs)
and
match_remove_ctors cnmap [] = []
and
match_remove_ctors cnmap ((p,e)::pes) =
  (pat_remove_ctors cnmap p, remove_ctors cnmap e)::match_remove_ctors cnmap pes

(* Constant folding *)
val fold_consts : exp -> exp

let rec
fold_consts (Raise err) = Raise err
and
fold_consts (Val v) = Val (v_fold_consts v)
and
fold_consts (Con c es) = Con c (List.map fold_consts es)
and
fold_consts (Var vn) = Var vn
and
fold_consts (Fun vn e) = Fun vn (fold_consts e)
and
fold_consts (App (Opn op) (Val (Lit (Num n1))) (Val (Lit (Num n2)))) =
  Val (Lit (Num (opn_lookup op n1 n2)))
and
fold_consts (App (Opb op) (Val (Lit (Num n1))) (Val (Lit (Num n2)))) =
  Val (Lit (Bool (opb_lookup op n1 n2)))
and
fold_consts (App Equality (Val (Lit (Num n1))) (Val (Lit (Num n2)))) =
  Val (Lit (Bool (n1 = n2)))
and
fold_consts (App Equality (Val (Lit (Bool b1))) (Val (Lit (Bool b2)))) =
  Val (Lit (Bool (b1 = b2)))
and
fold_consts (App op e1 e2) =
  let e1' = fold_consts e1 in
  let e2' = fold_consts e2 in
  if e1 = e1' && e2 = e2' then (App op e1 e2) else
  fold_consts (App op e1' e2')
and
fold_consts (Log And (Val (Lit (Bool true))) e2) =
  fold_consts e2
and
fold_consts (Log Or (Val (Lit (Bool false))) e2) =
  fold_consts e2
and
fold_consts (Log op (Val (Lit (Bool _))) as v _) =
  v
and
fold_consts (Log op e1 e2) =
  Log op (fold_consts e1) (fold_consts e2)
and
fold_consts (If (Val (Lit (Bool b))) e2 e3) =
  if b then fold_consts e2 else fold_consts e3
and
fold_consts (If e1 e2 e3) =
  If (fold_consts e1) (fold_consts e2) (fold_consts e3)
and
fold_consts (Mat (Val v) pes) =
  fold_match v pes
and
fold_consts (Mat e pes) =
  Mat (fold_consts e) (match_fold_consts pes)
and
fold_consts (Let vn e1 e2) =
  Let vn (fold_consts e1) (fold_consts e2)
and
fold_consts (Letrec funs e) =
  Letrec (funs_fold_consts funs) (fold_consts e)
and
fold_consts (Proj (Val (Lit (Conv None vs))) n) =
  Val (List.nth vs n)
and
fold_consts (Proj e n) = Proj (fold_consts e) n
and
v_fold_consts (Lit l) = Lit l
and
v_fold_consts (Conv None vs) =
  Conv None (List.map v_fold_consts vs)
and
v_fold_consts (Closure envE vn e) =
  Closure (env_fold_consts envE) vn (fold_consts e)
and
v_fold_consts (Recclosure envE funs vn) =
  Recclosure (env_fold_consts envE) (funs_fold_consts funs) vn
and
env_fold_consts [] = []
and
env_fold_consts ((vn,v)::env) =
  ((vn, v_fold_consts v)::env_fold_consts env)
and
funs_fold_consts [] = []
and
funs_fold_consts ((vn1,vn2,e)::funs) =
  ((vn1,vn2,fold_consts e)::funs_fold_consts funs)
and
match_fold_consts [] = []
and
match_fold_consts ((p,e)::pes) =
  (p, fold_consts e)::match_fold_consts pes
and
fold_match v [] = Raise Bind_error
and
fold_match (Lit l) as v ((Plit l',e)::pes) =
  if l = l' then
    fold_consts e
  else
    fold_match v pes
and
(* TODO: fold more pattern matching (e.g. to Let)? Need envC? *)
fold_match v pes =
  Mat (Val v) (match_fold_consts pes)
