(* TODO: move to lem *)
val fold_left2 : forall 'a 'b 'c. ('a -> 'b -> 'c -> 'a) -> 'a -> 'b list -> 'c list -> 'a
let inline {hol} fold_left2 f a lb lc =
  (* TODO: LEM internal error:
  List.fold_left (fun a -> Hol.UNCURRY (f a)) a (List.combine lb lc)
  *)
  (* TODO: LEM internal error:
  List.fold_left (fun a (b,c) -> f a b c) a (List.combine lb lc)
  *)
  Hol.FOLDL2 f a lb lc
(* TODO: lem library should use this for List.for_all2 *)
val every2 : forall 'a 'b. ('a -> 'b -> bool) -> 'a list -> 'b list -> bool
let inline {hol} every2 = Hol.EVERY2
val least : (num -> bool) -> num
let inline {hol} least = Hol.LEAST
val num_to_string : num -> string
let inline {hol} num_to_string = Hol.num_to_hex_string
val int_to_num : int -> num
let inline {hol} int_to_num = Hol.Num
val alist_to_fmap : forall 'a 'b. ('a * 'b) list -> ('a,'b) Pmap.map
let inline {hol} alist_to_fmap = Hol.alist_to_fmap
val optrel : forall 'a 'b 'c 'd. ('a -> 'b -> bool) -> 'c -> 'd -> bool
let inline {hol} optrel = Hol.OPTREL
val flookup : forall 'a 'b 'c. ('a,'b) Pmap.map -> 'a -> 'c
let inline {hol} flookup = Hol.FLOOKUP
val genlist : forall 'a. (num -> 'a) -> num -> 'a list
let inline {hol} genlist = Hol.GENLIST

(* TODO: elsewhere? *)
let rec
find_index y [] _ = None
and
find_index y (x::xs) n = if x = y then Some n else find_index y xs (n+1)

let fresh_var s =
  num_to_string (least (fun n -> not (num_to_string n IN s)))

open MiniML

(* TODO: elsewhere? *)
let rec
map_result f (Rval v) = Rval (f v)
and
map_result f (Rerr e) = Rerr e

(* observable values *)

type ov =
  | OLit of lit
  | OConv of conN * ov list
  | OFn

let rec
v_to_ov (Litv l) = OLit l
and
v_to_ov (Conv cn vs) = OConv cn (List.map v_to_ov vs)
and
v_to_ov (Closure _ _ _) = OFn
and
v_to_ov (Recclosure _ _ _) = OFn

(* Intermediate language for MiniML compiler *)

let i0 = Bytecode.int_of_num 0
let i1 = Bytecode.int_of_num 1
let i2 = Bytecode.int_of_num 2

(* Syntax *)

(* applicative primitives with bytecode counterparts *)
type Cprim2 = CAdd | CSub | CMul | CDiv | CMod | CLt | CEq

type Cpat =
  | CPvar of string
  | CPlit of lit
  | CPcon of num * Cpat list

type Cexp =
  | CDecl of string list
  | CRaise of error
  | CVar of string
  | CLit of lit
  | CCon of num * Cexp list
  | CTagEq of Cexp * num
  | CProj of Cexp * num
  | CLet of string list * Cexp list * Cexp
  | CLetfun of bool * string list * (string list * Cexp) list * Cexp
  | CFun of string list * Cexp
  | CCall of Cexp * Cexp list
  | CPrim2 of Cprim2 * Cexp * Cexp
  | CIf of Cexp * Cexp * Cexp

type Cv =
  | CLitv of lit
  | CConv of num * Cv list
  | CRecClos of (string,Cv) Pmap.map * string list * (string list * Cexp) list * string

(* Semantics *)

let rec
Cv_to_ov m (CLitv l) = OLit l
and
Cv_to_ov m (CConv cn vs) = OConv (Pmap.find cn m) (List.map (Cv_to_ov m) vs)
and
Cv_to_ov m (CRecClos _ _ _ _) = OFn

let rec
Cpat_vars (CPvar n) = {n}
and
Cpat_vars (CPlit _) = {}
and
Cpat_vars (CPcon _ ps) = List.fold_left (fun s p -> s union Cpat_vars p) {} ps

let rec
free_vars (CDecl xs) = Set.from_list xs
and
free_vars (CRaise _) = {}
and
free_vars (CVar n) = {n}
and
free_vars (CLit _) = {}
and
free_vars (CCon _ es) =
  List.fold_left (fun s e -> s union free_vars e) {} es
and
free_vars (CTagEq e _) = free_vars e
and
free_vars (CProj e _) = free_vars e
and
free_vars (CLet xs es e) =
  List.fold_left (fun s e -> s union free_vars e)
  (free_vars e \ Set.from_list xs) es
and
free_vars (CLetfun true ns defs e) =
  List.fold_left (fun s (vs,e) ->
    s union (free_vars e \ (Set.from_list ns union
                            Set.from_list vs)))
  (free_vars e \ Set.from_list ns) defs
and
free_vars (CLetfun false ns defs e) =
  List.fold_left (fun s (vs,e) ->
    s union (free_vars e \ Set.from_list vs))
  (free_vars e \ Set.from_list ns) defs
and
free_vars (CFun xs e) = free_vars e \ (Set.from_list xs)
and
free_vars (CCall e es) =
  List.fold_left (fun s e -> s union free_vars e)
  (free_vars e) es
and
free_vars (CPrim2 _ e1 e2) = free_vars e1 union free_vars e2
and
free_vars (CIf e1 e2 e3) = free_vars e1 union free_vars e2 union free_vars e3

(* Big-step semantics *)

let rec
no_closures (CLitv _) = true
and
no_closures (CConv _ vs) = List.for_all no_closures vs
and
no_closures (CRecClos _ _ _ _) = false

let rec
doPrim2 b ty op (CLitv (IntLit x)) (CLitv (IntLit y)) =
  if b && y = i0 then (Rerr (Rraise Div_error))
  else Rval (CLitv (ty (op x y)))
and
doPrim2 b ty op _ _ = Rerr Rtype_error

let rec
CevalPrim2 CAdd = doPrim2 false IntLit Int.(+)
and
CevalPrim2 CSub = doPrim2 false IntLit Int.(-)
and
CevalPrim2 CMul = doPrim2 false IntLit Int.( * )
and
CevalPrim2 CDiv = doPrim2 true IntLit Int.(/)
and
CevalPrim2 CMod = doPrim2 true IntLit Int.(%)
and
CevalPrim2 CLt = doPrim2 false Bool Int.(<)
and
CevalPrim2 CEq = fun v1 v2 ->
  if no_closures v1 && no_closures v2
  then Rval (CLitv (Bool (v1 = v2)))
  else Rerr Rtype_error

let extend_rec_env cenv env rs defs ns vs =
  fold_left2 (fun en n v -> Pmap.add n v en)
    (List.fold_left
        (fun en n -> Pmap.add n
          (CRecClos cenv rs defs n) en)
        env
        rs)
    ns vs

indreln
forall env error.
true
==>
Cevaluate env (CRaise error) (Rerr (Rraise error))

and
forall env n.
Pmap.mem n env
==>
Cevaluate env (CVar n) (Rval (Pmap.find n env))

and
forall env l.
true
==>
Cevaluate env (CLit l) (Rval (CLitv l))

and
forall env n es vs.
Cevaluate_list env es (Rval vs)
==>
Cevaluate env (CCon n es) (Rval (CConv n vs))
and
forall env n es err.
Cevaluate_list env es (Rerr err)
==>
Cevaluate env (CCon n es) (Rerr err)

and
forall env e n m vs.
Cevaluate env e (Rval (CConv m vs))
==>
Cevaluate env (CTagEq e n) (Rval (CLitv (Bool (n = m))))
and
forall env e n err.
Cevaluate env e (Rerr err)
==>
Cevaluate env (CTagEq e n) (Rerr err)

and
forall env e n m vs.
Cevaluate env e (Rval (CConv m vs)) &&
n < List.length vs
==>
Cevaluate env (CProj e n) (Rval (List.nth vs n))
and
forall env e n err.
Cevaluate env e (Rerr err)
==>
Cevaluate env (CProj e n) (Rerr err)

and
forall env b r.
Cevaluate env b r
==>
Cevaluate env (CLet [] [] b) r
and
forall env n ns e es b v r.
Cevaluate env e (Rval v) &&
Cevaluate (Pmap.add n v env) (CLet ns es b) r
==>
Cevaluate env (CLet (n::ns) (e::es) b) r
and
forall env n ns e es b err.
Cevaluate env e (Rerr err)
==>
Cevaluate env (CLet (n::ns) (e::es) b) (Rerr err)

and
forall env ns defs b r.
List.length ns = List.length defs &&
all_distinct ns &&
Cevaluate
  (fold_left2
    (fun env' n (xs,b) ->
      Pmap.add n (CRecClos env [fresh_var (free_vars b)] [(xs,b)]
                               (fresh_var (free_vars b))) env')
    env ns defs)
  b r
==>
Cevaluate env (CLetfun false ns defs b) r

and
forall env ns defs b r.
List.length ns = List.length defs &&
all_distinct ns &&
Cevaluate
  (List.fold_left
     (fun env' n ->
       Pmap.add n (CRecClos env ns defs n) env')
     env ns)
  b r
==>
Cevaluate env (CLetfun true ns defs b) r

and
forall env xs b.
true
==>
Cevaluate env (CFun xs b)
  (Rval (CRecClos env [fresh_var (free_vars b)] [(xs,b)]
                      (fresh_var (free_vars b))))

and
forall env e es env' ns' defs n i ns b vs r.
Cevaluate env e (Rval (CRecClos env' ns' defs n)) &&
List.length ns' = List.length defs &&
all_distinct ns' &&
Cevaluate_list env es (Rval vs) &&
find_index n ns' 0 = Some i &&
List.nth defs i = (ns,b) &&
List.length ns = List.length vs &&
all_distinct ns &&
Cevaluate (extend_rec_env env' env' ns' defs ns vs) b r
==>
Cevaluate env (CCall e es) r
and
forall env e v es err.
Cevaluate env e (Rval v) &&
Cevaluate_list env es (Rerr err)
==>
Cevaluate env (CCall e es) (Rerr err)

and
forall env e es err.
Cevaluate env e (Rerr err)
==>
Cevaluate env (CCall e es) (Rerr err)

and
forall env p2 e1 e2 v1 v2.
Cevaluate_list env [e1;e2] (Rval [v1;v2])
==>
Cevaluate env (CPrim2 p2 e1 e2) (CevalPrim2 p2 v1 v2)
and
forall env p2 e1 e2 err.
Cevaluate_list env [e1;e2] (Rerr err)
==>
Cevaluate env (CPrim2 p2 e1 e2) (Rerr err)

and
forall env e1 e2 e3 b1 r.
Cevaluate env e1 (Rval (CLitv (Bool b1))) &&
Cevaluate env (if b1 then e2 else e3) r
==>
Cevaluate env (CIf e1 e2 e3) r
and
forall env e1 e2 e3 err.
Cevaluate env e1 (Rerr err)
==>
Cevaluate env (CIf e1 e2 e3) (Rerr err)

and
forall env.
true
==>
Cevaluate_list env [] (Rval [])
and
forall env e es v vs.
Cevaluate env e (Rval v) &&
Cevaluate_list env es (Rval vs)
==>
Cevaluate_list env (e::es) (Rval (v::vs))
and
forall env e es err.
Cevaluate env e (Rerr err)
==>
Cevaluate_list env (e::es) (Rerr err)
and
forall env e es v err.
Cevaluate env e (Rval v) &&
Cevaluate_list env es (Rerr err)
==>
Cevaluate_list env (e::es) (Rerr err)

(* equivalence relations on intermediate language *)

indreln
forall l.
true
==>
syneq (CLitv l) (CLitv l)
and
forall cn vs1 vs2.
every2 syneq vs1 vs2
==>
syneq (CConv cn vs1) (CConv cn vs2)
and
forall env1 env2 ns defs d.
List.for_all
  (fun (xs,b) ->
    (forall v. v IN (free_vars b \ (Set.from_list ns union
                                    Set.from_list xs))
      --> (optrel syneq) (flookup env1 v) (flookup env2 v)))
  defs
==>
syneq (CRecClos env1 ns defs d) (CRecClos env2 ns defs d)

(* relating source to intermediate language *)

indreln
forall G cm env Cenv err.
true
==>
exp_Cexp G cm env Cenv (Raise err) (CRaise err)
and
forall G cm env Cenv l.
true
==>
exp_Cexp G cm env Cenv (Lit l) (CLit l)
and
forall G cm env Cenv cn es Ces.
Pmap.mem cn cm &&
every2 (exp_Cexp G cm env Cenv) es Ces
==>
exp_Cexp G cm env Cenv (Con cn es) (CCon (Pmap.find cn cm) Ces)
and
forall G cm env Cenv vn v Cvn.
lookup vn env = Some v &&
Pmap.mem Cvn Cenv &&
G cm v (Pmap.find Cvn Cenv)
==>
exp_Cexp G cm env Cenv (Var vn) (CVar Cvn)
and
forall G cm env Cenv vn e n Ce.
(forall v Cv. G cm v Cv -->
  exp_Cexp G cm (bind vn v env) (Pmap.add n Cv Cenv) e Ce)
==>
exp_Cexp G cm env Cenv (Fun vn e) (CFun [n] Ce)

indreln
forall G cm l.
true
==>
v_Cv G cm (Litv l) (CLitv l)
and
forall G cm cn vs Cvs.
Pmap.mem cn cm &&
every2 (v_Cv G cm) vs Cvs
==>
v_Cv G cm (Conv cn vs) (CConv (Pmap.find cn cm) Cvs)

(*
indreln
forall cm env Cenv err.
true
==>
exp_Cexp cm env Cenv (Raise err) (CRaise err)
and
forall cm env Cenv v Cv.
v_Cv cm v Cv
==>
exp_Cexp cm env Cenv (Val v) (CVal Cv)
and
forall cm env Cenv cn es Ces.
every2 (exp_Cexp cm env Cenv) es Ces
==>
exp_Cexp cm env Cenv (Con cn es) (CCon (Pmap.find cn cm) Ces)
and
forall cm env Cenv vn v Cvn Cv.
lookup vn env = Some v &&
Pmap.mem Cvn Cenv && Pmap.find Cvn Cenv = Cv && (* TODO: lookup *)
v_Cv cm v Cv
==>
exp_Cexp cm env Cenv (Var vn) (CVar Cvn)
and
forall cm env Cenv vn e n Ce.
(* but what to do here without a context of equal variables? *)
(* (see comments in v_Cv below) *)
==>
exp_Cexp cm env Cenv (Fun vn e) (CFun n Ce)
and
forall cm l.
true
==>
v_Cv cm (Lit l) (CLit l)
and
forall cm cn vs Cvs.
every2 (v_Cv cm) vs Cvs
==>
v_Cv cm (Conv cn vs) (CConv (Pmap.find cn cm) Cvs)
and
forall cm env vn e Cenv n Ce.
(* can't do this because it's a negative occurrence of v_Cv,
 * leading to a non-monotonic rule
(forall v Cv. v_Cv cm v Cv -->
 exp_Cexp cm (bind vn v env) (Pmap.add n Cv (alist_to_fmap Cenv)) e Ce)
*)
(* obviously this is incorrect (requires the functions to be equivalent on
 * arbitrary pairs of arguments)
 * options for extension include:
   * normal form (open): use the same free variable as the argument
     * but does this distinguish too many pairs of terms?
   * carry around a context of equal values/variables
     * but how does this relate with the environments in closures?
     * probably just have to have both independently
   * parameterise by a "global knowledge" relation of equal values *)
(forall v Cv. exp_Cexp cm (bind vn v env) (Pmap.add n Cv (alist_to_fmap Cenv)) e Ce)
==>
v_Cv cm (Closure env vn e) (CClosure Cenv [n] Ce)
*)

(*
let rec
Cv_to_bv (CLitv (IntLit i)) = Number i
and
Cv_to_bv (CLitv (Bool b)) = Number (bool_to_int b)
and
Cv_to_bv (CConv n vs) = Block n (Cvs_to_bvs vs)
and
Cv_to_bv (CClosure env vs b) = Block 0 [CodePtr ?, ?]
and
Cv_to_bv (CRecClos env ns defs n) = Block 0 [CodePtr ?, ?]
and
Cvs_to_bvs [] = []
and
Cvs_to_bvs (v::vs) = Cv_to_bv v :: Cvs_to_bvs vs
*)


type nt =
  | NTvar of num
  | NTapp of nt list * typeN
  | NTfn
  | NTnum
  | NTbool

let rec
t_to_nt a (Tvar x) = match find_index x a 0 with Some n -> NTvar n end
and
t_to_nt a (Tapp ts tn) = NTapp (List.map (t_to_nt a) ts) tn
and
t_to_nt a (Tfn _ _) = NTfn
and
t_to_nt a Tnum = NTnum
and
t_to_nt a Tbool = NTbool

(* values in compile-time environment *)
type ctbind = CTLet of num | CTArg of num | CTEnv of num | CTRef of num
(* CTLet n means stack[sz - n]
   CTArg n means stack[sz + n]
   CTEnv n means El n of the environment, which is at stack[sz]
   CTRef n means El n of the environment, but it's a ref pointer *)

open Bytecode

type call_context = TCNonTail | TCTail of num * num

type ctenv = (string,ctbind) Pmap.map

type compiler_state =
  <| env: ctenv
   ; sz: num
   ; out: bc_inst list (* reversed code *)
   ; next_label: num
   ; tail: call_context
   (* not modified on return: *)
   ; decl: (ctenv * num) option
   |>

type repl_state =
  <| cmap : (conN, num) Pmap.map
   ; cpam : (typeN, (num, conN * nt list) Pmap.map) Pmap.map
   ; code : bc_inst list
   ; renv : ctenv
   ; rsz  : num
   ; next_addr : num
   ; inst_length : bc_inst -> num
   |>

let rec
pat_to_Cpat m pvs (Pvar vn) = (vn::pvs, CPvar vn)
and
pat_to_Cpat m pvs (Plit l) = (pvs, CPlit l)
and
pat_to_Cpat m pvs (Pcon cn ps) =
  let (pvs,Cps) = pats_to_Cpats m pvs ps in
  (pvs,CPcon (Pmap.find cn m) Cps)
and
pats_to_Cpats m pvs [] = (pvs,[])
and
pats_to_Cpats m pvs (p::ps) =
  let (pvs,Cps) = pats_to_Cpats m pvs ps in
  let (pvs,Cp) = pat_to_Cpat m pvs p in
  (pvs,Cp::Cps)

let Cpes_vars =
  List.fold_left (fun s (p,e) -> s union Cpat_vars p union free_vars e) {}

(* Remove pattern-matching using continuations *)
(* TODO: more efficient method *)
(* TODO: store type information on CMat nodes *)

let rec
remove_mat_vp fk sk v (CPvar pv) =
  CLet [pv] [CVar v] sk
and
remove_mat_vp fk sk v (CPlit l) =
  CIf (CPrim2 CEq (CVar v) (CLit l))
    sk (CCall (CVar fk) [])
and
remove_mat_vp fk sk v (CPcon cn ps) =
  CIf (CTagEq (CVar v) cn)
    (remove_mat_con fk sk v 0 ps)
    (CCall (CVar fk) [])
and
remove_mat_con fk sk v n [] = sk
and
remove_mat_con fk sk v n (p::ps) =
  let v' = fresh_var ({v;fk} union (free_vars sk) union (Cpat_vars p)) in
  CLet [v'] [CProj (CVar v) n]
    (remove_mat_vp fk (remove_mat_con fk sk v (n+1) ps) v' p)

let rec
remove_mat_var v [] = CRaise Bind_error
and
remove_mat_var v ((p,sk)::pes) =
  let fk = fresh_var ({v} union (free_vars sk) union (Cpat_vars p)) in
  CLetfun false [fk] [([],(remove_mat_var v pes))]
    (remove_mat_vp fk sk v p)

let rec
exp_to_Cexp m (Raise err) = CRaise err
and
exp_to_Cexp m (Lit l) = CLit l
and
exp_to_Cexp m (Con cn es) =
  CCon (Pmap.find cn m) (exps_to_Cexps m es)
and
exp_to_Cexp m (Var vn) = CVar vn
and
exp_to_Cexp m (Fun vn e) =
  CFun [vn] (exp_to_Cexp m e)
and
exp_to_Cexp m (App (Opn opn) e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CPrim2 (match opn with
          | Plus   -> CAdd
          | Minus  -> CSub
          | Times  -> CMul
          | Divide -> CDiv
          | Modulo -> CMod
          end)
  Ce1 Ce2
and
exp_to_Cexp m (App (Opb opb) e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  match opb with
  | Lt -> CPrim2 CLt Ce1 Ce2
  | Leq -> CPrim2 CLt (CPrim2 CSub Ce1 Ce2) (CLit (IntLit i1))
  | opb ->
      let x1 = fresh_var (free_vars Ce2) in
      let x2 = fresh_var {x1} in
      CLet [x1;x2] [Ce1;Ce2]
        match opb with
        | Gt ->  CPrim2 CLt (CVar x2) (CVar x1)
        | Geq -> CPrim2 CLt (CPrim2 CSub (CVar x2) (CVar x1)) (CLit (IntLit i1))
        end
  end
and
exp_to_Cexp m (App Equality e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CPrim2 CEq Ce1 Ce2
and
exp_to_Cexp m (App Opapp e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  CCall Ce1 [Ce2]
and
exp_to_Cexp m (Log log e1 e2) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  (match log with
   | And -> CIf Ce1 Ce2 (CLit (Bool false))
   | Or  -> CIf Ce1 (CLit (Bool true)) Ce2
   end)
and
exp_to_Cexp m (If e1 e2 e3) =
  let Ce1 = exp_to_Cexp m e1 in
  let Ce2 = exp_to_Cexp m e2 in
  let Ce3 = exp_to_Cexp m e3 in
  CIf Ce1 Ce2 Ce3
and
exp_to_Cexp m (Mat e pes) =
  let Cpes = pes_to_Cpes m pes in
  let v = fresh_var (Cpes_vars Cpes) in
  let Ce = exp_to_Cexp m e in
  CLet [v] [Ce] (remove_mat_var v Cpes)
and
exp_to_Cexp m (Let vn e b) =
  let Ce = exp_to_Cexp m e in
  let Cb = exp_to_Cexp m b in
  CLet [vn] [Ce] Cb
and
exp_to_Cexp m (Letrec defs b) =
  let (fns,Cdefs) = defs_to_Cdefs m defs in
  let Cb = exp_to_Cexp m b in
  CLetfun true fns Cdefs Cb
and
defs_to_Cdefs m [] = ([],[])
and
defs_to_Cdefs m ((d,vn,e)::defs) =
  let Ce = exp_to_Cexp m e in
  let (fns,Cdefs) = defs_to_Cdefs m defs in
  (d::fns,([vn],Ce)::Cdefs)
and
pes_to_Cpes m [] = []
and
pes_to_Cpes m ((p,e)::pes) =
  let (_pvs,Cp) = pat_to_Cpat m [] p in
  let Ce = exp_to_Cexp m e in
  let Cpes = pes_to_Cpes m pes in
  (Cp,Ce)::Cpes
and
exps_to_Cexps s [] = []
and
exps_to_Cexps m (e::es) =
  exp_to_Cexp m e :: exps_to_Cexps m es

(* conversions between values in different languages *)

let rec
v_to_Cv m (Litv l) = CLitv l
and
v_to_Cv m (Conv cn vs) =
  CConv (Pmap.find cn m) (vs_to_Cvs m vs)
and
v_to_Cv m (Closure env vn e) =
  let Cenv = alist_to_fmap (env_to_Cenv m env) in
  let Ce = exp_to_Cexp m e in
  let a = fresh_var (free_vars Ce) in
  CRecClos Cenv [a] [([vn],Ce)] a
and
v_to_Cv m (Recclosure env defs vn) =
  let Cenv = alist_to_fmap (env_to_Cenv m env) in
  let (fns,Cdefs) = defs_to_Cdefs m defs in
  CRecClos Cenv fns Cdefs vn
and
vs_to_Cvs m [] = []
and
vs_to_Cvs m (v::vs) = v_to_Cv m v :: vs_to_Cvs m vs
and
env_to_Cenv m [] = []
and
env_to_Cenv m ((x,v)::env) =
  (x, v_to_Cv m v)::(env_to_Cenv m env)

(*
let rec
Cv_to_bv (CLitv (IntLit i)) = Number i
and
Cv_to_bv (CLitv (Bool b)) = Number (bool_to_int b)
and
Cv_to_bv (CConv n vs) = Block n (Cvs_to_bvs vs)
and
Cv_to_bv (CClosure env vs b) = Block 0 [CodePtr ?, ?]
and
Cv_to_bv (CRecClos env ns defs n) = Block 0 [CodePtr ?, ?]
and
Cvs_to_bvs [] = []
and
Cvs_to_bvs (v::vs) = Cv_to_bv v :: Cvs_to_bvs vs
*)

let lookup_conv_ty m ty n = Pmap.find n (Pmap.find ty m)

let rec
inst_arg tvs (NTvar n) = List.nth tvs n
and
inst_arg tvs (NTapp ts tn) = NTapp (List.map (inst_arg tvs) ts) tn
and
inst_arg tvs tt = tt

let rec
num_to_bool 0 = false
and
num_to_bool 1 = true

let rec
bv_to_ov m NTnum (Number i) = OLit (IntLit i)
and
bv_to_ov m NTbool (Number i) = OLit (Bool (num_to_bool (int_to_num i)))
and
bv_to_ov m (NTapp _ ty) (Number i) =
  OConv (fst (lookup_conv_ty m ty (int_to_num i))) []
and
bv_to_ov m (NTapp tvs ty) (Block n vs) =
  let (tag, args) = lookup_conv_ty m ty n in
  let args = List.map (inst_arg tvs) args in
  OConv tag (List.map2 (fun ty v -> bv_to_ov m ty v) args vs) (* uneta: Hol_defn sucks *)
and
bv_to_ov m NTfn (Block 0 _) = OFn


(* TODO: simple type system and checker *)

(* TODO: map_Cexp? *)

(* TODO: use Pmap.peek instead of mem when it becomes available *)
(* TODO: collapse nested functions *)
(* TODO: collapse nested lets *)
(* TODO: Letfun introduction and reordering *)
(* TODO: let floating *)
(* TODO: removal of redundant expressions *)
(* TODO: simplification (e.g., constant folding) *)
(* TODO: avoid Shifts when possible *)
(* TODO: registers, register allocation, greedy shuffling? *)
(* TODO: bytecode optimizer: repeated Pops, unreachable code (e.g. after a Jump) *)

let rec
error_to_int Bind_error = i0
and
error_to_int Div_error = i1

let rec
prim2_to_bc CAdd = Add
and
prim2_to_bc CSub = Sub
and
prim2_to_bc CMul = Mult
and
prim2_to_bc CDiv = Div
and
prim2_to_bc CMod = Mod
and
prim2_to_bc CLt = Less
and
prim2_to_bc CEq = Equal

let emit = List.fold_left (fun s i -> <| s with out = i :: s.out |>)

let rec
get_labels n s = (<| s with next_label = s.next_label + n |>,
                  genlist (fun i -> s.next_label + i) n)
let rec
compile_varref s (CTLet n) = emit s [Stack (Load (s.sz - n))]
and
compile_varref s (CTArg n) = emit s [Stack (Load (s.sz + n))]
and
compile_varref s (CTEnv n) = emit s [Stack (Load s.sz); Stack (El n)]
and
compile_varref s (CTRef n) = emit (compile_varref s (CTEnv n)) [Deref]

let incsz s = <| s with sz = s.sz + 1 |>
let decsz s = <| s with sz = s.sz - 1 |>
let sdt s = (<| s with decl = None; tail = TCNonTail |>, (s.decl,s.tail))
let ldt (d,t) s = <| s with decl = d; tail = t |>

(* helper for reconstructing closure environments *)
type cebind = CEEnv of string | CERef of num

let rec
emit_ec z s (CEEnv fv) = incsz (compile_varref s (Pmap.find fv s.env))
and
emit_ec z s (CERef j) = incsz (emit s [Stack (Load (s.sz - z - j))])

let rec
bind_fv ns xs az k fv (n,env,(ecl,ec)) =
  match find_index fv xs 1 with
  | Some j -> (n, Pmap.add fv (CTArg (2 + az - j)) env, (ecl,ec))
  | None -> match find_index fv ns 0 with
    | None -> (n+1, Pmap.add fv (CTEnv n) env, (ecl+1,CEEnv fv::ec))
    | Some j -> if j = k
                then (n, Pmap.add fv (CTArg (2 + az)) env, (ecl,ec))
                else (n+1, Pmap.add fv (CTRef n) env, (ecl+1,(CERef (j+1))::ec))
    end
  end

let rec
compile s (CDecl vs) =
  match s.decl with Some (env0,sz0) ->
  let sz1 = s.sz in
  let k = sz1 - sz0 in
  let (s,i,env) = List.fold_left
    (fun (s,i,env) v ->
      if Pmap.mem v env0 then
        (match Pmap.find v env0 with
         | CTLet x -> emit (compile_varref s (Pmap.find v s.env))
                           [Stack (Store (s.sz - x))]
         | _ -> emit s [Stack (PushInt i2); Exception] (* should not happen *)
         end, i, env)
      else
        (incsz (compile_varref s (Pmap.find v s.env)),
         i+1,
         Pmap.add v (CTLet i) env))
         (s,sz0+1,env0) vs in
  let s = emit s [Stack (Shift (i-(sz0+1)) k)] in
  <| s with sz = sz1+1; decl = Some (env,s.sz-k) |>
  | None -> emit s [Stack (PushInt i2); Exception] (* should not happen *)
  end
and
compile s (CRaise err) =
  incsz (emit s [Stack (PushInt (error_to_int err)); Exception])
and
compile s (CLit (IntLit i)) =
  incsz (emit s [Stack (PushInt i)])
and
compile s (CLit (Bool b)) =
  incsz (emit s [Stack (PushInt (bool_to_int b))])
and
compile s (CVar vn) = incsz (compile_varref s (Pmap.find vn s.env))
and
compile s (CCon n es) =
  let z = s.sz + 1 in
  let (s,dt) = sdt s in
  let s = List.fold_left (fun s e -> compile s e) s es in (* uneta because Hol_defn sucks *)
  let s = emit (ldt dt s) [Stack (Cons n (List.length es))] in
  <| s with sz = z |>
and
compile s (CTagEq e n) =
  let (s,dt) = sdt s in
  ldt dt (emit (compile s e) [Stack (TagEq n)])
and
compile s (CProj e n) =
  let (s,dt) = sdt s in
  ldt dt (emit (compile s e) [Stack (El n)])
and
compile s (CLet xs es e) =
  let z = s.sz + 1 in
  let (s,dt) = sdt s in
  let s = List.fold_left (fun s e -> compile s e) s es in (* uneta because Hol_defn sucks *)
  compile_bindings s.env z e 0 (ldt dt s) xs
and
compile s (CLetfun recp ns defs e) =
  let z = s.sz + 1 in
  let s = compile_closures (if recp then ns else []) s defs in
  compile_bindings s.env z e 0 s ns
and
compile s (CFun xs e) =
  compile_closures [] s [(xs,e)]
and
compile s (CCall e es) =
  let n = List.length es in
  let t = s.tail in
  let (s,dt) = sdt s in
  let s = match t with
  | TCNonTail ->
    let s = compile s e in
    let s = List.fold_left (fun s e -> compile s e) s es in (* uneta because Hol_defn sucks *)
    (* argn, ..., arg2, arg1, Block 0 [CodePtr c; env], *)
    let s = emit s [Stack (Load n); Stack (El 1)] in
    (* env, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    let s = emit s [Stack (Load (n+1)); Stack (El 0)] in
    (* CodePtr c, env, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    emit s [CallPtr]
    (* before: env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    (* after:  retval, *)
(* does it make sense to distinguish this case?
  | TCTop sz0 ->
    let k = match s.decl with None -> s.sz - sz0 | Some _ -> 0 end in
    let n1 = 1+1+n+1 in
    let (i,s) = pad k n1 s in
    let s = compile s e in
    let s = List.fold_left (fun s e -> compile s e) s es in (* uneta because Hol_defn sucks *)
    (* argn, ..., arg1, Block 0 [CodePtr c; env], 0i, ..., 01, vk, ..., v1, *)
    let s = emit s [Stack (Load n); Stack (El 1)] in
    (* env, argn, ..., arg1, Block 0 [CodePtr c; env], 0i, ..., 01, vk, ..., v1, *)
    let s = emit s [Stack (Load (n+1)); Stack (El 0)] in
    (* CodePtr c, env, argn, ..., arg1, Block 0 [CodePtr c; env], 0i, ..., 01, vk, ..., v1, *)
    let s = mv (k+i) n1 s in
    (* CodePtr c, env, argn, ..., arg1, Block 0 [CodePtr c; env], *)
    emit s [CallPtr]
*)
  | TCTail j k ->
    let s = compile s e in
    let s = List.fold_left (fun s e -> compile s e) s es in (* uneta because Hol_defn sucks *)
    (* argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Load (n+1+k+1))] in
    (* CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Load (n+1)); Stack (El 1)] in
    (* env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Load (n+2)); Stack (El 0)] in
    (* CodePtr c, env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
     * vk, ..., v1, env1, CodePtr ret, argj, ..., arg1, Block 0 [CodePtr c1; env1], *)
    let s = emit s [Stack (Shift (1+1+1+n+1) (k+1+1+j+1))] in
    emit s [JumpPtr]
  end in
  ldt dt <| s with sz = s.sz - n |>
and
compile s (CPrim2 op e1 e2) =
  let (s,dt) = sdt s in
  let s = compile s e1 in
  let s = compile s e2 in (* TODO: need to detect div by zero *)
  decsz (ldt dt (emit s [Stack (prim2_to_bc op)]))
and
compile s (CIf e1 e2 e3) =
  let (s,dt) = sdt s in
  let s = ldt dt (compile s e1) in
  let (s,labs) = get_labels 3 s in
  let n0 = List.nth labs 0 in
  let n1 = List.nth labs 1 in
  let n2 = List.nth labs 2 in
  let s = emit s [(JumpNil (Lab n0)); (Jump (Lab n1)); Label n0] in
  let s = compile (decsz s) e2 in
  let s = emit s [(Jump (Lab n2)); Label n1] in
  let s = compile (decsz s) e3 in
  emit s [Label n2]
and
compile_bindings env0 sz1 e n s [] =
  let s = match s.tail with
  | TCTail j k -> compile (<| s with tail = TCTail j (k+n) |>) e
  | TCNonTail -> match s.decl with
    | None -> emit (compile s e) [Stack (Pops n)]
    | Some _ -> compile s e
    end
  end in
  <| s with env = env0 ; sz = sz1 |>
and
compile_bindings env0 sz1 e n s (x::xs) =
  compile_bindings env0 sz1 e
    (n+1) (* parentheses below because Lem sucks *)
    (<| s with env = Pmap.add x (CTLet (sz1 + n)) s.env |>)
    xs
and
compile_closures ns s defs =
  (* calling convention:
   * before: env, CodePtr ret, argn, ..., arg1, Block 0 [CodePtr c; env],
   * thus, since env = stack[sz], argk should be CTArg (2 + n - k)
   * after:  retval,
       PushInt 0, Ref
       ...            (* create RefPtrs for recursive closures *)
       PushInt 0, Ref                       RefPtr 0, ..., RefPtr 0, rest
       PushInt 0                            0, RefPtr 0, ..., RefPtr 0, rest
       Call L1                              0, CodePtr f1, RefPtr 0, ..., RefPtr 0, rest
       ?
       ...      (* function 1 body *)
       Pops ?   (* delete local variables and env *)
       Load 1
       Store n+2(* replace closure with return pointer *)
       Pops n+1 (* delete arguments *)
       Return
   L1: Call L2                              0, CodePtr f2, CodePtr f1, RefPtrs, rest
       ?
       ...      (* function 2 body *)
       Return
   L2: Call L3
       ?
       ...      (* more function bodies *)
   ...
       Return
   LK: Call L
       ...
       Return   (* end of last function *)
   L:  Pop                                  CodePtr fk, ..., CodePtr f1, RefPtrs, rest
       Load ?   (* copy code pointer for function 1 *)
       Load ?   (* copy free mutrec vars for function 1 *)
       Load ?   (* copy free vars for function 1 *)
       ...                                  vm1, ..., v1, RefPtr 0, ..., RefPtr 0, CodePtr f1, CodePtr fk, ..., CodePtr f1, RefPtrs, rest
       Cons 0 (m1 + n1)
       Cons 0 2                             Block 0 [CodePtr f1; Block 0 Env], CodePtr fk, ..., CodePtr f1, RefPtrs, rest
       Store ?                              CodePtr fk, ..., CodePtr f2, f1, RefPtrs, rest
       Load ?   (* copy code pointer for function 2 *)
       Load ?   (* copy free mutrec vars for function k-1 *)
       Load ?   (* copy free vars for function k-1 *)
       ...
       Cons 0 (m2 + n2)
       Cons 0 2                             
       Store ?                              CodePtr fk, ..., CodePtr f3, f2, f1, RefPtrs, rest
       ...                                  fk, ..., f2, f1, RefPtrs, rest
       Load ?
       Load 1                               fk, RefPtr 0, fk, f(k-1), ..., RefPtrs, rest
       Update                               fk, f(k-1), ..., f1, RefPtrs, rest
       Load ?
       Load 2
       Update
       ...      (* update RefPtrs with closures *)
       Store ?  (* pop RefPtrs *)           fk, f(k-1), ..., f1, rest
       ...
  *)
  (*
   * - push refptrs and leading 0
   * - for each function (in order), push a Call 0, remember the next label,
   *   calculate its environment, remember the environment, compile its body in
   *   that environment
   * - update Calls
   * - for each environment emit code to load that
   *   environment and build the closure
   * - update refptrs, etc.
   *)
  let sz0 = s.sz in
  let s = List.fold_left (fun s _n -> incsz (emit s [Stack (PushInt i0); Ref])) s ns in
  let s = emit s [Stack (PushInt i0)] in
  let nk = List.length defs in
  let (s,labs) = get_labels nk s in
  let (s,k,ecs) = List.fold_left
    (fun (s,k,ecs) (xs,e) ->
      let az = List.length xs in
      let lab = List.nth labs k in
      let s = emit s [(Call (Lab lab))] in
      let (n,env,(ecl,ec)) =
        Set.fold (bind_fv ns xs az k) (free_vars e) (0,Pmap.empty,(0,[])) in
      let s' = <| s with env = env; sz = 0; tail = TCTail az 0 |> in
      let s' = compile s' e in
      let n = match s'.tail with TCNonTail -> 1 | TCTail j k -> k+1 end in
      let s' = emit s' [Stack (Pops n);
                        Stack (Load 1);
                        Stack (Store (az+2));
                        Stack (Pops (az+1));
                        Return;
                        Label lab] in
      let s = <| s' with env = s.env; sz = s.sz + 1; tail = s.tail |> in
      (s,k+1,(ecl,ec)::ecs))
    (s,0,[]) defs in
  let s = emit s [Stack Pop] in
  let (s,k) = List.fold_left
    (fun (s,k) (j,ec) ->
      let s = incsz (emit s [Stack (Load (nk - k))]) in
      let s = List.fold_left (emit_ec sz0) s (List.rev ec) in
      let s = emit s [Stack (if j = 0 then PushInt i0 else Cons 0 j)] in
      let s = emit s [Stack (Cons 0 2)] in
      let s = decsz (emit s [Stack (Store (nk - k))]) in
      let s = <| s with sz = s.sz - j |> in
      (s,k+1))
    (s,1) (List.rev ecs) in
  let (s,k) = List.fold_left
    (fun (s,k) _n ->
      let s = emit s [Stack (Load (nk + nk - k))] in
      let s = emit s [Stack (Load (nk + 1 - k))] in
      let s = emit s [Update] in
      (s,k+1))
    (s,1) ns in
  let k = nk - 1 in
  List.fold_left
    (fun s _n -> decsz (emit s [Stack (Store k)]))
         s ns

let rec
calculate_labels il m n a [] = (m,n,a)
and
calculate_labels il m n a (Label l::lbc) =
  calculate_labels il (Pmap.add l n m) n a lbc
and
calculate_labels il m n a (i::lbc) =
  calculate_labels il m (n + il i + 1) (i::a) lbc

let rec
replace_labels m a [] = a
and
replace_labels m a (Jump (Lab l)::bc) =
  replace_labels m (Jump (Addr (Pmap.find l m))::a) bc
and
replace_labels m a (JumpNil (Lab l)::bc) =
  replace_labels m (JumpNil (Addr (Pmap.find l m))::a) bc
and
replace_labels m a (Call (Lab l)::bc) =
  replace_labels m (Call (Addr (Pmap.find l m))::a) bc
and
replace_labels m a (i::bc) =
  replace_labels m (i::a) bc

let rec
compile_labels rs lbc =
  let (m,n,bc) = calculate_labels rs.inst_length Pmap.empty rs.next_addr [] lbc in
  <| rs with code = replace_labels m [] bc ; next_addr = n |>

indreln
forall il c cc.
true
==>
bc_code_prefix il (List.append c cc) 0 c
and
forall il p i c cc.
bc_code_prefix il cc p c
==>
bc_code_prefix il (i::cc) (p + il i) c

let rec
body_cs env xs =
  <| env = env; sz = 0; out = []; next_label = 0;
     tail = TCTail (List.length xs) 0; decl = None |>

let rec
body_env ns xs j fvs =
  let (n,env,(nec,ec)) =
    Set.fold (bind_fv ns xs (List.length xs) j) fvs (0,Pmap.empty,(0,[])) in
  (env,ec)

indreln
forall il c i.
true
==>
bceqv il c (CLitv (IntLit i)) (Number i)
and
forall il c b.
true
==>
bceqv il c (CLitv (Bool b)) (Number (bool_to_int b))
and
forall il c n vs bvs.
every2 (bceqv il c) vs bvs
==>
bceqv il c (CConv n vs) (Block n bvs)
and
forall il c env ns defs n j xs e cenv ec f bvs.
find_index n ns 0 = Some j &&
List.nth defs j = (xs,e) &&
(cenv,ec) = body_env ns xs j (free_vars e) &&
List.length bvs = List.length ec &&
(forall i. i < List.length ec -->
    (exist fv. List.nth ec i = CEEnv fv &&
               bceqv il c (Pmap.find fv env) (List.nth bvs i)) ||
    (exist k kxs ke kenv kec g.
        List.nth ec i = CERef k &&
        List.nth defs k = (kxs,ke) &&
        (kenv,kec) = body_env ns xs k (free_vars ke) &&
        bc_code_prefix il c g
          (List.rev (compile (body_cs kenv kxs) ke).out))) &&
bc_code_prefix il c f (List.rev (compile (body_cs cenv xs) e).out)
==>
bceqv il c (CRecClos env ns defs n)
  (Block 0 [CodePtr f; if bvs = [] then Number i0 else Block 0 bvs])

let init_repl_state =
  <| cmap = Pmap.empty
   ; cpam = Pmap.empty
   ; code = []
   ; renv = Pmap.empty
   ; rsz  = 0
   ; next_addr = 0
   ; inst_length = fun i -> 0
   |>

let compile_Cexp rs decl Ce =
  let cs = <| env = rs.renv; sz = rs.rsz
            ; out = []; next_label = 0
            ; tail = TCNonTail; decl = decl |> in
  let cs = compile cs Ce in
  let rs = match cs.decl with
    | None -> rs
    | Some (env,sz) -> <| rs with renv = env ; rsz = sz |>
    end in
  compile_labels rs (List.rev cs.out)

(* TODO: typechecking *)
(* TODO: printing *)

let rec
number_constructors a (cm,cw) n [] = (cm,cw)
and
number_constructors a (cm,cw) n ((c,tys)::cs) =
  let cm' = Pmap.add c n cm in
  let cw' = Pmap.add n (c, List.map (t_to_nt a) tys) cw in
  number_constructors a (cm',cw') (n+1) cs

let rec
repl_dec rs (Dtype []) = <| rs with code = [] |>
and
repl_dec rs (Dtype ((a,ty,cs)::ts)) =
  let (cm,cw) = number_constructors a (rs.cmap,Pmap.empty) 0 cs in
  repl_dec (<| rs with cmap = cm; cpam = Pmap.add ty cw rs.cpam |>) (Dtype ts) (* parens: Lem sucks *)
and
repl_dec rs (Dletrec defs) =
  let (fns,Cdefs) = defs_to_Cdefs rs.cmap defs in
  let decl = Some(rs.renv,rs.rsz) in
  compile_Cexp rs decl (CLetfun true fns Cdefs (CDecl fns))
and
repl_dec rs (Dlet p e) =
  let (pvs,Cp) = pat_to_Cpat rs.cmap [] p in
  let Cpes = [(Cp,CDecl pvs)] in
  let vn = fresh_var (Cpes_vars Cpes) in
  let Ce = exp_to_Cexp rs.cmap e in
  let decl = Some(rs.renv,rs.rsz) in
  compile_Cexp rs decl (CLet [vn] [Ce] (remove_mat_var vn Cpes))

let repl_exp s exp = compile_Cexp s None (exp_to_Cexp s.cmap exp)

(* Constant folding
val fold_consts : exp -> exp

let rec
fold_consts (Raise err) = Raise err
and
fold_consts (Val v) = Val (v_fold_consts v)
and
fold_consts (Con c es) = Con c (List.map fold_consts es)
and
fold_consts (Var vn) = Var vn
and
fold_consts (Fun vn e) = Fun vn (fold_consts e)
and
fold_consts (App (Opn opn) (Val (Lit (IntLit n1))) (Val (Lit (IntLit n2)))) =
  Val (Lit (IntLit (opn_lookup opn n1 n2)))
and
fold_consts (App (Opb opb) (Val (Lit (IntLit n1))) (Val (Lit (IntLit n2)))) =
  Val (Lit (Bool (opb_lookup opb n1 n2)))
and
fold_consts (App Equality (Val (Lit (IntLit n1))) (Val (Lit (IntLit n2)))) =
  Val (Lit (Bool (n1 = n2)))
and
fold_consts (App Equality (Val (Lit (Bool b1))) (Val (Lit (Bool b2)))) =
  Val (Lit (Bool (b1 = b2)))
and
fold_consts (App op e1 e2) =
  let e1' = fold_consts e1 in
  let e2' = fold_consts e2 in
  if e1 = e1' && e2 = e2' then (App op e1 e2) else
  fold_consts (App op e1' e2')
and
fold_consts (Log And (Val (Lit (Bool true))) e2) =
  fold_consts e2
and
fold_consts (Log Or (Val (Lit (Bool false))) e2) =
  fold_consts e2
and
fold_consts (Log _ (Val (Lit (Bool b))) _) =
  Val (Lit (Bool b))
and
fold_consts (Log log e1 e2) =
  Log log (fold_consts e1) (fold_consts e2)
and
fold_consts (If (Val (Lit (Bool b))) e2 e3) =
  if b then fold_consts e2 else fold_consts e3
and
fold_consts (If e1 e2 e3) =
  If (fold_consts e1) (fold_consts e2) (fold_consts e3)
and
fold_consts (Mat (Val v) pes) =
  fold_match v pes
and
fold_consts (Mat e pes) =
  Mat (fold_consts e) (match_fold_consts pes)
and
fold_consts (Let vn e1 e2) =
  Let vn (fold_consts e1) (fold_consts e2)
and
fold_consts (Letrec funs e) =
  Letrec (funs_fold_consts funs) (fold_consts e)
and
fold_consts (Proj (Val (Conv None vs)) n) =
  Val (List.nth vs n)
and
fold_consts (Proj e n) = Proj (fold_consts e) n
and
v_fold_consts (Lit l) = Lit l
and
v_fold_consts (Conv None vs) =
  Conv None (List.map v_fold_consts vs)
and
v_fold_consts (Closure envE vn e) =
  Closure (env_fold_consts envE) vn (fold_consts e)
and
v_fold_consts (Recclosure envE funs vn) =
  Recclosure (env_fold_consts envE) (funs_fold_consts funs) vn
and
env_fold_consts [] = []
and
env_fold_consts ((vn,v)::env) =
  ((vn, v_fold_consts v)::env_fold_consts env)
and
funs_fold_consts [] = []
and
funs_fold_consts ((vn1,vn2,e)::funs) =
  ((vn1,vn2,fold_consts e)::funs_fold_consts funs)
and
match_fold_consts [] = []
and
match_fold_consts ((p,e)::pes) =
  (p, fold_consts e)::match_fold_consts pes
and
fold_match v [] = Raise Bind_error
and
fold_match (Lit l) ((Plit l',e)::pes) =
  if l = l' then
    fold_consts e
  else
    fold_match (Lit l) pes
and
(* TODO: fold more pattern matching (e.g. to Let)? Need envC? *)
fold_match v pes =
  Mat (Val v) (match_fold_consts pes)
*)
