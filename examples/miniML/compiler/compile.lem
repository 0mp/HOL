open MiniML

(* Intermediate language for MiniML compiler *)

(* Syntax *)

type Cprimop =
  | CAdd | CSub | CMult | CDiv | CMod
  | CLt | CLeq | CEq | CIf | CAnd | COr

type Cpat =
  | CPvar of num
  | CPlit of lit
  | CPcon of num * Cpat list

type Cexp =
  | CRaise of error
  | CVar of num
  | CLit of lit
  | CCon of num * Cexp list
  | CProj of Cexp * num
  | CMat of num * (Cpat * Cexp) list
  | CLet of (num * Cexp) list * Cexp
  | CLetfun of bool * (num * num list * Cexp) list * Cexp
  | CFun of num list * Cexp
  | CCall of Cexp * Cexp list
  | CPrimCall of Cprimop * Cexp list

(* TODO: move to lem? *)
val range : forall 'a 'b. ('a,'b) Pmap.map -> 'b set
sub [hol] range = FRANGE
val least : (num -> bool) -> num
sub [hol] least = (LEAST)

let rec
remove_mat_exp (Mat (Var v) pes) =
  let pes = List.fold_left (fun pes (p,e) -> (p, remove_mat_exp e)::pes) [] pes in
  Mat (Var v) pes
and
remove_mat_exp (Mat e pes) =
  let pes = List.fold_left (fun pes (p,e) -> (p, remove_mat_exp e)::pes) [] pes in
  Let "" e (Mat (Var "") pes)
and
remove_mat_exp (Raise err) = Raise err
and
remove_mat_exp (Val u) = Val u
and
remove_mat_exp (Con cn es) = Con cn (List.map remove_mat_exp es)
and
remove_mat_exp (Var v) = Var v
and
remove_mat_exp (Fun v e) = Fun v (remove_mat_exp e)
and
remove_mat_exp (App op e1 e2) = App op (remove_mat_exp e1) (remove_mat_exp e2)
and
remove_mat_exp (Log lg e1 e2) = Log lg (remove_mat_exp e1) (remove_mat_exp e2)
and
remove_mat_exp (If e1 e2 e3) = If (remove_mat_exp e1) (remove_mat_exp e2) (remove_mat_exp e3)
and
remove_mat_exp (Let v e1 e2) = Let v (remove_mat_exp e1) (remove_mat_exp e2)
and
remove_mat_exp (Letrec defs e) =
  Letrec
    (List.map (fun (v1,v2,e) -> (v1,v2,remove_mat_exp e)) defs)
    (remove_mat_exp e)

let rec
remove_Gt_Geq (Raise err) = Raise err
and
remove_Gt_Geq (Val v) = Val v
and
remove_Gt_Geq (Con cn es) = Con cn (List.map remove_Gt_Geq es)
and
remove_Gt_Geq (Var vn) = Var vn
and
remove_Gt_Geq (Fun vn e) = Fun vn (remove_Gt_Geq e)
and
remove_Gt_Geq (App (Opb Gt) e1 e2) = App (Opb Lt) (remove_Gt_Geq e2) (remove_Gt_Geq e1)
and
remove_Gt_Geq (App (Opb Geq) e1 e2) = App (Opb Leq) (remove_Gt_Geq e2) (remove_Gt_Geq e1)
and
remove_Gt_Geq (App op e1 e2) = App op (remove_Gt_Geq e1) (remove_Gt_Geq e2)
and
remove_Gt_Geq (Log lg e1 e2) = Log lg (remove_Gt_Geq e1) (remove_Gt_Geq e2)
and
remove_Gt_Geq (If e1 e2 e3) = If (remove_Gt_Geq e1) (remove_Gt_Geq e2) (remove_Gt_Geq e3)
and
remove_Gt_Geq (Mat e pes) = Mat (remove_Gt_Geq e) (List.map (fun (p,e) -> (p,remove_Gt_Geq e)) pes)
and
remove_Gt_Geq (Let vn e b) = Let vn (remove_Gt_Geq e) (remove_Gt_Geq b)
and
remove_Gt_Geq (Letrec defs e) = Letrec (List.map (fun (fn,vn,e) ->
  (fn,vn,remove_Gt_Geq e)) defs) (remove_Gt_Geq e)

let least_not_in s = least (fun n -> not (n IN s))

let extend m vn =
  let n = least_not_in (range m) in
  (Pmap.add vn n m, n)

let rec
pat_to_Cpat (m, Pvar vn) =
  let (m',vn) = extend m vn in
  (m', CPvar vn)
and
pat_to_Cpat (m, Plit l) = (m, CPlit l)
and
pat_to_Cpat (m, Pcon cn ps) =
  let (m',ps) = List.fold_left
    (fun (m,ps) p -> let (m',p) = pat_to_Cpat (m,p) in (m',p::ps))
          (m,[]) ps in
  (m', CPcon (Pmap.find cn m) ps)

let rec
exp_to_Cexp (m, Raise err) = (m, CRaise err)
and
exp_to_Cexp (m, Val (Lit l)) = (m, CLit l)
and
exp_to_Cexp (m, Con cn es) =
  (m, CCon (Pmap.find cn m) (List.map (fun e -> let (_m,e) = exp_to_Cexp (m,e) in e) es))
and
exp_to_Cexp (m, Var vn) = (m, CVar (Pmap.find vn m))
and
exp_to_Cexp (m, Fun vn e) =
  let (m',n) = extend m vn in
  let (m',Ce) = exp_to_Cexp (m', e) in
  (m, CFun [n] Ce)
and
exp_to_Cexp (m, App (Opn opn) e1 e2) =
  let (_m,Ce1) = exp_to_Cexp (m, e1) in
  let (_m,Ce2) = exp_to_Cexp (m, e2) in
  (m, CPrimCall (match opn with
                 | Plus   -> CAdd
                 | Minus  -> CSub
                 | Times  -> CMult
                 | Divide -> CDiv
                 | Modulo -> CMod
                 end)
      [Ce1;Ce2])
and
exp_to_Cexp (m, App (Opb opb) e1 e2) =
  let (_m,Ce1) = exp_to_Cexp (m, e1) in
  let (_m,Ce2) = exp_to_Cexp (m, e2) in
  (m, CPrimCall (match opb with
                 | Lt  -> CLt
                 | Leq -> CLeq
                 end)
      [Ce1;Ce2])
and
exp_to_Cexp (m, Log log e1 e2) =
  let (_m,Ce1) = exp_to_Cexp (m, e1) in
  let (_m,Ce2) = exp_to_Cexp (m, e2) in
  (m, CPrimCall (match log with
                 | And -> CAnd
                 | Or  -> COr
                 end)
      [Ce1;Ce2])
and
exp_to_Cexp (m, If e1 e2 e3) =
  let (_m,Ce1) = exp_to_Cexp (m, e1) in
  let (_m,Ce2) = exp_to_Cexp (m, e2) in
  let (_m,Ce3) = exp_to_Cexp (m, e3) in
  (m, CPrimCall CIf [Ce1;Ce2;Ce3])
and
exp_to_Cexp (m, Mat (Var vn) pes) =
  let Cpes = List.fold_left
    (fun Cpes (p,e) -> let (m,Cp) = pat_to_Cpat (m,p) in
                       let (_m,Ce) = exp_to_Cexp (m,e) in
                       (Cp,Ce)::Cpes)
         [] pes in
  (m, CMat (Pmap.find vn m) Cpes)
and
exp_to_Cexp (m, Let vn e b) =
  let (m',n) = extend m vn in
  let (_m,Ce) = exp_to_Cexp (m, e) in
  let (_m,Cb) = exp_to_Cexp (m', b) in
  (m, CLet [(n,Ce)] Cb)
and
exp_to_Cexp (m, Letrec defs b) =
  let (m',fns) = List.fold_left
    (fun (m,fns) (d,_vn,_e) -> let (m',fn) = extend m d in (m',fn::fns))
          (m,[]) defs in
  let Cdefs = List.fold_left
    (fun Cdefs (fn,(_d,vn,e)) ->
      let (m'',n) = extend m' vn in
      let (_m,Ce) = exp_to_Cexp (m'',e) in
      (fn,[n],Ce)::Cdefs)
          [] (List.combine fns defs) in
  let (_m,Cb) = exp_to_Cexp (m',b) in
  (m, CLetfun true Cdefs Cb)

(* TODO: semantics *)
(* TODO: simple type system and checker *)

let rec
free_vars (CRaise _) = {}
and
free_vars (CVar n) = {n}
and
free_vars (CLit _) = {}
and
free_vars (CCon _ es) =
  List.fold_left (fun s e -> s union free_vars e) {} es
and
free_vars (CProj e _) = free_vars e
and
free_vars (CMat v pes) =
  Set.add v (List.fold_left (fun s (p,e) -> s union free_vars e) {} pes)
and
free_vars (CLet xes e) =
  free_vars e union
  List.fold_left (fun s (x,e) -> s union (free_vars e \ {x})) {} xes
and
free_vars (CLetfun true defs e) =
  let ns = Set.from_list (List.map (fun (n,_,_) -> n) defs) in
  free_vars e union
  List.fold_left (fun s (_,vs,e) -> free_vars e \
                                    (ns union (Set.from_list vs)))
                      {} defs
and
free_vars (CLetfun false defs e) =
  free_vars e union
  List.fold_left (fun s (_,vs,e) -> free_vars e \ Set.from_list vs)
                      {} defs
and
free_vars (CFun xs e) = free_vars e \ (Set.from_list xs)
and
free_vars (CCall e es) =
  free_vars e union
  List.fold_left (fun s e -> s union free_vars e) {} es
and
free_vars (CPrimCall _ es) =
  List.fold_left (fun s e -> s union free_vars e) {} es

(* Remove pattern-matching using continuations *)
(* TODO: more efficient method *)
val remove_mat : Cexp -> Cexp

let rec
remove_mat_vp fk sk v (CPvar pv) =
  CLet [(pv,(CVar v))] sk
and
remove_mat_vp fk sk v (CPlit l) =
  CPrimCall CIf [CPrimCall CEq [(CVar v);(CLit l)];
    sk; (CCall (CVar fk) [])]
and
remove_mat_vp fk sk v (CPcon cn ps) = remove_mat_con fk sk v 0 ps
and
remove_mat_con fk sk v n [] = sk
and
remove_mat_con fk sk v n (p::ps) =
  let v' = least_not_in (Set.add v (free_vars sk)) in
  CLet [(v',CProj (CVar v) n)]
    (remove_mat_vp fk (remove_mat_con fk sk v (n+1) ps) v' p)

let rec
remove_mat (CMat v pes) = remove_mat_var v pes
and
remove_mat (CRaise err) = CRaise err
and
remove_mat (CVar n) = CVar n
and
remove_mat (CCon n es) = CCon n (List.map remove_mat es)
and
remove_mat (CProj e n) = CProj (remove_mat e) n
and
remove_mat (CLet xes e) = CLet (List.map (fun (x,e) -> (x,remove_mat e)) xes) (remove_mat e)
and
remove_mat (CLetfun b defs e) = CLetfun b (List.map (fun (n,vs,e) -> (n,vs,remove_mat e)) defs) (remove_mat e)
and
remove_mat (CCall e es) = CCall (remove_mat e) (List.map remove_mat es)
and
remove_mat (CPrimCall op es) = CPrimCall op (List.map remove_mat es)
and
remove_mat_var v [] = CRaise Bind_error
and
remove_mat_var v ((p,e)::pes) =
  let sk = remove_mat e in
  let fk = least_not_in (Set.add v (free_vars sk)) in
  CLetfun false [(fk,[],(remove_mat_var v pes))]
    (remove_mat_vp fk sk v p)

(* TODO: collapse nested functions *)
(* TODO: collapse nested lets *)
(* TODO: removal of redundant expressions *)
(* TODO: simplification (e.g., constant folding) *)

let compile0 m e = (exp_to_Cexp (m, (remove_mat_exp (remove_Gt_Geq e))))

(* Constant folding
val fold_consts : exp -> exp

let rec
fold_consts (Raise err) = Raise err
and
fold_consts (Val v) = Val (v_fold_consts v)
and
fold_consts (Con c es) = Con c (List.map fold_consts es)
and
fold_consts (Var vn) = Var vn
and
fold_consts (Fun vn e) = Fun vn (fold_consts e)
and
fold_consts (App (Opn opn) (Val (Lit (IntLit n1))) (Val (Lit (IntLit n2)))) =
  Val (Lit (IntLit (opn_lookup opn n1 n2)))
and
fold_consts (App (Opb opb) (Val (Lit (IntLit n1))) (Val (Lit (IntLit n2)))) =
  Val (Lit (Bool (opb_lookup opb n1 n2)))
and
fold_consts (App Equality (Val (Lit (IntLit n1))) (Val (Lit (IntLit n2)))) =
  Val (Lit (Bool (n1 = n2)))
and
fold_consts (App Equality (Val (Lit (Bool b1))) (Val (Lit (Bool b2)))) =
  Val (Lit (Bool (b1 = b2)))
and
fold_consts (App op e1 e2) =
  let e1' = fold_consts e1 in
  let e2' = fold_consts e2 in
  if e1 = e1' && e2 = e2' then (App op e1 e2) else
  fold_consts (App op e1' e2')
and
fold_consts (Log And (Val (Lit (Bool true))) e2) =
  fold_consts e2
and
fold_consts (Log Or (Val (Lit (Bool false))) e2) =
  fold_consts e2
and
fold_consts (Log _ (Val (Lit (Bool b))) _) =
  Val (Lit (Bool b))
and
fold_consts (Log log e1 e2) =
  Log log (fold_consts e1) (fold_consts e2)
and
fold_consts (If (Val (Lit (Bool b))) e2 e3) =
  if b then fold_consts e2 else fold_consts e3
and
fold_consts (If e1 e2 e3) =
  If (fold_consts e1) (fold_consts e2) (fold_consts e3)
and
fold_consts (Mat (Val v) pes) =
  fold_match v pes
and
fold_consts (Mat e pes) =
  Mat (fold_consts e) (match_fold_consts pes)
and
fold_consts (Let vn e1 e2) =
  Let vn (fold_consts e1) (fold_consts e2)
and
fold_consts (Letrec funs e) =
  Letrec (funs_fold_consts funs) (fold_consts e)
and
fold_consts (Proj (Val (Conv None vs)) n) =
  Val (List.nth vs n)
and
fold_consts (Proj e n) = Proj (fold_consts e) n
and
v_fold_consts (Lit l) = Lit l
and
v_fold_consts (Conv None vs) =
  Conv None (List.map v_fold_consts vs)
and
v_fold_consts (Closure envE vn e) =
  Closure (env_fold_consts envE) vn (fold_consts e)
and
v_fold_consts (Recclosure envE funs vn) =
  Recclosure (env_fold_consts envE) (funs_fold_consts funs) vn
and
env_fold_consts [] = []
and
env_fold_consts ((vn,v)::env) =
  ((vn, v_fold_consts v)::env_fold_consts env)
and
funs_fold_consts [] = []
and
funs_fold_consts ((vn1,vn2,e)::funs) =
  ((vn1,vn2,fold_consts e)::funs_fold_consts funs)
and
match_fold_consts [] = []
and
match_fold_consts ((p,e)::pes) =
  (p, fold_consts e)::match_fold_consts pes
and
fold_match v [] = Raise Bind_error
and
fold_match (Lit l) ((Plit l',e)::pes) =
  if l = l' then
    fold_consts e
  else
    fold_match (Lit l) pes
and
(* TODO: fold more pattern matching (e.g. to Let)? Need envC? *)
fold_match v pes =
  Mat (Val v) (match_fold_consts pes)
*)
