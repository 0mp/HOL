(* A simple ML-like language that does not remain convenient to program in, but
   is suitable for:
 1. translation from MiniML
 2. source to source optimization
 3. translation to bytecode *)

open MiniML

type labN = string

type Cprimop =
  | CAdd | CSub | CMult | CDiv | CMod
  | CLt | CGt | CLeq | CGeq | CEqNum
  | CEqCon | CAnd | COr

type Cexp =
  | CCall of Cexp * Catom
  | CClosure of labN * varN list
  | CCase of Cexp * Calts
  | CLet of varN * Cexp * Cexp
  | CPrimCall of Cprimop * varN * varN
  | CCon of num * varN list
  | CProj of varN * num
  | CRaise of error

and Catom =
  | CVar of varN
  | CLit of lit

and Calts =
  | Conalts of (num * varN list * Cexp) list * Dftalt
  | Litalts of (lit * Cexp) list * Dftalt
and Dftalt = CNoDft | CDft of varN * Cexp

(* wrap expressions with bindings of labels to functions.
   labels will eventually be mapped to codeptrs.
   varN list is free variables.
   may be better to have an environment instead (add CLetEnv, change CClosure)
   to make environment sharing easier?
   should allow multi-argument functions to be represented so they can be optimized? *)
   
type Ctopexp = Labels of (labN, (varN list * varN * Cexp)) env * Cexp

(* compilation assumptions:
 - all variable names distinct
 - declarations processed elsewhere to make an
   environment, available during compilation *)

