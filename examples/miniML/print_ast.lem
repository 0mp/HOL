open MiniML


(* TODO: use a built-in int_to_string *)

val i : num -> Hol.int
sub [hol] i = (&)

let rec pos_int_to_string n =
  if n >. i 0 then
    let n' = n %. i 10 in
      pos_int_to_string (n /. i 10) ^
      (if n' = i 0 then "0"
       else if n' = i 1 then "1"
       else if n' = i 2 then "2"
       else if n' = i 3 then "3"
       else if n' = i 4 then "4"
       else if n' = i 5 then "5"
       else if n' = i 6 then "6"
       else if n' = i 7 then "7"
       else if n' = i 8 then "8"
       else "9")
  else
    ""

val int_to_string : Hol.int -> string
let int_to_string n = 
  if n = i 0 then 
    "0" 
  else if n >. i 0 then
    pos_int_to_string n
  else
    "~" ^ pos_int_to_string (i 0 -. n)

let infixes = ["+"; "-"; "*"; "/"; "mod"; "<"; ">"; "<="; ">="]

let rec
list_to_string printer sep [] =
  ""
and
list_to_string printer sep [x] =
  printer x
and
list_to_string printer sep (x::y::l) =
  printer x ^ sep ^ printer y ^ list_to_string printer sep l

let lit_to_string l = match l with
  (* Rely on the fact that true and false cannot be rebound in SML *)
  | Bool true -> "true"
  | Bool false -> "false"
  | Int n -> int_to_string n
end

let var_to_string v =
  if List.mem v infixes then
    "op " ^ v
  else
    v

let rec
pat_to_string (Pvar v) = var_to_string v
and
pat_to_string (Plit l) = lit_to_string l
and
pat_to_string (Pcon None ps) = "(" ^ list_to_string pat_to_string "," ps ^ ")"
and
pat_to_string (Pcon (Some c) []) =
  var_to_string c
and
pat_to_string (Pcon (Some c) ps) =
  "(" ^ var_to_string c ^ "(" ^ list_to_string pat_to_string "," ps ^ ")" ^ ")"

let rec
exp_to_string (Raise r) =
  "(raise Bind)"
and
exp_to_string (Val (Lit l)) =
  lit_to_string l
and
exp_to_string (Val _) =
  (* TODO: this shouldn't happen in source *)
  ""
and
exp_to_string (Con None es) = "(" ^ list_to_string exp_to_string "," es ^ ")"
and
exp_to_string (Con (Some c) []) =
  var_to_string c
and
exp_to_string (Con (Some c) es) =
  "(" ^ var_to_string c ^ "(" ^ list_to_string exp_to_string "," es ^ ")" ^ ")"
and
exp_to_string (Var v) =
  var_to_string v
and
exp_to_string (Fun v e) =
  "(fn " ^ var_to_string v ^ " => " ^ exp_to_string e ^ ")"
and
exp_to_string (App Opapp e1 e2) =
  "(" ^ exp_to_string e1 ^ " " ^ exp_to_string e2 ^ ")"
and
exp_to_string (App Equality e1 e2) =
  (* Rely on the fact (?) that = cannot be rebound in SML *)
  "(" ^ exp_to_string e1 ^ " = " ^ exp_to_string e2 ^ ")"
and
exp_to_string (App (Opn o) e1 e2) =
  let s = match o with
    | Plus -> "+"
    | Minus -> "-"
    | Times -> "*"
    | Divide -> "/"
    | Modulo -> "mod"
  end
  in
    if List.mem s infixes then
      "(" ^ exp_to_string e1 ^ " " ^ s ^ " " ^ exp_to_string e2 ^ ")"
    else
      "(" ^ s ^ " " ^ exp_to_string e1 ^ " " ^ exp_to_string e2 ^ ")"
and
exp_to_string (App (Opb o') e1 e2) =
  let s = match o' with
    | Lt -> "<"
    | Gt -> ">"
    | Leq -> "<="
    | Geq -> ">"
  end
  in
    if List.mem s infixes then
      "(" ^ exp_to_string e1 ^ " " ^ s ^ " " ^ exp_to_string e2 ^ ")"
    else
      "(" ^ s ^ " " ^ exp_to_string e1 ^ " " ^ exp_to_string e2 ^ ")"
and
exp_to_string (Log lop e1 e2) =
  "(" ^ exp_to_string e1 ^ (if lop = And then " andalso " else " orelse ") ^
  exp_to_string e2 ^ ")"
and
exp_to_string (If e1 e2 e3) =
  "(if " ^ exp_to_string e1 ^ " then " ^ exp_to_string e2 ^ " else " ^
  exp_to_string e3 ^ ")"
and
exp_to_string (Mat e pes) =
  "(case " ^ exp_to_string e ^ " of " ^
  list_to_string pat_exp_to_string "|" pes ^ ")"
and
exp_to_string (Let v e1 e2) =
  "(let val " ^ var_to_string v ^ " = " ^ exp_to_string e1 ^ " in " ^
  exp_to_string e2 ^ " end)"
and
exp_to_string (Letrec funs e) =
  "(let fun " ^ list_to_string fun_to_string " and " funs ^ " in " ^
  exp_to_string e ^ " end)"
and
pat_exp_to_string (p,e) =
  pat_to_string p ^ " => " ^ exp_to_string e
and
fun_to_string (v1,v2,e) =
  var_to_string v1 ^ " " ^ var_to_string v2 ^ " = " ^ exp_to_string e

let rec
type_to_string (Tvar tn) =
  tn
and
type_to_string (Tapp ts tn) =
  if ts = [] then
    tn
  else
    "(" ^ list_to_string type_to_string "," ts ^ ")" ^ tn
and
type_to_string (Tfn t1 t2) =
  "(" ^ type_to_string t1 ^ " -> " ^ type_to_string t2 ^ ")"
and
type_to_string Tnum =
  (* TODO: Get the numeric types sorted *)
  "int"
and
type_to_string Tbool =
  "bool"

let variant_to_string (c,ts) =
  var_to_string c ^ (if ts = [] then "" else " of " ^
  list_to_string type_to_string " * " ts)

let typedef_to_string (tvs, name, variants) =
  (if tvs = [] then "" else "(" ^ list_to_string (fun x -> x) "," tvs ^ ")") ^
  name ^ " = " ^ list_to_string variant_to_string "|" variants

let rec
dec_to_string (Dlet p e) =
  "val " ^ pat_to_string p ^ " = " ^ exp_to_string e
and
dec_to_string (Dletrec funs) =
  "fun " ^ list_to_string fun_to_string " and " funs
and
dec_to_string (Dtype types) =
  "datatype " ^ list_to_string typedef_to_string " and " types
