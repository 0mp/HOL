(* By Scott Owens, University of Cambridge, Copyright 2011
 *
 * Miniml is my idea of the simplest ML-like language that remains convenient
 * to program in.  It is purely functional (no refs or exceptions), has no
 * modules, no type abbreviations, or record types.  It does have mutually
 * recursive datatypes (at the top-level only) and functions, as well as
 * higher-order functions.  It also supports pattern matching for nested
 * patterns (which can fail due to non-exhaustive patterns).  Only booleans and
 * number types are built-in.  Syntactic sugar is generally omitted.
 *
 * In some ways it makes more sense to write these kind of semantics in Ott (to
 * get a presentation that looks like ML concrete-syntax-wise, and that has the
 * usual syntax for type systems and operational semantics, i.e., with |- and
 * horizontal lines).  Here in Lem, everything looks like abstract syntax;
 * however, unlike Ott, we get good support for functions, and not just
 * relations.
 * 
 * The small-step operational semantics is based on the CEK machine.  The type
 * system is typical, but it doesn't yet support polymorphism.  The big step
 * semantics is also typical *)

val all_distinct : forall 'a. 'a list -> bool
sub [hol] all_distinct = ALL_DISTINCT

(* Environments *)
type ('a,'b) env = ('a*'b) list

val emp : forall 'a 'b. ('a,'b) env
let emp = []

val lookup : forall 'a 'b. 'a -> ('a,'b) env -> 'b option
let rec 
lookup n [] = None
and
lookup n ((n',v)::e) =
  if n' = n then
    Some v
  else
    lookup n e 

val bind : forall 'a 'b. 'a -> 'b -> ('a,'b) env -> ('a,'b) env
let bind n v e = (n,v)::e

val merge : forall 'a 'b. ('a,'b) env -> ('a,'b) env -> ('a,'b) env
let merge e1 e2 = e1 @ e2

(* Literal constants *)
type lit = 
  | Num of num
  | Bool of bool

(* Built-in binary operations (including function application) *)
type op =
    (* e.g. + - * / *)
  | Opn of (num -> num -> num)
    (* e.g.  < > <= >= *)
  | Opb of (num -> num -> bool)
  | Opapp

(* Built-in logical operations *)
type log = 
  | And
  | Or 

(* Variable names *)
type varN = string
(* Constructor names (from datatype definitions) *)
type conN = string
(* Type names *)
type typeN = string
(* Type variable names *)
type tvarN = string

(* Types
 * 0-ary type applications represent unparameterised types (e.g., num or string)
 *)
type t = 
  | Tvar of tvarN
  | Tapp of t list * typeN
  | Tfn of t * t
  | Tnum
  | Tbool

(* Simultaneous substitution of types for type variables in a type *)
val type_subst : (tvarN,t) env -> t -> t
let rec
type_subst s (Tvar tv) =
  match lookup tv s with
    | None -> Tvar tv
    | Some(t) -> t
  end 
and
type_subst s (Tapp ts tn) =
  Tapp (List.map (type_subst s) ts) tn
and
type_subst s (Tfn t1 t2) =
  Tfn (type_subst s t1) (type_subst s t2)
and
type_subst s Tnum = Tnum
and
type_subst s Tbool = Tbool

(* Patterns *)
type pat =
  | Pvar of varN
  | Plit of lit
  (* Constructor applications *)
  | Pcon of conN * pat list

(* Runtime errors *)
type error = 
  | Bind_error

(* Expressions *)
type exp = 
  | Raise of error
  | Val of v
  (* Constructor application *)
  | Con of conN * exp list
  | Var of varN
  | Fun of varN * exp
  (* Application of an operator (including function application) *)
  | App of op * exp * exp
  (* Logical operations (and, or) *)
  | Log of log * exp * exp
  | If of exp * exp * exp
  (* Pattern matching *)
  | Mat of exp * (pat * exp) list
  | Let of varN * exp * exp
  (* Local definition of (potentially) mutually recursive functions 
   * The first varN is the function's name, and the second varN is its
   * parameter *)
  | Letrec of (varN * varN * exp) list * exp

(* Value forms *)
and v =
  | Lit of lit
  (* Constructor application *)
  | Conv of conN * v list
  (* Function closures
     The environment is used for the free variables in the function *)
  | Closure of (varN, v) env * varN * exp
  (* Function closure for recursive functions 
   * See Closure and Letrec above
   * The last variable name indicates which function from the mutually
   * recursive bundle this closure value represents *) 
  | Recclosure of (varN, v) env * (varN * varN * exp) list * varN

(* Environments *)
type envE = (varN, v) env

(* Declarations *)
type dec = 
  (* Top-level bindings
     The pattern allows several names to be bound at once *)
  | Dlet of pat * exp
  (* Mutually recursive function definition *)
  | Dletrec of (varN * varN * exp) list  
  (* Type definition
     Defines several types, each of which has several named variants, which can
     in turn have several arguments *)
  | Dtype of (tvarN list * typeN * (conN * t list) list) list

type decs = dec list

(* Maps each constructor to its arity and the set of all constructors of that
 * type *) 
type envC = (conN, num * conN set) env

(* Evaluation contexts 
 * The hole is denoted by the unit type 
 * The env argument contins bindings for the free variables of expressions in
     the context *)
type ctxt_frame = 
  | Capp1 of op * unit * exp
  | Capp2 of op * v * unit
  | Clog of log * unit * exp
  | Cif of unit * exp * exp
  | Cmat of unit * (pat * exp) list
  | Clet of varN * unit * exp
  (* Evaluating a constructor's arguments
   * The v list should be in reverse order. *)
  | Ccon of conN * v list * unit * exp list
type ctxt = ctxt_frame * envE

val lit_same_type : lit -> lit -> bool
let lit_same_type l1 l2 =
  match (l1,l2) with
    | (Num _, Num _) -> true
    | (Bool _, Bool _) -> true
    | _ -> false
  end

type match_result =
  | No_match
  | Match_type_error
  | Match of envE

(* A big-step pattern matcher.  If the value
 * matches the pattern, return an environment with the pattern variables bound
 * to the corresponding sub-terms of the value; this environment extends the
 * environment given as an argument.  No_match is returned when there is no
 * match, but any constructors encountered in determining the match failure are
 * applied to the correct number of arguments, and constructors in
 * corresponding positions in the pattern and value come from the same type.
 * Match_type_error is returned when one of these conditions is violated *)

val pmatch : envC -> pat -> v -> envE -> match_result
let rec 
pmatch envC (Pvar n) v' env = Match (bind n v' env)
and
pmatch envC (Plit l) (Lit l') env =
  if l = l' then
    Match env
  else if lit_same_type l l' then
    No_match
  else
    Match_type_error
and
pmatch envC (Pcon n ps) (Conv n' vs) env =
  match (lookup n envC, lookup n' envC) with
    | (Some (l, ns), Some (l', ns')) ->
        if n IN ns' && n' IN ns && (List.length ps = l) && (List.length vs = l')
        then
          if n = n' then
            pmatch_list envC ps vs env
          else
            No_match
        else
          Match_type_error
    | (_, _) -> Match_type_error
  end
and
pmatch envC _ _ env = Match_type_error
and
pmatch_list envC [] [] env = Match env
and
pmatch_list envC (p::ps) (v::vs) env =
  match pmatch envC p v env with
    | No_match -> No_match
    | Match_type_error -> Match_type_error
    | Match env' -> pmatch_list envC ps vs env'
  end
and
pmatch_list envC _ _ env = Match_type_error

(* State for CEK-style expression evaluation
 * - constructor data
 * - the environment for the free variables of the current expression 
 * - the current expression to evaluate
 * - the context stack (continuation) of what to do once the current expression
 *   is finished.  Each entry has an environment for it's free variables *)
type state = envC * envE * exp * ctxt list

type e_step_result =
  | Estep of state
  | Etype_error
  | Estuck

(* The semantics are deterministic, and presented functionally instead of
 * relationally for proof rather that readability; the steps are very small: we
 * push individual frames onto the context stack instead of finding a redex in a
 * single step *)

val push : envC -> envE -> exp -> ctxt_frame -> ctxt list -> e_step_result
let push envC env e c' cs = Estep (envC, env, e, (c',env)::cs)

val return : envC -> envE -> v -> ctxt list -> e_step_result
let return envC env v c = Estep (envC, env, Val v, c)

val type_error : envC -> envE -> ctxt list -> e_step_result
let type_error envC env c = Etype_error

(* Bind each function of a mutually recursive set of functions to its closure *)
val build_rec_env : (varN * varN * exp) list -> envE -> envE
let rec build_rec_env funs env =
  List.fold_right
    (fun (f,x,e) env' -> bind f (Recclosure env funs f) env')
    funs
    env

(* Lookup in the list of mutually recursive functions *)
val find_recfun : varN -> (varN * varN * exp) list -> (varN * exp) option
let rec find_recfun n funs =
  match funs with
    | [] -> None
    | (f,x,e) :: funs -> 
        if f = n then 
          Some (x,e)
        else 
          find_recfun n funs
  end

(* Do an application *)
val do_app : envE -> op -> v -> v -> (envE * exp) option
let do_app env' op v1 v2 =
  match (op, v1, v2) with
    | (Opapp, Closure env n e, v) ->
        Some (bind n v env, e)
    | (Opapp, Recclosure env funs n, v) ->
        match find_recfun n funs with
          | Some (n,e) -> Some (bind n v (build_rec_env funs env), e)
          | None -> None
        end
    | (Opn op, Lit (Num n1), Lit (Num n2)) -> 
        Some (env',Val (Lit (Num (op n1 n2))))
    | (Opb op, Lit (Num n1), Lit (Num n2)) -> 
        Some (env',Val (Lit (Bool (op n1 n2)))) 
    | _ -> None
  end

(* Do a logical operation *)
val do_log : log -> v -> exp -> exp option
let do_log l v e =
  match (l, v) with
    | (And, Lit (Bool true)) -> Some e
    | (Or, Lit (Bool false)) -> Some e
    | (_, Lit (Bool _)) -> Some (Val v)
    | _ -> None
  end

(* Do an if-then-else *)
val do_if : v -> exp -> exp -> exp option
let do_if v e1 e2 =
  if v = Lit (Bool true) then
    Some e1
  else if v = Lit (Bool false) then
    Some e2
  else
    None

(* apply a context to a value *)
val continue : envC -> v -> ctxt list -> e_step_result
let continue envC v cs =
  match cs with
    | [] -> Estuck
    | (Capp1 op () e, env) :: c -> 
        push envC env e (Capp2 op v ()) c
    | (Capp2 op v' (), env) :: c ->
        match do_app env op v' v with
          | Some (env,e) -> Estep (envC, env, e, c)
          | None -> Etype_error
        end
    | (Clog l () e, env) :: c ->
        match do_log l v e with
          | Some e -> Estep (envC, env, e, c)
          | None -> Etype_error
        end
    | (Cif () e1 e2, env) :: c ->
        match do_if v e1 e2 with
          | Some e -> Estep (envC, env, e, c)
          | None -> Etype_error
        end
    | (Cmat () [], env) :: c ->
        Estep (envC, env, Raise Bind_error, c)
    | (Cmat () ((p,e)::pes), env) :: c ->
        match pmatch envC p v env with
          | Match_type_error -> type_error envC env c
          | No_match -> push envC env (Val v) (Cmat () pes) c
          | Match env' -> Estep (envC, env', e, c)
        end
    | (Clet n () e, env) :: c ->
        Estep (envC, bind n v env, e, c) 
    | (Ccon n vs () [], env) :: c ->
        return envC env (Conv n (List.rev (v::vs))) c
    | (Ccon n vs () (e::es), env) :: c ->
        push envC env e (Ccon n (v::vs) () es) c
  end

(* The single step expression evaluator.  Returns None if there is nothing to
 * do, but no type error.  Returns Type_error on encountering free variables,
 * mis-applied (or non-existent) constructors, and when the wrong kind of value
 * if given to a primitive.  Returns Bind_error when no pattern in a match
 * matches the value.  Otherwise it returns the next state *)

val e_step : state -> e_step_result
let e_step (envC, env, e, c) =
  match e with
    | Raise e -> 
        if c <> [] then Estep (envC, emp, Raise e, []) else Estuck
    | Val v  -> 
	continue envC v c
    | Con n es -> 
        match lookup n envC with
          | None -> type_error envC env c
          | Some (l,_) -> 
	      if l = List.length es then
                match es with
                  | [] -> return envC env (Conv n []) c
                  | e::es ->
                      push envC env e (Ccon n [] () es) c
                end
              else
                type_error envC env c
        end
    | Var n ->
        match lookup n env with
          | None -> type_error envC env c
          | Some v -> return envC env v c
        end
    | Fun n e -> return envC env (Closure env n e) c
    | App op e1 e2 -> push envC env e1 (Capp1 op () e2) c 
    | Log l e1 e2 -> push envC env e1 (Clog l () e2) c
    | If e1 e2 e3 -> push envC env e1 (Cif () e2 e3) c
    | Mat e pes -> push envC env e (Cmat () pes) c
    | Let n e1 e2 -> push envC env e1 (Clet n () e2) c
    | Letrec funs e ->
        if not (all_distinct (List.map (fun (x,y,z) -> x) funs)) then
          type_error envC env c
        else
          Estep (envC, build_rec_env funs env, e, c)
  end 

(* Add the given type definition to the given constructor environment *)
val build_tdefs : 
  (tvarN list * typeN * (conN * t list) list) list -> envC -> envC
let build_tdefs tds envC =
  List.fold_right
    (fun (tvs, tn, condefs) envC ->
       List.fold_right
         (fun (conN, ts) envC ->
            bind conN (List.length ts, 
                       {cn | forall ((cn,ts) MEM condefs) | true}) envC)
         condefs
         envC)
    tds
    envC 

(* Checks that no constructor is defined twice *)
val check_dup_ctors : 
    (tvarN list * typeN * (conN * t list) list) list -> envC -> bool
let check_dup_ctors tds envC =
  (forall ((tvs, tn, condefs) MEM tds) ((n, ts) MEM condefs).
   lookup n envC = None) &&
  all_distinct 
    [ n | forall ((tvs, tn, condefs) MEM tds) ((n, ts) MEM condefs) | true ]

(* Whole program state
 * - constructor data
 * - values bound be previous definitions
 * - remaining definitions
 * - current state for evaluating the current definition *)
type d_state = envC * envE * decs * (pat * state) option

type d_step_result =
  | Dstep of d_state
  | Draise of error
  | Dtype_error
  | Dstuck

val d_step : d_state -> d_step_result
let d_step (envC, env, ds, st) =
  match st with
    | Some (p, (envC', env', Val v, [])) -> 
        match pmatch envC p v env with
          | Match env' -> Dstep (envC, env', ds, None)
          | No_match -> Draise Bind_error
          | Match_type_error -> Dtype_error
        end
    | Some (p, (envC, env', Raise err, [])) ->
        Draise err
    | Some (p, (envC, env', e, c)) -> 
        match e_step (envC, env', e, c) with
          | Estep st -> Dstep (envC, env, ds, Some (p, st))
          | Etype_error -> Dtype_error
          | Estuck -> Dstuck
        end
    | None ->
        match ds with
          | [] -> Dstuck
          | (Dlet p e) :: ds ->
              Dstep (envC, env, ds, Some (p, (envC, env, e, [])))
          | (Dletrec funs) :: ds ->
              Dstep (envC, build_rec_env funs env, ds, None)
          | (Dtype tds) :: ds ->
              if check_dup_ctors tds envC then
                Dtype_error
              else 
                Dstep (build_tdefs tds envC, env, ds, None)
      end
  end

(* ------------------------ Big step semantics -------------------------- *)

type error_result = 
  | Rtype_error
  | Rraise of error

type 'a result =
  | Rval of 'a
  | Rerr of error_result

val evaluate : envC -> envE -> exp -> v result -> bool
val evaluate_list : envC -> envE -> exp list -> v list result -> bool
val evaluate_match : envC -> envE -> v -> (pat * exp) list -> v result -> bool

indreln

forall cenv env err.
true
==>
evaluate cenv env (Raise err) (Rerr (Rraise err))

and

forall cenv env v.
true
==>
evaluate cenv env (Val v) (Rval v)

and

forall cenv env cn es vs ns.
(lookup cn cenv = Some (List.length es,ns)) &&
evaluate_list cenv env es (Rval vs)
==>
evaluate cenv env (Con cn es) (Rval (Conv cn vs))

and

forall cenv env cn es l ns.
(lookup cn cenv = None) || 
(lookup cn cenv = Some (l,ns) && l <> List.length es)
==>
evaluate cenv env (Con cn es) (Rerr Rtype_error)

and

forall cenv env cn es err ns.
(lookup cn cenv = Some (List.length es,ns)) &&
evaluate_list cenv env es (Rerr err)
==>
evaluate cenv env (Con cn es) (Rerr err)

and

forall cenv env n v.
(lookup n env = Some v)
==>
evaluate cenv env (Var n) (Rval v)

and

forall cenv env n.
(lookup n env = None)
==>
evaluate cenv env (Var n) (Rerr Rtype_error)

and

forall cenv env n e.
true
==>
evaluate cenv env (Fun n e) (Rval (Closure env n e))

and

forall cenv env op e1 e2 v1 v2 env' e3 bv.
evaluate cenv env e1 (Rval v1) &&
evaluate cenv env e2 (Rval v2) &&
do_app env op v1 v2 = Some (env', e3) &&
evaluate cenv env' e3 bv
==>
evaluate cenv env (App op e1 e2) bv

and

forall cenv env op e1 e2 v1 v2.
evaluate cenv env e1 (Rval v1) &&
evaluate cenv env e2 (Rval v2) &&
do_app env op v1 v2 = None
==>
evaluate cenv env (App op e1 e2) (Rerr Rtype_error)

and

forall cenv env op e1 e2 v1 err.
evaluate cenv env e1 (Rval v1) &&
evaluate cenv env e2 (Rerr err)
==>
evaluate cenv env (App op e1 e2) (Rerr err)

and

forall cenv env op e1 e2 err.
evaluate cenv env e1 (Rerr err)
==>
evaluate cenv env (App op e1 e2) (Rerr err)

and

forall cenv env op e1 e2 v e' bv.
evaluate cenv env e1 (Rval v) &&
do_log op v e2 = Some e' &&
evaluate cenv env e' bv
==>
evaluate cenv env (Log op e1 e2) bv

and

forall cenv env op e1 e2 v.
evaluate cenv env e1 (Rval v) &&
do_log op v e2 = None
==>
evaluate cenv env (Log op e1 e2) (Rerr Rtype_error)

and

forall cenv env e1 e2 e3 v e' bv.
evaluate cenv env e1 (Rval v) &&
do_if v e2 e3 = Some e' &&
evaluate cenv env e' bv
==>
evaluate cenv env (If e1 e2 e3) bv

and

forall cenv env e1 e2 e3 v.
evaluate cenv env e1 (Rval v) &&
do_if v e2 e3 = None
==>
evaluate cenv env (If e1 e2 e3) (Rerr Rtype_error)

and


forall cenv env e1 e2 e3 err.
evaluate cenv env e1 (Rerr err)
==>
evaluate cenv env (If e1 e2 e3) (Rerr err)

and

forall cenv env e pes v bv.
evaluate cenv env e (Rval v) &&
evaluate_match cenv env v pes bv
==>
evaluate cenv env (Mat e pes) bv

and

forall cenv env e pes err.
evaluate cenv env e (Rerr err)
==>
evaluate cenv env (Mat e pes) (Rerr err)

and

forall cenv env n e1 e2 v bv.
evaluate cenv env e1 (Rval v) &&
evaluate cenv (bind n v env) e2 bv
==>
evaluate cenv env (Let n e1 e2) bv

and

forall cenv env n e1 e2 err.
evaluate cenv env e1 (Rerr err)
==>
evaluate cenv env (Let n e1 e2) (Rerr err)

and

forall cenv env funs e bv.
evaluate cenv (build_rec_env funs env) e bv
==>
evaluate cenv env (Letrec funs e) bv

and

forall cenv env.
true
==>
evaluate_list cenv env [] (Rval [])

and

forall cenv env e es v vs.
evaluate cenv env e (Rval v) &&
evaluate_list cenv env es (Rval vs)
==>
evaluate_list cenv env (e::es) (Rval (v::vs))

and

forall cenv env e es err.
evaluate cenv env e (Rerr err)
==>
evaluate_list cenv env (e::es) (Rerr err)

and

forall cenv env e es v err.
evaluate cenv env e (Rval v) &&
evaluate_list cenv env es (Rerr err)
==>
evaluate_list cenv env (e::es) (Rerr err)

and

forall cenv env v.
true
==>
evaluate_match cenv env v [] (Rerr (Rraise Bind_error))

and

forall cenv env v p e pes env' bv.
(pmatch cenv p v env = Match env') &&
evaluate cenv env' e bv
==>
evaluate_match cenv env v ((p,e)::pes) bv

and

forall cenv env v p e pes bv.
(pmatch cenv p v env = No_match) &&
evaluate_match cenv env v pes bv
==>
evaluate_match cenv env v ((p,e)::pes) bv

and

forall cenv env v p e pes.
(pmatch cenv p v env = Match_type_error)
==>
evaluate_match cenv env v ((p,e)::pes) (Rerr Rtype_error)


(* TODO: declaration evaluation *)

(* ------------------------ Type system --------------------------------- *)

(* The type system does not currently support let polymorphism, but does 
* support polymorphic datatypes *)

(* constructor type environments: each constructor has a type 
 * forall (tyvarN list). t list -> typeN *)
type tenvC = (conN, (tvarN list * t list * typeN)) env 
(* Type environments *)
type tenvE = (varN, t) env

(* A pattern matches values of a certain type and extends the type environment
 * with the pattern's binders.  The pattern's type does not depend on the input
 * environment *)
val type_p : tenvC -> tenvE -> pat -> t -> tenvE -> bool

(* A value has a type *)
val type_v : tenvC -> v -> t -> bool

(* An expression has a type *)
val type_e : tenvC -> tenvE -> exp -> t -> bool

(* A list of expressions has a list of types *)
val type_es : tenvC -> tenvE -> exp list -> t list -> bool

(* A value environment has a corresponding type environment.  Since all of the
 * entries in the environment are values, and values have no free variables,
 * each entry in the environment can be typed in the empty environment (if at
 * all) *)
val type_env : tenvC -> envE -> tenvE -> bool

(* Type a mutually recursive bundle of functions.  Unlike pattern typing, the
 * resulting environment does not extend the input environment, but just
 * represents the functions *)
val type_funs : tenvC -> tenvE -> (varN * varN * exp) list -> tenvE -> bool

(* Check a declaration and update the top-level environments *)
val type_d : tenvC -> tenvE -> dec -> tenvC -> tenvE -> bool

val type_ds : tenvC -> tenvE -> dec list -> tenvC -> tenvE -> bool

(* Check that the operator can have type (t1 -> t2 -> t3) *)
val type_op : op -> t -> t -> t -> bool
let type_op op t1 t2 t3 =
  match (op,t1,t2) with
    | (Opapp, Tfn t2' t3', _) -> (t2 = t2') && (t3 = t3')
    | (Opn _, Tnum, Tnum) -> (t3 = Tnum)
    | (Opb _, Tnum, Tnum) -> (t3 = Tbool)
    | _ -> false
  end

indreln

forall cenv tenv n t.
true
==>
type_p cenv tenv (Pvar n) t (bind n t tenv)

and

forall cenv tenv b.
true
==>
type_p cenv tenv (Plit (Bool b)) Tbool tenv

and

forall cenv tenv n.
true
==>
type_p cenv tenv (Plit (Num n)) Tnum tenv

and

forall cenv tenv cn ps ts tvs tn ts' tenv'.
List.length ts' = List.length tvs &&
type_ps cenv tenv ps (List.map (type_subst (List.combine tvs ts')) ts) tenv' &&
lookup cn cenv = Some (tvs, ts, tn)
==>
type_p cenv tenv (Pcon cn ps) (Tapp ts' tn) tenv'

and

forall cenv tenv.
true
==>
type_ps cenv tenv [] [] tenv

and

forall cenv tenv p ps t ts tenv' tenv''.
type_p cenv tenv p t tenv' &&
type_ps cenv tenv' ps ts tenv''
==>
type_ps cenv tenv (p::ps) (t::ts) tenv''

indreln

forall cenv b.
true
==>
type_v cenv (Lit (Bool b)) Tbool

and
forall cenv n.
true
==>
type_v cenv (Lit (Num n)) Tnum

and

forall cenv cn vs tvs tn ts' ts.
List.length tvs = List.length ts' &&
type_vs cenv vs (List.map (type_subst (List.combine tvs ts')) ts) &&
lookup cn cenv = Some (tvs, ts, tn)
==>
type_v cenv (Conv cn vs) (Tapp ts' tn)

and

forall cenv env tenv n e t1 t2.
type_env cenv env tenv &&
type_e cenv (bind n t1 tenv) e t2
==>
type_v cenv (Closure env n e) (Tfn t1 t2)

and

forall cenv env funs n t tenv tenv'.
type_env cenv env tenv &&
type_funs cenv (merge tenv' tenv) funs tenv' &&
lookup n tenv' = Some t
==>
type_v cenv (Recclosure env funs n) t

and

forall cenv tenv err t.
true
==>
type_e cenv tenv (Raise err) t

and

forall cenv tenv v t.
type_v cenv v t
==>
type_e cenv tenv (Val v) t

and

forall cenv tenv cn es tvs tn ts' ts.
List.length tvs = List.length ts' &&
type_es cenv tenv es (List.map (type_subst (List.combine tvs ts')) ts) &&
lookup cn cenv = Some (tvs, ts, tn)
==>
type_e cenv tenv (Con cn es) (Tapp ts' tn)

and

forall cenv tenv n t.
(lookup n tenv = Some t)
==>
type_e cenv tenv (Var n) t

and

forall cenv tenv n e t1 t2.
type_e cenv (bind n t1 tenv) e t2
==>
type_e cenv tenv (Fun n e) (Tfn t1 t2)

and

forall cenv tenv op e1 e2 t1 t2 t3.
type_e cenv tenv e1 t1 &&
type_e cenv tenv e2 t2 &&
type_op op t1 t2 t3
==>
type_e cenv tenv (App op e1 e2) t3

and

forall cenv tenv l e1 e2.
type_e cenv tenv e1 Tbool &&
type_e cenv tenv e2 Tbool
==>
type_e cenv tenv (Log l e1 e2) Tbool

and

forall cenv tenv e1 e2 e3 t.
type_e cenv tenv e1 Tbool &&
type_e cenv tenv e2 t &&
type_e cenv tenv e3 t
==>
type_e cenv tenv (If e1 e2 e3) t

and

forall cenv tenv e pes t1 t2.
type_e cenv tenv e t1 &&
(forall ((p,e) MEM pes) tenv'.
   type_p cenv tenv p t1 tenv' &&
   type_e cenv tenv' e t2)
==>
type_e cenv tenv (Mat e pes) t2

and

forall cenv tenv n e1 e2 t1 t2.
type_e cenv tenv e1 t1 &&
type_e cenv (bind n t1 tenv) e2 t2
==>
type_e cenv tenv (Let n e1 e2) t2

and

forall cenv tenv funs e t tenv'.
type_funs cenv (merge tenv' tenv) funs tenv' &&
type_e cenv (merge tenv' tenv) e t
==>
type_e cenv tenv (Letrec funs e) t

and

forall cenv tenv.
true
==>
type_es cenv tenv [] []

and

forall cenv tenv e es t ts.
type_e cenv tenv e t &&
type_es cenv tenv es ts
==>
type_es cenv tenv (e::es) (t::ts)

and

forall cenv.
true
==>
type_vs cenv [] []

and

forall cenv v vs t ts.
type_v cenv v t &&
type_vs cenv vs ts
==>
type_vs cenv (v::vs) (t::ts)

and

forall cenv.
true
==>
type_env cenv [] []

and

forall cenv n v env t tenv.
type_e cenv [] (Val v) t &&
type_env cenv env tenv
==>
type_env cenv (bind n v env) (bind n t tenv)

and

forall cenv env.
true
==>
type_funs cenv env [] emp

and

forall cenv env fn n e funs env' t1 t2.
type_e cenv (bind n t1 env) e t2 &&
type_funs cenv env funs env' &&
lookup fn env' = None
==>
type_funs cenv env ((fn, n, e)::funs) (bind fn (Tfn t1 t2) env')


indreln

forall cenv tenv p e t tenv'.
type_p cenv tenv p t tenv' &&
type_e cenv tenv e t
==>
type_d cenv tenv (Dlet p e) cenv tenv'

and

forall cenv tenv funs tenv'.
type_funs cenv (merge tenv' tenv) funs tenv'
==>
type_d cenv tenv (Dletrec funs) cenv (merge tenv' tenv)

and

(* TODO: typing declarations *)
forall cenv tenv tdecs.
false
==>
type_d cenv tenv (Dtype tdecs) cenv tenv

indreln

forall cenv tenv.
true
==>
type_ds cenv tenv [] cenv tenv

and

forall cenv tenv d ds cenv' tenv' cenv'' tenv''.
type_d cenv tenv d cenv' tenv' &&
type_ds cenv' tenv' ds cenv'' tenv''
==>
type_ds cenv tenv (d::ds) cenv'' tenv''

(* --------- Auxiliary definitions used in the type soundness proofs -------- *)

(* An evaluation context has the second type when its hole is filled with a
 * value of the first type. *)
val type_ctxt : tenvC -> tenvE -> ctxt_frame -> t -> t -> bool
val type_ctxts : tenvC -> ctxt list -> t -> t -> bool
val type_state : tenvC -> state -> t -> bool

indreln

forall cenv tenv e op t1 t2 t3.
type_e cenv tenv e t2 &&
type_op op t1 t2 t3
==>
type_ctxt cenv tenv (Capp1 op () e) t1 t3

and

forall cenv tenv op v t1 t2 t3.
type_e cenv tenv (Val v) t1 &&
type_op op t1 t2 t3
==>
type_ctxt cenv tenv (Capp2 op v ()) t2 t3

and

forall cenv tenv op e.
type_e cenv tenv e Tbool
==>
type_ctxt cenv tenv (Clog op () e) Tbool Tbool

and

forall cenv tenv e1 e2 t.
type_e cenv tenv e1 t &&
type_e cenv tenv e2 t
==>
type_ctxt cenv tenv (Cif () e1 e2) Tbool t

and

forall cenv tenv t1 t2 pes.
(forall ((p,e) MEM pes) tenv'.
   type_p cenv tenv p t1 tenv' &&
   type_e cenv tenv' e t2)
==>
type_ctxt cenv tenv (Cmat () pes) t1 t2

and

forall cenv tenv e t1 t2 n.
type_e cenv (bind n t1 tenv) e t2
==>
type_ctxt cenv tenv (Clet n () e) t1 t2

and

forall cenv tenv cn vs es ts1 ts2 t tn ts' tvs.
List.length tvs = List.length ts' &&
type_es cenv tenv (List.rev (List.map Val vs)) 
        (List.map (type_subst (List.combine tvs ts')) ts1) &&
type_es cenv tenv es (List.map (type_subst (List.combine tvs ts')) ts2) &&
lookup cn cenv = Some (tvs, ts1@[t]@ts2, tn)
==>
type_ctxt cenv tenv (Ccon cn vs () es) (type_subst (List.combine tvs ts') t) 
          (Tapp ts' tn)

indreln

forall tenvC t.
true
==>
type_ctxts tenvC [] t t

and

forall tenvC c env cs tenv t1 t2 t3.
type_env tenvC env tenv &&
type_ctxt tenvC tenv c t1 t2 &&
type_ctxts tenvC cs t2 t3
==>
type_ctxts tenvC ((c,env)::cs) t1 t3

indreln

forall tenvC envC env e c t1 t2 tenv.
type_ctxts tenvC c t1 t2 &&
type_env tenvC env tenv &&
type_e tenvC tenv e t1
==>
type_state tenvC (envC, env, e, c) t2

(* TODO: Typing d_states *)


(* ------ Auxiliary relations for proving big/small step equivalence ------ *)

val evaluate_ctxt : envC -> envE -> ctxt_frame -> v -> v result -> bool
val evaluate_ctxts : envC -> ctxt list -> v -> v result -> bool
val evaluate_state : state -> v result -> bool

indreln

forall cenv env op e v bv.
evaluate cenv env (App op (Val v) e) bv
==>
evaluate_ctxt cenv env (Capp1 op () e) v bv

and

forall cenv env op v1 v2 bv.
evaluate cenv env (App op (Val v1) (Val v2)) bv
==>
evaluate_ctxt cenv env (Capp2 op v1 ()) v2 bv

and

forall cenv env op e v bv.
evaluate cenv env (Log op (Val v) e) bv
==>
evaluate_ctxt cenv env (Clog op () e) v bv

and

forall cenv env e1 e2 v bv.
evaluate cenv env (If (Val v) e1 e2) bv
==>
evaluate_ctxt cenv env (Cif () e1 e2) v bv

and

forall cenv env pes v bv.
evaluate cenv env (Mat (Val v) pes) bv
==>
evaluate_ctxt cenv env (Cmat () pes) v bv

and

forall cenv env n e v bv.
evaluate cenv env (Let n (Val v) e) bv
==>
evaluate_ctxt cenv env (Clet n () e) v bv

and

forall cenv env n vs es v bv.
evaluate cenv env (Con n (List.map Val (List.rev vs) @ [Val v] @ es)) bv
==>
evaluate_ctxt cenv env (Ccon n vs () es) v bv

indreln

forall cenv v.
true
==>
evaluate_ctxts cenv [] v (Rval v)

and

forall cenv c cs env v v' bv.
evaluate_ctxt cenv env c v (Rval v') &&
evaluate_ctxts cenv cs v' bv 
==>
evaluate_ctxts cenv ((c,env)::cs) v bv

and

forall cenv c cs v env err.
evaluate_ctxt cenv env c v (Rerr err)
==>
evaluate_ctxts cenv ((c,env)::cs) v (Rerr err)

indreln

forall cenv env e c v bv.
evaluate cenv env e (Rval v) &&
evaluate_ctxts cenv c v bv
==>
evaluate_state (cenv, env, e, c) bv

and

forall cenv env e c err.
evaluate cenv env e (Rerr err)
==>
evaluate_state (cenv, env, e, c) (Rerr err)
