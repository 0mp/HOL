app load ["sboxTheory","listSyntax","pairTools"]; 

open bossLib listSyntax pairTools;

(*---------------------------------------------------------------------------*)
(* Make bindings to pre-existing stuff                                       *)
(*---------------------------------------------------------------------------*)

val RESTR_EVAL_TAC = computeLib.RESTR_EVAL_TAC;

val Sbox_Inversion = sboxTheory.Sbox_Inversion;

(*---------------------------------------------------------------------------*)
(* The state is 16 bytes                                                     *)
(*---------------------------------------------------------------------------*)

type_abbrev("state", Type`:word8#word8#word8#word8#
                           word8#word8#word8#word8#
                           word8#word8#word8#word8#
                           word8#word8#word8#word8`);

type_abbrev("key", Type`:state`);

type_abbrev("w8x4",Type`:word8#word8#word8#word8`);

(*---------------------------------------------------------------------------*)
(* Start an inference counter                                                *)
(*---------------------------------------------------------------------------*)

val meter = Count.mk_meter();

(*---------------------------------------------------------------------------
      Name some constants used in the code
 ---------------------------------------------------------------------------*)

val ZERO_def   = Define   `ZERO = (F,F,F,F,F,F,F,F)`;
val ONE_def    = Define    `ONE = (F,F,F,F,F,F,F,T)`;
val TWO_def    = Define    `TWO = (F,F,F,F,F,F,T,F)`;
val THREE_def  = Define  `THREE = (F,F,F,F,F,F,T,T)`;
val NINE_def   = Define   `NINE = (F,F,F,F,T,F,F,T)`;
val ONE_B_def  = Define  `ONE_B = (F,F,F,T,T,F,T,T)`;
val EIGHTY_def = Define `EIGHTY = (T,F,F,F,F,F,F,F)`;
val B_HEX_def  = Define  `B_HEX = (F,F,F,F,T,F,T,T)`;
val D_HEX_def  = Define  `D_HEX = (F,F,F,F,T,T,F,T)`;
val E_HEX_def  = Define  `E_HEX = (F,F,F,F,T,T,T,F)`;

(*---------------------------------------------------------------------------
    Bits and bytes and numbers
 ---------------------------------------------------------------------------*)

val B2N = Define `(B2N T = 1) /\ (B2N F = 0)`;

val BYTE_TO_NUM = Define 
  `BYTE_TO_NUM (b7,b6,b5,b4,b3,b2,b1,b0) =
     128*B2N(b7) + 64*B2N(b6) + 32*B2N(b5) + 
      16*B2N(b4) + 8*B2N(b3) + 4*B2N(b2) + 2*B2N(b1) + B2N(b0)`;

(*---------------------------------------------------------------------------*)
(* XOR and AND on bytes                                                      *)
(*---------------------------------------------------------------------------*)

val _ = (set_fixity "XOR"     (Infixr 350); 
         set_fixity "XOR8x4"  (Infixr 350);
         set_fixity "XOR8"    (Infixr 350);
         set_fixity "AND8"    (Infixr 350));

val XOR_def =  Define `(x:bool) XOR y = ~(x=y)`;

val XOR8_def = Define 
 `(a,b,c,d,e,f,g,h) XOR8 (a1,b1,c1,d1,e1,f1,g1,h1) 
                     = 
                 (a XOR a1, 
                  b XOR b1, 
                  c XOR c1, 
                  d XOR d1,
                  e XOR e1, 
                  f XOR f1, 
                  g XOR g1, 
                  h XOR h1)`;

val AND8_def = Define 
 `(a,b,c,d,e,f,g,h) AND8 (a1,b1,c1,d1,e1,f1,g1,h1) 
                     = 
                 (a /\ a1, 
                  b /\ b1, 
                  c /\ c1, 
                  d /\ d1,
                  e /\ e1, 
                  f /\ f1, 
                  g /\ g1, 
                  h /\ h1)`;

val XOR8_ZERO = Q.prove
(`!x. x XOR8 ZERO = x`,
 PGEN_TAC (Term `(a1,a2,a3,a4,a5,a6,a7,a8):word8`) THEN EVAL_TAC);

val XOR8_AC = Q.prove 
(`(!x y:word8. (x XOR8 y) = (y XOR8 x)) /\
  (!x y z:word8. (x XOR8 y) XOR8 z = x XOR8 (y XOR8 z))`, 
 CONJ_TAC THEN
 PGEN_TAC (Term `(a1,a2,a3,a4,a5,a6,a7,a8):word8`) THEN 
 PGEN_TAC (Term `(b1,b2,b3,b4,b5,b6,b7,b8):word8`) THEN
 TRY (PGEN_TAC (Term `(c1,c2,c3,c4,c5,c6,c7,c8):word8`)) THEN
 EVAL_TAC THEN DECIDE_TAC);

val XOR_IDEMP = Q.prove
(`!x y:word8. (y XOR8 x) XOR8 x = y`, 
 PGEN_TAC (Term `(a1,a2,a3,a4,a5,a6,a7,a8):word8`) THEN 
 PGEN_TAC (Term `(b1,b2,b3,b4,b5,b6,b7,b8):word8`) THEN
 EVAL_TAC THEN DECIDE_TAC);

(*---------------------------------------------------------------------------
    Moving data into and out of a state
 ---------------------------------------------------------------------------*)

val to_state_def = Define
 `to_state (b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15) 
                =
            (b0,b4,b8,b12,
             b1,b5,b9,b13,
             b2,b6,b10,b14,
             b3,b7,b11,b15)`;

val from_state_def = Define
 `from_state (b0,b4,b8,b12,
              b1,b5,b9,b13,
              b2,b6,b10,b14,
              b3,b7,b11,b15) 
 = (b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15)`;

val to_state_Inversion = 
  Q.prove
  (`!s:state. from_state(to_state s) = s`,
   PGEN_TAC (Term `(b0,b1,b2,b3,b4,b5,b6,b7,b8,
                    b9,b10,b11,b12,b13,b14,b15):state`) THEN EVAL_TAC);


val from_state_Inversion = 
  Q.prove
  (`!s:state. to_state(from_state s) = s`,
   PGEN_TAC (Term `(b0,b1,b2,b3,b4,b5,b6,b7,b8,
                    b9,b10,b11,b12,b13,b14,b15):state`) THEN EVAL_TAC);


(*---------------------------------------------------------------------------
     Apply an Sbox to the state
 ---------------------------------------------------------------------------*)

val _ = Parse.hide "S";

val genSubBytes_def = try Define
  `genSubBytes S (b00,b01,b02,b03,
                  b10,b11,b12,b13,
                  b20,b21,b22,b23,
                  b30,b31,b32,b33) 
                          = 
             (S b00, S b01, S b02, S b03,
              S b10, S b11, S b12, S b13,
              S b20, S b21, S b22, S b23,
              S b30, S b31, S b32, S b33)`;


val SubBytes_def    = Define `SubBytes = genSubBytes Sbox`;
val InvSubBytes_def = Define `InvSubBytes = genSubBytes InvSbox`;

val SubBytes_Inversion = Q.prove
(`!s:state. genSubBytes InvSbox (genSubBytes Sbox s) = s`,
 PGEN_TAC (Term `(b00,b01,b02,b03,b10,b11,b12,b13,
                  b20,b21,b22,b23, b30,b31,b32,b33):state`)
 THEN EVAL_TAC
 THEN RW_TAC std_ss [Sbox_Inversion]);

(*---------------------------------------------------------------------------
    Left-shift the first row not at all, the second row by 1, the 
    third row by 2, and the last row by 3. And the inverse operation.
 ---------------------------------------------------------------------------*)

val ShiftRows_def = Define
  `ShiftRows (b00,b01,b02,b03,
              b10,b11,b12,b13,
              b20,b21,b22,b23,
              b30,b31,b32,b33) 
                     =
             (b00,b01,b02,b03,
              b11,b12,b13,b10,
              b22,b23,b20,b21,
              b33,b30,b31,b32)`;

val InvShiftRows_def = Define
  `InvShiftRows (b00,b01,b02,b03,
                 b11,b12,b13,b10,
                 b22,b23,b20,b21,
                 b33,b30,b31,b32)
                     =
                (b00,b01,b02,b03,
                 b10,b11,b12,b13,
                 b20,b21,b22,b23,
                 b30,b31,b32,b33)`; 

(*---------------------------------------------------------------------------
        InvShiftRows inverts ShiftRows
 ---------------------------------------------------------------------------*)

val ShiftRows_Inversion = Q.prove
(`!s:state. InvShiftRows (ShiftRows s) = s`,
 PGEN_TAC (Term`(b00,b01,b02,b03,b10,b11,b12,b13,
                 b20,b21,b22,b23,b30,b31,b32,b33):state`)
 THEN EVAL_TAC);

(*---------------------------------------------------------------------------
        Shift a byte left and right
 ---------------------------------------------------------------------------*)

val LeftShift = Define
   `LeftShift (b7,b6,b5,b4,b3,b2,b1,b0) = (b6,b5,b4,b3,b2,b1,b0,F)`;

val RightShift = Define
   `RightShift (b7,b6,b5,b4,b3,b2,b1,b0) = (F,b7,b6,b5,b4,b3,b2,b1)`;

(*---------------------------------------------------------------------------
       Compare bits and bytes as if they were numbers
 ---------------------------------------------------------------------------*)

val _ = Hol_datatype `order = LESS | EQUAL | GREATER`;

val BIT_COMPARE = Define 
  `(BIT_COMPARE F T = LESS) /\
   (BIT_COMPARE T F = GREATER) /\
   (BIT_COMPARE x y = EQUAL)`;
                        

val BYTE_COMPARE = Define
  `BYTE_COMPARE (a7,a6,a5,a4,a3,a2,a1,a0)
                (b7,b6,b5,b4,b3,b2,b1,b0) = 
    case BIT_COMPARE a7 b7 
     of EQUAL -> 
        (case BIT_COMPARE a6 b6
          of EQUAL -> 
             (case BIT_COMPARE a5 b5
               of EQUAL -> 
                  (case BIT_COMPARE a4 b4
                    of EQUAL ->
                       (case BIT_COMPARE a3 b3
                         of EQUAL -> 
                            (case BIT_COMPARE a2 b2
                              of EQUAL -> 
                                 (case BIT_COMPARE a1 b1
                                   of EQUAL -> BIT_COMPARE a0 b0
                                   || other -> other) 
                              || other -> other) 
                         || other -> other) 
                    || other -> other) 
               || other -> other) 
          || other -> other) 
     || other -> other`;


(*---------------------------------------------------------------------------
    Multiply a byte (representing a polynomial) by x. 

   xtime b = (LeftShift b) 
                XOR8 
             (case BYTE_COMPARE b EIGHTY
               of LESS  -> ZERO 
               || other -> ONE_B)

 ---------------------------------------------------------------------------*)

val xtime_def = Define
  `xtime (b7,b6,b5,b4,b3,b2,b1,b0)
     =
   if b7 then (b6,b5,b4,~b3,~b2,b1,~b0,T)
         else (b6,b5,b4,b3,b2,b1,b0,F)`;

val xtime_distrib = Q.prove
(`!a b. xtime (a XOR8 b) = xtime a XOR8 xtime b`,
 PGEN_TAC (Term `(a0,a1,a2,a3,a4,a5,a6,a7):word8`) THEN
 PGEN_TAC (Term `(b0,b1,b2,b3,b4,b5,b6,b7):word8`) THEN
 RW_TAC std_ss [xtime_def,XOR8_def,XOR_def] THEN DECIDE_TAC);

val _ = set_fixity "**" (Infixl 600);

val (PolyMult,PolyMult_ind) = 
Lib.with_flag (Globals.priming,SOME "")
 Defn.tprove
  (Defn.Hol_defn "PolyMult"
     `b1 ** b2 =
        if b1 = ZERO then ZERO else 
        if (b1 AND8 ONE) = ONE 
           then b2 XOR8 ((RightShift b1) ** (xtime b2))
           else (RightShift b1) ** (xtime b2)`,
   WF_REL_TAC `measure (BYTE_TO_NUM o FST)`
     THEN Cases THEN Cases_on `r` THEN Cases_on `r1`
     THEN Cases_on `r` THEN Cases_on `r1`
     THEN Cases_on `r` THEN Cases_on `r1`
     THEN RW_TAC arith_ss [ZERO_def,RightShift,BYTE_TO_NUM] 
     THEN RW_TAC arith_ss [B2N]);


val PolyExp_def = Define
   `PolyExp x n = if n=0 then ONE else x ** PolyExp x (n-1)`;

val PolyMult_induction = Q.prove
(`!P. (!b1 b2.
            (~(b1 = ZERO) /\ ~(b1 AND8 ONE = ONE) ==>
             P (RightShift b1) (xtime b2)) /\
            (~(b1 = ZERO) /\ (b1 AND8 ONE = ONE) ==>
             P (RightShift b1) (xtime b2)) ==>
            P b1 b2) ==>
         !v v1. P v v1`,
 GEN_TAC THEN DISCH_TAC THEN 
 PGEN_TAC (Term `(v,v1,v2,v3,v4,v5,v6,v7):word8`) THEN 
 PGEN_TAC (Term `(v8,v9,v10,v11,v12,v13,v14,v15):word8`) THEN 
 IMP_RES_TAC PolyMult_ind THEN ASM_REWRITE_TAC[]);

val PolyMultDistrib = Q.prove
(`!x y z. x ** (y XOR8 z) = (x ** y) XOR8 (x ** z)`,
 HO_MATCH_MP_TAC PolyMult_induction
   THEN REPEAT STRIP_TAC
   THEN ONCE_REWRITE_TAC [PolyMult]
   THEN RW_TAC std_ss [XOR8_ZERO,xtime_distrib] 
   THEN REPEAT (WEAKEN_TAC (K true)) 
   THEN PROVE_TAC [XOR8_AC]);


(*---------------------------------------------------------------------------
        Column multiplication and its inverse
 ---------------------------------------------------------------------------*)

val MultCol_def = Define
 `MultCol (a,b,c,d) = 
   ((TWO ** a)   XOR8 (THREE ** b) XOR8  c           XOR8 d,
     a           XOR8 (TWO ** b)   XOR8 (THREE ** c) XOR8 d,
     a           XOR8  b           XOR8 (TWO ** c)   XOR8 (THREE ** d),
    (THREE ** a) XOR8  b           XOR8  c           XOR8 (TWO ** d))`;

val InvMultCol_def = Define
 `InvMultCol (a,b,c,d) = 
   ((E_HEX ** a) XOR8 (B_HEX ** b) XOR8 (D_HEX ** c) XOR8 (NINE  ** d),
    (NINE  ** a) XOR8 (E_HEX ** b) XOR8 (B_HEX ** c) XOR8 (D_HEX ** d),
    (D_HEX ** a) XOR8 (NINE  ** b) XOR8 (E_HEX ** c) XOR8 (B_HEX ** d),
    (B_HEX ** a) XOR8 (D_HEX ** b) XOR8 (NINE  ** c) XOR8 (E_HEX ** d))`;

(*---------------------------------------------------------------------------*)
(* Inversion lemmas for column multiplication.                               *)
(*---------------------------------------------------------------------------*)

val lemma_a1 = Q.prove
(`!a. E_HEX ** (TWO ** a) XOR8 B_HEX ** a  XOR8 
      D_HEX ** a XOR8 NINE  ** (THREE ** a) = a`,
 PGEN_TAC (Term `(a0,a1,a2,a3,a4,a5,a6,a7):word8`) THEN EVAL_TAC
   THEN REWRITE_TAC [REWRITE_RULE [ZERO_def] XOR8_ZERO]
   THEN Cases_on `a0`
   THEN Cases_on `a1`
   THEN Cases_on `a2`
   THEN Cases_on `a3`
   THEN Cases_on `a4`
   THEN Cases_on `a5`
   THEN Cases_on `a6`
   THEN Cases_on `a7` THEN EVAL_TAC);

val lemma_a2 = Q.prove
(`!b. E_HEX ** (THREE ** b) XOR8 B_HEX ** (TWO ** b) XOR8 
      D_HEX ** b XOR8 NINE  ** b
        =
    ZERO`,
 PGEN_TAC (Term `(b0,b1,b2,b3,b4,b5,b6,b7):word8`) THEN EVAL_TAC
   THEN REWRITE_TAC [REWRITE_RULE [ZERO_def] XOR8_ZERO]
   THEN Cases_on `b0`
   THEN Cases_on `b1`
   THEN Cases_on `b2`
   THEN Cases_on `b3`
   THEN Cases_on `b4`
   THEN Cases_on `b5`
   THEN Cases_on `b6`
   THEN Cases_on `b7` THEN EVAL_TAC);


val lemma_a3 = Q.prove
(`!c. E_HEX ** c XOR8 B_HEX ** (THREE ** c) XOR8 
      D_HEX ** (TWO ** c) XOR8 NINE ** c
        =
    ZERO`,
 PGEN_TAC (Term `(c0,c1,c2,c3,c4,c5,c6,c7):word8`) THEN EVAL_TAC
   THEN REWRITE_TAC [REWRITE_RULE [ZERO_def] XOR8_ZERO]
   THEN Cases_on `c0`
   THEN Cases_on `c1`
   THEN Cases_on `c2`
   THEN Cases_on `c3`
   THEN Cases_on `c4`
   THEN Cases_on `c5`
   THEN Cases_on `c6`
   THEN Cases_on `c7` THEN EVAL_TAC);

val lemma_a4 = Count.apply Q.prove
(`!d. E_HEX ** d XOR8 B_HEX ** d XOR8 
      D_HEX ** (THREE ** d) XOR8 NINE ** (TWO ** d)
        =
    ZERO`,
 PGEN_TAC (Term `(d0,d1,d2,d3,d4,d5,d6,d7):word8`) THEN EVAL_TAC
   THEN REWRITE_TAC [REWRITE_RULE [ZERO_def] XOR8_ZERO]
   THEN Cases_on `d0`
   THEN Cases_on `d1`
   THEN Cases_on `d2`
   THEN Cases_on `d3`
   THEN Cases_on `d4`
   THEN Cases_on `d5`
   THEN Cases_on `d6`
   THEN Cases_on `d7` THEN EVAL_TAC);


val lemma_b1 = Q.prove
(`!a. NINE ** (TWO ** a) XOR8 E_HEX ** a  XOR8 
      B_HEX ** a XOR8 D_HEX  ** (THREE ** a) = ZERO`,
 PGEN_TAC (Term `(a0,a1,a2,a3,a4,a5,a6,a7):word8`) THEN EVAL_TAC
   THEN REWRITE_TAC [REWRITE_RULE [ZERO_def] XOR8_ZERO]
   THEN Cases_on `a0`
   THEN Cases_on `a1`
   THEN Cases_on `a2`
   THEN Cases_on `a3`
   THEN Cases_on `a4`
   THEN Cases_on `a5`
   THEN Cases_on `a6`
   THEN Cases_on `a7` THEN EVAL_TAC);

val lemma_b2 = Q.prove
(`!b. NINE ** (THREE ** b) XOR8 E_HEX ** (TWO ** b) XOR8 
      B_HEX ** b XOR8 D_HEX ** b
        =
    b`,
 PGEN_TAC (Term `(b0,b1,b2,b3,b4,b5,b6,b7):word8`) THEN EVAL_TAC
   THEN REWRITE_TAC [REWRITE_RULE [ZERO_def] XOR8_ZERO]
   THEN Cases_on `b0`
   THEN Cases_on `b1`
   THEN Cases_on `b2`
   THEN Cases_on `b3`
   THEN Cases_on `b4`
   THEN Cases_on `b5`
   THEN Cases_on `b6`
   THEN Cases_on `b7` THEN EVAL_TAC);


val lemma_b3 = Q.prove
(`!c. NINE ** c XOR8 E_HEX ** (THREE ** c) XOR8 
      B_HEX ** (TWO ** c) XOR8 D_HEX ** c
        =
    ZERO`,
 PGEN_TAC (Term `(c0,c1,c2,c3,c4,c5,c6,c7):word8`) THEN EVAL_TAC
   THEN REWRITE_TAC [REWRITE_RULE [ZERO_def] XOR8_ZERO]
   THEN Cases_on `c0`
   THEN Cases_on `c1`
   THEN Cases_on `c2`
   THEN Cases_on `c3`
   THEN Cases_on `c4`
   THEN Cases_on `c5`
   THEN Cases_on `c6`
   THEN Cases_on `c7` THEN EVAL_TAC);

val lemma_b4 = Count.apply Q.prove
(`!d. NINE ** d XOR8 E_HEX ** d XOR8 
      B_HEX ** (THREE ** d) XOR8 D_HEX ** (TWO ** d)
        =
    ZERO`,
 PGEN_TAC (Term `(d0,d1,d2,d3,d4,d5,d6,d7):word8`) THEN EVAL_TAC
   THEN REWRITE_TAC [REWRITE_RULE [ZERO_def] XOR8_ZERO]
   THEN Cases_on `d0`
   THEN Cases_on `d1`
   THEN Cases_on `d2`
   THEN Cases_on `d3`
   THEN Cases_on `d4`
   THEN Cases_on `d5`
   THEN Cases_on `d6`
   THEN Cases_on `d7` THEN EVAL_TAC);

val lemma_c1 = Q.prove
(`!a. D_HEX ** (TWO ** a) XOR8 NINE ** a  XOR8 
      E_HEX ** a XOR8 B_HEX  ** (THREE ** a) = ZERO`,
 PGEN_TAC (Term `(a0,a1,a2,a3,a4,a5,a6,a7):word8`) THEN EVAL_TAC
   THEN REWRITE_TAC [REWRITE_RULE [ZERO_def] XOR8_ZERO]
   THEN Cases_on `a0`
   THEN Cases_on `a1`
   THEN Cases_on `a2`
   THEN Cases_on `a3`
   THEN Cases_on `a4`
   THEN Cases_on `a5`
   THEN Cases_on `a6`
   THEN Cases_on `a7` THEN EVAL_TAC);

val lemma_c2 = Q.prove
(`!b. D_HEX ** (THREE ** b) XOR8 NINE ** (TWO ** b) XOR8 
      E_HEX ** b XOR8 B_HEX ** b
        =
    ZERO`,
 PGEN_TAC (Term `(b0,b1,b2,b3,b4,b5,b6,b7):word8`) THEN EVAL_TAC
   THEN REWRITE_TAC [REWRITE_RULE [ZERO_def] XOR8_ZERO]
   THEN Cases_on `b0`
   THEN Cases_on `b1`
   THEN Cases_on `b2`
   THEN Cases_on `b3`
   THEN Cases_on `b4`
   THEN Cases_on `b5`
   THEN Cases_on `b6`
   THEN Cases_on `b7` THEN EVAL_TAC);


val lemma_c3 = Q.prove
(`!c. D_HEX ** c XOR8 NINE ** (THREE ** c) XOR8 
      E_HEX ** (TWO ** c) XOR8 B_HEX ** c
        =
    c`,
 PGEN_TAC (Term `(c0,c1,c2,c3,c4,c5,c6,c7):word8`) THEN EVAL_TAC
   THEN REWRITE_TAC [REWRITE_RULE [ZERO_def] XOR8_ZERO]
   THEN Cases_on `c0`
   THEN Cases_on `c1`
   THEN Cases_on `c2`
   THEN Cases_on `c3`
   THEN Cases_on `c4`
   THEN Cases_on `c5`
   THEN Cases_on `c6`
   THEN Cases_on `c7` THEN EVAL_TAC);

val lemma_c4 = Count.apply Q.prove
(`!d. D_HEX ** d XOR8 NINE ** d XOR8 
      E_HEX ** (THREE ** d) XOR8 B_HEX ** (TWO ** d)
        =
    ZERO`,
 PGEN_TAC (Term `(d0,d1,d2,d3,d4,d5,d6,d7):word8`) THEN EVAL_TAC
   THEN REWRITE_TAC [REWRITE_RULE [ZERO_def] XOR8_ZERO]
   THEN Cases_on `d0`
   THEN Cases_on `d1`
   THEN Cases_on `d2`
   THEN Cases_on `d3`
   THEN Cases_on `d4`
   THEN Cases_on `d5`
   THEN Cases_on `d6`
   THEN Cases_on `d7` THEN EVAL_TAC);

val lemma_d1 = Q.prove
(`!a. B_HEX ** (TWO ** a) XOR8 D_HEX ** a  XOR8 
      NINE ** a XOR8 E_HEX  ** (THREE ** a) = ZERO`,
 PGEN_TAC (Term `(a0,a1,a2,a3,a4,a5,a6,a7):word8`) THEN EVAL_TAC
   THEN REWRITE_TAC [REWRITE_RULE [ZERO_def] XOR8_ZERO]
   THEN Cases_on `a0`
   THEN Cases_on `a1`
   THEN Cases_on `a2`
   THEN Cases_on `a3`
   THEN Cases_on `a4`
   THEN Cases_on `a5`
   THEN Cases_on `a6`
   THEN Cases_on `a7` THEN EVAL_TAC);

val lemma_d2 = Q.prove
(`!b. B_HEX ** (THREE ** b) XOR8 D_HEX ** (TWO ** b) XOR8 
      NINE ** b XOR8 E_HEX ** b
        =
    ZERO`,
 PGEN_TAC (Term `(b0,b1,b2,b3,b4,b5,b6,b7):word8`) THEN EVAL_TAC
   THEN REWRITE_TAC [REWRITE_RULE [ZERO_def] XOR8_ZERO]
   THEN Cases_on `b0`
   THEN Cases_on `b1`
   THEN Cases_on `b2`
   THEN Cases_on `b3`
   THEN Cases_on `b4`
   THEN Cases_on `b5`
   THEN Cases_on `b6`
   THEN Cases_on `b7` THEN EVAL_TAC);


val lemma_d3 = Q.prove
(`!c. B_HEX ** c XOR8 D_HEX ** (THREE ** c) XOR8 
      NINE ** (TWO ** c) XOR8 E_HEX ** c
        =
    ZERO`,
 PGEN_TAC (Term `(c0,c1,c2,c3,c4,c5,c6,c7):word8`) THEN EVAL_TAC
   THEN REWRITE_TAC [REWRITE_RULE [ZERO_def] XOR8_ZERO]
   THEN Cases_on `c0`
   THEN Cases_on `c1`
   THEN Cases_on `c2`
   THEN Cases_on `c3`
   THEN Cases_on `c4`
   THEN Cases_on `c5`
   THEN Cases_on `c6`
   THEN Cases_on `c7` THEN EVAL_TAC);

val lemma_d4 = Count.apply Q.prove
(`!d. B_HEX ** d XOR8 D_HEX ** d XOR8 
      NINE ** (THREE ** d) XOR8 E_HEX ** (TWO ** d)
        =
    d`,
 PGEN_TAC (Term `(d0,d1,d2,d3,d4,d5,d6,d7):word8`) THEN EVAL_TAC
   THEN REWRITE_TAC [REWRITE_RULE [ZERO_def] XOR8_ZERO]
   THEN Cases_on `d0`
   THEN Cases_on `d1`
   THEN Cases_on `d2`
   THEN Cases_on `d3`
   THEN Cases_on `d4`
   THEN Cases_on `d5`
   THEN Cases_on `d6`
   THEN Cases_on `d7` THEN EVAL_TAC);

(* set up AC rewriting for XOR8 *)
val [c,a] = CONJUNCTS XOR8_AC;
val a' = GSYM a;
val ss = simpLib.SIMPSET{convs = [], rewrs = [], ac = [(a',c)],
          filter = NONE, dprocs = [], congs = []};
val sset = simpLib.mk_simpset [ss];

(*---------------------------------------------------------------------------*)
(* The following is hideous to prove without ordered rewriting               *)
(*---------------------------------------------------------------------------*)

val rearrange_xors = Q.prove   
(`(a1 XOR8 b1 XOR8 c1 XOR8 d1) XOR8
  (a2 XOR8 b2 XOR8 c2 XOR8 d2) XOR8
  (a3 XOR8 b3 XOR8 c3 XOR8 d3) XOR8
  (a4 XOR8 b4 XOR8 c4 XOR8 d4) 
     = 
  (a1 XOR8 a2 XOR8 a3 XOR8 a4) XOR8
  (b1 XOR8 b2 XOR8 b3 XOR8 b4) XOR8
  (c1 XOR8 c2 XOR8 c3 XOR8 c4) XOR8
  (d1 XOR8 d2 XOR8 d3 XOR8 d4)`,
CONV_TAC (LHS_CONV (SIMP_CONV sset [])) THEN
CONV_TAC (RHS_CONV (SIMP_CONV sset [])) THEN REFL_TAC);

val mix_lemma1 = Q.prove
(`!a b c d. 
   (E_HEX ** ((TWO ** a) XOR8 (THREE ** b) XOR8 c XOR8 d)) XOR8
   (B_HEX ** (a XOR8 (TWO ** b) XOR8 (THREE ** c) XOR8 d)) XOR8
   (D_HEX ** (a XOR8 b XOR8 (TWO ** c) XOR8 (THREE ** d))) XOR8
   (NINE  ** ((THREE ** a) XOR8 b XOR8 c XOR8 (TWO ** d)))
        =
    a`,
 RW_TAC std_ss [PolyMultDistrib] 
   THEN ONCE_REWRITE_TAC [rearrange_xors] 
   THEN RW_TAC std_ss [lemma_a1,lemma_a2,lemma_a3,lemma_a4,XOR8_ZERO]);

val mix_lemma2 = Q.prove
(`!a b c d. 
   (NINE ** ((TWO ** a) XOR8 (THREE ** b) XOR8 c XOR8 d)) XOR8
   (E_HEX ** (a XOR8 (TWO ** b) XOR8 (THREE ** c) XOR8 d)) XOR8
   (B_HEX ** (a XOR8 b XOR8 (TWO ** c) XOR8 (THREE ** d))) XOR8
   (D_HEX ** ((THREE ** a) XOR8 b XOR8 c XOR8 (TWO ** d)))
        =
    b`,
 RW_TAC std_ss [PolyMultDistrib] 
   THEN ONCE_REWRITE_TAC [rearrange_xors] 
   THEN RW_TAC std_ss [lemma_b1,lemma_b2,lemma_b3,lemma_b4,
                       XOR8_ZERO, ONCE_REWRITE_RULE [XOR8_AC] XOR8_ZERO]);

val mix_lemma3 = Q.prove
(`!a b c d. 
   (D_HEX ** ((TWO ** a) XOR8 (THREE ** b) XOR8 c XOR8 d)) XOR8
   (NINE ** (a XOR8 (TWO ** b) XOR8 (THREE ** c) XOR8 d)) XOR8
   (E_HEX ** (a XOR8 b XOR8 (TWO ** c) XOR8 (THREE ** d))) XOR8
   (B_HEX ** ((THREE ** a) XOR8 b XOR8 c XOR8 (TWO ** d)))
        =
    c`,
 RW_TAC std_ss [PolyMultDistrib] 
   THEN ONCE_REWRITE_TAC [rearrange_xors] 
   THEN RW_TAC std_ss [lemma_c1,lemma_c2,lemma_c3,lemma_c4,
                       XOR8_ZERO, ONCE_REWRITE_RULE [XOR8_AC] XOR8_ZERO]);

val mix_lemma4 = Q.prove
(`!a b c d. 
   (B_HEX ** ((TWO ** a) XOR8 (THREE ** b) XOR8 c XOR8 d)) XOR8
   (D_HEX ** (a XOR8 (TWO ** b) XOR8 (THREE ** c) XOR8 d)) XOR8
   (NINE ** (a XOR8 b XOR8 (TWO ** c) XOR8 (THREE ** d))) XOR8
   (E_HEX ** ((THREE ** a) XOR8 b XOR8 c XOR8 (TWO ** d)))
        =
    d`,
 RW_TAC std_ss [PolyMultDistrib] 
   THEN ONCE_REWRITE_TAC [rearrange_xors] 
   THEN RW_TAC std_ss [lemma_d1,lemma_d2,lemma_d3,lemma_d4,
                       XOR8_ZERO, ONCE_REWRITE_RULE [XOR8_AC] XOR8_ZERO]);

(*---------------------------------------------------------------------------*)
(* Get the constants of various definitions                                  *)
(*---------------------------------------------------------------------------*)

val [xtime_tm] = decls "xtime";
val [XOR_tm]   = decls "XOR";
val [mult]     = decls "**";
val [B_HEX]    = decls "B_HEX";
val [D_HEX]    = decls "D_HEX";
val [E_HEX]    = decls "E_HEX";
val [NINE]     = decls "NINE";
val [TWO]      = decls "TWO";
val [THREE]    = decls "THREE";

val genMixColumns_def = Define
 `genMixColumns MC (b00,b01,b02,b03,
                    b10,b11,b12,b13,
                    b20,b21,b22,b23,
                    b30,b31,b32,b33)
 = let (b00', b10', b20', b30') = MC (b00,b10,b20,b30) in
   let (b01', b11', b21', b31') = MC (b01,b11,b21,b31) in
   let (b02', b12', b22', b32') = MC (b02,b12,b22,b32) in
   let (b03', b13', b23', b33') = MC (b03,b13,b23,b33)
   in 
    (b00', b01', b02', b03',
     b10', b11', b12', b13',
     b20', b21', b22', b23',
     b30', b31', b32', b33')`;


val MixColumns_def    = Define `MixColumns    = genMixColumns MultCol`;
val InvMixColumns_def = Define `InvMixColumns = genMixColumns InvMultCol`;

val MixColumnsInv = Q.prove
(`!s. genMixColumns InvMultCol (genMixColumns MultCol s) = s`,
 PGEN_TAC (Term `(b00,b01,b02,b03,b10,b11,b12,b13,
                  b20,b21,b22,b23,b30,b31,b32,b33):state`)
  THEN RESTR_EVAL_TAC [mult,B_HEX,D_HEX,E_HEX,TWO,THREE,NINE]
  THEN RW_TAC std_ss [mix_lemma1,mix_lemma2,mix_lemma3,mix_lemma4]);


(*---------------------------------------------------------------------------
    Pairwise XOR the state with the round key
 ---------------------------------------------------------------------------*)

val AddRoundKey_def = Define
 `AddRoundKey 
         (k00,k01,k02,k03,k10,k11,k12,k13,k20,k21,k22,k23,k30,k31,k32,k33)
         (b00,b01,b02,b03,b10,b11,b12,b13,b20,b21,b22,b23,b30,b31,b32,b33)
       =
  (b00 XOR8 k00, b01 XOR8 k01, b02 XOR8 k02, b03 XOR8 k03,
   b10 XOR8 k10, b11 XOR8 k11, b12 XOR8 k12, b13 XOR8 k13, 
   b20 XOR8 k20, b21 XOR8 k21, b22 XOR8 k22, b23 XOR8 k23,
   b30 XOR8 k30, b31 XOR8 k31, b32 XOR8 k32, b33 XOR8 k33)`;


val AddRoundKey_Idemp = Q.prove
(`!v u. AddRoundKey v (AddRoundKey v u) = u`,
 PGEN_TAC (Term `(v0,v1,v2,v3,v4,v5,v6,v7,v8,v9,
                  v10,v11,v12,v13,v14,v15):state`) THEN 
 PGEN_TAC (Term `(u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,
                  u10,u11,u12,u13,u14,u15):state`)
 THEN EVAL_TAC THEN RW_TAC std_ss [XOR_IDEMP]);

(*---------------------------------------------------------------------------
     Generate the key schedule from key. We work using 4-tuples of
     bytes. Unpacking moves from four contiguous 4-tuples to a 16-tuple,
     and also lays the bytes out in the top-to-bottom, left-to-right
     order that the state also has.
 ---------------------------------------------------------------------------*)

val XOR8x4_def = Define `(a,b,c,d) XOR8x4 (a1,b1,c1,d1) 
                                     = 
                                 (a XOR8 a1, 
                                  b XOR8 b1, 
                                  c XOR8 c1, 
                                  d XOR8 d1)`;

val SubWord_def = Define 
 `SubWord(b0,b1,b2,b3) = (Sbox b0, Sbox b1, Sbox b2, Sbox b3)`;

val RotWord_def = Define 
 `RotWord(b0,b1,b2,b3) = (b1,b2,b3,b0)`;

val Rcon_def = Define
 `Rcon i = (PolyExp TWO (i-1), ZERO,ZERO,ZERO)`;

val unpack_def = Define
 `(unpack [] A = A) /\
  (unpack ((a,b,c,d)::(e,f,g,h)::(i,j,k,l)::(m,n,o1,p)::rst) A 
       = unpack rst ((m,i,e,a,n,j,f,b,o1,k,g,c,p,l,h,d)::A))`;

(*---------------------------------------------------------------------------*)
(* This is too specific, but should work for now                             *)
(*---------------------------------------------------------------------------*)

val (expand_def,expand_ind) = Defn.tprove 
 (Hol_defn 
   "expand"
   `expand n sched = 
      if 43 < n then unpack sched []
      else let h = HD sched in 
           let h' = if ~(n MOD 4 = 0) then h
                       else SubWord(RotWord h) XOR8x4 Rcon(n DIV 4)
           in expand (n+1) ((h' XOR8x4 (HD(TL(TL(TL sched)))))::sched)`,
  WF_REL_TAC `measure ($- 44 o FST)`);

val mk_keysched_def = Define
 `mk_keysched ((b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15):key)
    = 
  expand 4 [(b12,b13,b14,b15) ; (b8,b9,b10,b11) ;
            (b4,b5,b6,b7)     ; (b0,b1,b2,b3)]`;


(*---------------------------------------------------------------------------*)
(* This gives a bizarre induction theorem, by fully expanding state to a     *)
(* large tuple of variables. Also, the termination prover should get this    *)
(* one.                                                                      *)
(*                                                                           *)
(* (Round 0 [key] state = AddRoundKey key (ShiftRows (SubBytes state))) /\   *)
(* (Round n (key::keys) state = Round (n-1) keys                             *)
(*                                  (AddRoundKey key (MixColumns             *)
(*                                     (ShiftRows (SubBytes state)))))`;     *)
(*---------------------------------------------------------------------------*)

val (Round_def, Round_ind) = Defn.tprove
 (Hol_defn 
   "Round"
   `Round n keys state = 
     if n=0 
      then (case keys 
             of [key] -> AddRoundKey key (ShiftRows (SubBytes state)))
      else (case keys
             of k0::rst -> Round (n-1) rst
                               (AddRoundKey k0 (MixColumns 
                                     (ShiftRows (SubBytes state)))))`,
  WF_REL_TAC `measure FST`);

(*---------------------------------------------------------------------------*)
(*  (InvRound 0 [key] state = AddRoundKey key                                *)
(*                               (InvSubBytes(InvShiftRows state))) /\       *)
(*  (InvRound n (key::keys) state =                                          *)
(*      InvRound (n-1) keys                                                  *)
(*         (InvMixColumns (AddRoundKey key                                   *)
(*              (InvSubBytes (InvShiftRows state)))))`                       *)
(*---------------------------------------------------------------------------*)

val (InvRound_def,InvRound_ind) = Defn.tprove
 (Hol_defn 
   "Inv_Round"
   `InvRound n keys state =
      if n=0 
       then (case keys 
              of [key] -> AddRoundKey key 
                            (InvSubBytes(InvShiftRows state)))
       else (case keys
              of k0::rst -> InvRound (n-1) rst
                              (InvMixColumns (AddRoundKey k0 
                                (InvSubBytes (InvShiftRows state)))))`,
  WF_REL_TAC `measure FST`);

(*---------------------------------------------------------------------------*)
(* Generate key schedule, and its inverse, then build the encryption and     *)
(* decryption functions.                                                     *)
(*---------------------------------------------------------------------------*)

val preCrypt_def = Define
 `preCrypt key =
   let sched = mk_keysched key in
   let isched = REVERSE sched 
   in
     ((from_state o Round 9 (TL sched) o AddRoundKey (HD sched) o to_state),
      (from_state o InvRound 9 (TL isched) 
                  o AddRoundKey (HD isched) o to_state))`;

(*---------------------------------------------------------------------------*)
(* Example.

key = (0wx00, 0wx01, 0wx02, 0wx03, 0wx04, 0wx05, 0wx06, 0wx07,
       0wx08, 0wx09, 0wx0a, 0wx0b, 0wx0c, 0wx0d, 0wx0e, 0wx0f) : state;

plaintext = (0wx00,0wx11,0wx22,0wx33,0wx44,0wx55,0wx66,0wx77,
             0wx88,0wx99,0wxaa,0wxbb,0wxcc,0wxdd,0wxee,0wxff) : state

ciphertext = (0wx69, 0wxC4, 0wxE0, 0wxD8, 0wx6A, 0wx7B, 0wx4, 0wx30, 
              0wxD8, 0wxCD, 0wxB7, 0wx80, 0wx70, 0wxB4, 0wxC5, 0wx5A) :state;

val key = Term 
   `((F,F,F,F,F,F,F,F),
     (F,F,F,F,F,F,F,T),
     (F,F,F,F,F,F,T,F),
     (F,F,F,F,F,F,T,T),
     (F,F,F,F,F,T,F,F),
     (F,F,F,F,F,T,F,T),
     (F,F,F,F,F,T,T,F),
     (F,F,F,F,F,T,T,T),
     (F,F,F,F,T,F,F,F),
     (F,F,F,F,T,F,F,T),
     (F,F,F,F,T,F,T,F),
     (F,F,F,F,T,F,T,T),
     (F,F,F,F,T,T,F,F),
     (F,F,F,F,T,T,F,T),
     (F,F,F,F,T,T,T,F),
     (F,F,F,F,T,T,T,T)):state`;

val plaintext = Term
  `((F,F,F,F,F,F,F,F),
    (F,F,F,T,F,F,F,T),
    (F,F,T,F,F,F,T,F),
    (F,F,T,T,F,F,T,T),
    (F,T,F,F,F,T,F,F),
    (F,T,F,T,F,T,F,T),
    (F,T,T,F,F,T,T,F),
    (F,T,T,T,F,T,T,T),
    (T,F,F,F,T,F,F,F),
    (T,F,F,T,T,F,F,T),
    (T,F,T,F,T,F,T,F),
    (T,F,T,T,T,F,T,T),
    (T,T,F,F,T,T,F,F),
    (T,T,F,T,T,T,F,T),
    (T,T,T,F,T,T,T,F),
    (T,T,T,T,T,T,T,T)) : state`;


val tm = Term`let (encrypt,decrypt) = preCrypt ^key 
              in decrypt(encrypt ^plaintext) = ^plaintext`;

val thm = Count.apply EVAL tm;

*)
(*---------------------------------------------------------------------------*)


(*---------------------------------------------------------------------------*)
(* Do it symbolically, for all inputs                                        *)
(*---------------------------------------------------------------------------*)

fun upto b t = if b > t then [] else b::upto (b+1) t;
fun gen_word8vars s n = map (fn i => mk_var(s^Int.toString i, Type`:word8`)) 
                            (upto 0 (n-1));
val word8vars = gen_word8vars "v";

fun grab16 [] = []
  | grab16 (h1::h2::h3::h4::h5::h6::h7::h8::
            h9::h10::h11::h12::h13::h14::h15::h16::rst) 
     = pairSyntax.list_mk_pair
         [h1,h2,h3,h4,h5,h6,h7,h8,h9,h10,h11,h12,h13,h14,h15,h16]::grab16 rst
  | grab16 other = raise Fail "grab16: length not a multiple of 16";

val list = grab16(word8vars (16*11));
val ilist = rev list;

val sched = listSyntax.mk_list(list,Type`:state`)
val isched = listSyntax.mk_list(ilist,Type`:state`);
val [plaintext] = grab16(gen_word8vars "s" 16);

val [MultCol] = decls "MultCol";
val [InvMultCol] = decls "InvMultCol";
val [genMixColumns] = decls "genMixColumns";
val [PolyExp] = decls "PolyExp";
val [expand_tm] = decls "expand";
val [SubWord] = decls "SubWord";
val [RotWord] = decls "RotWord";
val [Rcon] = decls "Rcon";
val [XOR8x4] = decls "XOR8x4";
computeLib.monitoring := SOME (same_const expand_tm);

(*---------------------------------------------------------------------------*)
(* expand is tail recursive and adds a new element to its accumulator at     *)
(* recursive call.                                                           *)
(*---------------------------------------------------------------------------*)

val lemma = Q.prove
(`!n l a1 a2 a3 a4 t. 
    3 < n /\ n < 44 /\ (l = a1::a2::a3::a4::t)
      ==> 
    ?h. expand (n+1) (h::l) = expand n l`,
 recInduct expand_ind
   THEN RW_TAC list_ss []
   THEN GEN_REWRITE_TAC (BINDER_CONV o RHS_CONV) empty_rewrites [expand_def]
   THEN BasicProvers.NORM_TAC list_ss [] 
   THEN PROVE_TAC []);

(*---------------------------------------------------------------------------*)
(* Need special purpose proof support for next lemma.                        *)
(*---------------------------------------------------------------------------*)

fun inst_lemma_tac i (asl,w) =
  let open numSyntax boolSyntax
      val j = term_of_int i
      val num_eq = DECIDE (Term `^j + 1 = ^(term_of_int (i+1))`)
      val ineq   = DECIDE (Term `3 < ^j /\ ^j < 44`)
      val lem = GSYM (simpLib.SIMP_RULE std_ss [num_eq,ineq] (SPEC j lemma))
      val pat = lhs(snd(dest_exists(snd(strip_forall (concl lem)))))
      val theta = match_term pat (find_term (can (match_term pat)) w)
  in
    CHOOSE_THEN (fn th => PURE_REWRITE_TAC [th]) 
                (INST (fst theta) (SPEC_ALL lem)) (asl,w)
  end;

val expand_4_lemma = Lib.with_flag(Globals.priming,SOME "")
Q.prove
 (`!a b c d.
   ?h1 h2 h3 h4 h5 h6 h7 h8 h9 h10
    h11 h12 h13 h14 h15 h16 h17 h18 h19 h20 
    h21 h22 h23 h24 h25 h26 h27 h28 h29 h30
    h31 h32 h33 h34 h35 h36 h37 h38 h39 h40. 
     expand 44 [h40;h39;h38;h37;h36;h35;h34;h33;h32;h31;h30;h29;h28;
                 h27;h26;h25;h24;h23;h22;h21;h20;h19;h18;h17;h16;h15;
                 h14;h13;h12;h11;h10;h9;h8;h7;h6;h5;h4;h3;h2;h1;a;b;c;d]
        = 
     expand 4 [a;b;c;d]`,
  REPEAT GEN_TAC 
    THEN EVERY (map inst_lemma_tac (upto 4 43)) 
    THEN PROVE_TAC []);

(*---------------------------------------------------------------------------*)
(* Surprisingly complicated to calculate the length of the list produced by  *)
(* mk_keysched.                                                               *)
(*---------------------------------------------------------------------------*)

val keysched_length = Q.prove
(`!key. LENGTH (mk_keysched key) = 11`,
 PGEN_TAC (Term `(b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15):key`) 
  THEN REWRITE_TAC [mk_keysched_def]
  THEN STRIP_ASSUME_TAC 
       (GSYM (Q.SPECL [`(b12,b13,b14,b15)`, `(b8,b9,b10,b11)`, 
                       `(b4,b5,b6,b7)`,     `(b0,b1,b2,b3)`] expand_4_lemma))
  THEN ASM_REWRITE_TAC[]
  THEN POP_ASSUM (K ALL_TAC)
  THEN EVAL_TAC
  THEN MAP_EVERY Q.ID_SPEC_TAC  
   [`h1`, `h2`, `h3`, `h4`, `h5`, `h6`, `h7`, `h8`, `h9`, `h10`,
    `h11`, `h12`, `h13`, `h14`, `h15`, `h16`, `h17`, `h18`, `h19`, `h20`, 
    `h21`, `h22`, `h23`, `h24`, `h25`, `h26`, `h27`, `h28`, `h29`, `h30`,
    `h31`, `h32`, `h33`, `h34`, `h35`, `h36`, `h37`, `h38`, `h39`, `h40`]
  THEN PGEN_TAC (Term`(h1a,h1b,h1c,h1d):w8x4`)
  THEN PGEN_TAC (Term`(h2a,h2b,h2c,h2d):w8x4`)
  THEN PGEN_TAC (Term`(h3a,h3b,h3c,h3d):w8x4`)
  THEN PGEN_TAC (Term`(h4a,h4b,h4c,h4d):w8x4`)
  THEN PGEN_TAC (Term`(h5a,h5b,h5c,h5d):w8x4`)
  THEN PGEN_TAC (Term`(h6a,h6b,h6c,h6d):w8x4`)
  THEN PGEN_TAC (Term`(h7a,h7b,h7c,h7d):w8x4`)
  THEN PGEN_TAC (Term`(h8a,h8b,h8c,h8d):w8x4`)
  THEN PGEN_TAC (Term`(h9a,h9b,h9c,h9d):w8x4`)
  THEN PGEN_TAC (Term`(h10a,h10b,h10c,h10d):w8x4`)
  THEN PGEN_TAC (Term`(h11a,h11b,h11c,h11d):w8x4`)
  THEN PGEN_TAC (Term`(h12a,h12b,h12c,h12d):w8x4`)
  THEN PGEN_TAC (Term`(h13a,h13b,h13c,h13d):w8x4`)
  THEN PGEN_TAC (Term`(h14a,h14b,h14c,h14d):w8x4`)
  THEN PGEN_TAC (Term`(h15a,h15b,h15c,h15d):w8x4`)
  THEN PGEN_TAC (Term`(h16a,h16b,h16c,h16d):w8x4`)
  THEN PGEN_TAC (Term`(h17a,h17b,h17c,h17d):w8x4`)
  THEN PGEN_TAC (Term`(h18a,h18b,h18c,h18d):w8x4`)
  THEN PGEN_TAC (Term`(h19a,h19b,h19c,h19d):w8x4`)
  THEN PGEN_TAC (Term`(h20a,h20b,h20c,h20d):w8x4`)
  THEN PGEN_TAC (Term`(h21a,h21b,h21c,h21d):w8x4`)
  THEN PGEN_TAC (Term`(h22a,h22b,h22c,h22d):w8x4`)
  THEN PGEN_TAC (Term`(h23a,h23b,h23c,h23d):w8x4`)
  THEN PGEN_TAC (Term`(h24a,h24b,h24c,h24d):w8x4`)
  THEN PGEN_TAC (Term`(h25a,h25b,h25c,h25d):w8x4`)
  THEN PGEN_TAC (Term`(h26a,h26b,h26c,h26d):w8x4`)
  THEN PGEN_TAC (Term`(h27a,h27b,h27c,h27d):w8x4`)
  THEN PGEN_TAC (Term`(h28a,h28b,h28c,h28d):w8x4`)
  THEN PGEN_TAC (Term`(h29a,h29b,h29c,h29d):w8x4`)
  THEN PGEN_TAC (Term`(h30a,h30b,h30c,h30d):w8x4`)
  THEN PGEN_TAC (Term`(h31a,h31b,h31c,h31d):w8x4`)
  THEN PGEN_TAC (Term`(h32a,h32b,h32c,h32d):w8x4`)
  THEN PGEN_TAC (Term`(h33a,h33b,h33c,h33d):w8x4`)
  THEN PGEN_TAC (Term`(h34a,h34b,h34c,h34d):w8x4`)
  THEN PGEN_TAC (Term`(h35a,h35b,h35c,h35d):w8x4`)
  THEN PGEN_TAC (Term`(h36a,h36b,h36c,h36d):w8x4`)
  THEN PGEN_TAC (Term`(h37a,h37b,h37c,h37d):w8x4`)
  THEN PGEN_TAC (Term`(h38a,h38b,h38c,h38d):w8x4`)
  THEN PGEN_TAC (Term`(h39a,h39b,h39c,h39d):w8x4`)
  THEN PGEN_TAC (Term`(h40a,h40b,h40c,h40d):w8x4`)
  THEN EVAL_TAC);

val length_11 = 
 Lib.with_flag(Globals.priming,SOME "")
  Q.prove
 (`!l. (LENGTH l = 11) = 
       ?h1 h2 h3 h4 h5 h6 h7 h8 h9 h10 h11.
         l = [h1;h2;h3;h4;h5;h6;h7;h8;h9;h10;h11]`,
 GEN_TAC THEN EQ_TAC THENL
 [Cases_on `l`  THEN EVAL_TAC THEN
  Cases_on `t`  THEN EVAL_TAC THEN
  Cases_on `t1` THEN EVAL_TAC THEN
  Cases_on `t`  THEN EVAL_TAC THEN
  Cases_on `t1` THEN EVAL_TAC THEN
  Cases_on `t`  THEN EVAL_TAC THEN
  Cases_on `t1` THEN EVAL_TAC THEN
  Cases_on `t`  THEN EVAL_TAC THEN
  Cases_on `t1` THEN EVAL_TAC THEN
  Cases_on `t`  THEN EVAL_TAC THEN
  Cases_on `t1` THEN EVAL_TAC THEN
  Cases_on `t`  THEN EVAL_TAC THENL
  [PROVE_TAC [], DECIDE_TAC],
 RW_TAC list_ss [] THEN EVAL_TAC]);


val lemma = Q.prove
(`!plaintext : state. 
  !sched rsched:state list. 
    (LENGTH sched = 11) /\ (rsched = REVERSE sched)
        ==>
    ((from_state
       o InvRound 9 (TL rsched) 
       o AddRoundKey (HD rsched) 
       o to_state
       o from_state
       o Round 9 (TL sched) 
       o AddRoundKey (HD sched) 
       o to_state) plaintext = plaintext)`,
 PGEN_TAC plaintext 
   THEN RW_TAC std_ss [length_11]
   THEN RESTR_EVAL_TAC [MultCol,InvMultCol,genMixColumns]
   THEN RW_TAC std_ss [ShiftRows_Inversion,SubBytes_Inversion,
                       AddRoundKey_Idemp,MixColumnsInv,
                       from_state_Inversion,from_state_def]);


(*---------------------------------------------------------------------------*)
(* Basic theorem about encryption/decryption                                 *)
(*---------------------------------------------------------------------------*)

val RijndaelCorrect = Q.prove
(`!key plaintext. 
     let (encrypt,decrypt) = preCrypt key 
     in 
       decrypt (encrypt plaintext) = plaintext`,
 RW_TAC std_ss [preCrypt_def,GSYM combinTheory.o_ASSOC] THEN
 RW_TAC std_ss [combinTheory.o_THM] THEN
 PROVE_TAC [SIMP_RULE std_ss [combinTheory.o_THM] lemma, keysched_length]);

(*---------------------------------------------------------------------------*)
(* Inference summary                                                         *)
(*---------------------------------------------------------------------------*)

Count.report (Count.read meter);
