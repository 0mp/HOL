(*---------------------------------------------------------------------------*)
(* Alternative decryption approach and its correctness                       *)
(*---------------------------------------------------------------------------*)

use "rijn";

(*---------------------------------------------------------------------------*)
(* Map InvMixColumns over the keyschedule before embarking on the            *)
(* alternative inverse round computation. However, do not alter the first or *)
(* last element of the keyschedule.                                          *)
(*---------------------------------------------------------------------------*)

val InvMix_def = Define 
   `(InvMix [x] = [x]) /\
    (InvMix (h::t) = InvMixColumns h::InvMix t)`;

val InvMixify_def = Define 
   `InvMixify (h::t) = h::InvMix t`;


(*---------------------------------------------------------------------------*)
(* Alternative inverse rounds                                                *)
(*                                                                           *)
(*  EqInvRound 0 [key] state = AddRoundKey key                               *)
(*                               (InvShiftRows                               *)
(*                                 (InvSubBytes state)))                     *)
(*  EqInvRound n (key::keys) state =                                         *)
(*      EqInvRound (n-1) keys                                                *)
(*         (AddRoundKey key                                                  *)
(*           (InvMixColumns                                                  *)
(*             (InvShiftRows                                                 *)
(*               (InvSubBytes state))))                                      *)
(*---------------------------------------------------------------------------*)

val (EqInvRound_def,EqInvRound_ind) = Defn.tprove
 (Hol_defn 
   "EqInvRound"
   `EqInvRound n keys state =
      if n=0 
       then (case keys 
              of [key] -> AddRoundKey key 
                            (InvShiftRows 
                               (InvSubBytes(state))))
       else (case keys
              of k::rst -> EqInvRound (n-1) rst
                              (AddRoundKey k 
                                (InvMixColumns 
                                  (InvShiftRows
                                     (InvSubBytes state)))))`,
  WF_REL_TAC `measure FST`);

(*---------------------------------------------------------------------------*)
(* Grab some constants                                                       *)
(*---------------------------------------------------------------------------*)

val [InvMixColumns] = decls "InvMixColumns";
val [InvShiftRows]  = decls "InvShiftRows";
val [InvSubBytes]   = decls "InvSubBytes";
val [AddRoundKey]   = decls "AddRoundKey";

(*---------------------------------------------------------------------------*)
(* Prove the equivalence of the alternative scheme                           *)
(*---------------------------------------------------------------------------*)

val Equiv_lemma = Q.prove
(`!sched sched' : state list.
      (LENGTH sched = 11) /\ (sched' = InvMixify sched)
      ==> 
       (EqInvRound 9 (TL sched') o AddRoundKey (HD sched')
         =
        InvRound 9 (TL sched) o AddRoundKey (HD sched))`,
  RW_TAC std_ss [] THEN CONV_TAC FUN_EQ_CONV THEN GEN_TAC 
    THEN POP_ASSUM MP_TAC 
    THEN RW_TAC std_ss [length_11]
    THEN RW_TAC list_ss [InvMixify_def]
    THEN MATCH_MP_TAC (PROVE [combinTheory.o_THM] 
           (Term `(!s:state. f s = g s) ==> ((f o h) s = (g o h) s)`))
    THEN RESTR_EVAL_TAC [InvMixColumns,InvShiftRows,AddRoundKey,InvSubBytes]
    THEN RW_TAC std_ss [InvShiftRows_InvSubBytes_Commute,
                        GSYM InvMixColumns_Distrib]);

val LENGTH_REVERSE = Q.prove
(`!l. LENGTH(REVERSE l) = LENGTH l`,
 Induct THEN RW_TAC list_ss []);

(*---------------------------------------------------------------------------*)
(* Encrypt as in preCrypt, but use alternative decryptor.                    *)
(*---------------------------------------------------------------------------*)

val preCryptAlt_def = Define
 `preCryptAlt key =
   let sched = mk_keysched key in
   let isched = InvMixify (REVERSE sched)
   in
     ((from_state o Round 9 (TL sched) 
                  o AddRoundKey (HD sched) o to_state),
      (from_state o EqInvRound 9 (TL isched) 
                  o AddRoundKey (HD isched) o to_state))`;

(*---------------------------------------------------------------------------*)
(* Equality of preCrypt and preCryptAlt                                      *)
(*---------------------------------------------------------------------------*)

val preCryptAlt_eq_preCrypt = Q.prove
(`!k. preCryptAlt k = preCrypt k`,
 RW_TAC std_ss [preCryptAlt_def, preCrypt_def] THEN
 RW_TAC std_ss
    [PROVE [combinTheory.o_THM] (Term `(f=g) ==> (h o f = h o g)`),
     PROVE [combinTheory.o_THM] (Term `(f=g) ==> (f o h = g o h)`),
     combinTheory.o_ASSOC, Equiv_lemma,LENGTH_REVERSE,keysched_length]);

(*---------------------------------------------------------------------------*)
(* Hence correctness of alternative decryptor                                *)
(*---------------------------------------------------------------------------*)

val RijndaelAlt_Correct = 
 Q.prove
  (`!key plaintext. 
       let (encrypt,decrypt) = preCryptAlt key 
       in 
         decrypt (encrypt plaintext) = plaintext`,
   RW_TAC std_ss [Rijndael_Correct,preCryptAlt_eq_preCrypt]);
