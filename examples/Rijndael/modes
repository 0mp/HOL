(*---------------------------------------------------------------------------*)
(* Modes of operation                                                        *)
(* ECB, CBC, CFB, CFB, CTR                                                   *)
(*---------------------------------------------------------------------------*)

app load ["aesTheory", "metisLib", "intLib"];

val _ = quietdec := true;
open aesTheory RoundOpTheory pairTools metisLib 
     listTheory arithmeticTheory;
val _ = quietdec := false;

numLib.prefer_num();
Globals.priming := SOME "";   (* rename variables with number suffixes *)

(*---------------------------------------------------------------------------*)
(* Make list append into an infix recognized by the parser                   *)
(*---------------------------------------------------------------------------*)

val _ = set_fixity "<>" (Infixl 500);
val _ = overload_on ("<>", Term`APPEND`);

(*---------------------------------------------------------------------------*)
(* Generally useful stuff                                                    *)
(*---------------------------------------------------------------------------*)

val ADD_MODULUS = Q.prove
(`!n x. 0 < n ==> ((x + n) MOD n = x MOD n)`,
 METIS_TAC [MOD_PLUS,DIVMOD_ID,MOD_MOD,ADD_CLAUSES]);

val BOUNDED_CASES = Q.prove
(`!c. 0<c ==> ((!n. n < c ==> P n) = P (c-1) /\ !n. n < (c-1) ==> P n)`,
 RW_TAC std_ss [] THEN EQ_TAC 
   THEN RW_TAC arith_ss []
   THEN `n <= c - 1` by DECIDE_TAC 
   THEN FULL_SIMP_TAC arith_ss [arithmeticTheory.LESS_OR_EQ]);

(*---------------------------------------------------------------------------*)
(* If "c" is a number constant,                                              *)
(*                                                                           *)
(*    BOUNDED_CASES_CONV cnv `!n. n < c ==> P n`                             *)
(*                                                                           *)
(* generates "P (c-1) /\ !n. < (c-1) ==> P n"  and applies cnv to the first  *)
(* conjunct "P (c-1)". With NTAC or REPEATC, this can be used to prove       *)
(* bounded quantifications.                                                  *)
(*---------------------------------------------------------------------------*)

fun BOUNDED_CASES_CONV cnv M = 
 let open numSyntax
     val c = snd(dest_less(fst(dest_imp(snd(dest_forall M)))))
     val thm = MP (SPEC c BOUNDED_CASES) 
                  (EQT_ELIM(reduceLib.REDUCE_CONV (mk_less(zero_tm,c))))
     val thm1 = (HO_REWR_CONV thm THENC LAND_CONV cnv
                                  THENC reduceLib.REDUCE_CONV) M
 in thm1
 end; 

(*---------------------------------------------------------------------------*)
(* Electronic Code Book. We define it parameterized by an encoding function, *)
(* which can also be a decoding function.                                    *)
(*---------------------------------------------------------------------------*)

val ECB_def = TotalDefn.DefineSchema
   `(ECB [] = []) /\
    (ECB (h::t) = enc h::ECB t)`;

val ECB_Correct = Q.prove
(`!l key. ((encoder,decoder) = AES key) 
           ==> 
          (ECB decoder (ECB encoder l) = l)`,
 Induct THEN PROVE_TAC [AES_Correct,ECB_def]);

(*---------------------------------------------------------------------------*)
(* Misc. stuff, should appear earlier in theory hierarchy                    *)
(*---------------------------------------------------------------------------*)

val XOR_16X8_def = Define `XOR_16X8 = AddRoundKey`;

val XOR_16X8_THM = Q.prove
 (`XOR_16X8 ((a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15):state)
            ((b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15):state)
       =
      (a0 XOR8 b0,   a1 XOR8 b1,   a2 XOR8 b2,   a3 XOR8 b3,
       a4 XOR8 b4,   a5 XOR8 b5,   a6 XOR8 b6,   a7 XOR8 b7,
       a8 XOR8 b8,   a9 XOR8 b9,   a10 XOR8 b10, a11 XOR8 b11,
       a12 XOR8 b12, a13 XOR8 b13, a14 XOR8 b14, a15 XOR8 b15):state`,
  SRW_TAC [simpLib.ac_ss [(CONJUNCT1 XOR8_AC,CONJUNCT2 XOR8_AC)]] 
          [XOR_16X8_def,AddRoundKey_def]);
  
val XOR_16X8_IDEM = Q.store_thm
("XOR_16X8_IDEM",
 `!v u. XOR_16X8 (XOR_16X8 v u) u = v`,
 PGEN_TAC (Term `(v0,v1,v2,v3,v4,v5,v6,v7,v8,v9,
                  v10,v11,v12,v13,v14,v15):state`) THEN 
 PGEN_TAC (Term `(u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,
                  u10,u11,u12,u13,u14,u15):state`)
 THEN EVAL_TAC
 THEN PROVE_TAC [XOR8_INV,XOR8_ZERO, XOR8_AC]);

  
(*---------------------------------------------------------------------------*)
(* Cipher Block Chaining.                                                    *)
(*---------------------------------------------------------------------------*)

val (CBC_ENC_def,_) = Defn.tprove (Defn.Hol_defn 
    "CBC_ENC"
   `(CBC_ENC __ [] : state list = []) /\
    (CBC_ENC v (h::t) = let x = enc (XOR_16X8 h v) in x::CBC_ENC x t)`,
 WF_REL_TAC `measure (LENGTH o SND)` THEN RW_TAC list_ss []);


val (CBC_DEC_def,_) = Defn.tprove (Defn.Hol_defn 
    "CBC_DEC"
   `(CBC_DEC __ [] : state list = []) /\
    (CBC_DEC v (h::t) = XOR_16X8 (dec h) v :: CBC_DEC h t)`,
 WF_REL_TAC `measure (LENGTH o SND)` THEN RW_TAC list_ss []);


val CBC_Correct = Q.prove
(`!l key v. ((encrypt,decrypt) = AES key) 
           ==> 
          (CBC_DEC decrypt v (CBC_ENC encrypt v l) = l)`,
 Induct THEN RW_TAC std_ss [CBC_ENC_def,CBC_DEC_def] THENL
 [PROVE_TAC [AES_Correct,XOR_16X8_IDEM],
  PROVE_TAC []]);


(*---------------------------------------------------------------------------*)
(* CFB, OFB, CTR still to come                                               *)
(*---------------------------------------------------------------------------*)



(*---------------------------------------------------------------------------*)
(* Padding                                                                   *)
(*---------------------------------------------------------------------------*)

val (NUM_TO_BITS_def,NUM_TO_BITS_ind) = 
 Defn.tprove(Hol_defn 
   "NUM_TO_BITS"
   `NUM_TO_BITS n l = 
      if n = 0 then l else
      if EVEN n then NUM_TO_BITS (n DIV 2) (F::l) 
                else NUM_TO_BITS (n DIV 2) (T::l)`,
  WF_REL_TAC `measure FST` THEN 
  RW_TAC arith_ss [arithmeticTheory.DIV_LESS]);

val BITS_OF_def = Define `BITS_OF n = if n = 0 then [F] else NUM_TO_BITS n []`;

val BITS_TO_NUM = Define `BITS_TO_NUM = FOLDL (\sum b. B2N(b) + 2*sum)`;

val NUM_OF_def  = Define `NUM_OF l = BITS_TO_NUM 0 l`;

g`!n. NUM_OF (BITS_OF n) = n`;
g`!l. ~NULL l ==> (BITS_OF (NUM_OF l) = l)`;


val NUM_TO_BYTE = Define
   `NUM_TO_BYTE n7 =
      let n6 = n7 DIV 2 in 
      let n5 = n6 DIV 2 in 
      let n4 = n5 DIV 2 in 
      let n3 = n4 DIV 2 in 
      let n2 = n3 DIV 2 in 
      let n1 = n2 DIV 2 in 
      let n0 = n1 DIV 2 
      in
        (ODD n0, ODD n1, ODD n2, ODD n3, 
         ODD n4, ODD n5, ODD n6, ODD n7)`; 
     
val lemma = Q.prove
(`!b7 b6 b5 b4 b3 b2 b1 b0. 
   NUM_TO_BYTE 
      (BYTE_TO_NUM (b7,b6,b5,b4,b3,b2,b1,b0)) = (b7,b6,b5,b4,b3,b2,b1,b0)`,
  REPEAT Cases THEN EVAL_TAC);

val BYTE_TO_NUM_TO_BYTE = Q.prove
(`!b. NUM_TO_BYTE(BYTE_TO_NUM b) = b`,
  METIS_TAC [lemma, pairTheory.ABS_PAIR_THM]);

   
val NUM_TO_BYTE_TO_NUM = Q.prove
(`!n. n < 256 ==> (BYTE_TO_NUM (NUM_TO_BYTE n) = n)`,
 CONV_TAC (REPEATC (BOUNDED_CASES_CONV EVAL)) THEN PROVE_TAC []);

val BYTE_TO_LIST_def = Define
   `BYTE_TO_LIST (b7,b6,b5,b4,b3,b2,b1,b0) = [b7;b6;b5;b4;b3;b2;b1;b0]`;

val LENGTH_BYTE_TO_LIST = Q.prove
(`!b. LENGTH (BYTE_TO_LIST b) = 8`,
 METIS_TAC [EVAL (Term`LENGTH[b7;b6;b5;b4;b3;b2;b1;b0]`),
            BYTE_TO_LIST_def,pairTheory.ABS_PAIR_THM]);

(*---------------------------------------------------------------------------*)
(* Put n copies of x into a list                                             *)
(*---------------------------------------------------------------------------*)

val REPLICATE_def = Define
   `REPLICATE n x = if n = 0 then [] else x::REPLICATE (n-1) x`;

val LENGTH_REPLICATE = Q.prove
(`!n x. LENGTH(REPLICATE n x) = n`,
 Induct THENL
 [EVAL_TAC THEN PROVE_TAC [],
  ONCE_REWRITE_TAC [REPLICATE_def] THEN RW_TAC list_ss []]);

(*---------------------------------------------------------------------------*)
(* Define a padding function and its inverse                                 *)
(*---------------------------------------------------------------------------*)

val PAD_DEF = Define
   `PAD l = let slop = (LENGTH l) MOD 128 in
            let to_drop = (if slop <= 120 then 128 else 256) - slop in
            let stuffing = to_drop - 8
            in
             REPLICATE stuffing F <> BYTE_TO_LIST (NUM_TO_BYTE to_drop)`;

(*---------------------------------------------------------------------------*)
(* Extract the length of the over-run from the last 8 bits of a padded list  *)
(*---------------------------------------------------------------------------*)

val TO_DROP_DEF = Define
   `(TO_DROP [b7;b6;b5;b4;b3;b2;b1;b0] = BYTE_TO_NUM (b7,b6,b5,b4,b3,b2,b1,b0))
/\  (TO_DROP (b8::b7::b6::b5::b4::b3::b2::b1::b0::t) 
      = TO_DROP (b7::b6::b5::b4::b3::b2::b1::b0::t))`;

(*---------------------------------------------------------------------------*)
(* The first n elements of a list                                            *)
(*---------------------------------------------------------------------------*)

val (FRONT_DEF,_) = Defn.tprove (Hol_defn "FRONT"
    `FRONT n l = if n = 0 then [] else HD(l)::FRONT (n-1) (TL l)`,
  WF_REL_TAC `measure FST`);

(*---------------------------------------------------------------------------*)
(* Inverse of padding function.                                              *)
(*---------------------------------------------------------------------------*)

val UNPAD_DEF = Define `UNPAD l = FRONT (LENGTH l - TO_DROP l) l`;

val LENGTH_PAD_EQUALS_TO_DROP = Q.prove
(`!l. LENGTH (PAD l) = TO_DROP (PAD l)`,
 REWRITE_TAC [PAD_DEF] 
  THEN RW_TAC std_ss [LENGTH_APPEND,LENGTH_REPLICATE] THENL
  [POP_ASSUM MP_TAC THEN Q.SPEC_TAC (`LENGTH l MOD 128`, `x`) 
     THEN GEN_TAC THEN STRIP_TAC
     THEN `x < 121` by DECIDE_TAC
     THEN Q.PAT_ASSUM `x <= y` (K ALL_TAC)
     THEN POP_ASSUM MP_TAC THEN Q.ID_SPEC_TAC `x`
     THEN NTAC 121 (CONV_TAC (BOUNDED_CASES_CONV EVAL))
     THEN PROVE_TAC [],
   `120 < LENGTH l MOD 128 /\ LENGTH l MOD 128 < 128` 
       by RW_TAC arith_ss [arithmeticTheory.DIVISION]
     THEN REPEAT (POP_ASSUM MP_TAC) 
     THEN Q.SPEC_TAC (`LENGTH l MOD 128`, `x`) 
     THEN GEN_TAC THEN REPEAT STRIP_TAC 
     THEN `(x = 121) \/ (x = 122) \/ (x = 123) \/ 
           (x = 124) \/ (x = 125) \/ (x = 126) \/ (x = 127)` 
          by RW_TAC arith_ss []
     THEN RW_TAC std_ss []
     THEN EVAL_TAC]);

val LENGTH8 = Q.prove
(`!l. (LENGTH l = 8) ==> 
      ?h0 h1 h2 h3 h4 h5 h6 h7. l = [h7; h6; h5; h4; h3; h2; h1; h0]`,
 Cases THENL [EVAL_TAC, ALL_TAC] THEN 
 NTAC 4 (Cases_on `t` THENL 
         [EVAL_TAC, Cases_on `t1` THENL [EVAL_TAC, ALL_TAC]]) THENL
 [PROVE_TAC [],RW_TAC list_ss []]);

val PAD_APPEND_LEMMA = Q.prove
(`!l. ?l1 h0 h1 h2 h3 h4 h5 h6 h7. 
        PAD l = l1 <> [h7;h6;h5;h4;h3;h2;h1;h0]`,
 RW_TAC std_ss [PAD_DEF] 
  THENL [Q.EXISTS_TAC `(REPLICATE (128 - LENGTH l MOD 128 - 8) F)`,
         Q.EXISTS_TAC `(REPLICATE (256 - LENGTH l MOD 128 - 8) F)`]
  THEN RW_TAC std_ss [APPEND_11]
  THEN PROVE_TAC [LENGTH_BYTE_TO_LIST,LENGTH8]);

val lem = Q.prove
(`!l. ?l1 b0 b1 b2 b3 b4 b5 b6 b7 t. 
       l <> [h7; h6; h5; h4; h3; h2; h1; h0] = 
       b0::b1::b2::b3::b4::b5::b6::b7::t`,
 Induct THEN EVAL_TAC THEN PROVE_TAC []);

val TO_DROP_EQUALS_BYTE_TO_NUM = Q.prove
(`!l. TO_DROP (l <> [h7;h6;h5;h4;h3;h2;h1;h0]) 
        = BYTE_TO_NUM (h7,h6,h5,h4,h3,h2,h1,h0)`,
 Induct THENL
 [EVAL_TAC, RW_TAC list_ss [] THEN METIS_TAC [lem,TO_DROP_DEF]]);

val TO_DROP_APPEND = Q.prove
(`!l. TO_DROP (l <> PAD l) = TO_DROP (PAD l)`,
 PROVE_TAC [APPEND_ASSOC,TO_DROP_EQUALS_BYTE_TO_NUM,PAD_APPEND_LEMMA]);

val FRONT_LENGTH = Q.prove
(`!l. FRONT (LENGTH l) l = l`,
 Induct THENL 
 [EVAL_TAC,
  ONCE_REWRITE_TAC [FRONT_DEF] THEN RW_TAC list_ss []]);

val FRONT_LENGTH_APPEND = Q.prove
(`!l l1. FRONT (LENGTH l) (l <> l1) = l`,
 Induct THENL
 [GEN_TAC THEN EVAL_TAC,
  ONCE_REWRITE_TAC [FRONT_DEF]
    THEN RW_TAC list_ss []]);

val lemma = Q.prove
(`!n l. (n = LENGTH l) ==> (FRONT n l = l)`,
 PROVE_TAC [FRONT_LENGTH]);

val lemma1 = Q.prove
(`!n l l1 l2. (n = LENGTH l1) /\ (l = l1 <> l2) ==> (FRONT n l = l1)`,
 PROVE_TAC [FRONT_LENGTH_APPEND]);

(*---------------------------------------------------------------------------*)
(* Correctness of padding then unpadding                                     *)
(*---------------------------------------------------------------------------*)

val UNPAD_PAD_THM = Q.prove
(`!l. UNPAD (l <> PAD l) = l`,
 RW_TAC std_ss [UNPAD_DEF] 
   THEN MATCH_MP_TAC lemma1
   THEN Q.EXISTS_TAC `PAD l` THEN RW_TAC list_ss []
   THEN MATCH_MP_TAC (DECIDE (Term `(x = y) ==> (p + x - y = p)`))
   THEN PROVE_TAC [TO_DROP_APPEND,LENGTH_PAD_EQUALS_TO_DROP]);

(*---------------------------------------------------------------------------*)
(* Padding always yields a multiple of 128                                   *)
(*---------------------------------------------------------------------------*)

val PADDED_LENGTH_THM = Q.prove
(`!l. LENGTH (APPEND l (PAD l)) MOD 128 = 0`,
 RW_TAC std_ss [PAD_DEF,listTheory.LENGTH_APPEND,LENGTH_REPLICATE,
                 LENGTH_BYTE_TO_LIST]
  THEN ONCE_REWRITE_TAC [EVAL_RULE (Q.SPEC `128` (GSYM MOD_PLUS))] THENL
  [POP_ASSUM MP_TAC 
     THEN Q.SPEC_TAC (`LENGTH l MOD 128`, `x`) 
     THEN RW_TAC std_ss [] 
     THEN `(x = 0) \/ 0 < x` by DECIDE_TAC THEN RW_TAC arith_ss [LESS_MOD],
   `120 < LENGTH l MOD 128 /\ LENGTH l MOD 128 < 128` 
         by RW_TAC arith_ss [arithmeticTheory.DIVISION]
      THEN REPEAT (POP_ASSUM MP_TAC)
      THEN Q.SPEC_TAC (`LENGTH l MOD 128`, `x`) 
      THEN GEN_TAC THEN REPEAT STRIP_TAC 
      THEN `(x = 121) \/ (x = 122) \/ (x = 123) \/ 
            (x = 124) \/ (x = 125) \/ (x = 126) \/ (x = 127)` 
          by RW_TAC arith_ss []
      THEN RW_TAC arith_ss []]);


(*---------------------------------------------------------------------------*)
(* Trivial maps between a lists of bits and a 16-tuple of bytes              *)
(*---------------------------------------------------------------------------*)

val BYTE_DEF = Define 
  `(BYTE [] = []) /\
   (BYTE (a::b::c::d::e::f::g::h::t) = (a,b,c,d,e,f,g,h)::BYTE t)`;

val BLOCK_DEF = Define
 `(BLOCK [] = []) /\
  (BLOCK (a::b::c::d::e::f::g::h::i::j::k::l::m::n::p::q::t) 
       = (a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q)::BLOCK t)`;

val UNBYTE_DEF = Define 
   `(UNBYTE [] = []) /\
    (UNBYTE ((a,b,c,d,e,f,g,h)::t) = a::b::c::d::e::f::g::h::UNBYTE t)`;

val UNBLOCK_DEF = Define
 `(UNBLOCK [] = []) /\
  (UNBLOCK ((a,b,c,d,e,f,g,h,i,j,k,l,m,n,p,q)::t) = 
    a::b::c::d::e::f::g::h::i::j::k::l::m::n::p::q::UNBLOCK t)`;

val BYTE_THEN_UNBYTE = Q.prove
(`!l. (LENGTH l MOD 8 = 0) ==> (UNBYTE (BYTE l) = l)`,
 recInduct(fetch "-" "BYTE_ind") THEN EVAL_TAC
   THEN FULL_SIMP_TAC list_ss [ADD1,ADD_MODULUS]);

val BLOCK_THEN_UNBLOCK = Q.prove
(`!l k. (LENGTH (l) MOD 16 = 0) ==> (UNBLOCK (BLOCK l) = l)`,
 recInduct(fetch "-" "BLOCK_ind") THEN EVAL_TAC
   THEN FULL_SIMP_TAC list_ss [ADD1,ADD_MODULUS]);

(*---------------------------------------------------------------------------*)
(* Next proof requires 128 cases in the induction, so we get such an ind.    *)
(* thm by making an arbitrary recursive definition with the right shape.     *)
(*---------------------------------------------------------------------------*)

val foo_def = Define
 `(foo (v1::v2::v3::v4::v5::v6::v7::v8::v9::v10::v11::v12::v13::v14::v15::v16::
        v17::v18::v19::v20::v21::v22::v23::v24::v25::v26::v27::v28::v29::v30::
        v31::v32::v33::v34::v35::v36::v37::v38::v39::v40::v41::v42::v43::v44::
        v45::v46::v47::v48::v49::v50::v51::v52::v53::v54::v55::v56::v57::v58::
        v59::v60::v61::v62::v63::v64::v65::v66::v67::v68::v69::v70::v71::v72::
        v73::v74::v75::v76::v77::v78::v79::v80::v81::v82::v83::v84::v85::v86::
        v87::v88::v89::v90::v91::v92::v93::v94::v95::v96::v97::v98::v99::v100::
        v101::v102::v103::v104::v105::v106::v107::v108::v109::v110::v111::v112::
        v113::v114::v115::v116::v117::v118::v119::v120::v121::v122::v123::v124::
        v125::v126::v127::v128::t) = foo t) /\
  (foo otherwise = T)`;

val listind128 = fetch "-" "foo_ind";

val LENGTH_BYTE_THM = Q.prove
(`!l. (LENGTH l MOD 128 = 0) ==> (LENGTH (BYTE l) MOD 16 = 0)`,
 HO_MATCH_MP_TAC listind128 
   THEN CONJ_TAC 
   THEN REPEAT CONJ_TAC 
   THEN REPEAT GEN_TAC
   THEN EVAL_TAC   (* Gets all cases except induction step *)
   THEN SIMP_TAC std_ss [ADD1] THEN RW_TAC arith_ss [ADD_MODULUS]);

val MOD_FACTOR = Q.prove
(`!n. (n MOD 128 = 0) ==> (n MOD 8 = 0)`,
  RW_TAC arith_ss [BETA_RULE (Q.ISPECL [`\x.x=0`] MOD_P)]
   THEN Q.EXISTS_TAC `16 * k` THEN DECIDE_TAC);

val BYTE_THEN_UNBYTE = Q.prove
(`!l. (LENGTH l MOD 128 = 0) ==> (UNBYTE(UNBLOCK (BLOCK (BYTE l))) = l)`,
 METIS_TAC [LENGTH_BYTE_THM,BYTE_THEN_UNBYTE,BLOCK_THEN_UNBLOCK,MOD_FACTOR]);

val BYTE_THEN_UNBYTE_PADDED_THM = Q.prove
(`!l. UNBYTE (UNBLOCK(BLOCK(BYTE (l<>PAD l)))) = l<>PAD l`,
 PROVE_TAC [BYTE_THEN_UNBYTE,PADDED_LENGTH_THM]);

val PAD_TO_UNPAD_THM = Q.prove
(`!l. UNPAD (UNBYTE (UNBLOCK(BLOCK(BYTE (l<>PAD l))))) = l`,
 PROVE_TAC [BYTE_THEN_UNBYTE_PADDED_THM,UNPAD_PAD_THM]);


(*---------------------------------------------------------------------------*)
(* Encode the data, pad it, block it, then encrypt it. And the reverse.      *)
(*---------------------------------------------------------------------------*)

val AES_CBC_DEF = Define
   `AES_CBC (enc:'a -> bool list) 
            (dec:bool list -> 'a) key init = 
    let (encrypt,decrypt) = AES key
    in 
     (CBC_ENC encrypt init o BLOCK o BYTE o S APPEND PAD o enc,
      dec o UNPAD o UNBYTE o UNBLOCK o CBC_DEC decrypt init)`;

          
val ENCRYPTION_CORRECT = Q.prove
(`!encode decode key iv E D.
    (decode o encode = I) /\  
    ((E,D) = AES_CBC encode decode key iv)
       ==> 
    (D o E = I)`,
 REWRITE_TAC [AES_CBC_DEF] THEN REPEAT GEN_TAC
  THEN Cases_on `AES key`
  THEN RW_TAC std_ss [FUN_EQ_THM]
  THEN METIS_TAC [CBC_Correct, PAD_TO_UNPAD_THM]);



fun upto b t = if b> t then [] else b::upto(b+1) t;
upto 1 128;

val M = Term `
[v1; v2; v3; v4; v5; v6; v7; v8; v9; v10; v11; v12; v13; v14; v15; v16; v17; v18; v19; v20; v21;
 v22; v23; v24; v25; v26; v27; v28; v29; v30; v31; v32; v33; v34; v35; v36; v37; v38; v39;
 v40; v41; v42; v43; v44; v45; v46; v47; v48; v49; v50; v51; v52; v53; v54; v55; v56; v57;
 v58; v59; v60; v61; v62; v63; v64; v65; v66; v67; v68; v69; v70; v71; v72; v73; v74; v75;
 v76; v77; v78; v79; v80; v81; v82; v83; v84; v85; v86; v87; v88; v89; v90; v91; v92; v93;
 v94; v95; v96; v97; v98; v99; v100; v101; v102; v103; v104; v105; v106; v107; v108; v109;
 v110; v111; v112; v113; v114; v115; v116; v117; v118; v119; v120; v121; v122; v123; v124;
 v125; v126; v127;v128]`;



EVAL (Term `let encoded = encode_num 23 in
      let padded = APPEND encoded (PAD encoded) in
      let unpadded = UNPAD padded
      in
        decode_num (K T) unpadded`);


g`!n. let encoded = encode_num n in
      let padded = APPEND encoded (PAD encoded) in
      let unpadded = UNPAD padded 
      in
        FST(THE (decode_num (K T) unpadded)) = n`;
e (RW_TAC std_ss [UNPAD_PAD_THM]);
wf_coder_num;



(* Might not be needed *)
val LENGTH_MOD_8 = Q.prove
(`!l. (LENGTH l MOD 8 = 0) 
        ==> 
      (l=[]) \/
      ?a b c d e f g h t. (l = a::b::c::d::e::f::g::h::t) /\
                          (LENGTH t MOD 8 = 0)`,
 Cases THENL
 [EVAL_TAC,
  NTAC 3 (Cases_on `t` THENL [RW_TAC list_ss [], ALL_TAC] THEN
          Cases_on `t1` THENL [RW_TAC list_ss [], ALL_TAC]) 
    THEN Cases_on `t` THENL 
    [RW_TAC list_ss [], 
     RW_TAC list_ss [ADD1,ADD_MODULUS]]]);

