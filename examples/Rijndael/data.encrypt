(*---------------------------------------------------------------------------*)
(* Encryption of high-level datatypes.                                       *)
(*---------------------------------------------------------------------------*)

app load ["modesTheory", "CoderTheory", "metisLib", "Encode"];
open EncodeTheory DecodeTheory CoderTheory combinTheory pairTheory;

fun encode tm = 
 let val db = TypeBase.theTypeBase()
     val f = TypeBasePure.type_encode db (type_of tm)
 in
    bossLib.EVAL (mk_comb (f, tm))
 end;

val encode = encode o Term;
try encode `[(1,2,3,4) ; (5,6,7,8)]`;

(*---------------------------------------------------------------------------*)
(* Example. Encode then pad. Unpad then decode.                              *)
(*---------------------------------------------------------------------------*)

Count.apply EVAL 
  (Term `let encoded = encode_num 255 in
         let padded = PAD encoded in
         let unpadded = UNPAD padded
          in
           decode_num (K T) unpadded`);


(*---------------------------------------------------------------------------*)
(* Currently, the decoders installed for basic types are not efficient,      *)
(* mainly because they use case statements on the rhs, and that is not       *)
(* efficiently supported. The following two versions of decode_num and       *)
(* decode_list are far better.                                               *)
(*---------------------------------------------------------------------------*)

val decode_num_thm = 
 mk_thm ([], Term 
 `(decode_num P [] = NONE) /\
  (decode_num P [x] = NONE) /\
  (decode_num P (T::T::t) = SOME (0,t)) /\
  (decode_num P (T::F::t) = 
     let x = decode_num P t 
     in if IS_SOME x then (let (m,t') = THE(x) in SOME (2*m + 1, t'))
        else NONE) /\
  (decode_num P (F::t) = 
     let x = decode_num P t 
     in if IS_SOME x then (let (m,t') = THE(x) in SOME (2*m + 2, t'))
        else NONE)`);

val decode_list_thm = 
 mk_thm ([],Term
  `(decode_list (ALL_EL (K T)) (decode_num (K T)) [] = NONE) /\
   (decode_list (ALL_EL (K T)) (decode_num (K T)) (F::t) = SOME([],t)) /\
   (decode_list (ALL_EL (K T)) (decode_num (K T)) (T::t) =
       let x = decode_num (K T) t
       in if IS_SOME x 
            then let (y,t') = THE(x) 
                 in let z = decode_list (ALL_EL (K T)) (decode_num (K T)) t'
                    in if IS_SOME z
                        then (let (u,w) = THE(z) in SOME (y::u,w))
                        else NONE
            else NONE)`);

computeLib.add_funs [decode_num_thm,decode_list_thm];

(*---------------------------------------------------------------------------*)
(* For example, the following is more than twice as fast as the previous     *)
(*---------------------------------------------------------------------------*)

Count.apply EVAL 
  (Term `let encoded = encode_num 255 in
         let padded = PAD encoded in
         let unpadded = UNPAD padded
          in
           decode_num (K T) unpadded`);

(*---------------------------------------------------------------------------*)
(* Example: encryption and decryption of elements of the type                *)
(*                                                                           *)
(*    (num # bool option) list                                               *)
(*                                                                           *)
(*---------------------------------------------------------------------------*)

val ty = Type `:(num # bool option) list`;
val Dom_ty = Term `ALL_EL (lift_prod (K T) (lift_option (K T))) 
                   : ^(ty_antiq ty) -> bool`;
val Enc_ty = TypeBasePure.type_encode 
               (TypeBase.theTypeBase()) ty;
val Dec_ty = Term 
  `decode_list (ALL_EL (lift_prod (K T) (lift_option (K T))))
      (decode_prod (lift_prod (K T) (lift_option (K T)))
         (decode_num (K T))
         (decode_option (lift_option (K T)) (decode_bool (K T))))`;

(*---------------------------------------------------------------------------*)
(* Rephrase some preproved theorems for easier use while backwards chaining  *)
(*---------------------------------------------------------------------------*)

val wf_coder_option' = Q.prove
(`!P e d lc. wf_coder (P,e,d) /\ (option_coder (P,e,d) = oc) ==> wf_coder oc`,
 METIS_TAC [ABS_PAIR_THM,wf_coder_option]);

val wf_coder_prod' = Q.prove
(`!P1 P2 e1 e2 d1 d2 pc. 
   wf_coder (P1,e1,d1) /\ 
   wf_coder (P2,e2,d2) /\ 
(prod_coder (P1,e1,d1) (P2,e2,d2) = pc) ==> wf_coder pc`,
 METIS_TAC [ABS_PAIR_THM,wf_coder_prod]);

val wf_coder_list' = Q.prove
(`!P e d lc. wf_coder (P,e,d) /\ (list_coder (P,e,d) = lc) ==> wf_coder lc`,
 METIS_TAC [ABS_PAIR_THM,wf_coder_list]);

(*---------------------------------------------------------------------------*)
(* More useful (for me) versions of wf_coder theorems from CoderTheory.      *)
(*---------------------------------------------------------------------------*)

val [wf_list_coder,wf_prod_coder,wf_option_coder,
     wf_num_coder, wf_bool_coder] = 
  [SIMP_RULE std_ss [FORALL_PROD,list_coder_def] wf_coder_list,
   SIMP_RULE std_ss [FORALL_PROD,prod_coder_def] wf_coder_prod,
   SIMP_RULE std_ss [FORALL_PROD,option_coder_def] wf_coder_option,
   SIMP_RULE std_ss [FORALL_PROD,num_coder_def] wf_coder_num,
   SIMP_RULE std_ss [FORALL_PROD,bool_coder_def] wf_coder_bool];

val wf_pred_KT = REWRITE_RULE [K_THM] (Q.SPEC `K T` wf_pred_def);

(*---------------------------------------------------------------------------*)
(* (Dom_ty, Enc_ty, Dec_ty) is a wf_coder                                    *)
(*---------------------------------------------------------------------------*)

val thm = Q.prove
(`wf_coder (^Dom_ty,^Enc_ty,^Dec_ty)`,
 METIS_TAC [wf_pred_KT, wf_list_coder, wf_num_coder, 
            wf_bool_coder, wf_prod_coder, wf_option_coder]);

(* OR *)
val thm = Q.prove
(`wf_coder (^Dom_ty,^Enc_ty,^Dec_ty)`,
 REPEAT (CONJ_TAC 
       ORELSE MATCH_ACCEPT_TAC wf_pred_KT 
       ORELSE MAP_FIRST MATCH_MP_TAC 
               [wf_list_coder, wf_num_coder,
                wf_bool_coder, wf_prod_coder, wf_option_coder]));


(*---------------------------------------------------------------------------*)
(* Hence Dec_ty o Enc_ty = I                                                 *)
(*---------------------------------------------------------------------------*)

val thm1 = SIMP_RULE std_ss [domain_def,decoder_def, encoder_def] 
                            (MATCH_MP wf_coder thm);
val thm2 = prove (fst(dest_imp(snd(dest_forall(concl thm1)))),
                  Induct_on `x` THEN EVAL_TAC THEN ASM_REWRITE_TAC []);
val thm3 = GEN_ALL (MATCH_MP thm1 thm2);

(*---------------------------------------------------------------------------*)
(* Apply example to AES_CBC_CORRECT                                          *)
(*---------------------------------------------------------------------------*)

val EC1 = SIMP_RULE std_ss [GSYM AND_IMP_INTRO,FUN_EQ_THM] 
                  modesTheory.AES_CBC_CORRECT;
val EC2 = MATCH_MP EC1 thm3;

