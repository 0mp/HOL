%{
  open Data;

  fun sh_imm1_to_imm2 (DpShiftImmediate x) = DtShiftImmediate x
    | sh_imm1_to_imm2 _ = raise Parse "not a DpShiftImmediate"

  fun register2int r =
  case r of
    R0  => 0  | R1  => 1  | R2  => 2  | R3  => 3
  | R4  => 4  | R5  => 5  | R6  => 6  | R7  => 7
  | R8  => 8  | R9  => 9  | R10 => 10 | R11 => 11
  | R12 => 12 | R13 => 13 | R14 => 14 | R15 => 15;

  fun intset2int s =
  let val lw = map Word.fromInt (Intset.listItems s)
      val w0 = Word.fromInt 0
      val w1 = Word.fromInt 1 in
    Word.toInt (foldl (fn (i,w) => Word.orb(w,Word.<<(w1,i))) w0 lw)
  end;

  fun fst (a, b) = a;
  fun snd (a, b) = b;
  val toi = Arbnum.toInt o snd;

  fun cptoi x =
    let val i = toi x
        val _ = if i mod 4 = 0 then () else
                  print "Warning: offset was not aligned.\n"
    in Int.div(i, 4) end;
%}

%token <Arbnum.num> NUMBER
%token <Data.register> REG COREG
%token <string> LABEL
%token <int> COPROC
%token <Data.shift> SHIFT
%token <bool * bool * bool> PSRF
%token <bool> PSR
%token <Data.condition> SWI_EX MRS MSR CDP
%token <Data.opcode * Data.condition * bool> DPROC1 DPROC2
%token <Data.condition * bool> BRANCH MULT3 SWAP MCR_MRC
%token <Data.condition * bool * bool * bool * bool> MULT4
%token <bool * Data.condition * bool> STRANS LDC_STC
%token <bool * Data.condition * bool * bool> BTRANS
%token RRX LBRACE RBRACE LSQUARE RSQUARE HASH MINUS PLUS
       EXCLAIM COLON COMMA HAT BAR
%token EOF

%start Main
%type <Data.assembler list> Main
%type <Data.assembler> Line
%type <Data.instruction> Code Inst
%type <Arbnum.num> Target
%type <bool * Arbnum.num> Number
%type <Data.addr_mode1> ShiftImmediate AddrMode1
%type <bool * bool * bool * Data.addr_mode2> AddrMode2
%type <bool * bool * bool * int> AddrMode5
%type <Intset.intset> RegListEntry RegList

%%

Main:
    Line EOF       { [$1] }
  | Line Main      { $1 :: $2 }

Line:
    Code          { Code $1 }
  | BRANCH LABEL  { BranchS (fst $1, snd $1, $2) }
  | BRANCH Target { BranchN (fst $1, snd $1, $2) }
  | LABEL COLON   { Label $1 }
  | NUMBER COLON  { Mark $1 }
  | BAR LABEL BAR { Label $2 }
    
Code:
    Inst   { $1 }
  | Number { Data (if fst $1 then two_comp32 (snd $1) else snd $1) }

Inst:
    SWI_EX                     { Instruction(Swi_ex,$1) }
  | DPROC1 REG COMMA AddrMode1 { let val (opc,cond,s) = $1 in
                                   Instruction(Data_proc {opc = opc, S = s,
                                     Rd = $2, Rn = $2, op2 = $4},cond) end }
  | DPROC2 REG COMMA REG COMMA AddrMode1
                               { let val (opc,cond,s) = $1 in
                                   Instruction(Data_proc {opc = opc, S = s,
                                     Rd = $2, Rn = $4, op2 = $6},cond) end }
  | MULT3 REG COMMA REG COMMA REG
                               { Instruction(Mla_mul {L = false,
                                   Signed = false, A = false, S = snd $1,
                                   Rd = $2, Rm = $4, Rs = $6, Rn = R0},fst $1) }
  | MULT4 REG COMMA REG COMMA REG COMMA REG
                               { let val (c,l,sgn,a,s) = $1 in
                                   if l then
                                     Instruction(Mla_mul {L = true,
                                       Signed = sgn, A = a, S = s,
                                       Rd = $2, Rm = $6, Rs = $8, Rn = $4},c)
                                   else
                                     Instruction(Mla_mul {L = false,
                                       Signed = false, A = true, S = s,
                                       Rd = $2, Rm = $4, Rs = $6, Rn = $8},c)
                                 end }
  | STRANS REG COMMA LSQUARE REG AddrMode2
                               { let val (l,cond,b) = $1
                                     val (p,u,w,offset) = $6 in
                                   Instruction(Ldr_str {P = p, U = u, B = b,
                                     W = w, L = l, Rd = $2, Rn = $5,
                                     offset = offset},cond) end }
  | BTRANS REG COMMA LBRACE RegList RBRACE
                               { let val (l,c,p,u) = $1 in
                                   Instruction(Ldm_stm {L = l, P = p, U = u,
                                     S = false, W = false, Rn = $2,
                                     list = intset2int $5},c) end }
  | BTRANS REG COMMA LBRACE RegList RBRACE HAT
                               { let val (l,c,p,u) = $1 in
                                   Instruction(Ldm_stm {L = l, P = p, U = u,
                                     S = true, W = false, Rn = $2,
                                     list = intset2int $5},c) end }
  | BTRANS REG EXCLAIM COMMA LBRACE RegList RBRACE
                               { let val (l,c,p,u) = $1 in
                                   Instruction(Ldm_stm {L = l, P = p, U = u,
                                     S = false, W = true, Rn = $2,
                                     list = intset2int $6},c) end }
  | BTRANS REG EXCLAIM COMMA LBRACE RegList RBRACE HAT
                               { let val (l,c,p,u) = $1 in
                                   Instruction(Ldm_stm {L = l, P = p, U = u,
                                     S = true, W = true, Rn = $2,
                                     list = intset2int $6},c) end }
  | SWAP REG COMMA REG COMMA LSQUARE REG RSQUARE
                               { Instruction(Swp {B = snd $1, Rd = $2,
                                   Rm = $4, Rn = $7},fst $1) }
  | MRS REG COMMA PSR          { Instruction(Mrs {R = $4, Rd = $2},$1) }
  | MSR PSR COMMA REG          { Instruction(Msr {R = $2, bit19 = true,
                                   bit16= true, Op = MsrRegister $4},$1) }
  | MSR PSRF COMMA REG         { let val (r,b19,b16) = $2 in
                                   Instruction(Msr {R = r, bit19 = b19,
                                     bit16= b16, Op = MsrRegister $4},$1) end }
  | MSR PSR COMMA HASH NUMBER  { Instruction(Msr {R = $2, bit19 = true,
                                   bit16= true, Op = MsrImmediate $5},$1) }
  | MSR PSRF COMMA HASH NUMBER { let val (r,b19,b16) = $2 in
                                   Instruction(Msr {R = r, bit19 = b19,
                                     bit16= b16, Op = MsrImmediate $5},$1) end }
  | CDP COPROC COMMA NUMBER COMMA COREG COMMA COREG COMMA COREG
                               { Instruction(Cdp {CP = $2, CRd = $6,
                                   Cop1 = Arbnum.toInt $4, CRn = $8, CRm = $10,
                                   Cop2 = 0},$1) }
  | CDP COPROC COMMA NUMBER COMMA COREG COMMA COREG COMMA COREG COMMA NUMBER
                               { Instruction(Cdp {CP = $2, CRd = $6,
                                   Cop1 = Arbnum.toInt $4, CRn = $8, CRm = $10,
                                   Cop2 = Arbnum.toInt $12},$1) }
  | MCR_MRC COPROC COMMA NUMBER COMMA REG COMMA COREG COMMA COREG
                               { Instruction(Mcr_mrc {CP = $2, L = snd $1,
                                   Rd = $6, Cop1 = Arbnum.toInt $4, CRn = $8,
                                   CRm = $10, Cop2 = 0},fst $1) }
  | MCR_MRC COPROC COMMA NUMBER COMMA REG COMMA COREG COMMA COREG COMMA NUMBER
                               { Instruction(Mcr_mrc {CP = $2, L = snd $1,
                                   Rd = $6, Cop1 = Arbnum.toInt $4, CRn = $8,
                                   CRm = $10, Cop2 = Arbnum.toInt $12},fst $1) }
  | LDC_STC COPROC COMMA COREG COMMA LSQUARE REG AddrMode5
                               { let val (l,cond,n) = $1
                                     val (p,u,w,offset) = $8 in
                                   Instruction(Ldc_stc {P = p, U = u, N = n,
                                     CP = $2, W = w, L = l, CRd = $4, Rn = $7,
                                     offset = offset},cond) end }

Target:
    NUMBER         { let open Arbnum in
                       if $1 <= fromHexString "FFFFFFFF" then
                         align32 $1
                       else raise BadInstruction "Branch address too large"
                     end }
  | MINUS NUMBER   { let open Arbnum in
                       if $2 <= fromHexString "FFFFFFFF" then
                         (two_comp32 o align32) $2
                       else raise BadInstruction "Branch address too large"
                     end }

Number:
    NUMBER         { (false,$1) }
  | MINUS NUMBER   { (true, $2) }

ShiftImmediate:
    REG                        { DpShiftImmediate {Rm = $1, Sh = LSL, Imm = 0} }
  | REG COMMA RRX              { DpShiftImmediate {Rm = $1, Sh = ROR, Imm = 0} }
  | REG COMMA SHIFT HASH NUMBER
      { let val imm = Arbnum.toInt $5 in
          if 32 < imm orelse
             imm = 32 andalso (($3 = LSL) orelse ($3 = ROR)) then
            raise BadInstruction "Immediate shift value too large"
          else
            DpShiftImmediate {Rm = $1, Sh = $3,
               Imm = (if imm = 32 then 0 else imm)} end }

AddrMode1:
    ShiftImmediate        { $1 }
  | REG COMMA SHIFT REG   { DpShiftRegister {Rm = $1, Sh = $3, Rs = $4} }
  | HASH Number           { DpImmediate(if fst $2 then two_comp32 (snd $2)
                                                  else snd $2) }

  /* check after parse (others) + can MOV <-> MVN, ADD <-> SUB etc. */

AddrMode2: /* (P,U,W,offset) */
    RSQUARE                   { (true,true,false,DtImmediate 0) }
  | COMMA HASH Number RSQUARE { (true,not (fst $3),false,DtImmediate (toi $3)) }
  | COMMA HASH Number RSQUARE EXCLAIM
                              { (true,not (fst $3),true,DtImmediate (toi $3)) }
  | COMMA ShiftImmediate RSQUARE
                              { (true,true,false,sh_imm1_to_imm2 $2) }
  | COMMA ShiftImmediate RSQUARE EXCLAIM
                              { (true,true,true,sh_imm1_to_imm2 $2) }
  | COMMA PLUS ShiftImmediate RSQUARE
                              { (true,true,false,sh_imm1_to_imm2 $3) }
  | COMMA PLUS ShiftImmediate RSQUARE EXCLAIM
                              { (true,true,true,sh_imm1_to_imm2 $3) }
  | COMMA MINUS ShiftImmediate RSQUARE
                              { (true,false,false,sh_imm1_to_imm2 $3) }
  | COMMA MINUS ShiftImmediate RSQUARE EXCLAIM
                              { (true,false,true,sh_imm1_to_imm2 $3) }
  | RSQUARE COMMA HASH Number { (false,not (fst $4),true,DtImmediate (toi $4)) }
  | RSQUARE COMMA ShiftImmediate
                              { (false,true,true,sh_imm1_to_imm2 $3) }
  | RSQUARE COMMA PLUS ShiftImmediate
                              { (false,true,true,sh_imm1_to_imm2 $4) }
  | RSQUARE COMMA MINUS ShiftImmediate
                              { (false,false,true,sh_imm1_to_imm2 $4) }

AddrMode5: /* (P,U,W,offset) */
    RSQUARE                             { (true,true,false,0) }
  | COMMA HASH Number RSQUARE           { (true,not(fst $3),false,cptoi $3) }
  | COMMA HASH Number RSQUARE EXCLAIM   { (true,not(fst $3),true,cptoi $3) }
  | RSQUARE COMMA HASH Number           { (false,not(fst $4),true,cptoi $4) }
  
RegListEntry:
    REG                 { Intset.singleton (register2int $1) }
  | REG MINUS REG       { let val nl = register2int $1
                              val nr = register2int $3 in
                            if nl < nr then
                              Intset.addList(Intset.empty,
                                List.tabulate(nr + 1 - nl, fn i => nl + i))
                              else raise BadInstruction "Invalid register list"
                            end }

RegList:
    RegListEntry                { $1 }
  | RegListEntry COMMA RegList  { Intset.union($1, $3) }
;
