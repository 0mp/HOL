app load ["word32Lib", "word8Lib"];

(*---------------------------------------------------------------------------*)
(* Further tests (need bespoke compset)                                      *)
(*---------------------------------------------------------------------------*)

val string_to_w8_thms = [char_to_w8_def, string_to_w8_list_def];

val pairs_and_lists = let open pairTheory listTheory 
 in
  [CLOSED_PAIR_EQ, FST, SND,pair_case_thm,
   CURRY_DEF,UNCURRY_DEF,PAIR_MAP_THM,
   numeralTheory.numeral_funpow, (* LET_THM, *)
   APPEND,APPEND_NIL, FLAT, HD, TL,
   LENGTH, MAP, MAP2, NULL_DEF, MEM, EXISTS_DEF,
   EVERY_DEF, ZIP, UNZIP, FILTER, FOLDL, FOLDR,
   FOLDL, REVERSE_DEF, EL_compute, ALL_DISTINCT,
   computeLib.lazyfy_thm list_case_compute,
   list_size_def,FRONT_DEF,LAST_DEF]
 end;

val string_thms = let open stringTheory
   in [ORD_CHR_COMPUTE,CHR_ORD,STRING_CASE_DEF,STRLEN_DEF,
       EXPLODE_EQNS,IMPLODE_EQNS,STRCAT_EQNS]
   end;

val word8thms = 
 let open bitsTheory numeral_bitsTheory word8Theory 
     val THE_WL = SIMP_RULE arith_ss [HB_def,arithmeticTheory.ADD1] WL_def
     val MOD_WL_EVAL = REWRITE_RULE [THE_WL,GSYM MOD_2EXP_def] MOD_WL_def;
     val RRX_EVAL2 = GEN_ALL (REWRITE_RULE 
                         [GSYM DIV2_def,RRXn_def,LSR_ONE_def,HB_def] RRX_EVAL);
     val LT_EVAL = REWRITE_RULE [MSBn_def,THE_WL,MOD_WL_EVAL] LT_EVAL;
     val LE_EVAL = REWRITE_RULE [MSBn_def,THE_WL,MOD_WL_EVAL] LE_EVAL;
     val GT_EVAL = REWRITE_RULE [MSBn_def,THE_WL,MOD_WL_EVAL] GT_EVAL;
     val GE_EVAL = REWRITE_RULE [MSBn_def,THE_WL,MOD_WL_EVAL] GE_EVAL;
     val LO_EVAL = REWRITE_RULE [MOD_WL_EVAL] LO_EVAL;
     val LS_EVAL = REWRITE_RULE [MOD_WL_EVAL] LS_EVAL;
     val HI_EVAL = REWRITE_RULE [MOD_WL_EVAL] HI_EVAL;
     val HS_EVAL = REWRITE_RULE [MOD_WL_EVAL] HS_EVAL;
   in
    [LT_EVAL, LE_EVAL, GT_EVAL, GE_EVAL,
     LO_EVAL, LS_EVAL, HI_EVAL, HS_EVAL,
     THE_WL, HB_def, word_0, word_1, word_L_def, word_H_def, word_T,
     MOD_WL_EVAL, w2n_EVAL, n2w_11,
     OR_def, AND_def, EOR_def, TWO_COMP_def, ONE_COMP_def, RRX_def,MSB_def,
     ADD_EVAL, MUL_EVAL, word_sub,
     ONE_COMP_EVAL, TWO_COMP_EVAL,
     AND_EVAL, OR_EVAL, EOR_EVAL,
     LSL_EVAL, LSR_THM, ASR_THM, ROR_THM, RRX_EVAL,
     WORD_BIT_def, WORD_BITS_def, WORD_SLICE_def,
     MSB_EVAL, LSB_EVAL,
     iBITWISE, NUMERAL_BITWISE, NUMERAL_DIV2, SIGN_EXTEND_def,
     DIVMOD_2EXP, iMOD_2EXP, NUMERAL_MOD_2EXP, NUMERAL_DIV_2EXP, TIMES_2EXP_def,
     MSBn_def, LSBn_def, BITV_def, SBIT_def, BITS_def, BIT_def, SLICE_def]
   end;

val word32thms = 
let open bitsTheory numeral_bitsTheory word32Theory
     val THE_WL = SIMP_RULE arith_ss [HB_def,arithmeticTheory.ADD1] WL_def
     val MOD_WL_EVAL = REWRITE_RULE [THE_WL,GSYM MOD_2EXP_def] MOD_WL_def;
     val LT_EVAL = REWRITE_RULE [MSBn_def,THE_WL,MOD_WL_EVAL] LT_EVAL;
     val LE_EVAL = REWRITE_RULE [MSBn_def,THE_WL,MOD_WL_EVAL] LE_EVAL;
     val GT_EVAL = REWRITE_RULE [MSBn_def,THE_WL,MOD_WL_EVAL] GT_EVAL;
     val GE_EVAL = REWRITE_RULE [MSBn_def,THE_WL,MOD_WL_EVAL] GE_EVAL;
     val LO_EVAL = REWRITE_RULE [MOD_WL_EVAL] LO_EVAL;
     val LS_EVAL = REWRITE_RULE [MOD_WL_EVAL] LS_EVAL;
     val HI_EVAL = REWRITE_RULE [MOD_WL_EVAL] HI_EVAL;
     val HS_EVAL = REWRITE_RULE [MOD_WL_EVAL] HS_EVAL;
   in
    [LT_EVAL, LE_EVAL, GT_EVAL, GE_EVAL,LO_EVAL, LS_EVAL, HI_EVAL, HS_EVAL,
     THE_WL, HB_def, word_0, word_1, word_L_def, word_H_def, word_T,
     MOD_WL_EVAL, w2n_EVAL, n2w_11,
     OR_def, AND_def, EOR_def, TWO_COMP_def, ONE_COMP_def, RRX_def,MSB_def,
     ADD_EVAL, MUL_EVAL, word_sub,ONE_COMP_EVAL, TWO_COMP_EVAL,
     AND_EVAL, OR_EVAL, EOR_EVAL,LSL_EVAL, LSR_THM, ASR_THM, ROR_THM, RRX_EVAL,
     WORD_BIT_def, WORD_BITS_def, WORD_SLICE_def,
     MSB_EVAL, LSB_EVAL,
     iBITWISE, NUMERAL_BITWISE, NUMERAL_DIV2, SIGN_EXTEND_def,
     DIVMOD_2EXP, iMOD_2EXP, NUMERAL_MOD_2EXP, NUMERAL_DIV_2EXP, TIMES_2EXP_def,
     MSBn_def, LSBn_def, BITV_def, SBIT_def, BITS_def, BIT_def, SLICE_def]
   end;


val sha1thms = 
 [TAKE_def,rotl32_def, W8, W32, ZEROx64_def, 
  w8to32, w8x4to32_def, w32to8x4_def,
  w32List_def, w8List_def, w32x5to8_def,PaddingBitsHelper_def, 
  PaddingBits, LengthBitsHelper_def,LengthBits_def,
  Pad, f1_def, f2_def, f3_def, f4_def, 
  Helper_def, Round_def,expand_def, 
  digestBlock_def,digest_def, H0_def,H1_def,H2_def,H3_def,H4_def,computeMD_def];

val compset = reduceLib.num_compset();

val _ = try (computeLib.add_thms 
          (string_to_w8_thms @ string_thms @ pairs_and_lists @ 
           word8thms @ word32thms @ sha1thms))
          compset;

val SHA1_CONV = computeLib.WEAK_CBV_CONV compset;

(*
val thm1 = SHA1_CONV (Term `appendPadding (string_to_w8_list "abc")`);
val thm2 = SHA1_CONV (Term `LENGTH (appendPadding (string_to_w8_list "abc")) < 64`);
val thm3 = SHA1_CONV (Term 
  `let (next,rest) = TAKE 64 (appendPadding (string_to_w8_list "abc")) in 
   let block1 = expand (w32List next ++ ZEROx64) 
   in block1`);
  
val thm4a = SHA1_CONV (Term 
  `let (next,rest) = TAKE 64 (appendPadding (string_to_w8_list "abc")) in 
   let block1 = expand (w32List next ++ ZEROx64) in
   doRound (Helper f1) 0 (H0,H1,H2,H3,H4) block1`);

val thm4 = SHA1_CONV (Term 
  `let (next,rest) = TAKE 64 (appendPadding (string_to_w8_list "abc")) in 
   let block1 = expand (w32List next ++ ZEROx64) in
   doRound (Helper f1) 0 (H0,H1,H2,H3,H4) block1`);


val thm5 = Count.apply EVAL ``computeMD (string_to_w8_list "abc")``;;

*)



(* load "sha1ML"; open sha1ML listML stringML;
   load "Timing"; open Timing;

  Meta.installPP numML.ppHex;

  fun SHAlist L = 
    let open word8ML
        val (w0,(w1,(w2,(w3,(w4,(w5,(w6,(w7,(w8,(w9,(w10,(w11,(w12,(w13,
            (w14,(w15,(w16,(w17,(w18,w19))))))))))))))))))) = computeMD L
        val w0' = toNum w0
        val w1' = toNum w1
        val w2' = toNum w2
        val w3' = toNum w3
        val w4' = toNum w4
        val w5' = toNum w5
        val w6' = toNum w6
        val w7' = toNum w7
        val w8' = toNum w8
        val w9' = toNum w9
        val w10' = toNum w10
        val w11' = toNum w11
        val w12' = toNum w12
        val w13' = toNum w13
        val w14' = toNum w14
        val w15' = toNum w15
        val w16' = toNum w16
        val w17' = toNum w17
        val w18' = toNum w18
        val w19' = toNum w19
    in   
     (w0',w1',w2',w3',w4',w5',w6',w7',w8',w9',
      w10',w11',w12',w13',w14',w15',w16',w17',w18',w19')
    end;

  fun SHAstring s = SHAlist (MAP char_to_w8 (EXPLODE s));

     SHAstring "abc";
     (* = (A9,99,3E,36,47,6,81,6A,BA,3E,25,71,78,50,C2,6C,9C,D0,D8,9D) *)
     SHAstring "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq";
     (* = (84,98,3E,44,1C,3B,D2,6E,BA,AE,4A,A1,F9,51,29,E5,E5,46,70,F1) *)

  fun chars s top = 
    let val (SOME c) = Char.fromString s
        val w8 = word8ML.fromNum (ORD c)
        fun loop n acc = if n >= top then acc else loop (n+1) (w8::acc)
    in loop 0 []
    end;

   (* linear but slow *)
   time SHAlist (chars "a" 10);
   time SHAlist (chars "a" 100);
   time SHAlist (chars "a" 1000); (* 6.7 sec *)
   time SHAlist (chars "a" 10000); (* 65.6 sec *)
   time SHAlist (chars "a" 100000); (* 653.4 sec *)
   time SHAlist (chars "a" 1000000); (* 6522.27 sec *)
   (* =  (34,AA,97,3C,D4,C4,DA,A4,F6,1E,EB,2B,DB,AD,27,31,65,34,1,6F) *)

*)
