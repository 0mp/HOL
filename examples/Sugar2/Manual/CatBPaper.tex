\documentclass{llncs}

\parindent 0pt

\parskip 0.5mm

\newlength{\minipagewidth}
\setlength{\minipagewidth}{\textwidth}

\newenvironment{myenumerate}{\begin{enumerate}
  \renewcommand{\theenumi}{\roman{enumi}}
  \renewcommand{\labelenumi}{(\roman{enumi})}}{\end{enumerate}}



\usepackage{makeidx}                  % allows for indexgeneration
\usepackage{xspace}
\usepackage{alltt}
\usepackage{pstricks}

\newcommand{\And}{\(\wedge\)}
\newcommand{\Or}{\(\vee\)}
\newcommand{\Imp}{\(\Rightarrow\)}
\newcommand{\Not}{\(\neg\)}
\newcommand{\Forall}{\(\forall\)}
\newcommand{\Exists}{\(\exists\)}
\newcommand{\Lam}{\(\lambda\)}
\newcommand{\In}{\(\in\)}
\newcommand{\Length}{\({\rm{length}}\)}
\newcommand{\IsFinitePath}{\({\rm{finite}}\)}
\newcommand{\PathLength}{\({\rm{length}}\)}

\newcommand{\cat}{\hspace*{0.5mm}}
\newcommand{\pathCat}[2]{#1\hspace*{0.5mm}#2}
\newcommand{\Cat}{\(\cat\)}
\newcommand{\Leq}{\(\leq\)}
\newcommand{\Geq}{\(\geq\)}
\newcommand{\Le}{\(<\)}
\newcommand{\Ge}{\(>\)}

\newcommand{\T}{\texttt{\small\rm{T}}}
\newcommand{\bTrue}{\T}
\renewcommand{\Pi}{\(\pi\)}
\newcommand{\modelsT}{\models^{\hspace*{-3.3mm}\raisebox{1mm}{\T}}}

\newcommand{\CONCAT}[1]{\texttt{Concat}~#1}
\newcommand{\EVERY}[2]{\texttt{Every}~#1~#2}
\newcommand{\BSem}[3]{(\(\tt#1,~#2~{\models}~#3\))}
\newcommand{\Bsem}{\texttt{B\_SEM}\xspace}
\newcommand{\bSem}[3]{(\tt#1,~#2~{\models}~#3)}
\newcommand{\SSem}[4]{(\(\tt{#1,~#2~\models^{\hspace*{-2.3mm}\raisebox{1mm}{\tt#3}}~#4}\))}
\newcommand{\Ssem}{\texttt{S\_SEM}\xspace}
\newcommand{\sSem}[4]{(\tt{#1,~#2~\models^{\hspace*{-2.3mm}\raisebox{1mm}{\tt#3}}~#4})}
\renewcommand{\c}{{\hspace*{2.5mm}}}
\newcommand{\FSem}[4]{(\(\tt{#1,~#2~\models^{\hspace*{-2.3mm}\raisebox{1mm}{\tt#3}}~#4}\))}
\newcommand{\fSem}[4]{(\tt{#1,~#2~\models^{\hspace*{-2.3mm}\raisebox{1mm}{\tt#3}}~#4})}
\newcommand{\Fsem}{\texttt{F\_SEM}\xspace}
\newcommand{\OSem}[3]{(\(\tt{#1,~#2~{\models}~#3}\))}
\newcommand{\Osem}{\texttt{O\_SEM}\xspace}
\newcommand{\oSem}[3]{(\tt{#1,~#2~{\models}~#3})}

\newcommand{\BProp}[1]{\(#1\)}
\newcommand{\bProp}[1]{#1}
\newcommand{\sFusion}[2]{#1\texttt{:}#2}
\newcommand{\sClock}[2]{#1\texttt{@}#2}
\newcommand{\FBool}[1]{#1}
\newcommand{\bNot}[1]{\neg#1}
\newcommand{\BNot}[1]{\(\neg#1\)}
\newcommand{\fNot}[1]{\neg#1}
\newcommand{\weakClock}[1]{#1}
\newcommand{\strongClock}[1]{#1!}
\newcommand{\restN}[2]{#1^{#2}}
\newcommand{\pathEl}[2]{#1_{#2}}
\newcommand{\PathEl}[2]{\(#1_{#2}\)}
\newcommand{\pathSeg}[2]{#1^{#2}}
\newcommand{\PathSeg}[2]{\(#1^{#2}\)}
\newcommand{\el}[2]{#2_{#1}}
\newcommand{\LHat}[1]{\(\hat{\texttt{L}}_{#1}\)}
\newcommand{\lHat}[1]{\hat{\texttt{L}}_{#1}}
\newcommand{\lNoHat}[1]{{\texttt{L}}_{#1}}
\newcommand{\getR}[1]{\({\texttt{R}}_{#1}\)}
\newcommand{\sBool}[1]{#1}
\newcommand{\oBool}[1]{#1}
\newcommand{\oNot}[1]{\neg#1}
\newcommand{\sRepeat}[1]{#1\texttt{[*]}}
\newcommand{\sCat}[2]{#1\texttt{;}#2}
\newcommand{\sOr}[2]{\{#1\}\texttt{|}\{#2\}}
\newcommand{\oOr}[2]{\{#1\}\vee\{#2\}}
\newcommand{\sRigAnd}[2]{\{#1\}\texttt{\&\&}\{#2\}}
\newcommand{\sFlexAnd}[2]{\{#1\}\texttt{\&}\{#2\}}
\newcommand{\bAnd}[2]{#1\wedge#2}
\newcommand{\oAnd}[2]{#1\wedge#2}
\newcommand{\oEx}[1]{{\texttt{EX}}~#1}
\newcommand{\oEg}[1]{{\texttt{EG}}~#1}
\newcommand{\oEu}[2]{\texttt{[}#1~{\texttt{U}}~#2\texttt{]}}

\newcommand{\fAnd}[2]{#1 \wedge #2}
\newcommand{\fNext}[1]{\texttt{X!}#1}
\newcommand{\fUntil}[2]{\texttt{[}#1~\texttt{U}~#2\texttt{]}}
\newcommand{\fSuffixImp}[2]{\{#1\}(#2)}
\newcommand{\fStrongImp}[2]{\{#1\}\texttt{|->}\{#2\}\texttt{!}}
\newcommand{\fWeakImp}[2]{\{#1\}\texttt{|->}\{#2\}}
\newcommand{\fAbort}[2]{#1~\texttt{abort}~#2}
\newcommand{\fWeakClock}[2]{#1\texttt{@}#2}
\newcommand{\fStrongClock}[2]{#1\texttt{@}#2\texttt{!}}

\newcommand\Sugar{{\it{Sugar~2.0}}\xspace}
\newcommand\Hol{HOL\xspace}
\newcommand\HOL{\Hol}
\newcommand{\mosml}{Moscow~ML\xspace}
\newcommand{\Buddy}{BuDDy\xspace}
\newcommand{\Muddy}{MuDDy\xspace}
\newcommand\HolBuddy{{Hol{+}\Buddy\xspace}}
\newcommand\HolBddLib{\texttt{HolBddLib}\xspace}
\newcommand\tool{\texttt{PuzzleTool}\xspace}

\renewcommand{\t}[1]{\texttt{#1}}

%\newcommand{\con}[1]{{\sf #1}}
\newcommand{\con}[1]{\texttt{#1}}
\newcommand{\ty}[1]{\mbox{\sl #1}}
\newcommand{\ml}[1]{\mbox{\tt #1}}
\newcommand{\ma}[1]{{{$#1$}}}
\newcommand{\prev}[1]{#1}
\newcommand{\txt}[1]{{\footnotesize\texttt{#1}}}
\newcommand\fun{{\to}}
\renewcommand{\prod}{\times}
\newcommand\turn{{\vdash}}
\newcommand\imp{{\Rightarrow}}
%\newcommand\T{\con{T}}
%
\newcommand\F{\con{F}}
\newcommand\termbddty{\ty{termbdd}}
\newcommand{\termbdd}[3]{\mbox{$#1~#2~\mapsto~#3$}}
\newcommand{\globtermbdd}[2]{\mbox{$#1\hspace{0.5mm}\mapsto\hspace{0.5mm}#2$}}

\newcommand{\PATH}{\texttt{Path}\xspace}
\newcommand{\TAIL}{\texttt{Tail}\xspace}
%\newcommand{\Bsem}{\mbox{$\cal{B}$}\xspace}
%\newcommand{\Lsem}{\mbox{$\cal{L}$}\xspace}
%\newcommand{\Isem}{\mbox{$\cal{I}$}\xspace}
%\newcommand{\Csem}{\mbox{$\cal{C}$}\xspace}
%\newcommand{\Fsem}{\mbox{$\cal{F}$}\xspace}
%\newcommand{\Ssem}{\mbox{$\cal{S}$}\xspace}

\renewcommand{\L}{\texttt{L}\xspace}


\newcommand{\Until}{{\cal U}}
\newcommand{\Unless}{{\cal W}}
\newcommand{\TLNext}{\raisebox{1mm}{\mbox{\large\bf$\bigcirc$}}}
\newcommand{\TLNot}{\mbox{\large\bf$\neg$}}
\newcommand{\TLImp}{\mbox{\large\bf$\Rightarrow$}}
\newcommand{\TLAnd}{\mbox{\large\bf$\wedge$}}
\newcommand{\TLOr}{\mbox{\large\bf$\vee$}}

\newcommand{\SC}{\texttt{;}}
\newcommand{\C}{\texttt{:}}
\newcommand{\hd}{\texttt{hd}}
\newcommand{\lsb}{\texttt{[}}
\newcommand{\rsb}{\texttt{]}}
\newcommand{\R}{\mbox{$R$}}

\newcommand{\Sb}[1]{\(\sb{#1}\)}


\begin{document}



\pagestyle{headings}                  % switches on printing of running heads

\title{Using HOL to study \Sugar semantics}

\titlerunning%
{Programming combinations of%
and computation and deduction}        % abbreviated title (for running head)
                                      % also used for the TOC unless
                                      % \toctitle is used
 

\author{Michael J.~C.~Gordon}

\authorrunning{Mike Gordon}           % abbreviated author list (for running head)

\institute{
\begin{tabular}{c}
University of Cambridge Computer Laboratory\\
William Gates Building,
JJ Thomson Avenue, Cambridge CB3 0FD, U.K.\\
Email: \email{mjcg@cl.cam.ac.uk} \qquad
Web: \texttt{http://www.cl.cam.ac.uk/\homedir mjcg}
\end{tabular}}

\maketitle                            % typeset the title of the contribution

\vspace*{-3mm}

\begin{abstract}
The Accellera standards-promoting organisation has selected \Sugar,
IBM's formal specification language, as a standard that it says will
drive assertion-based verification.

\Sugar combines aspects of Interval Temporal Logic (ITL), Linear
Temporal Logic (LTL) and Computation Tree Logic (CTL) into a property
language suitable for both formal verification and use with simulation
test benchs. As industrial strength languages go it is remarkably
elegant, consisting of a small kernel conservatively extended by
numerous definitions.

We have constructed a semantic embedding of \Sugar in the version of
higher order logic supported by the \Hol system. To `sanity check' the
semantics we subjected it to some `formal challenges' and bugs in the
semantics were discovered and fixed. Further formal challenges may
well reveal more bugs.

We are contemplating a variety of applications of the mechanised
semantics, including the exploitation of existing work to build a
Sugar model checker inside \Hol. In the longer term we want to
investigate the use of theorem proving to reason about models with
infinite state spaces, which might involve developing extensions of
\Sugar.
\end{abstract}

\vspace*{-3mm}

\section{Background on Accellera and Sugar}

The Accellera organisation's website has their mission statement:

\vspace*{-1mm}

{\sl\begin{quote}

To improve designers' productivity, the electronic design industry
needs a methodology based on both worldwide standards and open
interfaces. Accellera was formed in 2000 through the unification of
Open Verilog International and VHDL International to focus on
identifying new standards, development of standards and formats, and
to foster the adoption of new methodologies.

Accellera's mission is to drive worldwide development and use of
standards required by systems, semiconductor and design tools
companies, which enhance a language-based design automation
process. Its Board of Directors guides all the operations and
activities of the organisation and is comprised of representatives
from ASIC manufacturers, systems companies and design tool vendors.
\end{quote}}

\vspace*{-1mm}

Faced with a plethora of syntactically and semantically incompatible
formal property languages, Accellera initiated a process of selecting
a standard property language to ``drive assertion-based verification''.

\newpage

Four contributions were initially considered

\vspace*{-3mm}

\begin{itemize}

\item Motorola's CBV language;

\item IBM's Sugar (the language of its RuleBase FV toolset);

\item Intel's ForSpec;

\item Verisity's {\it e} language (the language of the Specman Elite testbench).

\end{itemize}

\vspace*{-3mm}

After a combination of discussion and voting, some details of which
can be viewed on the web\footnote{\url{http://www.eda.org/vfv/hm/}},
attention was narrowed down to Sugar and CBV, and then in April
2002 a vote\footnote{\url{http://www.eda.org/vfv/hm/0795.html}}
selected IBM's submission, \Sugar.


\Sugar is primarily an LTL-based language that is a successor to 
the CTL-based {\it Sugar~1\/} \cite{sugar}. A key idea of both languages is the use
of ITL-like \cite{ITL} constructs called {\it Sugar Extended Regular Expressions}.
\Sugar retains CTL constructs in its {\it Optional Branching Extension} (OBE),
but this is de-emphasised in the defining document.

Besides moving from CTL to LTL, \Sugar supports clocking and finite
paths.  Clocking allows one to specify on which clock edges signals are
sampled at (i.e. it defines the `next event' for each signal). The
finite path semantics allows properties to be interpreted on
simulation runs, as in test-bench tools like Specman and Vera.

The addition of clocking and finite path semantics makes the \Sugar
semantics more than twice as complicated as the {\it Sugar~1}
semantics. However, for a real `industry standard' language \Sugar is still
remarkably simple, and it was routine to define the abstract syntax
and semantics of the whole language in \Hol \cite{GordonMelham}.

In the rest of this paper we start by discussing the point of
embedding Sugar in \Hol. Next we briefly review semantic embedding,
illustrating the
ideas on simplified semantics of fragments of \Sugar.  We then
give the complete semantics of \Sugar, and finally we discuss our
small achievements so far in analysing the semantics using the
\Hol system, including a discussion of the bugs found.

\vspace*{-3mm}

\section{Why embed Sugar in \Hol?}

\vspace*{-3mm}

There are several justifications for the work described here. This project
has only just started and its goals are still being defined. Current motivations include
the following.

\vspace*{-3mm}

\subsection{Sanity checking and proving meta-theorems}


By formalising the semantics and passing it through a parser and
type-checker one achieves a first level of sanity checking of the
definition. One also exposes possible ambiguities, fuzzy corner cases etc
(e.g. see Section~\ref{finite}).
The process is also very educational for the formaliser and
a good learning exercise.

There are a number of meta-theorems one might expect to be true, and
proving them with a theorem prover provides a further and deeper kind
of sanity checking.  In the case of \Sugar, such meta-theorems include
showing that expected simplifications to the semantics occur if
there is no non-trivial clocking, that different semantics of clocking
are equivalent and that if finite paths are ignored then the standard
`text-book semantics' results. Such meta-theorems are generally mathematically
shallow, but full of tedious details -- i.e.~ideal for automated
theorem proving. See Section~\ref{progress} for what we have proved so far. 
It's not much, but we have already found minor bugs in the semantics!

A key feature of the Sugar approach is to have a small kernel and a large
number of definitions. Using a theorem prover,
the definitions can be validated by proving that they achieve the
correct semantics.  See, for example, the analysis of \t{FirstRise}
and \t{NextRise} in Section~\ref{progress} (these are not official
Sugar definitions, but the analysis here illustrates the idea of
validating definitions).
\vspace*{-3mm}

\subsection{Develop a machine readable semantics}

The current \Sugar document is admirably clear, but it is informal mathematics presented
as typeset text. Tool developers  could benefit from a machine readable version.
One might think of using some standard representation of mathematical content,
like  MathML\footnote{\url{http://www.w3.org/Math/}}, however there is currently
not much mathematically sophisticated tool support for such XML-based representations. 

Higher order logic is a fairly widely used formalisation medium
(e.g. versions of higher order logic are used by \Hol,
Isabelle/HOL, PVS, NuPrl and Coq) and once one has a representation
in it then representations in other formats should be straightforward
to derive.

\vspace*{-3mm}

\subsection{Research using our local tools}


We are contemplating developing semantically-based reasoning and
checking infrastructure in \HOL to support \Sugar, and a prerequisite
for this is to have a `golden semantics' to which application specific
semantics can be proved equivalent.

One area of research that we have an interest in is the development of property
languages that support data operations and can have variables
ranging over infinite data-types like numbers
(e.g.~including reals and complex numbers for DSP applications). Some
sort of mixture of Hoare Logic and \Sugar is being contemplated
(rather vaguely, it must be admitted).  Developing the language by
extending an existing semantics is a way to ensure some `backward
compatibility'.  Also, we might wish to prove sanity checking
meta-theorem about our extended language, e.g.~that it collapses to
\Sugar when there are no infinite types.

\vspace*{-3mm}

\subsection{Education}

Both semantic embedding and property specification are taught as part
of the Computer Science undergraduate course at
Cambridge%
\footnote{\url{http://www.cl.cam.ac.uk/users/mjcg/Teaching/SpecVer2/SpecVer2.html}},
and being able to illustrate the ideas on a real example like \Sugar
is pedagogically valuable.

The semantic embadding of \Sugar in the \Hol system is an interesting case
study. It nicely illustrates some issues in making total functional
definitions, and the formal challenges attempted so far provide
insight into how to perform structural induction using the built-in
tools.  Thus \Sugar has educational potential for training \Hol
users. In fact, the semantics described in this paper is an
example distributed with \Hol.%
\footnote%
{\url{http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/hol/hol98/examples/Sugar2/}}

\section{Review of semantic embedding in higher order logic}\label{review}

Higher order logic is an extension of first-order predicate calculus
that allows quantification over functions and relations. It is a
natural language for formalising informal set theoretic specifications
(indeed, it is usually more natural than formal first-order set
theories, like ZF).  We hope that the \Hol notation that follows is
sufficiently close to standard informal notation that it needs no
systematic explanation.

We use Church's $\lambda$-notation for denoting functions: 
a `lambda-term' like $\lambda x.~t$, where $x$
is a variable and $t$ a term, denotes the function 
that maps a value $v$ to the result of substituting $v$ for the
variable $x$ in $t$ (the infix notation $x \mapsto t$ is
sometimes used instead of $\lambda x.~t$).

To embed\footnote{We shall only be concerned with so called `deep
embeddings' here.}  a language in \Hol one first defines constructors
for all the syntactic constructs of the language. This is the
`abstract syntax' and provides a representation of parse trees as
terms in the logic.  The semantics is then given by defining a
semantic function that recursively maps each construct to a
representation of its meaning.

For \Sugar, a model \t{M} is a quintuple
$(\t{S}_{\t{M}},{\t{S}_0}_{\t{M}},\t{R}_{\t{M}},\t{P}_{\t{M}},\t{L}_{\t{M}})$, where $\t{S}_{\t{M}}$
is a set of states, ${\t{S}_0}_{\t{M}}$ is the subset of initial states, $\t{R}_{\t{M}}$ is a
transition relation (so $\t{R}_{\t{M}}(s,s')$ means $s'$ is a possible
successor state to $s$), $\t{P}_{\t{M}}$ is a set of atomic propositions, and
$\L_{\t{M}}$ is a valuation that maps a state to the
set of atomic propositions that hold at the state
(so $\L~s~\t{p}$ is true iff atomic proposition
\t{p} is true in state $s$).

The syntax of boolean expressions \t{b}
built from atomic propositions
(ranged over by \t{p}) using negation ($\neg$) and conjunction ($\wedge$)
is given by:


\medskip

$\begin{array}{ccll}
{\t{b}} & {\rm ::=} & \t{p}
  & \mbox{\rm(Atomic formula)}\\
 & \phantom{\rm ::}\mid & \neg{\t{b}}
  & \mbox{\rm(Negation)}\\
 & \phantom{\rm ::}\mid & {\t{b}}_1~\wedge~{\t{b}}_2
  & \mbox{\rm(Conjunction)}\\
\end{array}$

\medskip

\noindent in \Hol this is defined by a recursive type definition of
a syntactic type of boolean expressions.

Let \t{l} range over predicates on $\t{P}_{\t{M}}$, called ``truth assignments'' in the Sugar
documentation.
The semantics of boolean expressions
is given by defining a semantic function \Bsem such that
$\Bsem~\t{M}~\t{l}~\t{b}$ if true iff \t{b} is built from propositions in $\t{P}_{\t{M}}$ and
it is true with respect to the truth assignment \t{l}.

If we write $\bSem{M}{l}{b}$ for $\Bsem~\t{M}~\t{l}~\t{b}$
then the semantics is given by


{\begin{alltt}
   ({\BSem{M}{l}{\bProp{p}}}     = p {\In} \(\t{P}\sb{\t{M}}\) {\And} p {\In} l)
   {\And}
   ({\BSem{M}{l}{\bTrue}}     = T)
   {\And}
   ({\BSem{M}{l}{{\bNot{b}}}}    = {\Not}{\BSem{M}{l}{b}})
   {\And}
   ({\BSem{M}{l}{\bAnd{b1}{b2}}} = {\BSem{M}{l}{b1}} {\And} {\BSem{M}{l}{b2}})
\end{alltt}}

\medskip



Before looking at the full official semantics of \Sugar, we first
consider a simplified semantics in which there is no clocking, and paths
are always infinite. We consider separately the parts of \Sugar corresponding
to Interval Temporal Logic (ITL), Linear Temporal Logic (LTL) and
Computation Tree Logic (CTL).


\subsection{ITL: Sugar Extended Regular Expressions (SEREs)}\label{SimpleSERE}

Interval Temporal Logic (ITL) provides formulas that are true or false
of intervals of states.  Here we just consider finite intervals,
though recent formulations of ITL\footnote{\url{http://www.cms.dmu.ac.uk/{\homedir}cau/itlhomepage/}} 
allow intervals to be infinite. For
Sugar we only need to consider ITL formulas, as there are no constructs
corresponding to ITL expressions (expressions map intervals to
values). Providing more elaborate ITL constructs in Sugar strikes us as an interesting research topic.



The Sugar subset corresponding to ITL is called {\it Sugar Extended
Regular Expressions} (SEREs).  If $\t{r}$ ranges over SEREs and \t{p} ranges over a
set  $\t{P}_{\t{M}}$ of atomic propositions, then the syntax is given by:



\medskip

$\begin{array}{ccll}
{\t{r}} & {\rm ::=} & \t{p}
  & \mbox{\rm(Atomic formula)}\\
 & \phantom{\rm ::}\mid & \{{\t{r}}_1\}~\texttt{|}~\{{\t{r}}_2\}
  & \mbox{\rm(Disjunction)}\\
 & \phantom{\rm ::}\mid & {\t{r}}_1~{\bf{{\SC}}}~{\t{r}}_2~~~~~~~~~~~~
  & \mbox{\rm(Concatenation)}\\
 & \phantom{\rm ::}\mid & {\t{r}}_1~{\bf{{\C}}}~{\t{r}}_2
  & \mbox{\rm(Fusion: ITL's chop)}\\
 & \phantom{\rm ::}\mid & \{{\t{r}}_1\}~\texttt{\&\&}~\{{\t{r}}_2\}
  & \mbox{\rm(Length matching conjunction)}\\
 & \phantom{\rm ::}\mid & \{{\t{r}}_1\}~\texttt{\&}~\{{\t{r}}_2\}
  & \mbox{\rm(Flexible matching conjunction)}\\
 & \phantom{\rm ::}\mid & {\t{r}}{\bf{[*]}}
  & \mbox{\rm(Repeat)}\\
\end{array}$

\medskip

The semantics of SEREs 
is given by defining a semantic function \Ssem such that
$\Ssem~\t{M}~\t{w}~\t{r}$ if true iff \t{w} is in the language of the extended regular expression
\t{r}.  

We write $\sSem{M}{w}{\c}{r}$ for $\Ssem~\t{M}~\t{w}~\t{r}$.

If \texttt{wlist} is a list of lists then
\texttt{\CONCAT{wlist}} is the concatenation of the lists
in \texttt{wlist} and if $P$ is some predicate
then \texttt{\EVERY{$P$}wlist} means that $P(\texttt{w})$
holds for every \texttt{w} in \texttt{wlist}.

{\begin{alltt}
   ({\SSem{M}{w}{\c}{\sBool{b}}} = 
     {\Exists}l. (w = [l]) \And {\BSem{M}{l}{b}})
   {\And}
   ({\SSem{M}{w}{\c}{\sCat{r1}{r2}}} = 
     {\Exists}w1 w2. (w = w1{\Cat}w2) {\And} {\SSem{M}{w1}{\c}{r1}} {\And} {\SSem{M}{w2}{\c}{r2}})
   {\And}
   ({\SSem{M}{w}{\c}{\sFusion{r1}{r2}}} = 
     {\Exists}w1 w2 l. (w = w1{\cat}[l]{\cat}w2) {\And} 
               {\SSem{M}{(w1{\cat}\texttt{[}l\texttt{]})}{\c}{r1}} {\And} {\SSem{M}{(\texttt{[}l\texttt{]}{\cat}w2)}{\c}{r2}}) 
   {\And}
   ({\SSem{M}{w}{\c}{\sOr{r1}{r2}}} = 
     {\SSem{M}{w}{\c}{r1}} {\Or} {\SSem{M}{w}{\c}{r2}}) 
   {\And}
   ({\SSem{M}{w}{\c}{\sRigAnd{r1}{r2}}} = 
     {\SSem{M}{w}{\c}{r1}} {\And} {\SSem{M}{w}{\c}{r2}}) 
   {\And}
   ({\SSem{M}{w}{\c}{\sFlexAnd{r1}{r2}}} = 
     {\Exists}w1 w2. (w = w1{\Cat}w2) {\And} 
             (({\SSem{M}{w}{\c}{r1}} {\And} {\SSem{M}{w1}{\c}{r2}}) 
              {\Or}
              ({\SSem{M}{w}{\c}{r2}} {\And} {\SSem{M}{w1}{\c}{r1}})))
   {\And}
   ({\SSem{M}{w}{\c}{\sRepeat{r}}} = 
     {\Exists}wlist. (w = \CONCAT{wlist}) {\And} \EVERY{({\Lam}w. {\SSem{M}{w}{\c}{r}})}{wlist})
\end{alltt}}

\vspace*{-6mm}

\subsection{LTL: Sugar Foundation Language (FL)}



\Sugar has a kernel combining standard LTL notation
with a less standard \t{abort} operation and some constructs using SEREs. The suffix
``\texttt{!}~'' found on some constructs indicates
that these are `strong' (i.e. liveness-enforcing) operators.  The
distinction between strong and weak operators is given in the
semantics of full \Sugar in Section~\ref{SugarSemantics}. Numerous
additional notations are introduced by definitions (which are
conservative extensions of the language, and can be formalised as
definitions in \Hol).

\smallskip

$\begin{array}{llll}
{\t{f}} & {\rm ::=} & \t{p}
  & \mbox{\rm(Atomic formula)}\\
 & \phantom{\rm ::}\mid & \TLNot{\t{f}}
  & \mbox{\rm(Negation)}\\
 & \phantom{\rm ::}\mid & {\t{f}}_1~\TLAnd~{\t{f}}_2
  & \mbox{\rm(Conjunction)}\\
 & \phantom{\rm ::}\mid & \texttt{X!}{\t{f}}
  & \mbox{\rm(Successor)}\\
 & \phantom{\rm ::}\mid & [{\t{f}}_1~\texttt{U}~{\t{f}}_2]~~~~
  & \mbox{\rm(Until)}\\
 & \phantom{\rm ::}\mid & \{{\t{r}}\}({\t{f}})~~~~
  & \mbox{\rm(Suffix implication)}\\
 & \phantom{\rm ::}\mid & \{{\t{r}}_1\}~\texttt{|->}~\{{\t{r}}_2\}\texttt{!}~~~~
  & \mbox{\rm(Strong suffix implication)}\\
 & \phantom{\rm ::}\mid & \{{\t{r}}_1\}~\texttt{|->}~\{{\t{r}}_2\}~~~~
  & \mbox{\rm(Weak suffix implication)}\\
 & \phantom{\rm ::}\mid & \t{f}~\texttt{abort}~{\t{b}}~~~~
  & \mbox{\rm(Abort)}\\
\end{array}$

\medskip

Being LTL, the semantics of FL formulas is defined with respect to a path $\pi$,
which (in the simplified semantics here) is a function from the natural numbers to states.

We define a semantic function \Fsem such that $\Fsem~\t{M}~\pi~\t{f}$
means FL formula \t{f} is true of path $\pi$.
We write $\fSem{M}{\pi}{\c}{r}$ for $\Fsem~\t{M}~\pi~\t{f}$.


Note that in the semantics below it is not assumed that paths $\pi$ are necessarily computations
(i.e.~satisfy $\texttt{Path~M}~\pi$, as defined in Section~\ref{OBE}). This is important
for the \t{abort} construct (where the $\exists\pi'$ quantifies over all paths).

The notation $\pi_i$ denotes the $i$-th state in the path (i.e.~$\pi(i)$);
$\pi^i$ denotes the `$i$-th tail' of $\pi$ -- the path obtained
by chopping $i$ elements off the front of $\pi$ (i.e. $\pi^i~=~\lambda n.~\pi(n{+}i)$).
$\pi^{(i,j)}$ denotes the finite sequence of states from $i$ to $j$ in $\pi$,
i.e.~$\pi_i\pi_{i{+}1}\cdots\pi_j$. The juxtaposition
$\pi^{(i,j)}\pi'$ denotes the path obtained by concatenating the finite sequence
$\pi^{(i,j)}$ on to the front of the path $\pi'$. 

The function $\hat{\t{L}}_{\t{M}}$ denotes the point-wise extension of
$\t{L}_{\t{M}}$ to finite sequences of states
(i.e.~$\texttt{MAP}~\t{L}_{\t{M}}$ in \Hol and functional programming notation).



{\begin{alltt}
    ({\FSem{M}{{\pi}}{{\c}}{\FBool{b}}} = 
     {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{0})}{b}}
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fNot{f}}} =
     {\Not}({\FSem{M}{{\pi}}{\c}{f}})) 
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fAnd{f1}{f2}}} =
     {\FSem{M}{\pi}{{\c}}{f1}} {\And} {\FSem{M}{\pi}{{\c}}{f2}})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fNext{f}}} =
     {\FSem{M}{\restN{{\pi}}{1}}{{\c}}{f)}}
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fUntil{f1}{f2}}} = 
      {\Exists}k. {\FSem{M}{\restN{{\pi}}{k}}{\c}{f2}} {\And} {\Forall}j. j \Le k \Imp {\FSem{M}{\restN{{\pi}}{j}}{{\c}}{f1}})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fSuffixImp{r}{f}}} = 
      {\Forall}j. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(0,j)}))}{\c}{r} {\Imp} {\FSem{M}{\restN{{\pi}}{j}}{{\c}}{f}})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fStrongImp{r1}{r2}}} = 
      {\Forall}j. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(0,j)}))}{\c}{r1} {\Imp} {\Exists}k. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(j,k)}))}{\c}{r2})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fWeakImp{r1}{r2}}} = 
     {\FSem{M}{{\pi}}{{\c}}{\fStrongImp{r1}{r2}}}
      \Or
      {\Forall}j. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(0,j)}))}{\c}{r1} 
          \Imp ({\Exists}k. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(j,k)}))}{\c}{r2})
             \Or
             {\Forall}k. {\Exists}w. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(j,k)}))w}{\c}{r2})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fAbort{f}{b}}} =
      ({\FSem{M}{\pi}{{\c}}{f }}
       {\Or}
       {\Exists}j {\Pi}'. {\FSem{M}{\restN{{\pi}}{j}}{\c}{{\FBool{b}}}} {\And} {\FSem{M}{\pathCat{\pathSeg{\pi}{(i,j-1)}}{{\pi}'}}{{\c}}{f}}))
\end{alltt}}

\subsection{CTL: Sugar Optional Branching Extension (OBE)}\label{OBEfinite}

The syntax of the \Sugar OBE is completely standard. The syntax of
the OBE formulas is:

\medskip


$\begin{array}{ccll}

{\t{f}} & {\rm ::=} & \t{p}
  & \mbox{\rm(Atom)}\\

 & \phantom{\rm ::}\mid & \TLNot{\t{f}}
  & \mbox{\rm(Negation)}\\

 & \phantom{\rm ::}\mid & {\t{f}}_1~\TLAnd~{\t{f}}_2
  & \mbox{\rm(Conjunction)}\\

 & \phantom{\rm ::}\mid & {\bf{EX}}{\t{f}}
  & \mbox{\rm(Some successors)}\\

 & \phantom{\rm ::}\mid & {\bf{E}}{\lsb}{\t{f}}_1~{\bf{U}}~{\t{f}}_2{\rsb}
  & \mbox{\rm(Until -- along some path)}\\

 & \phantom{\rm ::}\mid & {\bf{EG}}{\t{f}}
  & \mbox{\rm(Always on some path)}\\

\end{array}$

\medskip

For the semantics, define $\texttt{Path~M}~\pi$ to be true iff $\pi$ is a computation of \texttt{M}:

{\begin{alltt}
   Path M {\Pi} = {\Forall}n. \getR{M}(\PathEl{{\pi}}{n}, \PathEl{{\pi}}{n+1})
\end{alltt}}


The semantic function \Osem is defined so that
\texttt{\Osem~M~s~f} is true iff \texttt{f} is true of \texttt{M} at
state \texttt{s}.
Write $\oSem{M}{s}{f}$ for \texttt{\Osem~M~s~f}, and then the semantics of the OBE is defined by:

{\begin{alltt}
   (\OSem{M}{s}{\oBool{b}} = {\BSem{M}{\lNoHat{M}(s)}{b}})
   {\And}
   (\OSem{M}{s}{\oNot{f}} = {\Not}(\OSem{M}{s}{f})) 
   {\And}
   (\OSem{M}{s}{\oAnd{f1}{f2}} = \OSem{M}{s}{f1} {\And} \OSem{M}{s}{f2})
   {\And}
   (\OSem{M}{s}{\oEx{f}} = 
     {\Exists}{\Pi}. Path M {\Pi} {\And} (\PathEl{{\pi}}{0} = s) {\And} \OSem{M}{\pathEl{{\pi}}{1}}{f})
   {\And}
   (\OSem{M}{s}{\oEu{f1}{f2}} = 
     {\Exists}{\Pi}. Path M {\Pi} {\And} (\PathEl{{\pi}}{0} = s) \And
         \OSem{M}{\pathEl{{\pi}}{k}}{f2} {\And} {\Forall}j. j {\Le} k {\Imp} \OSem{M}{\pathEl{{\pi}}{j}}{f1})
   {\And}
   (\OSem{M}{s}{\oEg{f}} = 
     {\Exists}{\Pi}. Path M {\Pi} {\And} (\PathEl{{\pi}}{0} = s) {\And} {\Forall}j. \OSem{M}{\pathEl{{\pi}}{j}}{f})
\end{alltt}}


\section{Full \Sugar semantics in higher order logic}\label{SugarSemantics}

The semantics that follows is derived from of a deep semantic embedding of
{\it Sugar 2.0} in higher order logic (HOL-4 version).
The official  \Sugar semantics 
can be found in the Accellera submission document \cite{Accellera}


\medskip

~~{
\url{http://www.haifa.il.ibm.com/projects/verification/sugar/literature.html}}

\medskip

Corresponding to Appendix A.1 of the Sugar documentation
we have defined types \texttt{bexp}, \texttt{sere}, \texttt{fl} and
\texttt{obe} in the HOL logic to represent the syntax of Boolean Expressions, Sugar
Extended Regular Expressions (SEREs), formulas of the Sugar Foundation
Language (FL) and formulas of the Optional Branching Extension (OBE),
respectively.


Corresponding to Appendix A.2 of the Sugar documentation
we have defined semantic functions \texttt{B\_SEM}, \texttt{S\_SEM},
\texttt{F\_SEM} and \texttt{O\_SEM} that interpret boolean expressions,
SEREs, FL formulas and OBE formulas, respectively.

The HOL definitions can be seen in

\medskip

~~{\url{http://www.cl.cam.ac.uk/{\homedir}mjcg/Sugar}}

\medskip

In the next two sub-sections we discuss clocking and finite paths.
In the remaining four sub-sections 
we give manually
typeset versions of the HOL definitions of the semantic functions. The
typesetting was done as algorithmically as I could by editing the HOL
sources. I hope to have avoided
transcription errors, but this cannot be guaranteed. Following
some proof activity, changes to the original HOL semantics have been
made, as discussed in Section~\ref{progress}.

\subsection{Clocking}

If \t{b} is a boolean expression, then the SERE \texttt{b@clk} recognises
a sequence of states in which \t{b} is true on the next rising edge of \texttt{clk}.
Thus \texttt{b@clk} behaves like \texttt{\{$\neg$clk[*]; clk ${\wedge}$ b\}}.

One can also clock formulas (\texttt{f@clk}), and there may be
several clocks. Consider:\footnote{The discussion of clocking here is based on email communication
with Cindy Eisner.}

\medskip

~~\texttt{G(req\_in -> X(req\_out@clkb))@clka}

\medskip

\noindent this means that the entire formula is clocked on
clock \texttt{clka}, except that signal \texttt{req\_out} is clocked on \texttt{clkb}. 
Clocks do not ``accumulate'', so
the signal \texttt{req\_out} is only clocked by \texttt{clkb}, not by both clocks.  
Thus \texttt{clkb} ``protects''
\texttt{req\_out} from the main clock, \texttt{clka}, i.e.:

\medskip

~~\texttt{req\_out@clkb@clka = req\_out@clkb}

\medskip

\noindent This meaning of clocking prevents us simply defining:

\medskip

~~\texttt{req\_out@clkb = [$\neg$clkb U (clkb $\wedge$ req\_out)]}

\medskip

\noindent since if this were the definition of \texttt{req\_out@clkb}
then we would be forced to have:

\medskip

~~\texttt{req\_out@clkb@clka = [$\neg$clkb U (clkb $\wedge$ req\_out)]@clka}

\medskip

\noindent when we actually want

\medskip

~~\texttt{req\_out@clkb@clka = req\_out@clkb}

\medskip

Thus we cannot just rewrite away clocking annotations using 
equational reasoning. However, if one starts at the outside and works
inwards, then one can systematically compile away clocking. The rules
for doing this are given in the \Sugar documentation as part of the
implementation of formal verification.

The official semantics uses a different approach in which the
currently active clock is an argument of the semantic function used
to interpret SEREs and formulas.  Proving this approach equivalent to
compiling away clocks, followed by a simpler unclocked semantics, is
one of the formal challenges to which we hope to submit the semantics.


\subsection{Finite paths}\label{finite}

\Sugar gives a semantics to formulas for both finite and infinite
paths.  To represent this, we model a path as being either a finite
list of states or a function from natural numbers to states and define a
predicate \t{finite} to test if a path is a finite list. The function
\t{length} gives the length of a finite path (it is not defined on
paths for which \t{finite} is not true).

\noindent We interpret the official semantics locution 

~~``for every $j < \t{length}(\pi)$:$~\cdots~j~\cdots$''

\noindent as meaning 

~~``for every $j$: (\t{finite}~$\pi$ implies $j < \t{length}(\pi)$) implies $~\cdots~j~\cdots$''

\noindent and we interpret the official semantics locution 

~~``there exists $j < \t{length}(\pi)$ s.t.$~\cdots~j~\cdots$''

\noindent as meaning 

~~``there exists $j$ s.t. (\t{finite}~$\pi$ implies $j < \t{length}(\pi)$) and $~\cdots~j~\cdots$''

Here is a version of the unclocked FL semantics that allows
paths to be finite.




{\begin{alltt}
    ({\FSem{M}{{\pi}}{{\c}}{\FBool{b}}} = 
     {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{0})}{b}}
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fNot{f}}} =
     {\Not}({\FSem{M}{{\pi}}{\c}{f}})) 
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fAnd{f1}{f2}}} =
     {\FSem{M}{\pi}{{\c}}{f1}} {\And} {\FSem{M}{\pi}{{\c}}{f2}})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fNext{f}}} =
     ({\IsFinitePath} {\Pi} {\Imp} \PathLength {\Pi} \Ge 1) \And {\FSem{M}{\restN{{\pi}}{1}}{{\c}}{f)}}
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fUntil{f1}{f2}}} = 
      {\Exists}k. {\FSem{M}{\restN{{\pi}}{k}}{\c}{f2}} 
          \And ({\IsFinitePath} {\Pi} {\Imp} k {\Le} \PathLength {\Pi}) \And {\Forall}j. j \Le k \Imp {\FSem{M}{\restN{{\pi}}{j}}{{\c}}{f1}})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fSuffixImp{r}{f}}} = 
      {\Forall}j. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(0,j)}))}{\c}{r} {\Imp} {\FSem{M}{\restN{{\pi}}{j}}{{\c}}{f}})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fStrongImp{r1}{r2}}} = 
      {\Forall}j. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(0,j)}))}{\c}{r1} {\Imp} {\Exists}k. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(j,k)}))}{\c}{r2})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fWeakImp{r1}{r2}}} = 
     {\FSem{M}{{\pi}}{{\c}}{\fStrongImp{r1}{r2}}}
      \Or
      {\Forall}j. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(0,j)}))}{\c}{r1} 
          \Imp ({\Exists}k. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(j,k)}))}{\c}{r2})
             \Or
             {\Forall}k. ({\IsFinitePath} {\Pi} {\Imp} k {\Le} \PathLength {\Pi}) 
                  \Imp {\Exists}w. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(j,k)}))w}{\c}{r2})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fAbort{f}{b}}} =
      ({\FSem{M}{\pi}{{\c}}{f }}
       {\Or}
       {\Exists}j {\Pi}'. {\FSem{M}{\restN{{\pi}}{j}}{\c}{{\FBool{b}}}} {\And} {\FSem{M}{\pathCat{\pathSeg{\pi}{(0,j-1)}}{{\pi}'}}{{\c}}{f}}))
\end{alltt}}

This semantics is similar to an existing unpublished semantics of unclocked 
FL formulas\footnote{Personal communication from Cindy Eisner.},
except that the restriction $\tt{finite~\pi~\Rightarrow~k < length~\pi}$
and disjunct $\tt{({\exists}k.~\sSem{M}{(\lHat{M} (\pathSeg{\pi}{(j,k)}))}{\c}{r2})}$
were added to the semantics of $\fWeakImp{r1}{r2}$ to ensure equivalence with the clocked semantics
in Section~\ref{FL}.

The following four sub-sections are the manually typeset HOL semantics of \Sugar.

\subsection{Boolean expressions}

The semantics below is identical to that given earlier
in Section~\ref{review}.

{\begin{alltt}
   ({\BSem{M}{l}{\bProp{p}}}     = \(p\) {\In} P\(\sb{M}\) {\And} \(p\) {\In} l)
   {\And}
   ({\BSem{M}{l}{\bTrue}}     = T)
   {\And}
   ({\BSem{M}{l}{{\bNot{b}}}}    = {\Not}{\BSem{M}{l}{b}})
   {\And}
   ({\BSem{M}{l}{\bAnd{b1}{b2}}} = {\BSem{M}{l}{b1}} {\And} {\BSem{M}{l}{b2}})
\end{alltt}}

\subsection{Sugar Extended Regular Expressions}\label{FullSERE}


The semantics of SEREs expressions
is given by defining a semantic function \Ssem such that
$\Ssem~\t{M}~\t{w}~\t{c}~\t{r}$ if true iff \t{w} is in the language of the extended regular expression
\t{r} clocked with \t{c}.  

We write $\sSem{M}{w}{c}{r}$ for $\Ssem~\t{M}~\t{w}~\t{c}~\t{r}$.


If \texttt{wlist} is a list of lists then
\texttt{\CONCAT{wlist}} is the concatenation of the lists
in \texttt{wlist} and if $P$ is some predicate
then \texttt{\EVERY{$P$}wlist} means that $P(\texttt{w})$
holds for every \texttt{w} in \texttt{wlist}.

{\begin{alltt}
   ({\SSem{M}{w}{c}{\sBool{b}}} = 
     {\Exists}n. n {\Geq} 1                                 {\And} 
         ({\PathLength} w = n)                         {\And} 
         ({\Forall}i. 1 {\Leq} i {\And} i {\Le} n {\Imp} {\BSem{M}{\el{i-1}{w}}{\bNot{c}}} {\And}
         {\BSem{M}{\el{n-1}{w}}{\bAnd{c}{b}}})
   {\And}
   ({\SSem{M}{w}{c}{\sCat{r1}{r2}}} = 
     {\Exists}w1 w2. (w = w1{\Cat}w2) {\And} {\SSem{M}{w1}{c}{r1}} {\And} {\SSem{M}{w2}{c}{r2}})
   {\And}
   ({\SSem{M}{w}{c}{\sFusion{r1}{r2}}} = 
     {\Exists}w1 w2 l. (w = w1{\cat}[l]{\cat}w2) {\And} 
               {\SSem{M}{(w1{\cat}\texttt{[}l\texttt{]})}{c}{r1}} {\And} {\SSem{M}{(\texttt{[}l\texttt{]}{\cat}w2)}{c}{r2}}) 
   {\And}
   ({\SSem{M}{w}{c}{\sOr{r1}{r2}}} = 
     {\SSem{M}{w}{c}{r1}} {\Or} {\SSem{M}{w}{c}{r2}}) 
   {\And}
   ({\SSem{M}{w}{c}{\sRigAnd{r1}{r2}}} = 
     {\SSem{M}{w}{c}{r1}} {\And} {\SSem{M}{w}{c}{r2}}) 
   {\And}
   ({\SSem{M}{w}{c}{\sFlexAnd{r1}{r2}}} = 
     {\Exists}w1 w2. (w = w1{\Cat}w2) {\And} 
             (({\SSem{M}{w}{c}{r1}} {\And} {\SSem{M}{w1}{c}{r2}}) 
              {\Or}
              ({\SSem{M}{w}{c}{r2}} {\And} {\SSem{M}{w1}{c}{r1}})))
   {\And}
   ({\SSem{M}{w}{c}{\sRepeat{r}}} = 
     {\Exists}wlist. (w = \CONCAT{wlist}) {\And} \EVERY{({\Lam}w. {\SSem{M}{w}{c}{r}})}{wlist})
   {\And}
   ({\SSem{M}{w}{c}{\sClock{r}{c1}}} =
     {\SSem{M}{w}{c1}{r}})
\end{alltt}}

\vspace*{-8mm}

\subsection{Foundation Language}\label{FL}

\vspace*{-2mm}

We define a semantic function \Fsem such that $\Fsem~\t{M}~\pi~\t{c}~\t{f}$
means FL formula \t{f} is true of path $\pi$ if the current clock is \t{c}.
The cases for weak (\t{c}) and strong (\t{c!}) clocks are considered separately.

\noindent We write $\fSem{M}{\pi}{c}{r}$ for $\Fsem~\t{M}~\pi~\t{c}~\t{f}$
and use the following two definitions:

\vspace*{-4.5mm}

{\begin{alltt}
   FirstRise M {\Pi} c i    = \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(0,i)}))}{\bTrue}{\sCat{\sRepeat{\sBool{\bNot{c}}}}{\sBool{c}}}
   NextRise M {\Pi} c (i,j) = \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(i,j)}))}{\bTrue}{\sCat{\sRepeat{\sBool{\bNot{c}}}}{\sBool{c}}}
\end{alltt}}

\vspace*{-3.5mm}

\noindent The semantic clauses are then:

\vspace*{-3.5mm}

{\begin{alltt}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\FBool{b}}} = 
      {\Exists}i. FirstRise M {\Pi} c i {\And} {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{i})}{b}})
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fNot{f}}} = 
      {\Not}({\FSem{M}{{\pi}}{{\weakClock{c}}}{f}})) 
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fAnd{f1}{f2}}} = 
      {\Exists}i. FirstRise M {\Pi} c i {\And} 
          {\FSem{M}{\restN{{\pi}}{i}}{{\strongClock{c}}}{f1}}    {\And}
          {\FSem{M}{\restN{{\pi}}{i}}{{\strongClock{c}}}{f2}})
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fNext{f}}} = 
      {\Exists}i. FirstRise M {\Pi} c i            {\And} 
          ({\IsFinitePath} {\Pi} {\Imp} i {\Le} \PathLength {\Pi} - 1) {\And}
          {\FSem{M}{\restN{{\pi}}{i+1}}{{\strongClock{c}}}{f)}}
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fUntil{f1}{f2}}} = 
      {\Exists}i k. k {\Geq} i  \(\hspace*{0.8mm}\)                 {\And}
            ({\IsFinitePath} {\Pi} {\Imp} k {\Le} \PathLength {\Pi}) \And
            FirstRise M {\Pi} c i    \(\hspace*{0.4mm}\)    {\And}
            {\FSem{M}{\restN{{\pi}}{k}}{\weakClock{\T}}{{\FBool{c}}}} \(\hspace*{0.8mm}\)           {\And}  
            {\FSem{M}{\restN{{\pi}}{k}}{{\strongClock{c}}}{f2}}           {\And}
            {\Forall}j. i {\Leq} j {\And} j {\Le} k {\And} 
                {\FSem{M}{\restN{{\pi}}{j}}{\weakClock{\T}}{{\FBool{c}}}} 
                {\Imp}
                {\FSem{M}{\restN{{\pi}}{j}}{{\strongClock{c}}}{f1}})
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fSuffixImp{r}{f}}} = 
      {\Exists}i. FirstRise M {\Pi} c i {\And} 
          {\Forall}j. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(i,j)}))}{c}{r}
              {\Imp}
              {\FSem{M}{\restN{{\pi}}{j}}{{\strongClock{c}}}{f}})
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fStrongImp{r1}{r2}}} = 
      {\Exists}i. FirstRise M {\Pi} c i {\And} 
          {\Forall}j. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(i,j)}))}{c}{r1}
              {\Imp}
              {\Exists}k. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(j,k)}))}{c}{r2})
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fWeakImp{r1}{r2}}} = 
     {\FSem{M}{{\pi}}{{\strongClock{c}}}{\fStrongImp{r1}{r2}}}
     {\Or}
     ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fWeakImp{r1}{r2}}}
      {\And}
      {\Forall}j. ({\IsFinitePath} {\Pi} {\Imp} j {\Le} \PathLength {\Pi})
          {\Imp}
          {\Exists}k. NextRise M {\Pi} c (j,k)))
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fAbort{f}{b}}} =
      {\Exists}i. FirstRise M {\Pi} c i {\And}
          ({\FSem{M}{\restN{{\pi}}{i}}{{\strongClock{c}}}{f }}
           {\Or}
           {\Exists}j {\Pi}'. 
             {\FSem{M}{\restN{{\pi}}{j}}{\weakClock{\T}}{{\FBool{\bAnd{c}{b}}}}} {\And} 
             {\FSem{M}{\pathCat{\pathSeg{\pi}{(i,j-1)}}{{\pi}'}}{{\strongClock{c}}}{f}}))
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fWeakClock{f}{c1}}} =   
      {\FSem{M}{{\pi}}{{\weakClock{c1}}}{f)}}
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fStrongClock{f}{c1}}} =   
      {\FSem{M}{{\pi}}{{\strongClock{c1}}}{f}})
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{{\FBool{b}}}} = 
      {\Forall}i. FirstRise M {\Pi} c i {\Imp} {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{i})}{b}})
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fNot{f}}} = 
      {\Not}({\FSem{M}{{\pi}}{{\strongClock{c}}}{f}})) 
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fAnd{f1}{f2}}} = 
      {\Forall}i. FirstRise M {\Pi} c i
          {\Imp}
          ({\FSem{M}{\restN{{\pi}}{i}}{{\weakClock{c}}}{f1}} {\And}
           {\FSem{M}{\restN{{\pi}}{i}}{{\weakClock{c}}}{f2}}))
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fNext{f}}} = 
      {\Forall}i. (FirstRise M {\Pi} c i {\And}
          ({\IsFinitePath} {\Pi} {\Imp} i {\Le} \PathLength {\Pi} - 1))
           {\Imp}
           {\FSem{M}{\restN{{\pi}}{i+1}}{{\weakClock{c}}}{f}})
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fUntil{f1}{f2}}} = 
      {\FSem{M}{{\pi}}{{\strongClock{c}}}{\fUntil{f1}{f2}}}  
      {\Or}
      ({\Exists}k. {\Forall}l. l {\Ge} k
               {\Imp}
               {\FSem{M}{\restN{{\pi}}{l}}{\weakClock{\T}}{{\FBool{\bNot{c}}}}}   {\And} 
               {\Forall}j. j {\Leq} k 
                   {\Imp}
                   {\FSem{M}{\restN{{\pi}}{j}}{\weakClock{\T}}{{\FBool{c}}}} {\Imp} {\FSem{M}{\restN{{\pi}}{j}}{{\weakClock{c}}}{f1}}))
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fSuffixImp{r}{f}}} = 
      {\Forall}i. FirstRise M {\Pi} c i {\Imp}
          {\Forall}j. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(i,j)}))}{c}{r}
              {\Imp}
              {\FSem{M}{\restN{{\pi}}{j}}{{\weakClock{c}}}{f}})
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fStrongImp{r1}{r2}}} = 
      {\FSem{M}{{\pi}}{{\strongClock{c}}}{\fStrongImp{r1}{r2}}}  
      {\Or}
      ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fWeakImp{r1}{r2}}} 
       {\And}
       {\Exists}k. {\Forall}l. l {\Ge} k 
               {\Imp} 
               {\FSem{M}{\restN{{\pi}}{l}}{\weakClock{\T}}{{\FBool{\bNot{c}}}}}))
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fWeakImp{r1}{r2}}} = 
      {\Forall}i.  FirstRise M {\Pi} c i
           {\Imp}
           {\Forall}j. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(i,j)}))}{c}{r1}
               {\Imp}
               (({\Exists}k. \SSem{M}{ (\lHat{M} (\pathSeg{\pi}{(j,k)}))}{c}{r2})
                {\Or}
                {\Forall}k. ({\IsFinitePath} {\Pi} {\Imp} k {\Le} \PathLength {\Pi})
                     {\Imp}
                     {\Exists}w. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(j,k)}){\cat}w)}{c}{r2}))
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fAbort{f}{b}}} =
      {\Forall}i. FirstRise M {\Pi} c i 
          {\Imp}
          ({\FSem{M}{\restN{{\pi}}{i}}{{\weakClock{c}}}{f}} 
           {\Or}   
           {\Exists}j {\Pi}'. 
            {\FSem{M}{\restN{{\pi}}{j}}{\weakClock{\T}}{{\FBool{\bAnd{c}{b}}}}}
            {\And}
            {\FSem{M}{\pathCat{\pathSeg{\pi}{(i,j-1)}}{{\pi}'}}{{\weakClock{c}}}{f}}))
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fWeakClock{f}{c1}}} =   
      {\FSem{M}{{\pi}}{{\weakClock{c1}}}{f}})
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fStrongClock{f}{c1}}} =   
      {\FSem{M}{{\pi}}{{\strongClock{c1}}}{f}})
\end{alltt}}


This semantics of FL formulas differs from the one we originally transcribed from the \Sugar document
as a result of some mismatches found when trying to prove the equivalence of
the clocked and unclocked semantics when the clock is \t{T}. See Section~\ref{progress}
for a discussion of the differences.



\subsection{Optional Branching Extension}\label{OBE}


The semantic function \Osem is defined so that
\texttt{\Osem~M~s~f} is true iff \texttt{f} is true of \texttt{M} at
state \texttt{s}.

The semantics here differs from the simpler one in Section~\ref{OBEfinite}
in that it handles both finite and infinite paths.

Write $\oSem{M}{s}{f}$ for \texttt{\Osem~M~s~f}, and then the semantics of the OBE is defined by:

{\begin{alltt}
   (\OSem{M}{s}{\oBool{b}} = {\BSem{M}{\lNoHat{M}(s)}{b}})
   {\And}
   (\OSem{M}{s}{\oNot{f}} = {\Not}(\OSem{M}{s}{f})) 
   {\And}
   (\OSem{M}{s}{\oAnd{f1}{f2}} = \OSem{M}{s}{f1} {\And} \OSem{M}{s}{f2})
   {\And}
   (\OSem{M}{s}{\oEx{f}} = 
     {\Exists}{\Pi}. Path M {\Pi}                 {\And} 
         ({\IsFinitePath} {\Pi} {\Imp} 1 {\Le} \PathLength {\Pi}) {\And} 
         (\PathEl{{\pi}}{0} = s) {\And} \OSem{M}{\pathEl{{\pi}}{1}}{f})
   {\And}
   (\OSem{M}{s}{\oEu{f1}{f2}} = 
     {\Exists}{\Pi}. Path M {\Pi}                    {\And} 
         (\PathEl{{\pi}}{0} = s)                     {\And} 
         {\Exists}k. ({\IsFinitePath} {\Pi} {\Imp} k {\Le} \PathLength {\Pi}) {\And}
             \OSem{M}{\pathEl{{\pi}}{k}}{f2}             {\And} 
             {\Forall}j. j {\Le} k {\Imp} \OSem{M}{\pathEl{{\pi}}{j}}{f1})
   {\And}
   (\OSem{M}{s}{\oEg{f}} = 
     {\Exists}{\Pi}. Path M {\Pi} {\And} 
         (\PathEl{{\pi}}{0} = s)  {\And} 
         {\Forall}j. ({\IsFinitePath} {\Pi} {\Imp} j {\Le} \PathLength {\Pi}) {\Imp} \OSem{M}{\pathEl{{\pi}}{j}}{f})
\end{alltt}}

\section{Progress on analysing the semantics}\label{progress}

We have established a number of properties of the semantics using the \HOL system.
Some of these went through first time without any problems,
but others revealed bugs in the original HOL semantics.


Recall the definitions:


{\begin{alltt}
   FirstRise M {\Pi} c i    = \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(0,i)}))}{\bTrue}{\sCat{\sRepeat{\sBool{\bNot{c}}}}{\sBool{c}}}
   NextRise M {\Pi} c (i,j) = \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(i,j)}))}{\bTrue}{\sCat{\sRepeat{\sBool{\bNot{c}}}}{\sBool{c}}}
\end{alltt}}

We have proved that the definitions of \t{FirstRise} and \t{NextRise} give them the correct meaning,
namely $\t{FirstRise~M}~{\pi}~\t{c~i}$ is true iff \t{i} is the time of the first
rising edge of \t{c},
and $\t{NextRise~M}~{\pi}~\t{c~(i,j)}$ is true iff \t{j} is the time of the first
rising edge of \t{c} after \t{i}.

\medskip

$\begin{array}{l}
\vdash~ \t{FirstRise~M}~{\pi}~\t{c~i}~=\\
\phantom{\vdash~}
~(\forall \t{j}.~\t{j} < \t{i} ~\Rightarrow~\neg\bSem{M}{L_{M}(\pi_j)}{\t{c}})~\wedge~\bSem{M}{L_{M}(\pi_i)}{\t{c}}\\
 \\
\vdash~ \t{i}\leq \t{j}\\
\phantom{\vdash~}
\Rightarrow\\
\phantom{\vdash~}
(\t{NextRise~M}~{\pi}~\t{c~(i,j)}~=\\
\phantom{\vdash~(}
~(\forall \t{k}.~\t{i} \leq \t{k} \wedge \t{k} < \t{j} ~\Rightarrow~\neg\bSem{M}{L_{M}(\pi_k)}{\t{c}})~\wedge~\bSem{M}{L_{M}(\pi_j)}{\t{c}})
\end{array}$

\medskip

The proof of these were essentially routine, though quite a bit more tricky than expected. Immediate corollaries are


\medskip

$\begin{array}{l}
\vdash~ \t{FirstRise~M}~{\pi}~\t{\T~i}~=~(\t{i}=0)
 \\
\vdash~ \t{i}\leq \t{j}~\Rightarrow~(\t{NextRise~M}~{\pi}~\t{\T~(i,j)}~=~(\t{i} = \t{j}))
\end{array}$

\medskip


The next thing we have proved is that if we define \t{ClockFree~r} to mean
that \t{r} contains no clocking constructs (a simple recursion over the syntax of SEREs),
then clocking with \T{} is equivalent to the unclocked SERE semantics.

\medskip

$\vdash~\forall{\t{r}}.~\t{ClockFree~r}~\Rightarrow~(\sSem{M}{w}{\T}{r}~=~\sSem{M}{w}{\c}{r})$

\medskip

The proof of this is an easy structural induction, and shows that the semantics in Section~\ref{FullSERE}
collapses to that in Section~\ref{SimpleSERE} when the clock is \T.

We next tried to prove a similar result for FL formulas, but this turned out to be impossible.
The reason is that the proof required first showing


\medskip

$~~\forall{\t{f}}~\pi.~\fSem{M}{\pi}{\T}{f}~=~\sSem{M}{\pi}{\T\texttt{!}}{f})$

\medskip

However, the original semantics had the following:

{\begin{alltt}
  {\FSem{M}{{\pi}}{{\strongClock{c}}}{\FBool{b}}} = {\Exists}i. FirstRise M {\Pi} c i {\And} {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{i})}{b}}

  {\FSem{M}{{\pi}}{{\weakClock{c}}}{{\FBool{b}}}}  = {\Exists}i. FirstRise M {\Pi} c i {\Imp} {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{i})}{b}}
\end{alltt}}


Instantiating \t{c} to \T{} and using the corollary about \t{FirstRise} yields


{\begin{alltt}
  {\FSem{M}{{\pi}}{{\strongClock{\T}}}{\FBool{b}}} = {\Exists}i. (i=0) {\And} {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{i})}{b}}

  {\FSem{M}{{\pi}}{{\weakClock{\T}}}{{\FBool{b}}}}  = {\Exists}i. (i=0) {\Imp} {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{i})}{b}}
\end{alltt}}

With this, clearly $\fSem{M}{\pi}{\T}{\FBool{b}}$ is not equal to $\sSem{M}{\pi}{\T\texttt{!}}{\FBool{b}})$.
The solution, suggested by Cindy Eisner, is to replace the weak semantics by


{\begin{alltt}
  {\FSem{M}{{\pi}}{{\weakClock{c}}}{{\FBool{b}}}}  = {\Forall}i. FirstRise M {\Pi} c i {\Imp} {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{i})}{b}}
\end{alltt}}

so that we get 


{\begin{alltt}
  {\FSem{M}{{\pi}}{{\strongClock{\T}}}{\FBool{b}}} = {\Exists}i. (i=0) {\And} {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{i})}{b}}

  {\FSem{M}{{\pi}}{{\weakClock{\T}}}{{\FBool{b}}}}  = {\Forall}i. (i=0) {\Imp} {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{i})}{b}}
\end{alltt}}

which makes $\fSem{M}{\pi}{\T}{\FBool{b}}$ equal to $\sSem{M}{\pi}{\T\texttt{!}}{\FBool{b}})$.
The same change of $\exists$ to $\forall$ is also needed for the semantics of weak clocking for
$\tt{\fAnd{f1}{f2}}$,  $\tt{\fNext{f}}$, $\tt{\fSuffixImp{r}{f}}$, $\tt{\fWeakImp{r1}{r2}}$ and $\tt{\fAbort{f}{b}}$.
With these changes, a structural induction proves:

\medskip

$~~\vdash~\forall{\t{f}}~\pi.~\fSem{M}{\pi}{\T}{f}~=~\sSem{M}{\pi}{\T\texttt{!}}{f})$

\medskip

However, we were still unable to prove

\medskip

$\vdash~\forall{\t{f}}.~\t{ClockFree~f}~\Rightarrow~(\sSem{M}{w}{\T}{f}~=~\sSem{M}{w}{\c}{f})$

\medskip
where here \t{ClockFree~f} means that \t{f} contains no clocked FL formulas or SEREs,
the semantics on the left of the equation is the one in Section~\ref{FL} and the
semantics on the right of the equation is the one in Section~\ref{finite}.
The proof attempt failed because the unclocked semantics for $\tt{\fUntil{f1}{f2}}$ 
had a path length check, but the strongly clocked semantics didn't. By adding the conjunct
$\t{finite}~\pi~\Rightarrow~\t{k}<\t{length}~\pi$ to the strongly clocked semantics
the proof could be completed. 

\Section{Conclusions}

It was quite straightforward to use the informal semantics in the
\Sugar documentation to create a deep
embedding of the whole \Sugar kernel.  Proving some simple `sanity
checking' lemmas with a proof assistant revealed minor bugs in the
translated semantics (and possibly in the original). We cannot claim
that the current semantics is `golden', since other errors may have
crept in and not yet been detected, but the process of analysing it
using machine assisted proof has increased our confidence in its
correctness.

\section{Acknowledgements}

Cindy Eisner patiently answered numerous email questions
in great detail. She also supplied valuable comments and corrections
to an earlier version of this paper, and suggested
ways of modifying the HOL semantics to get the proofs described in Section~\ref{progress} to go through.

\bibliographystyle{plain}{\bibliography{CatBPaper}}

\end{document}








