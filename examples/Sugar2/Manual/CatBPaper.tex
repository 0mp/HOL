\documentclass{llncs}

\parindent 0pt

\parskip 0.5mm

\newlength{\minipagewidth}
\setlength{\minipagewidth}{\textwidth}

\newenvironment{myenumerate}{\begin{enumerate}
  \renewcommand{\theenumi}{\roman{enumi}}
  \renewcommand{\labelenumi}{(\roman{enumi})}}{\end{enumerate}}



\usepackage{makeidx}                  % allows for indexgeneration
\usepackage{xspace}
\usepackage{alltt}
\usepackage{pstricks}

\newcommand{\And}{\(\wedge\)}
\newcommand{\Or}{\(\vee\)}
\newcommand{\Imp}{\(\Rightarrow\)}
\newcommand{\Not}{\(\neg\)}
\newcommand{\Forall}{\(\forall\)}
\newcommand{\Exists}{\(\exists\)}
\newcommand{\Lam}{\(\lambda\)}
\newcommand{\In}{\(\in\)}
\newcommand{\Length}{\({\rm{length}}\)}
\newcommand{\IsFinitePath}{\({\rm{finite}}\)}
\newcommand{\PathLength}{\({\rm{length}}\)}

\newcommand{\cat}{\hspace*{0.5mm}}
\newcommand{\pathCat}[2]{#1\hspace*{0.5mm}#2}
\newcommand{\Cat}{\(\cat\)}
\newcommand{\Leq}{\(\leq\)}
\newcommand{\Geq}{\(\geq\)}
\newcommand{\Le}{\(<\)}
\newcommand{\Ge}{\(>\)}

\newcommand{\T}{\texttt{\small\rm{T}}}
\newcommand{\bTrue}{\T}
\renewcommand{\Pi}{\(\pi\)}
\newcommand{\modelsT}{\models^{\hspace*{-3.3mm}\raisebox{1mm}{\T}}}

\newcommand{\CONCAT}[1]{\texttt{Concat}~#1}
\newcommand{\EVERY}[2]{\texttt{Every}~#1~#2}
\newcommand{\BSem}[3]{(\(\tt#1,~#2~{\models}~#3\))}
\newcommand{\Bsem}{\texttt{B\_SEM}\xspace}
\newcommand{\bSem}[3]{(\tt#1,~#2~{\models}~#3)}
\newcommand{\SSem}[4]{(\(\tt{#1,~#2~\models^{\hspace*{-2.3mm}\raisebox{1mm}{\tt#3}}~#4}\))}
\newcommand{\Ssem}{\texttt{S\_SEM}\xspace}
\newcommand{\sSem}[4]{(\tt{#1,~#2~\models^{\hspace*{-2.3mm}\raisebox{1mm}{\tt#3}}~#4})}
\renewcommand{\c}{{\hspace*{2.5mm}}}
\newcommand{\FSem}[4]{(\(\tt{#1,~#2~\models^{\hspace*{-2.3mm}\raisebox{1mm}{\tt#3}}~#4}\))}
\newcommand{\fSem}[4]{(\tt{#1,~#2~\models^{\hspace*{-2.3mm}\raisebox{1mm}{\tt#3}}~#4})}
\newcommand{\Fsem}{\texttt{F\_SEM}\xspace}
\newcommand{\OSem}[3]{(\(\tt{#1,~#2~{\models}~#3}\))}
\newcommand{\Osem}{\texttt{O\_SEM}\xspace}
\newcommand{\oSem}[3]{(\tt{#1,~#2~{\models}~#3})}
\newcommand{\Pl}{\(\texttt{pl}\xspace\)}
\newcommand{\pl}{\texttt{pl}\xspace}
\newcommand{\Sim}{\(\texttt{sim}\xspace\)}
\renewcommand{\sim}{\texttt{sim}\xspace}
\newcommand{\ResExists}[2]{\(\exists{\tt#1}\in\pl\hspace*{0.5mm}#2\)}
\newcommand{\ResForall}[2]{\(\forall{\tt#1}\in\pl\hspace*{0.5mm}#2\)}
\newcommand{\Similar}[2]{\(\texttt{similar}\hspace*{0.5mm}#1\hspace*{0.5mm}#2\)}
\newcommand{\BProp}[1]{\(#1\)}
\newcommand{\bProp}[1]{#1}
\newcommand{\sFusion}[2]{#1\texttt{:}#2}
\newcommand{\sClock}[2]{#1\texttt{@}#2}
\newcommand{\FBool}[1]{#1}
\newcommand{\bNot}[1]{\neg#1}
\newcommand{\BNot}[1]{\(\neg#1\)}
\newcommand{\fNot}[1]{\neg#1}
\newcommand{\weakClock}[1]{#1}
\newcommand{\strongClock}[1]{#1!}
\newcommand{\restN}[2]{#1^{#2}}
\newcommand{\pathEl}[2]{#1_{#2}}
\newcommand{\PathEl}[2]{\(#1_{#2}\)}
\newcommand{\pathSeg}[2]{#1^{#2}}
\newcommand{\PathSeg}[2]{\(#1^{#2}\)}
\newcommand{\el}[2]{#2_{#1}}
\newcommand{\LHat}[1]{\(\hat{\texttt{L}}_{#1}\)}
\newcommand{\lHat}[1]{\hat{\texttt{L}}_{#1}}
\newcommand{\lNoHat}[1]{{\texttt{L}}_{#1}}
\newcommand{\getR}[1]{\({\texttt{R}}_{#1}\)}
\newcommand{\sBool}[1]{#1}
\newcommand{\oBool}[1]{#1}
\newcommand{\oNot}[1]{\neg#1}
\newcommand{\sRepeat}[1]{#1\texttt{[*]}}
\newcommand{\sCat}[2]{#1\texttt{;}#2}
\newcommand{\sOr}[2]{\{#1\}\texttt{|}\{#2\}}
\newcommand{\oOr}[2]{\{#1\}\vee\{#2\}}
\newcommand{\sRigAnd}[2]{\{#1\}\texttt{\&\&}\{#2\}}
\newcommand{\sFlexAnd}[2]{\{#1\}\texttt{\&}\{#2\}}
\newcommand{\bAnd}[2]{#1\wedge#2}
\newcommand{\oAnd}[2]{#1\wedge#2}
\newcommand{\oEx}[1]{{\texttt{EX}}~#1}
\newcommand{\oEg}[1]{{\texttt{EG}}~#1}
\newcommand{\oEu}[2]{\texttt{[}#1~{\texttt{U}}~#2\texttt{]}}

\newcommand{\fAnd}[2]{#1 \wedge #2}
\newcommand{\fNext}[1]{\texttt{X!}\hspace*{0.8mm}#1}
\newcommand{\fUntil}[2]{\texttt{[}#1~\texttt{U}~#2\texttt{]}}
\newcommand{\fSuffixImp}[2]{\{#1\}(#2)}
\newcommand{\fStrongImp}[2]{\{#1\}\texttt{|->}\{#2\}\texttt{!}}
\newcommand{\fWeakImp}[2]{\{#1\}\texttt{|->}\{#2\}}
\newcommand{\fAbort}[2]{#1~\texttt{abort}~#2}
\newcommand{\fWeakClock}[2]{#1\texttt{@}#2}
\newcommand{\fStrongClock}[2]{#1\texttt{@}#2\texttt{!}}

\newcommand\Sugar{{\it{Sugar~2.0}}\xspace}
\newcommand\Hol{HOL\xspace}
\newcommand\HOL{\Hol}
\newcommand{\mosml}{Moscow~ML\xspace}
\newcommand{\Buddy}{BuDDy\xspace}
\newcommand{\Muddy}{MuDDy\xspace}
\newcommand\HolBuddy{{Hol{+}\Buddy\xspace}}
\newcommand\HolBddLib{\texttt{HolBddLib}\xspace}
\newcommand\tool{\texttt{PuzzleTool}\xspace}

\renewcommand{\t}[1]{\texttt{#1}}

%\newcommand{\con}[1]{{\sf #1}}
\newcommand{\con}[1]{\texttt{#1}}
\newcommand{\ty}[1]{\mbox{\sl #1}}
\newcommand{\ml}[1]{\mbox{\tt #1}}
\newcommand{\ma}[1]{{{$#1$}}}
\newcommand{\prev}[1]{#1}
\newcommand{\txt}[1]{{\footnotesize\texttt{#1}}}
\newcommand\fun{{\to}}
\renewcommand{\prod}{\times}
\newcommand\turn{{\vdash}}
\newcommand\imp{{\Rightarrow}}
%\newcommand\T{\con{T}}
%
\newcommand\F{\con{F}}
\newcommand\termbddty{\ty{termbdd}}
\newcommand{\termbdd}[3]{\mbox{$#1~#2~\mapsto~#3$}}
\newcommand{\globtermbdd}[2]{\mbox{$#1\hspace{0.5mm}\mapsto\hspace{0.5mm}#2$}}

\newcommand{\PATH}{\texttt{Path}\xspace}
\newcommand{\TAIL}{\texttt{Tail}\xspace}
%\newcommand{\Bsem}{\mbox{$\cal{B}$}\xspace}
%\newcommand{\Lsem}{\mbox{$\cal{L}$}\xspace}
%\newcommand{\Isem}{\mbox{$\cal{I}$}\xspace}
%\newcommand{\Csem}{\mbox{$\cal{C}$}\xspace}
%\newcommand{\Fsem}{\mbox{$\cal{F}$}\xspace}
%\newcommand{\Ssem}{\mbox{$\cal{S}$}\xspace}

\renewcommand{\L}{\texttt{L}\xspace}


\newcommand{\Until}{{\cal U}}
\newcommand{\Unless}{{\cal W}}
\newcommand{\TLNext}{\raisebox{1mm}{\mbox{\large\bf$\bigcirc$}}}
\newcommand{\TLNot}{\mbox{\large\bf$\neg$}}
\newcommand{\TLImp}{\mbox{\large\bf$\Rightarrow$}}
\newcommand{\TLAnd}{\mbox{\large\bf$\wedge$}}
\newcommand{\TLOr}{\mbox{\large\bf$\vee$}}

\newcommand{\SC}{\texttt{;}}
\newcommand{\C}{\texttt{:}}
\newcommand{\hd}{\texttt{hd}}
\newcommand{\lsb}{\texttt{[}}
\newcommand{\rsb}{\texttt{]}}
\newcommand{\R}{\mbox{$R$}}

\newcommand{\Sb}[1]{\(\sb{#1}\)}


\begin{document}



\pagestyle{headings}                  % switches on printing of running heads

\title{Using HOL to study \Sugar semantics}

\titlerunning%
{Programming combinations of%
and computation and deduction}        % abbreviated title (for running head)
                                      % also used for the TOC unless
                                      % \toctitle is used
 

\author{Michael J.~C.~Gordon}

\authorrunning{Mike Gordon}           % abbreviated author list (for running head)

\institute{
\begin{tabular}{c}
University of Cambridge Computer Laboratory\\
William Gates Building,
JJ Thomson Avenue, Cambridge CB3 0FD, U.K.\\
Email: \email{mjcg@cl.cam.ac.uk} \qquad
Web: \texttt{http://www.cl.cam.ac.uk/\homedir mjcg}\\[2mm]
{\normalsize\sf\today}
\end{tabular}}

\maketitle                            % typeset the title of the contribution

\vspace*{-6mm}

\begin{abstract}
The Accellera standards-promoting organisation has selected \Sugar,
IBM's formal specification language, as a standard that it says will
drive assertion-based verification.
\Sugar combines aspects of Interval Temporal Logic (ITL), Linear
Temporal Logic (LTL) and Computation Tree Logic (CTL) into a property
language suitable for both formal verification and use with simulation
test benchs. As industrial strength languages go it is remarkably
elegant, consisting of a small kernel conservatively extended by
numerous definitions.

We are constructing a semantic embedding of \Sugar in the version of
higher order logic supported by the \Hol system. To `sanity check' the
semantics we tried to prove some simple properties and as a result a few bugs
were discovered. Further analysis may well reveal more.

%\medskip
%
%{\red\bf\it WARNING: this draft is in an inconsistent state because
%the semantics has been updated with the result that some of the commentary is invalid.}

We are contemplating a variety of applications of the mechanised
semantics, including the exploitation of existing work to build a
Sugar model checker inside \Hol. In the longer term we want to
investigate the use of theorem proving to reason about models with
infinite state spaces, which might involve developing extensions of
\Sugar.
\end{abstract}

\vspace*{-6mm}

\section{Background on Accellera and Sugar}

The Accellera organisation's website has their mission statement:

\vspace*{-1mm}

{\sl\begin{quote}

To improve designers' productivity, the electronic design industry
needs a methodology based on both worldwide standards and open
interfaces. Accellera was formed in 2000 through the unification of
Open Verilog International and VHDL International to focus on
identifying new standards, development of standards and formats, and
to foster the adoption of new methodologies.

Accellera's mission is to drive worldwide development and use of
standards required by systems, semiconductor and design tools
companies, which enhance a language-based design automation
process. Its Board of Directors guides all the operations and
activities of the organisation and is comprised of representatives
from ASIC manufacturers, systems companies and design tool vendors.
\end{quote}}

\vspace*{-1mm}

Faced with a plethora of syntactically and semantically incompatible
formal property languages, Accellera initiated a process of selecting
a standard property language to ``drive assertion-based verification''.

\newpage

Four contributions were initially considered

\vspace*{-3mm}

\begin{itemize}

\item Motorola's CBV language;

\item IBM's Sugar (the language of its RuleBase FV toolset);

\item Intel's ForSpec;

\item Verisity's {\it e} language (the language of the Specman Elite testbench).

\end{itemize}

\vspace*{-3mm}

After a combination of discussion and voting, some details of which
can be viewed on the web\footnote{\url{http://www.eda.org/vfv/hm/}},
attention was narrowed down to Sugar and CBV, and then in April
2002 a vote\footnote{\url{http://www.eda.org/vfv/hm/0795.html}}
selected IBM's submission, \Sugar.


\Sugar is primarily an LTL-based language that is a successor to 
the CTL-based {\it Sugar~1\/} \cite{sugar}. A key idea of both languages is the use
of ITL-like \cite{ITL} constructs called {\it Sugar Extended Regular Expressions}.
\Sugar retains CTL constructs in its {\it Optional Branching Extension} (OBE),
but this is de-emphasised in the defining document.

Besides moving from CTL to LTL, \Sugar supports clocking and finite
paths.  Clocking allows one to specify on which clock edges signals are
sampled at (i.e. it defines the `next event' for each signal). The
finite path semantics allows properties to be interpreted on
simulation runs, as in test-bench tools like Specman and Vera.

The addition of clocking and finite path semantics makes the \Sugar
semantics more than twice as complicated as the {\it Sugar~1}
semantics. However, for a real `industry standard' language \Sugar is still
remarkably simple, and it was routine to define the abstract syntax
and semantics of the whole language in \Hol \cite{GordonMelham}.

In the rest of this paper we start by discussing the point of
embedding Sugar in \Hol. Next we briefly review semantic embedding,
illustrating the
ideas on simplified semantics of fragments of \Sugar.  We then
give the complete semantics of \Sugar, and finally we discuss our
small achievements so far in analysing the semantics using the
\Hol system, including a discussion of the bugs found.

\vspace*{-3mm}

\section{Why embed Sugar in \Hol?}

\vspace*{-3mm}

There are several justifications for the work described here. This project
has only just started and its goals are still being defined. Current motivations include
the following.

\vspace*{-3mm}

\subsection{Sanity checking and proving meta-theorems}


By formalising the semantics and passing it through a parser and
type-checker one achieves a first level of sanity checking of the
definition. One also exposes possible ambiguities, fuzzy corner cases etc
(e.g. see Section~\ref{finite}).
The process is also very educational for the formaliser and
a good learning exercise.

There are a number of meta-theorems one might expect to be true, and
proving them with a theorem prover provides a further and deeper kind
of sanity checking.  In the case of \Sugar, such meta-theorems include
showing that expected simplifications to the semantics occur if
there is no non-trivial clocking, that different semantics of clocking
are equivalent and that if finite paths are ignored then the standard
`text-book semantics' results. Such meta-theorems are generally mathematically
shallow, but full of tedious details -- i.e.~ideal for automated
theorem proving. See Section~\ref{progress} for what we have proved so far. 
It's not much, but we have already found minor bugs in the semantics!

A key feature of the Sugar approach is to have a small kernel and a large
number of definitions. Using a theorem prover,
the definitions can be validated by proving that they achieve the
correct semantics.  See, for example, the analysis of \t{FirstRise}
and \t{NextRise} in Section~\ref{progress} (these are not official
Sugar definitions, but the analysis here illustrates the idea of
validating definitions).
\vspace*{-3mm}

\subsection{Develop a machine readable semantics}

The current \Sugar document is admirably clear, but it is informal mathematics presented
as typeset text. Tool developers  could benefit from a machine readable version.
One might think of using some standard representation of mathematical content,
like  MathML\footnote{\url{http://www.w3.org/Math/}}, however there is currently
not much mathematically sophisticated tool support for such XML-based representations. 

Higher order logic is a widely used formalisation medium
(versions of higher order logic are used by \Hol, Isabelle/HOL, PVS,
NuPrl and Coq) and the semantic embedding of model-checkable logics in HOL
is standard \cite{Rajan95:CAV,Nipkow-Paulson-Wenzel:2002}. Once one has
a representation in it then representations in other formats should be
straightforward to derive.

\vspace*{-3mm}

\subsection{Research using our local tools}


We are contemplating developing semantically-based reasoning and
checking infrastructure in \HOL to support \Sugar, and a prerequisite
for this is to have a `golden semantics' to which application specific
semantics can be proved equivalent.

One area of research that we have an interest in is the development of property
languages that support data operations and can have variables
ranging over infinite data-types like numbers
(e.g.~including reals and complex numbers for DSP applications). Some
sort of mixture of Hoare Logic and \Sugar is being contemplated
(rather vaguely, it must be admitted).  Developing the language by
extending an existing semantics is a way to ensure some `backward
compatibility'.  Also, we might wish to prove sanity checking
meta-theorem about our extended language, e.g.~that it collapses to
\Sugar when there are no infinite types.

\vspace*{-3mm}

\subsection{Education}

Both semantic embedding and property specification are taught as part
of the Computer Science undergraduate course at
Cambridge%
\footnote{\url{http://www.cl.cam.ac.uk/users/mjcg/Teaching/SpecVer2/SpecVer2.html}},
and being able to illustrate the ideas on a real example like \Sugar
is pedagogically valuable.

The semantic embadding of \Sugar in the \Hol system is an interesting case
study. It nicely illustrates some issues in making total functional
definitions, and the formal challenges attempted so far provide
insight into how to perform structural induction using the built-in
tools.  Thus \Sugar has educational potential for training \Hol
users. In fact, the semantics described in this paper is an
example distributed with \Hol.%
\footnote%
{\url{http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/hol/hol98/examples/Sugar2/}}

\section{Review of semantic embedding in higher order logic}\label{review}

Higher order logic is an extension of first-order predicate calculus
that allows quantification over functions and relations. It is a
natural language for formalising informal set theoretic specifications
(indeed, it is usually more natural than formal first-order set
theories, like ZF).  We hope that the \Hol notation that follows is
sufficiently close to standard informal notation that it needs no
systematic explanation.

We use Church's $\lambda$-notation for denoting functions: a
`lambda-term' like $\lambda x.~t$, where $x$ is a variable and $t$ a
term, denotes the function that maps a value $v$ to the result of
substituting $v$ for the variable $x$ in $t$ (the infix notation $x
\mapsto t$ is sometimes used instead of $\lambda x.~t$). If $P$ is a
function that returns a truth-value (i.e.~a predicate), then $P$ can
be thought of a set, and we write $x \in P$ to mean $P(x)$ is
true. Note that $\lambda x .~\cdots{x}\cdots$ corresponds to the set abstraction
$\{x \mid ~\cdots{x}\cdots\}$. We write $\forall x\in P.~Q(x)$, $\exists x\in
P.~Q(x)$ to mean $\forall x.~P(x)\Rightarrow Q(x)$, $\exists
x.~P(x)\wedge Q(x)$, respectively.

To embed\footnote{We shall only be concerned with so called `deep
embeddings' here.}  a language in \Hol one first defines constructors
for all the syntactic constructs of the language. This is the
`abstract syntax' and provides a representation of parse trees as
terms in the logic.  The semantics is then given by defining a
semantic function that recursively maps each construct to a
representation of its meaning.

For \Sugar, a model \t{M} is a quintuple
$(\t{S}_{\t{M}},{\t{S}_0}_{\t{M}},\t{R}_{\t{M}},\t{P}_{\t{M}},\t{L}_{\t{M}})$, where $\t{S}_{\t{M}}$
is a set of states, ${\t{S}_0}_{\t{M}}$ is the subset of initial states, $\t{R}_{\t{M}}$ is a
transition relation (so $\t{R}_{\t{M}}(s,s')$ means $s'$ is a possible
successor state to $s$), $\t{P}_{\t{M}}$ is a set of atomic propositions, and
$\L_{\t{M}}$ is a valuation that maps a state to the
set of atomic propositions that hold at the state
(so $\L~s~\t{p}$ is true iff atomic proposition
\t{p} is true in state $s$).

The syntax of boolean expressions \t{b}
built from atomic propositions
(ranged over by \t{p}) using negation ($\neg$) and conjunction ($\wedge$)
is given by:


\medskip

$\begin{array}{ccll}
{\t{b}} & {\rm ::=} & \t{p}
  & \mbox{\rm(Atomic formula)}\\
 & \phantom{\rm ::}\mid & \neg{\t{b}}
  & \mbox{\rm(Negation)}\\
 & \phantom{\rm ::}\mid & {\t{b}}_1~\wedge~{\t{b}}_2
  & \mbox{\rm(Conjunction)}\\
\end{array}$

\medskip

\noindent in \Hol this is defined by a recursive type definition of
a syntactic type of boolean expressions.

Let \t{l} range over predicates on $\t{P}_{\t{M}}$, called ``truth assignments'' in the Sugar
documentation.
The semantics of boolean expressions
is given by defining a semantic function \Bsem such that
$\Bsem~\t{M}~\t{l}~\t{b}$ if true iff \t{b} is built from propositions in $\t{P}_{\t{M}}$ and
it is true with respect to the truth assignment \t{l}.

If we write $\bSem{M}{l}{b}$ for $\Bsem~\t{M}~\t{l}~\t{b}$
then the semantics is given by


{\begin{alltt}
   ({\BSem{M}{l}{\bProp{p}}}     = p {\In} \(\t{P}\sb{\t{M}}\) {\And} p {\In} l)
   {\And}
   ({\BSem{M}{l}{\bTrue}}     = T)
   {\And}
   ({\BSem{M}{l}{{\bNot{b}}}}    = {\Not}{\BSem{M}{l}{b}})
   {\And}
   ({\BSem{M}{l}{\bAnd{b1}{b2}}} = {\BSem{M}{l}{b1}} {\And} {\BSem{M}{l}{b2}})
\end{alltt}}

\medskip



Before looking at the full official semantics of \Sugar, we first
consider a simplified semantics in which there is no clocking, and paths
are always infinite. We consider separately the parts of \Sugar corresponding
to Interval Temporal Logic (ITL), Linear Temporal Logic (LTL) and
Computation Tree Logic (CTL).


\subsection{ITL: Sugar Extended Regular Expressions (SEREs)}\label{SimpleSERE}

Interval Temporal Logic (ITL) provides formulas that are true or false
of intervals of states.  Here we just consider finite intervals,
though recent formulations of ITL\footnote{\url{http://www.cms.dmu.ac.uk/{\homedir}cau/itlhomepage/}} 
allow intervals to be infinite. For
Sugar we only need to consider ITL formulas, as there are no constructs
corresponding to ITL expressions (expressions map intervals to
values). Providing more elaborate ITL constructs in Sugar strikes us as an interesting research topic.



The Sugar subset corresponding to ITL is called {\it Sugar Extended
Regular Expressions} (SEREs).  If $\t{r}$ ranges over SEREs and \t{p} ranges over a
set  $\t{P}_{\t{M}}$ of atomic propositions, then the syntax is given by:



\medskip

$\begin{array}{ccll}
{\t{r}} & {\rm ::=} & \t{p}
  & \mbox{\rm(Atomic formula)}\\
 & \phantom{\rm ::}\mid & \{{\t{r}}_1\}~\texttt{|}~\{{\t{r}}_2\}
  & \mbox{\rm(Disjunction)}\\
 & \phantom{\rm ::}\mid & {\t{r}}_1~{\bf{{\SC}}}~{\t{r}}_2~~~~~~~~~~~~
  & \mbox{\rm(Concatenation)}\\
 & \phantom{\rm ::}\mid & {\t{r}}_1~{\bf{{\C}}}~{\t{r}}_2
  & \mbox{\rm(Fusion: ITL's chop)}\\
 & \phantom{\rm ::}\mid & \{{\t{r}}_1\}~\texttt{\&\&}~\{{\t{r}}_2\}
  & \mbox{\rm(Length matching conjunction)}\\
 & \phantom{\rm ::}\mid & \{{\t{r}}_1\}~\texttt{\&}~\{{\t{r}}_2\}
  & \mbox{\rm(Flexible matching conjunction)}\\
 & \phantom{\rm ::}\mid & {\t{r}}{\bf{[*]}}
  & \mbox{\rm(Repeat)}\\
\end{array}$

\medskip

The semantics of SEREs 
is given by defining a semantic function \Ssem such that
$\Ssem~\t{M}~\t{w}~\t{r}$ if true iff \t{w} is in the language of the extended regular expression
\t{r}.  

We write $\sSem{M}{w}{\c}{r}$ for $\Ssem~\t{M}~\t{w}~\t{r}$.

If \texttt{wlist} is a list of lists then
\texttt{\CONCAT{wlist}} is the concatenation of the lists
in \texttt{wlist} and if $P$ is some predicate
then \texttt{\EVERY{$P$}wlist} means that $P(\texttt{w})$
holds for every \texttt{w} in \texttt{wlist}.

{\begin{alltt}
   ({\SSem{M}{w}{\c}{\sBool{b}}} = 
     {\Exists}l. (w = [l]) \And {\BSem{M}{l}{b}})
   {\And}
   ({\SSem{M}{w}{\c}{\sCat{r1}{r2}}} = 
     {\Exists}w1 w2. (w = w1{\Cat}w2) {\And} {\SSem{M}{w1}{\c}{r1}} {\And} {\SSem{M}{w2}{\c}{r2}})
   {\And}
   ({\SSem{M}{w}{\c}{\sFusion{r1}{r2}}} = 
     {\Exists}w1 w2 l. (w = w1{\cat}[l]{\cat}w2) {\And} 
               {\SSem{M}{(w1{\cat}\texttt{[}l\texttt{]})}{\c}{r1}} {\And} {\SSem{M}{(\texttt{[}l\texttt{]}{\cat}w2)}{\c}{r2}}) 
   {\And}
   ({\SSem{M}{w}{\c}{\sOr{r1}{r2}}} = 
     {\SSem{M}{w}{\c}{r1}} {\Or} {\SSem{M}{w}{\c}{r2}}) 
   {\And}
   ({\SSem{M}{w}{\c}{\sRigAnd{r1}{r2}}} = 
     {\SSem{M}{w}{\c}{r1}} {\And} {\SSem{M}{w}{\c}{r2}}) 
   {\And}
   ({\SSem{M}{w}{\c}{\sFlexAnd{r1}{r2}}} = 
     {\Exists}w1 w2. (w = w1{\Cat}w2) {\And} 
             (({\SSem{M}{w}{\c}{r1}} {\And} {\SSem{M}{w1}{\c}{r2}}) 
              {\Or}
              ({\SSem{M}{w}{\c}{r2}} {\And} {\SSem{M}{w1}{\c}{r1}})))
   {\And}
   ({\SSem{M}{w}{\c}{\sRepeat{r}}} = 
     {\Exists}wlist. (w = \CONCAT{wlist}) {\And} \EVERY{({\Lam}w. {\SSem{M}{w}{\c}{r}})}{wlist})
\end{alltt}}

\vspace*{-6mm}

\subsection{LTL: Sugar Foundation Language (FL)}



\Sugar has a kernel combining standard LTL notation
with a less standard \t{abort} operation and some constructs using SEREs. The suffix
``\texttt{!}'' found on some constructs indicates
that these are `strong' (i.e. liveness-enforcing) operators.  The
distinction between strong and weak operators is given in the
semantics of full \Sugar in Section~\ref{SugarSemantics}. Numerous
additional notations are introduced by definitions (which are
conservative extensions of the language, and can be formalised as
definitions in \Hol).

\smallskip

$\begin{array}{llll}
{\t{f}} & {\rm ::=} & \t{p}
  & \mbox{\rm(Atomic formula)}\\
 & \phantom{\rm ::}\mid & \TLNot{\t{f}}
  & \mbox{\rm(Negation)}\\
 & \phantom{\rm ::}\mid & {\t{f}}_1~\TLAnd~{\t{f}}_2
  & \mbox{\rm(Conjunction)}\\
 & \phantom{\rm ::}\mid & \texttt{X!}{\t{f}}
  & \mbox{\rm(Successor)}\\
 & \phantom{\rm ::}\mid & [{\t{f}}_1~\texttt{U}~{\t{f}}_2]~~~~
  & \mbox{\rm(Until)}\\
 & \phantom{\rm ::}\mid & \{{\t{r}}\}({\t{f}})~~~~
  & \mbox{\rm(Suffix implication)}\\
 & \phantom{\rm ::}\mid & \{{\t{r}}_1\}~\texttt{|->}~\{{\t{r}}_2\}\texttt{!}~~~~
  & \mbox{\rm(Strong suffix implication)}\\
 & \phantom{\rm ::}\mid & \{{\t{r}}_1\}~\texttt{|->}~\{{\t{r}}_2\}~~~~
  & \mbox{\rm(Weak suffix implication)}\\
 & \phantom{\rm ::}\mid & \t{f}~\texttt{abort}~{\t{b}}~~~~
  & \mbox{\rm(Abort)}\\
\end{array}$

\medskip

Being LTL, the semantics of FL formulas is defined with respect to a path $\pi$,
which (in the simplified semantics here) is a function from the natural numbers to states.

We define a semantic function \Fsem such that $\Fsem~\t{M}~\pi~\t{f}$
means FL formula \t{f} is true of path $\pi$.
We write $\fSem{M}{\pi}{\c}{r}$ for $\Fsem~\t{M}~\pi~\t{f}$.


Note that in the semantics below it is not assumed that paths $\pi$ are necessarily computations
(i.e.~satisfy $\texttt{Path~M}~\pi$, as defined in Section~\ref{OBE}). This is important
for the \t{abort} construct (where the $\exists\pi'$ quantifies over all paths).

The notation $\pi_i$ denotes the $i$-th state in the path (i.e.~$\pi(i)$);
$\pi^i$ denotes the `$i$-th tail' of $\pi$ -- the path obtained
by chopping $i$ elements off the front of $\pi$ (i.e. $\pi^i~=~\lambda n.~\pi(n{+}i)$).
$\pi^{(i,j)}$ denotes the finite sequence of states from $i$ to $j$ in $\pi$,
i.e.~$\pi_i\pi_{i{+}1}\cdots\pi_j$. The juxtaposition
$\pi^{(i,j)}\pi'$ denotes the path obtained by concatenating the finite sequence
$\pi^{(i,j)}$ on to the front of the path $\pi'$. 

The function $\hat{\t{L}}_{\t{M}}$ denotes the point-wise extension of
$\t{L}_{\t{M}}$ to finite sequences of states
(i.e.~$\texttt{MAP}~\t{L}_{\t{M}}$ in \Hol and functional programming notation).



{\begin{alltt}

    ({\FSem{M}{{\pi}}{{\c}}{\FBool{b}}} = {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{0})}{b}})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fNot{f}}} = {\Not}{\FSem{M}{{\pi}}{\c}{f}})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fAnd{f1}{f2}}} = {\FSem{M}{\pi}{{\c}}{f1}} {\And} {\FSem{M}{\pi}{{\c}}{f2}})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fNext{f}}} = {\FSem{M}{\restN{{\pi}}{1}}{{\c}}{f}})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fUntil{f1}{f2}}} = 
      {\Exists}k. {\FSem{M}{\restN{{\pi}}{k}}{\c}{f2}} {\And} {\Forall}j. j \Le k \Imp {\FSem{M}{\restN{{\pi}}{j}}{{\c}}{f1}})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fSuffixImp{r}{f}}} = 
      {\Forall}j. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(0,j)}))}{\c}{r} {\Imp} {\FSem{M}{\restN{{\pi}}{j}}{{\c}}{f}})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fStrongImp{r1}{r2}}} = 
      {\Forall}j. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(0,j)}))}{\c}{r1} 
          {\Imp} {\Exists}k. j \Leq k \And \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(j,k)}))}{\c}{r2})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fWeakImp{r1}{r2}}} = 
      {\Forall}j. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(0,j)}))}{\c}{r1} 
          \Imp ({\Exists}k. j \Leq k \And \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(j,k)}))}{\c}{r2})
             \Or
             {\Forall}k. j \Leq k \Imp {\Exists}w. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(j,k)}))w}{\c}{r2})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fAbort{f}{b}}} =
      ({\FSem{M}{\pi}{{\c}}{f }}
       {\Or}
       {\Exists}j {\Pi}'. {\FSem{M}{\restN{{\pi}}{j}}{\c}{{\FBool{b}}}} {\And} {\FSem{M}{\pathCat{\pathSeg{\pi}{(0,j-1)}}{{\pi}'}}{{\c}}{f}}))

\end{alltt}}

\subsection{CTL: Sugar Optional Branching Extension (OBE)}\label{OBEfinite}

The syntax of the \Sugar OBE is completely standard. The syntax of
the OBE formulas is:

\medskip


$\begin{array}{ccll}

{\t{f}} & {\rm ::=} & \t{p}
  & \mbox{\rm(Atom)}\\

 & \phantom{\rm ::}\mid & \TLNot{\t{f}}
  & \mbox{\rm(Negation)}\\

 & \phantom{\rm ::}\mid & {\t{f}}_1~\TLAnd~{\t{f}}_2
  & \mbox{\rm(Conjunction)}\\

 & \phantom{\rm ::}\mid & {\bf{EX}}{\t{f}}
  & \mbox{\rm(Some successors)}\\

 & \phantom{\rm ::}\mid & {\bf{E}}{\lsb}{\t{f}}_1~{\bf{U}}~{\t{f}}_2{\rsb}
  & \mbox{\rm(Until -- along some path)}\\

 & \phantom{\rm ::}\mid & {\bf{EG}}{\t{f}}
  & \mbox{\rm(Always on some path)}\\

\end{array}$

\medskip

For the semantics, define $\texttt{Path~M}~\pi$ to be true iff $\pi$ is a computation of \texttt{M}:

{\begin{alltt}
   Path M {\Pi} = {\Forall}n. \getR{M}(\PathEl{{\pi}}{n}, \PathEl{{\pi}}{n+1})
\end{alltt}}


The semantic function \Osem is defined so that
\texttt{\Osem~M~s~f} is true iff \texttt{f} is true of \texttt{M} at
state \texttt{s}.
Write $\oSem{M}{s}{f}$ for \texttt{\Osem~M~s~f}, and then the semantics of the OBE is defined by:

{\begin{alltt}
   (\OSem{M}{s}{\oBool{b}} = {\BSem{M}{\lNoHat{M}(s)}{b}})
   {\And}
   (\OSem{M}{s}{\oNot{f}} = {\Not}(\OSem{M}{s}{f})) 
   {\And}
   (\OSem{M}{s}{\oAnd{f1}{f2}} = \OSem{M}{s}{f1} {\And} \OSem{M}{s}{f2})
   {\And}
   (\OSem{M}{s}{\oEx{f}} = 
     {\Exists}{\Pi}. Path M {\Pi} {\And} (\PathEl{{\pi}}{0} = s) {\And} \OSem{M}{\pathEl{{\pi}}{1}}{f})
   {\And}
   (\OSem{M}{s}{\oEu{f1}{f2}} = 
     {\Exists}{\Pi}. Path M {\Pi} {\And} (\PathEl{{\pi}}{0} = s) \And
         \OSem{M}{\pathEl{{\pi}}{k}}{f2} {\And} {\Forall}j. j {\Le} k {\Imp} \OSem{M}{\pathEl{{\pi}}{j}}{f1})
   {\And}
   (\OSem{M}{s}{\oEg{f}} = 
     {\Exists}{\Pi}. Path M {\Pi} {\And} (\PathEl{{\pi}}{0} = s) {\And} {\Forall}j. \OSem{M}{\pathEl{{\pi}}{j}}{f})
\end{alltt}}


\section{Full \Sugar semantics in higher order logic}\label{SugarSemantics}

The semantics that follows is derived from of a deep semantic embedding of
{\it Sugar 2.0} in higher order logic (HOL-4 version).
The official  \Sugar semantics 
can be found in the Accellera submission document \cite{Accellera}


\medskip

~~{
\url{http://www.haifa.il.ibm.com/projects/verification/sugar/literature.html}}

\medskip

Corresponding to Appendix A.1 of the Sugar documentation
we have defined types \texttt{bexp}, \texttt{sere}, \texttt{fl} and
\texttt{obe} in the HOL logic to represent the syntax of Boolean Expressions, Sugar
Extended Regular Expressions (SEREs), formulas of the Sugar Foundation
Language (FL) and formulas of the Optional Branching Extension (OBE),
respectively.


Corresponding to Appendix A.2 of the Sugar documentation
we have defined semantic functions \texttt{B\_SEM}, \texttt{S\_SEM},
\texttt{F\_SEM} and \texttt{O\_SEM} that interpret boolean expressions,
SEREs, FL formulas and OBE formulas, respectively.

The HOL definitions can be seen in

\medskip

~~{\url{http://www.cl.cam.ac.uk/{\homedir}mjcg/Sugar}}

\medskip

In the next two sub-sections we discuss clocking and finite paths.
In the remaining four sub-sections 
we give manually
typeset versions of the HOL definitions of the semantic functions. The
typesetting was done as algorithmically as I could by editing the HOL
sources. I hope to have avoided
transcription errors, but this cannot be guaranteed. Following
some proof activity, changes to the original HOL semantics have been
made, as discussed in Section~\ref{progress}.

\subsection{Clocking}

If \t{b} is a boolean expression, then the SERE \texttt{b@clk} recognises
a sequence of states in which \t{b} is true on the next rising edge of \texttt{clk}.
Thus \texttt{b@clk} behaves like \texttt{\{$\neg$clk[*]; clk ${\wedge}$ b\}}.

One can also clock formulas (\texttt{f@clk}), and there may be
several clocks. Consider:\footnote{The discussion of clocking here is based on email communication
with Cindy Eisner.}

\medskip

~~\texttt{G(req\_in -> X(req\_out@clkb))@clka}

\medskip

\noindent this means that the entire formula is clocked on
clock \texttt{clka}, except that signal \texttt{req\_out} is clocked on \texttt{clkb}. 
Clocks do not ``accumulate'', so
the signal \texttt{req\_out} is only clocked by \texttt{clkb}, not by both clocks.  
Thus \texttt{clkb} ``protects''
\texttt{req\_out} from the main clock, \texttt{clka}, i.e.:

\medskip

~~\texttt{req\_out@clkb@clka = req\_out@clkb}

\medskip

\noindent This meaning of clocking prevents us simply defining:

\medskip

~~\texttt{req\_out@clkb = [$\neg$clkb U (clkb $\wedge$ req\_out)]}

\medskip

\noindent since if this were the definition of \texttt{req\_out@clkb}
then we would be forced to have:

\medskip

~~\texttt{req\_out@clkb@clka = [$\neg$clkb U (clkb $\wedge$ req\_out)]@clka}

\medskip

\noindent when we actually want

\medskip

~~\texttt{req\_out@clkb@clka = req\_out@clkb}

\medskip

Thus we cannot just rewrite away clocking annotations using 
equational reasoning. However, if one starts at the outside and works
inwards, then one can systematically compile away clocking. The rules
for doing this are given in the \Sugar documentation as part of the
implementation of formal verification.

The official semantics uses a different approach in which the
currently active clock is an argument of the semantic function used
to interpret SEREs and formulas.  Proving this approach equivalent to
compiling away clocks, followed by a simpler unclocked semantics, is
one of the formal challenges to which we hope to submit the semantics.


\subsection{Finite paths}\label{finite}

\Sugar gives a semantics to formulas for both finite and infinite
paths.  To represent this, we model a path as being either a 
non-empty\footnote{The need for finite paths to be non-empty arose
when trying to prove some properties. This requirement does not seem to be explicit in
the Accellera specification.} finite
list of states or a function from natural numbers to states and define a
predicate \t{finite} to test if a path is a finite list. The function
\t{length} gives the length of a finite path (it is not defined on
paths for which \t{finite} is not true).

\noindent We interpret the official semantics locution 

~~``for every $j < \t{length}(\pi)$:$~\cdots~j~\cdots$''

\noindent as meaning 

~~``for every $j$: (\t{finite}~$\pi$ implies $j < \t{length}~\pi$) implies $~\cdots~j~\cdots$''

\noindent and we interpret the official semantics locution 

~~``there exists $j < \t{length}(\pi)$ s.t.$~\cdots~j~\cdots$''

\noindent as meaning 

~~``there exists $j$ s.t. (\t{finite}~$\pi$ implies $j < \t{length}~\pi$) and $~\cdots~j~\cdots$''

Define ${\pl~\pi~n}$ to mean that
if $\pi$ is finite then $n$ is
less than the length of $\pi$, i.e.~the predicate \pl is defined by

~~$\pl~\pi~n~=~\t{finite}~\pi~\Rightarrow~ n < \t{length}~\pi$

We can then write ``$\forall i\in\pl~\pi.~\cdots~i~\cdots$'' and ``$\exists i\in\pl~\pi.~\cdots~i~\cdots$''
for the locutions above. The name ``$\pl$'' is short for ``path length''

%Define $\sim~\pi~\pi'$ to mean that $\pi$ and $\pi'$ are similar in that they are
%either both finite or both infinite:
%
%~~$\sim~\pi~\pi'~=~(\rm{finite}~\pi~=~\rm{finite}~\pi')$
%
%We will write ``$\exists \pi'\in\sim~\pi.~\cdots~\pi'~\cdots$'' to restrict quantification
%of $\pi'$ to range of paths that are similar (in the sense just defined) to $\pi$. This
%comes up in the semantics of \texttt{abort} formulas.

Here is a version of the unclocked FL semantics that allows
paths to be finite.


{\begin{alltt}
    ({\FSem{M}{{\pi}}{{\c}}{\FBool{b}}} = {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{0})}{b}})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fNot{f}}} = {\Not}{\FSem{M}{{\pi}}{\c}{f}}))
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fAnd{f1}{f2}}} = {\FSem{M}{\pi}{{\c}}{f1}} {\And} {\FSem{M}{\pi}{{\c}}{f2}})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fNext{f}}} = {\Pl \Pi 1} \And {\FSem{M}{\restN{{\pi}}{1}}{{\c}}{f}})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fUntil{f1}{f2}}} = 
      {\ResExists{k}{\pi}}. 
       {\FSem{M}{\restN{{\pi}}{k}}{\c}{f2}} \And {\ResForall{j}{\pi}}. j {\Le} k \Imp {\FSem{M}{\restN{{\pi}}{j}}{{\c}}{f1}})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fSuffixImp{r}{f}}} = 
      {\ResForall{j}{\pi}}. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(0,j)}))}{\c}{r} {\Imp} {\FSem{M}{\restN{{\pi}}{j}}{{\c}}{f}})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fStrongImp{r1}{r2}}} = 
      {\ResForall{j}{\pi}}. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(0,j)}))}{\c}{r1} 
                {\Imp} {\ResExists{k}{\pi}}. j \Leq k \And \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(j,k)}))}{\c}{r2})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fWeakImp{r1}{r2}}} = 
      {\ResForall{j}{\pi}}. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(0,j)}))}{\c}{r1} 
                \Imp ({\ResExists{k}{\pi}}. j \Leq k \And \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(j,k)}))}{\c}{r2})
                   \Or
                   {\ResForall{k}{\pi}}. j \Leq k \Imp {\Exists}w. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(j,k)}))w}{\c}{r2})
    {\And}
    ({\FSem{M}{{\pi}}{{\c}}{\fAbort{f}{b}}} =
      ({\FSem{M}{\pi}{{\c}}{f }}
       {\Or}
       {\ResExists{j}{\pi}}. 
        0 < j \And \Exists{\Pi}'. {\FSem{M}{\restN{{\pi}}{j}}{\c}{{\FBool{b}}}} {\And} {\FSem{M}{\pathCat{\pathSeg{\pi}{(0,j-1)}}{{\pi}'}}{{\c}}{f}}))
\end{alltt}}

This semantics was initially derived from an existing unpublished semantics of unclocked 
FL formulas\footnote{Personal communication from Cindy Eisner.}.
%except that the restrictions ``$\in\pl\hspace*{0.5mm}\pi$'' 
%and ``$\in\sim\hspace*{0.5mm}\pi$'' were added to the quantifications,
%and also the disjunct $\tt{({\exists}k.~\sSem{M}{(\lHat{M} (\pathSeg{\pi}{(j,k)}))}{\c}{r2})}$
%and also some changes were made to
%was added to 
%the semantics of $\fWeakImp{r1}{r2}$ to get the proof of the equivalence with the clocked semantics
%in Section~\ref{FL} to go through.

The following four sub-sections are the manually typeset HOL semantics of \Sugar.

%\vspace*{-4mm}

\subsection{Boolean expressions}

The semantics below is identical to that given earlier
in Section~\ref{review}.

%\vspace*{-4mm}

{\begin{alltt}
   ({\BSem{M}{l}{\bProp{p}}}   \(\hspace*{1.5mm}\)  = \(p\) {\In} P\(\sb{M}\) {\And} \(p\) {\In} l) 
   {\And}
   ({\BSem{M}{l}{\bTrue}}     \(\hspace*{1.3mm}\)= T)       
   {\And}
   ({\BSem{M}{l}{{\bNot{b}}}}    \(\hspace*{1.5mm}\)= {\Not}{\BSem{M}{l}{b}})
   {\And}
   ({\BSem{M}{l}{\bAnd{b1}{b2}}} \(\hspace*{0mm}\)= {\BSem{M}{l}{b1}} {\And} {\BSem{M}{l}{b2}})
\end{alltt}}

%\vspace*{-4mm}

\subsection{Sugar Extended Regular Expressions}\label{FullSERE}


The semantics of SEREs expressions
is given by defining a semantic function \Ssem such that
$\Ssem~\t{M}~\t{w}~\t{c}~\t{r}$ if true iff \t{w} is in the language of the extended regular expression
\t{r} clocked with \t{c}.  

We write $\sSem{M}{w}{c}{r}$ for $\Ssem~\t{M}~\t{w}~\t{c}~\t{r}$.


If \texttt{wlist} is a list of lists then
\texttt{\CONCAT{wlist}} is the concatenation of the lists
in \texttt{wlist} and if $P$ is some predicate
then \texttt{\EVERY{$P$}wlist} means that $P(\texttt{w})$
holds for every \texttt{w} in \texttt{wlist}.

\vspace*{-3mm}

{\begin{alltt}
   ({\SSem{M}{w}{c}{\sBool{b}}} = 
     {\Exists}n. n {\Geq} 1                                 {\And} 
         ({\PathLength} w = n)                         {\And} 
         ({\Forall}i. 1 {\Leq} i {\And} i {\Le} n {\Imp} {\BSem{M}{\el{i-1}{w}}{\bNot{c}}} {\And}
         {\BSem{M}{\el{n-1}{w}}{\bAnd{c}{b}}})
   {\And}
   ({\SSem{M}{w}{c}{\sCat{r1}{r2}}} = 
     {\Exists}w1 w2. (w = w1{\Cat}w2) {\And} {\SSem{M}{w1}{c}{r1}} {\And} {\SSem{M}{w2}{c}{r2}})
   {\And}
   ({\SSem{M}{w}{c}{\sFusion{r1}{r2}}} = 
     {\Exists}w1 w2 l. (w = w1{\cat}[l]{\cat}w2) {\And} 
               {\SSem{M}{(w1{\cat}\texttt{[}l\texttt{]})}{c}{r1}} {\And} {\SSem{M}{(\texttt{[}l\texttt{]}{\cat}w2)}{c}{r2}}) 
   {\And}
   ({\SSem{M}{w}{c}{\sOr{r1}{r2}}} = 
     {\SSem{M}{w}{c}{r1}} {\Or} {\SSem{M}{w}{c}{r2}}) 
   {\And}
   ({\SSem{M}{w}{c}{\sRigAnd{r1}{r2}}} = 
     {\SSem{M}{w}{c}{r1}} {\And} {\SSem{M}{w}{c}{r2}}) 
   {\And}
   ({\SSem{M}{w}{c}{\sFlexAnd{r1}{r2}}} = 
     {\Exists}w1 w2. (w = w1{\Cat}w2) {\And} 
             (({\SSem{M}{w}{c}{r1}} {\And} {\SSem{M}{w1}{c}{r2}}) 
              {\Or}
              ({\SSem{M}{w}{c}{r2}} {\And} {\SSem{M}{w1}{c}{r1}})))
   {\And}
   ({\SSem{M}{w}{c}{\sRepeat{r}}} = 
     {\Exists}wlist. (w = \CONCAT{wlist}) {\And} \EVERY{({\Lam}w. {\SSem{M}{w}{c}{r}})}{wlist})
   {\And}
   ({\SSem{M}{w}{c}{\sClock{r}{c1}}} =
     {\SSem{M}{w}{c1}{r}})
\end{alltt}}

%\vspace*{-8mm}

\subsection{Foundation Language}\label{FL}

%\vspace*{-2mm}

We define a semantic function \Fsem such that $\Fsem~\t{M}~\pi~\t{c}~\t{f}$
means FL formula \t{f} is true of path $\pi$ if the current clock is \t{c}.
The cases for weak (\t{c}) and strong (\t{c!}) clocks are considered separately.

\noindent We write $\fSem{M}{\pi}{c}{r}$ for $\Fsem~\t{M}~\pi~\t{c}~\t{f}$
and use the following two definitions:

%\vspace*{-4.5mm}

{\begin{alltt}
   FirstRise M {\Pi} c i    = \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(0,i)}))}{\bTrue}{\sCat{\sRepeat{\sBool{\bNot{c}}}}{\sBool{c}}}

   NextRise M {\Pi} c (i,j) = \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(i,j)}))}{\bTrue}{\sCat{\sRepeat{\sBool{\bNot{c}}}}{\sBool{c}}}
\end{alltt}}

%\vspace*{-3.5mm}

\noindent The semantic clauses are then:

%\vspace*{-3.5mm}

{\begin{alltt}

    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\FBool{b}}} = 
      {\ResExists{i}{\pi}}. FirstRise M {\Pi} c i {\And} {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{i})}{b}})
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fNot{f}}} = 
      {\Not}{\FSem{M}{{\pi}}{{\weakClock{c}}}{f}}) 
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fAnd{f1}{f2}}} = 
      {\ResExists{i}{\pi}}. FirstRise M {\Pi} c i {\And} 
                {\FSem{M}{\restN{{\pi}}{i}}{{\strongClock{c}}}{f1}}    {\And}
                {\FSem{M}{\restN{{\pi}}{i}}{{\strongClock{c}}}{f2}})
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fNext{f}}} = 
      {\ResExists{i}{\pi}}. FirstRise M {\Pi} c i {\And} 
                \ResExists{j}{\pi}. 
                  i < j \And NextRise M {\Pi} c (i+1,j) \And {\FSem{M}{\restN{{\pi}}{j}}{{\strongClock{c}}}{f}})
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fUntil{f1}{f2}}} = 
      {\ResExists{i k}{\pi}}. k {\Geq} i  \(\hspace*{0.8mm}\)  \(\hspace*{3.5mm}\)               {\And}
                  FirstRise M {\Pi} c i    \(\hspace*{0.4mm}\) \(\hspace*{2mm}\)   {\And}
                  {\FSem{M}{\restN{{\pi}}{k}}{\weakClock{\T}}{{\FBool{c}}}} \(\hspace*{3mm}\)           {\And}  
                  {\FSem{M}{\restN{{\pi}}{k}}{{\strongClock{c}}}{f2}}       \(\hspace*{2mm}\)    {\And}
                  {\ResForall{j}{\pi}}. 
                    i {\Leq} j {\And} j {\Le} k {\And} 
                    {\FSem{M}{\restN{{\pi}}{j}}{\weakClock{\T}}{{\FBool{c}}}} 
                    {\Imp}
                    {\FSem{M}{\restN{{\pi}}{j}}{{\strongClock{c}}}{f1}})
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fSuffixImp{r}{f}}} = 
      {\ResExists{i}{\pi}}. FirstRise M {\Pi} c i {\And} 
                {\ResForall{j}{\pi}}. i \Leq j \And \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(i,j)}))}{c}{r}
                          {\Imp}
                          {\FSem{M}{\restN{{\pi}}{j}}{{\strongClock{c}}}{f}})
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fStrongImp{r1}{r2}}} = 
      {\ResExists{i}{\pi}}. FirstRise M {\Pi} c i {\And} 
                {\ResForall{j}{\pi}}. 
                     i \Leq j \And \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(i,j)}))}{c}{r1}
                     {\Imp}
                     {\ResExists{k}{\pi}}. j \Leq k \And \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(j,k)}))}{c}{r2})
    {\And}


    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fWeakImp{r1}{r2}}} = 
     {\FSem{M}{{\pi}}{{\strongClock{c}}}{\fStrongImp{r1}{r2}}}
     {\Or}
     ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fWeakImp{r1}{r2}}} {\And}
       {\ResForall{j}{\pi}}. {\ResExists{k}{\pi}}. j {\Leq} k \And NextRise M {\Pi} c (j,k)))
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fAbort{f}{b}}} =
      {\ResExists{i}{\pi}}. FirstRise M {\Pi} c i {\And}
                ({\FSem{M}{\restN{{\pi}}{i}}{{\strongClock{c}}}{f }}
                 {\Or}
                 {\ResExists{j}{\pi}}. i \Le j \And 
                   \Exists{\Pi}'. 
                    {\FSem{M}{\restN{{\pi}}{j}}{\weakClock{\T}}{{\FBool{\bAnd{c}{b}}}}} {\And} {\FSem{M}{\pathCat{\pathSeg{\pi}{(i,j-1)}}{{\pi}'}}{{\strongClock{c}}}{f}}))
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fWeakClock{f}{c1}}} =   
      {\FSem{M}{{\pi}}{{\weakClock{c1}}}{f)}}
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fStrongClock{f}{c1}}} =   
      {\FSem{M}{{\pi}}{{\strongClock{c1}}}{f}})
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{{\FBool{b}}}} = 
      {\ResForall{i}{\pi}}. FirstRise M {\Pi} c i {\Imp} {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{i})}{b}})
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fNot{f}}} = 
      {\Not}{\FSem{M}{{\pi}}{{\strongClock{c}}}{f}}) 
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fAnd{f1}{f2}}} = 
       {\ResForall{i}{\pi}}. FirstRise M {\Pi} c i
                 {\Imp}
                 ({\FSem{M}{\restN{{\pi}}{i}}{{\weakClock{c}}}{f1}} {\And} {\FSem{M}{\restN{{\pi}}{i}}{{\weakClock{c}}}{f2}}))
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fNext{f}}} = 
      {\ResForall{i}{\pi}}. FirstRise M {\Pi} c i {\Imp} 
                \ResExists{j}{\pi}. 
                  i < j \And NextRise M {\Pi} c (i+1,j) \And {\FSem{M}{\restN{{\pi}}{j}}{{\strongClock{c}}}{f}})
    {\And}






    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fUntil{f1}{f2}}} = 
      {\FSem{M}{{\pi}}{{\strongClock{c}}}{\fUntil{f1}{f2}}}  
       {\Or}
      ({\ResExists{k}{\pi}}.
        {\ResForall{l}{\pi}}.
          l {\Geq} k {\Imp} {\FSem{M}{\restN{{\pi}}{l}}{\weakClock{\T}}{{\FBool{\bNot{c}}}}}
                    {\And} 
                    {\ResForall{j}{\pi}}. 
                      j {\Leq} k {\Imp} {\FSem{M}{\restN{{\pi}}{j}}{\weakClock{\T}}{{\FBool{c}}}} {\Imp} {\FSem{M}{\restN{{\pi}}{j}}{{\weakClock{c}}}{f1}}))
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fSuffixImp{r}{f}}} = 
      {\ResForall{i}{\pi}}. FirstRise M {\Pi} c i {\Imp}
                {\ResForall{j}{\pi}}. i \Leq j \And \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(i,j)}))}{c}{r}
                          {\Imp}
                          {\FSem{M}{\restN{{\pi}}{j}}{{\weakClock{c}}}{f}})
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fStrongImp{r1}{r2}}} = 
      {\FSem{M}{{\pi}}{{\strongClock{c}}}{\fStrongImp{r1}{r2}}}  
      {\Or}
      ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fWeakImp{r1}{r2}}} 
       {\And}
       {\ResExists{k}{\pi}}. {\ResForall{l}{\pi}}. l {\Geq} k {\Imp} {\FSem{M}{\restN{{\pi}}{l}}{\weakClock{\T}}{{\FBool{\bNot{c}}}}}))
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fWeakImp{r1}{r2}}} = 
      {\ResForall{i}{\pi}}.  FirstRise M {\Pi} c i
                 {\Imp}
                 {\ResForall{j}{\pi}}. i \Leq j \And \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(i,j)}))}{c}{r1}
                           {\Imp}
                           (({\ResExists{k}{\pi}}. j \Leq k \And \SSem{M}{ (\lHat{M} (\pathSeg{\pi}{(j,k)}))}{c}{r2})
                            {\Or}
                            {\ResForall{k}{\pi}}. j \Leq k \Imp {\Exists}w. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(j,k)}){\cat}w)}{c}{r2}))
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fAbort{f}{b}}} =
      {\ResForall{i}{\pi}}. FirstRise M {\Pi} c i 
                {\Imp}
                ({\FSem{M}{\restN{{\pi}}{i}}{{\weakClock{c}}}{f}} 
                 {\Or}   
                 {\ResExists{j}{\pi}}. i \Le j \And
                  \Exists{\Pi}'\In\Sim {\Pi}. {\FSem{M}{\restN{{\pi}}{j}}{\weakClock{\T}}{{\FBool{\bAnd{c}{b}}}}} {\And} {\FSem{M}{\pathCat{\pathSeg{\pi}{(i,j-1)}}{{\pi}'}}{{\weakClock{c}}}{f}}))
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fWeakClock{f}{c1}}} =   
      {\FSem{M}{{\pi}}{{\weakClock{c1}}}{f}})
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fStrongClock{f}{c1}}} =   
      {\FSem{M}{{\pi}}{{\strongClock{c1}}}{f}})
\end{alltt}}


This semantics of FL formulas differs from the one we originally transcribed from the Accellera submission document
\cite{Accellera}.
See the Appendix for the original semantics and Section~\ref{progress} for a discussion of the differences
between it and the current semantics in Section~\ref{FL}.



\subsection{Optional Branching Extension}\label{OBE}


The semantic function \Osem is defined so that
\texttt{\Osem~M~s~f} is true iff \texttt{f} is true of \texttt{M} at
state \texttt{s}.

The semantics here differs from the simpler one in Section~\ref{OBEfinite}
in that it handles both finite and infinite paths.

Write $\oSem{M}{s}{f}$ for \texttt{\Osem~M~s~f}, and then the semantics of the OBE is defined by:

{\begin{alltt}
   (\OSem{M}{s}{\oBool{b}} = {\BSem{M}{\lNoHat{M}(s)}{b}})
   {\And}
   (\OSem{M}{s}{\oNot{f}} = {\Not}(\OSem{M}{s}{f})) 
   {\And}
   (\OSem{M}{s}{\oAnd{f1}{f2}} = \OSem{M}{s}{f1} {\And} \OSem{M}{s}{f2})
   {\And}
   (\OSem{M}{s}{\oEx{f}} = 
     {\Exists}{\Pi}. Path M {\Pi} {\And} \Pl \Pi 1 {\And} (\PathEl{{\pi}}{0} = s) {\And} \OSem{M}{\pathEl{{\pi}}{1}}{f})
   {\And}
   (\OSem{M}{s}{\oEu{f1}{f2}} = 
     {\Exists}{\Pi}. Path M {\Pi} {\And} (\PathEl{{\pi}}{0} = s)
         {\And} 
         {\ResExists{k}{\pi}}. 
           \OSem{M}{\pathEl{{\pi}}{k}}{f2} {\And} {\ResForall{j}{\pi}}. j {\Le} k {\Imp} \OSem{M}{\pathEl{{\pi}}{j}}{f1})
   {\And}
   (\OSem{M}{s}{\oEg{f}} = 
     {\Exists}{\Pi}. Path M {\Pi} {\And} (\PathEl{{\pi}}{0} = s) {\And} {\ResForall{j}{\pi}}. \OSem{M}{\pathEl{{\pi}}{j}}{f})
\end{alltt}}

\section{Progress on analysing the semantics}\label{progress}

We have established a number of properties of the semantics using the \HOL system.
Some of these went through first time without any problems,
but others revealed bugs both in the \Sugar semantics and  original HOL representation
of the semantics.

\subsection{Properties of $\t{FirstRise}$ and $\t{NextRise}$}

Recall the definitions:


{\begin{alltt}
   FirstRise M {\Pi} c i    = \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(0,i)}))}{\bTrue}{\sCat{\sRepeat{\sBool{\bNot{c}}}}{\sBool{c}}}
   NextRise M {\Pi} c (i,j) = \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(i,j)}))}{\bTrue}{\sCat{\sRepeat{\sBool{\bNot{c}}}}{\sBool{c}}}
\end{alltt}}

We have proved that the definitions of \t{FirstRise} and \t{NextRise} give them the correct meaning,
namely $\t{FirstRise~M}~{\pi}~\t{c~i}$ is true iff \t{i} is the time of the first
rising edge of \t{c},
and $\t{NextRise~M}~{\pi}~\t{c~(i,j)}$ is true iff \t{j} is the time of the first
rising edge of \t{c} after \t{i}.

\medskip

$\begin{array}{l}
\vdash~ \t{FirstRise~M}~{\pi}~\t{c~i}~=\\
\phantom{\vdash~}
~(\forall \t{j}.~\t{j} < \t{i} ~\Rightarrow~\neg\bSem{M}{L_{M}(\pi_j)}{\t{c}})~\wedge~\bSem{M}{L_{M}(\pi_i)}{\t{c}}\\
 \\
\vdash~ \t{i}\leq \t{j}\\
\phantom{\vdash~}
\Rightarrow\\
\phantom{\vdash~}
(\t{NextRise~M}~{\pi}~\t{c~(i,j)}~=\\
\phantom{\vdash~(}
~(\forall \t{k}.~\t{i} \leq \t{k} \wedge \t{k} < \t{j} ~\Rightarrow~\neg\bSem{M}{L_{M}(\pi_k)}{\t{c}})~\wedge~\bSem{M}{L_{M}(\pi_j)}{\t{c}})
\end{array}$

\medskip

The proof of these were essentially routine, though quite a bit more tricky than expected. Immediate corollaries are


\medskip

$\begin{array}{l}
\vdash~ \t{FirstRise~M}~{\pi}~\t{\T~i}~=~(\t{i}=0)
 \\
\vdash~ \t{i}\leq \t{j}~\Rightarrow~(\t{NextRise~M}~{\pi}~\t{\T~(i,j)}~=~(\t{i} = \t{j}))
\end{array}$

\subsection{Relating the clocked and unclocked semantics}\label{relatingclocks}

If we define \t{ClockFree~r} to mean
that \t{r} contains no clocking constructs (a simple recursion over the syntax of SEREs),
then clocking with \T{} is equivalent to the unclocked SERE semantics.

\medskip

$\vdash~\forall{\t{r}}.~\t{ClockFree~r}~\Rightarrow~(\sSem{M}{w}{\T}{r}~=~\sSem{M}{w}{\c}{r})$

\medskip

The proof of this is an easy structural induction, and shows that the semantics in Section~\ref{FullSERE}
collapses to that in Section~\ref{SimpleSERE} when the clock is \T.

We tried to prove a similar result for FL formulas, but this turned out to be impossible.
The reason is that the proof required first showing


\medskip

$~~\forall{\t{f}}~\pi.~\fSem{M}{\pi}{\T}{f}~=~\sSem{M}{\pi}{\T\texttt{!}}{f})$

\medskip

However, the original semantics had the following:

{\begin{alltt}
  {\FSem{M}{{\pi}}{{\strongClock{c}}}{\FBool{b}}} = {\Exists}i. FirstRise M {\Pi} c i {\And} {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{i})}{b}}

  {\FSem{M}{{\pi}}{{\weakClock{c}}}{{\FBool{b}}}}  = {\Exists}i. FirstRise M {\Pi} c i {\Imp} {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{i})}{b}}
\end{alltt}}


Instantiating \t{c} to \T{} and using the corollary about \t{FirstRise} yields


{\begin{alltt}
  {\FSem{M}{{\pi}}{{\strongClock{\T}}}{\FBool{b}}} = {\Exists}i. (i=0) {\And} {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{i})}{b}}

  {\FSem{M}{{\pi}}{{\weakClock{\T}}}{{\FBool{b}}}}  = {\Exists}i. (i=0) {\Imp} {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{i})}{b}}
\end{alltt}}

With this, clearly $\fSem{M}{\pi}{\T}{\FBool{b}}$ is not equal to $\sSem{M}{\pi}{\T\texttt{!}}{\FBool{b}})$.
The solution, suggested by Cindy Eisner, is to replace the weak semantics by


{\begin{alltt}
  {\FSem{M}{{\pi}}{{\weakClock{c}}}{{\FBool{b}}}}  = {\Forall}i. FirstRise M {\Pi} c i {\Imp} {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{i})}{b}}
\end{alltt}}

so that we get 


{\begin{alltt}
  {\FSem{M}{{\pi}}{{\strongClock{\T}}}{\FBool{b}}} = {\Exists}i. (i=0) {\And} {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{i})}{b}}

  {\FSem{M}{{\pi}}{{\weakClock{\T}}}{{\FBool{b}}}}  = {\Forall}i. (i=0) {\Imp} {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{i})}{b}}
\end{alltt}}

which makes $\fSem{M}{\pi}{\T}{\FBool{b}}$ equal to $\sSem{M}{\pi}{\T\texttt{!}}{\FBool{b}})$.
The same change of $\exists$ to $\forall$ is also needed for the semantics of weak clocking for
$\tt{\fAnd{f1}{f2}}$,  $\tt{\fNext{f}}$, $\tt{\fSuffixImp{r}{f}}$, $\tt{\fWeakImp{r1}{r2}}$ and $\tt{\fAbort{f}{b}}$.
With these changes, a structural induction proves:

\medskip

$~~\vdash~\forall{\t{f}}~\pi.~\fSem{M}{\pi}{\T}{f}~=~\sSem{M}{\pi}{\T\texttt{!}}{f})$

\medskip

However, we were still unable to prove

\medskip

$\vdash~\forall{\t{f}}.~\t{ClockFree~f}~\Rightarrow~(\sSem{M}{w}{\T}{f}~=~\sSem{M}{w}{\c}{f})$

\medskip
where here \t{ClockFree~f} means that \t{f} contains no clocked FL
formulas or SEREs, the semantics on the left of the equation is the
one in Section~\ref{FL} and the semantics on the right of the equation
is the one in Section~\ref{finite}.  The proof attempt failed because
the unclocked semantics for $\tt{\fUntil{f1}{f2}}$ had a path length
check, but the strongly clocked semantics didn't. After restricting
the quantification of \t{k} in the strongly clocked semantics to
values satisfying $\pl~\pi$ the proof went through.

\subsection{Further analysis}

The original semantics specifies
that some of the quantifications over the variables
$\t{i}$, $\t{j}$, $\t{k}$ etc.{} be restricted to range over values
the are smaller than the length of the current path $\pi$
(we represent this using $\pl\hspace*{0.5mm}\pi$).
Our initial attempts to relate the clocked and unclocked semantics needed
additional quantifier restrictions to be added, as discussed at the end of
Section~\ref{relatingclocks} above. However, during email discussions with the
\Sugar designers it became clear that in fact all quantifications
should be restricted, for otherwise the semantics would rely on the
HOL logic's default interpretions of terms like $\pi^j$ when $\pi$ is
finite and $j \geq \t{length}~\pi$.\footnote{The logical treatment of
`undefined' terms like $1/0$ or $\t{hd[]}$ has been much
discussed. HOL uses a simple and consistent approach based on
Hilbert's $\varepsilon$-operator. Other approaches include `free
logics' (i.e.~logics with non-denoting terms) and three-valued logics
in which formulas can evaluate to $true$, $false$ and $undefined$.}
With HOL's default interpretation of `meaningless' terms, it is
unclear whether the semantics accurately reflects the designers
intentions.

Thus the semantics was modified so that all quantifications are
suitably restricted.  In addition, and in the same spirit, we added
the requirement that all terms $\pathSeg{\pi}{(m,n)}$ occured in a
context where $m\leq n$, so that the arbitrary value of
$\pathSeg{\pi}{(m,n)}$ when $m>n$ was not invoked. Unfortunately
these changes broke the
existing proof of

\medskip

$~~\vdash~\forall{\t{f}}~\pi.~\fSem{M}{\pi}{\T}{f}~=~\sSem{M}{\pi}{\T\texttt{!}}{f})$

\medskip

and hence the proof relating the clocked and unclocked semantics.

Further discussion with the \Sugar designers at first suggested that
in fact this property should not be expected to hold after all.  What
we thought had happened was that our semantics, following the
Accellera submission semantics, was imprecise about certain details,
and this imprecision conspired to make the property true.  When we
sharpened the semantics (to eliminate meaningless terms), the property
became false. However, in the end it turned out that there was just a
bug in the semantics: ``$\t{l}>\t{k}$'' should be ``$\t{l}\geq\t{k}$''
in the weakly clocked semantics of until and strong suffix
implication, and when this change was made the proof of the above
property, and the equivalence between the unclocked and true-clocked
semantics, went through. However, just as we thought everything was
sorted out, the \Sugar designers announced they had discovered a bug
and pointed out that we should not have been able to prove what we had
without a tweak.  Careful analysis showed that a discrepancy between
the semantics in this paper and what was defined in HOL had crept
in. The bug in the HOL semantics allowed a proof to succeed when it
shouldn't have. After fixing the discrepancy the proofs failed, as
they should, and after the correct fix was made they went through.

\section{Conclusions}

It was quite straightforward to use the informal semantics in the
\Sugar documentation to create a deep embedding of the whole \Sugar
kernel.  Attempting to prove some simple `sanity checking' lemmas with
a proof assistant quickly revealed bugs in the translated semantics (and
possibly in the original). Further probing revealed more bugs.

It is hoped that the
semantics in Section~\ref{SugarSemantics} is correct, but until
further properties are proved we cannot be sure, and the experience so
far suggests caution!

%Although the process of analysing the semantics using machine assisted
%proof has revealed a number of interesting issues, we expect eventually
%to converge on a semantics that, with high confidence, is correct.

\section{Acknowledgements}

Cindy Eisner and Dana Fisman patiently answered numerous email questions
in great detail. They also supplied valuable comments and corrections
to an earlier version of this paper, and suggested
ways of modifying the HOL semantics to get the proofs described in Section~\ref{progress} to go through.

\bibliographystyle{plain}{\bibliography{CatBPaper}}

\newpage
\section*{APPENDIX: Initial HOL semantics}\label{appendix}


This appendix consists of a typeset version of our initial transcription into higher order logic of
the semantics in the Sugar documentation

~~{\footnotesize
\url{http://www.haifa.il.ibm.com/projects/verification/sugar/literature.html}}

This semantics turned out to be inadequate for the reasons discussed in Section~\ref{progress}.

\section{Boolean expressions}

\vspace*{-2mm}

{\begin{alltt}
   ({\BSem{M}{l}{\bProp{p}}}   \(\hspace*{1.5mm}\)  = \(p\) {\In} P\(\sb{M}\) {\And} \(p\) {\In} l) \(\hspace*{0.5mm}\)           {\And}
   ({\BSem{M}{l}{\bTrue}}     \(\hspace*{1.3mm}\)= T)                        \(\hspace*{1mm}\)  {\And}
   ({\BSem{M}{l}{{\bNot{b}}}}    \(\hspace*{1.5mm}\)= {\Not}{\BSem{M}{l}{b}})      \(\hspace*{1.5mm}\)         {\And}
   ({\BSem{M}{l}{\bAnd{b1}{b2}}} \(\hspace*{0mm}\)= {\BSem{M}{l}{b1}} {\And} {\BSem{M}{l}{b2}})
\end{alltt}}

\vspace*{-6mm}

\section{Sugar Extended Regular Expressions}

If \texttt{wlist} is a list of lists then
\texttt{\CONCAT{wlist}} is the concatenation of the lists
in \texttt{wlist} and if $P$ is some predicate
then \texttt{\EVERY{$P$}wlist} means that $P(\texttt{w})$
holds for every \texttt{w} in \texttt{wlist}.

\begin{alltt}
   ({\SSem{M}{w}{c}{\sBool{b}}} = 
     {\Exists}n. n {\Geq} 1                                 {\And} 
         ({\Length} w = n)                         {\And} 
         ({\Forall}i. 1 {\Leq} i {\And} i {\Le} n {\Imp} {\BSem{M}{\el{i-1}{w}}{\bNot{c}}} {\And}
         {\BSem{M}{\el{n-1}{w}}{\bAnd{c}{b}}})
   {\And}
   ({\SSem{M}{w}{c}{\sCat{r1}{r2}}} = 
     {\Exists}w1 w2. (w = w1{\Cat}w2) {\And} {\SSem{M}{w1}{c}{r1}} {\And} {\SSem{M}{w2}{c}{r2}})
   {\And}
   ({\SSem{M}{w}{c}{\sFusion{r1}{r2}}} = 
     {\Exists}w1 w2 l. (w = w1{\cat}[l]{\cat}w2) {\And} 
               {\SSem{M}{(w1{\cat}\texttt{[}l\texttt{]})}{c}{r1}} {\And} {\SSem{M}{(\texttt{[}l\texttt{]}{\cat}w2)}{c}{r2}}) 
   {\And}
   ({\SSem{M}{w}{c}{\sOr{r1}{r2}}} = 
     {\SSem{M}{w}{c}{r1}} {\Or} {\SSem{M}{w}{c}{r2}}) 
   {\And}
   ({\SSem{M}{w}{c}{\sRigAnd{r1}{r2}}} = 
     {\SSem{M}{w}{c}{r1}} {\And} {\SSem{M}{w}{c}{r2}}) 
   {\And}
   ({\SSem{M}{w}{c}{\sFlexAnd{r1}{r2}}} = 
     {\Exists}w1 w2. (w = w1{\Cat}w2) {\And} 
             (({\SSem{M}{w}{c}{r1}} {\And} {\SSem{M}{w1}{c}{r2}}) 
              {\Or}
              ({\SSem{M}{w}{c}{r2}} {\And} {\SSem{M}{w1}{c}{r1}})))
   {\And}
   ({\SSem{M}{w}{c}{\sRepeat{r}}} = 
     {\Exists}wlist. (w = \CONCAT{wlist}) {\And} \EVERY{({\Lam}w. {\SSem{M}{w}{c}{r}})}{wlist})
   {\And}
   ({\SSem{M}{w}{c}{\sClock{r}{c1}}} =
     {\SSem{M}{w}{c1}{r}})
\end{alltt}

\section{Foundation Language}

The following two constants are defined:

\begin{alltt}
   FirstRise M {\Pi} c i    = \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(0,i)}))}{\bTrue}{\sCat{\sRepeat{\sBool{\bNot{c}}}}{\sBool{c}}}
   NextRise M {\Pi} c (i,j) = \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(i,j)}))}{\bTrue}{\sCat{\sRepeat{\sBool{\bNot{c}}}}{\sBool{c}}}
\end{alltt}

The semantic clauses are then:

\begin{alltt}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\FBool{b}}} = 
      {\Exists}i. FirstRise M {\Pi} c i {\And} {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{i})}{b}}
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fNot{f}}} = 
      {\Not}({\FSem{M}{{\pi}}{{\weakClock{c}}}{f}})) 
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fAnd{f1}{f2}}} = 
      {\Exists}i. FirstRise M {\Pi} c i {\And} 
          {\FSem{M}{\restN{{\pi}}{i}}{{\strongClock{c}}}{f1}}    {\And}
          {\FSem{M}{\restN{{\pi}}{i}}{{\strongClock{c}}}{f2}})
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fNext{f}}} = 
      {\Exists}i. FirstRise M {\Pi} c i            {\And} 
          ({\IsFinitePath} {\Pi} {\Imp} i {\Le} \PathLength {\Pi} - 1) {\And}
          {\FSem{M}{\restN{{\pi}}{i+1}}{{\strongClock{c}}}{f)}}
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fUntil{f1}{f2}}} = 
      {\Exists}i k. k {\Geq} i             {\And}
            FirstRise M {\Pi} c i  {\And}
            {\FSem{M}{\restN{{\pi}}{k}}{\weakClock{\T}}{{\FBool{c}}}}      {\And}  
            {\FSem{M}{\restN{{\pi}}{k}}{{\strongClock{c}}}{f2}}     {\And}
            {\Forall}j. i {\Leq} j {\And} j {\Le} k {\And} 
              {\FSem{M}{\restN{{\pi}}{j}}{\weakClock{\T}}{{\FBool{c}}}} 
              {\Imp}
              {\FSem{M}{\restN{{\pi}}{j}}{{\strongClock{c}}}{f1}})
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fSuffixImp{r}{f}}} = 
      {\Exists}i. FirstRise M {\Pi} c i {\And} 
          {\Forall}j. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(i,j)}))}{c}{r}
              {\Imp}
              {\FSem{M}{\restN{{\pi}}{j}}{{\strongClock{c}}}{f}})
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fStrongImp{r1}{r2}}} = 
      {\Exists}i. FirstRise M {\Pi} c i {\And} 
          {\Forall}j. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(i,j)}))}{c}{r1}
              {\Imp}
              {\Exists}k. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(j,k)}))}{c}{r2})
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fWeakImp{r1}{r2}}} = 
     {\FSem{M}{{\pi}}{{\strongClock{c}}}{\fStrongImp{r1}{r2}}}
      {\Or}
     ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fWeakImp{r1}{r2}}}
      {\And}
      {\Forall}j. ({\IsFinitePath} {\Pi} {\Imp} j {\Le} \PathLength {\Pi})
          {\Imp}
          {\Exists}k. NextRise M {\Pi} c (j,k)))
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fAbort{f}{b}}} =
      {\Exists}i. FirstRise M {\Pi} c i {\And}
          ({\FSem{M}{\restN{{\pi}}{i}}{{\strongClock{c}}}{f }}
           {\Or}
           {\Exists}j {\Pi}'. 
             {\FSem{M}{\restN{{\pi}}{j}}{\weakClock{\T}}{{\FBool{\bAnd{c}{b}}}}} {\And} 
             {\FSem{M}{\pathCat{\pathSeg{\pi}{(i,j-1)}}{{\pi}'}}{{\strongClock{c}}}{f}}))
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fWeakClock{f}{c1}}} =   
      {\FSem{M}{{\pi}}{{\weakClock{c1}}}{f)}}
    {\And}
    ({\FSem{M}{{\pi}}{{\strongClock{c}}}{\fStrongClock{f}{c1}}} =   
      {\FSem{M}{{\pi}}{{\strongClock{c1}}}{f}})
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{{\FBool{b}}}} = 
      {\Exists}i. FirstRise M {\Pi} c i 
          {\Imp} 
          {\BSem{M}{\lNoHat{M}(\pathEl{{\pi}}{i})}{b}})
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fNot{f}}} = 
      {\Not}({\FSem{M}{{\pi}}{{\strongClock{c}}}{f}})) 
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fAnd{f1}{f2}}} = 
      {\Exists}i. FirstRise M {\Pi} c i
          {\Imp}
          ({\FSem{M}{\restN{{\pi}}{i}}{{\weakClock{c}}}{f1}} 
           {\And}
           {\FSem{M}{\restN{{\pi}}{i}}{{\weakClock{c}}}{f2}}))
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fNext{f}}} = 
      {\Exists}i. (FirstRise M {\Pi} c i 
           {\And}
           ({\IsFinitePath} {\Pi} {\Imp} i {\Le} \PathLength {\Pi} - 1))
           {\Imp}
           {\FSem{M}{\restN{{\pi}}{i+1}}{{\weakClock{c}}}{f}})
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fUntil{f1}{f2}}} = 
      {\FSem{M}{{\pi}}{{\strongClock{c}}}{\fUntil{f1}{f2}}}  
      {\Or}
      ({\Exists}k. {\Forall}l. l {\Ge} k
               {\Imp}
               {\FSem{M}{\restN{{\pi}}{l}}{\weakClock{\T}}{{\FBool{\bNot{c}}}}} 
               {\And} 
               {\Forall}j. j {\Leq} k 
                   {\Imp}
                   {\FSem{M}{\restN{{\pi}}{j}}{\weakClock{\T}}{{\FBool{c}}}}
                   {\Imp}
                   {\FSem{M}{\restN{{\pi}}{j}}{{\weakClock{c}}}{f1}}))
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fSuffixImp{r}{f}}} = 
      {\Exists}i. FirstRise M {\Pi} c i {\Imp}
          {\Forall}j. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(i,j)}))}{c}{r}
              {\Imp}
              {\FSem{M}{\restN{{\pi}}{j}}{{\weakClock{c}}}{f}})
    {\And}

    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fStrongImp{r1}{r2}}} = 
      {\FSem{M}{{\pi}}{{\strongClock{c}}}{\fStrongImp{r1}{r2}}}  
      {\Or}
      ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fWeakImp{r1}{r2}}} 
       {\And}
       {\Exists}k. {\Forall}l. l {\Ge} k 
               {\Imp} 
               {\FSem{M}{\restN{{\pi}}{l}}{\weakClock{\T}}{{\FBool{\bNot{c}}}}}))
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fWeakImp{r1}{r2}}} = 
      {\Exists}i.  FirstRise M {\Pi} c i
           {\Imp}
           {\Forall}j. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(i,j)}))}{c}{r1}
               {\Imp}
               (({\Exists}k. \SSem{M}{ (\lHat{M} (\pathSeg{\pi}{(j,k)}))}{c}{r2})
                {\Or}
                {\Forall}k. ({\IsFinitePath} {\Pi} {\Imp} k {\Le} \PathLength {\Pi})
                    {\Imp}
                    {\Exists}w. \SSem{M}{(\lHat{M} (\pathSeg{\pi}{(j,k)}){\cat}w)}{c}{r2}))
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fAbort{f}{b}}} =
      {\Exists}i. FirstRise M {\Pi} c i 
          {\Imp}
          ({\FSem{M}{\restN{{\pi}}{i}}{{\weakClock{c}}}{f}} 
           {\Or}   
           {\Exists}j {\Pi}'. {\FSem{M}{\restN{{\pi}}{j}}{\weakClock{\T}}{{\FBool{\bAnd{c}{b}}}}}
                   {\And}
                  {\FSem{M}{\pathCat{\pathSeg{\pi}{(i,j-1)}}{{\pi}'}}{{\weakClock{c}}}{f}}))
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fWeakClock{f}{c1}}} =   
      {\FSem{M}{{\pi}}{{\weakClock{c1}}}{f}})
    {\And}
    ({\FSem{M}{{\pi}}{{\weakClock{c}}}{\fStrongClock{f}{c1}}} =   
      {\FSem{M}{{\pi}}{{\strongClock{c1}}}{f}})
\end{alltt}

\section{Optional Branching Extension}

The following predicate is defined

\begin{alltt}
   Path M {\Pi} = {\Forall}n. \getR{M}(\PathEl{{\pi}}{n}, \PathEl{{\pi}}{n+1})
\end{alltt}

The semantic clauses are then:

\begin{alltt}
   (\OSem{M}{s}{\oBool{b}} = {\BSem{M}{\lNoHat{M}(s)}{b}})
   {\And}
   (\OSem{M}{s}{\oNot{f}} = {\Not}(\OSem{M}{s}{f})) 
   {\And}
   (\OSem{M}{s}{\oAnd{f1}{f2}} = \OSem{M}{s}{f1} {\And} \OSem{M}{s}{f2})
   {\And}
   (\OSem{M}{s}{\oEx{f}} = 
     {\Exists}{\Pi}. Path M {\Pi}                 {\And} 
         ({\IsFinitePath} {\Pi} {\Imp} 1 {\Le} \PathLength {\Pi}) {\And} 
         (\PathEl{{\pi}}{0} = s) {\And} \OSem{M}{\pathEl{{\pi}}{1}}{f})
   {\And}
   (\OSem{M}{s}{\oEu{f1}{f2}} = 
     {\Exists}{\Pi}. Path M {\Pi}                    {\And} 
         (\PathEl{{\pi}}{0} = s)                     {\And} 
         {\Exists}k. ({\IsFinitePath} {\Pi} {\Imp} k {\Le} \PathLength {\Pi}) {\And}
             \OSem{M}{\pathEl{{\pi}}{k}}{f2}             {\And} 
             {\Forall}j. j {\Le} k {\Imp} \OSem{M}{\pathEl{{\pi}}{j}}{f1})
   {\And}
   (\OSem{M}{s}{\oEg{f}} = 
     {\Exists}{\Pi}. Path M {\Pi} {\And} 
         (\PathEl{{\pi}}{0} = s)  {\And} 
         {\Forall}j. ({\IsFinitePath} {\Pi} {\Imp} j {\Le} \PathLength {\Pi}) {\Imp} \OSem{M}{\pathEl{{\pi}}{j}}{f})
\end{alltt}


\end{document}








