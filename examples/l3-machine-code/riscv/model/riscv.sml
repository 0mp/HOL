(* riscv - generated by L3 - Mon May 23 12:34:14 2016 *)

structure riscv :> riscv =
struct

structure Map = MutableMap

(* -------------------------------------------------------------------------
   Type declarations
   ------------------------------------------------------------------------- *)

datatype accessType = Read | Write

datatype fetchType = Instruction | Data

datatype Architecture = RV32I | RV64I | RV128I

datatype Privilege = User | Supervisor | Hypervisor | Machine

datatype VM_Mode = Mbare | Mbb | Mbbid | Sv32 | Sv39 | Sv48 | Sv57 | Sv64

datatype ExtStatus = Off | Initial | Clean | Dirty

datatype Interrupt = Software | Timer

datatype ExceptionType
  = Fetch_Misaligned | Fetch_Fault | Illegal_Instr | Breakpoint
  | Load_Fault | AMO_Misaligned | Store_AMO_Fault | UMode_Env_Call
  | SMode_Env_Call | HMode_Env_Call | MMode_Env_Call

type mcpuid =
  { ArchBase: BitsN.nbit, I: bool, M: bool, S: bool, U: bool,
    mcpuid'rst: BitsN.nbit }

type mimpid = { RVImpl: BitsN.nbit, RVSource: BitsN.nbit }

type mstatus =
  { MFS: BitsN.nbit, MIE: bool, MIE1: bool, MIE2: bool, MIE3: bool,
    MMPRV: bool, MPRV: BitsN.nbit, MPRV1: BitsN.nbit, MPRV2: BitsN.nbit,
    MPRV3: BitsN.nbit, MSD: bool, MXS: BitsN.nbit, VM: BitsN.nbit,
    mstatus'rst: BitsN.nbit }

type mtdeleg = { Exc_deleg: BitsN.nbit, Intr_deleg: BitsN.nbit }

type mip =
  { HSIP: bool, HTIP: bool, MSIP: bool, MTIP: bool, SSIP: bool,
    STIP: bool, mip'rst: BitsN.nbit }

type mie =
  { HSIE: bool, HTIE: bool, MSIE: bool, MTIE: bool, SSIE: bool,
    STIE: bool, mie'rst: BitsN.nbit }

type mcause = { EC: BitsN.nbit, Int: bool, mcause'rst: BitsN.nbit }

type MachineCSR =
  { mbadaddr: BitsN.nbit, mbase: BitsN.nbit, mbound: BitsN.nbit,
    mcause: mcause, mcpuid: mcpuid, mdbase: BitsN.nbit,
    mdbound: BitsN.nbit, mepc: BitsN.nbit, mfromhost: BitsN.nbit,
    mhartid: BitsN.nbit, mibase: BitsN.nbit, mibound: BitsN.nbit,
    mie: mie, mimpid: mimpid, mip: mip, mscratch: BitsN.nbit,
    mstatus: mstatus, mtdeleg: mtdeleg, mtime_delta: BitsN.nbit,
    mtimecmp: BitsN.nbit, mtohost: BitsN.nbit, mtvec: BitsN.nbit }

type HypervisorCSR =
  { hbadaddr: BitsN.nbit, hcause: mcause, hepc: BitsN.nbit,
    hscratch: BitsN.nbit, hstatus: mstatus, htdeleg: mtdeleg,
    htime_delta: BitsN.nbit, htimecmp: BitsN.nbit, htvec: BitsN.nbit }

type sstatus =
  { SFS: BitsN.nbit, SIE: bool, SMPRV: bool, SPIE: bool, SPS: bool,
    SSD: bool, SXS: BitsN.nbit, sstatus'rst: BitsN.nbit }

type sip = { SSIP: bool, STIP: bool, sip'rst: BitsN.nbit }

type sie = { SSIE: bool, STIE: bool, sie'rst: BitsN.nbit }

type SupervisorCSR =
  { sasid: BitsN.nbit, sbadaddr: BitsN.nbit, scause: mcause,
    sepc: BitsN.nbit, sptbr: BitsN.nbit, sscratch: BitsN.nbit,
    stime_delta: BitsN.nbit, stimecmp: BitsN.nbit, stvec: BitsN.nbit }

type UserCSR =
  { cycle_delta: BitsN.nbit, instret_delta: BitsN.nbit,
    time_delta: BitsN.nbit }

type SynchronousTrap = { badaddr: BitsN.nbit option, trap: ExceptionType }

datatype TransferControl
  = BranchTo of BitsN.nbit | Ereturn | Mrts | Trap of SynchronousTrap

type StateDelta =
  { addr: BitsN.nbit option, data1: BitsN.nbit option,
    data2: BitsN.nbit option, exc_taken: bool, fetch_exc: bool,
    fp_data: BitsN.nbit option, pc: BitsN.nbit, rinstr: BitsN.nbit,
    st_width: BitsN.nbit option }

type SV_PTE =
  { PTE_D: bool, PTE_PPNi: BitsN.nbit, PTE_R: bool, PTE_SW: BitsN.nbit,
    PTE_T: BitsN.nbit, PTE_V: bool, sv_pte'rst: BitsN.nbit }

type SV_Vaddr =
  { Sv_PgOfs: BitsN.nbit, Sv_VPNi: BitsN.nbit, sv_vaddr'rst: BitsN.nbit }

type TLBEntry =
  { age: BitsN.nbit, asid: BitsN.nbit, global: bool, pAddr: BitsN.nbit,
    pte: SV_PTE, pteAddr: BitsN.nbit, vAddr: BitsN.nbit,
    vAddrMask: BitsN.nbit, vMatchMask: BitsN.nbit }

datatype Internal
  = FETCH_FAULT of BitsN.nbit | FETCH_MISALIGNED of BitsN.nbit

datatype System
  = CSRRC of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | CSRRCI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | CSRRS of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | CSRRSI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | CSRRW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | CSRRWI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | EBREAK
  | ECALL
  | ERET
  | MRTS
  | SFENCE_VM of BitsN.nbit
  | WFI

datatype AMO
  = AMOADD_D of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOADD_W of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOAND_D of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOAND_W of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOMAXU_D of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOMAXU_W of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOMAX_D of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOMAX_W of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOMINU_D of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOMINU_W of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOMIN_D of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOMIN_W of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOOR_D of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOOR_W of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOSWAP_D of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOSWAP_W of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOXOR_D of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOXOR_W of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | LR_D of BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | LR_W of BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | SC_D of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | SC_W of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))

datatype Store
  = SB of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SD of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SH of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype Load
  = LB of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LBU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LD of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LH of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LHU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LWU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype Branch
  = BEQ of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | BGE of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | BGEU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | BLT of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | BLTU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | BNE of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | JAL of BitsN.nbit * BitsN.nbit
  | JALR of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype MulDiv
  = DIV of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | DIVU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | DIVUW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | DIVW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | MUL of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | MULH of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | MULHSU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | MULHU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | MULW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | REM of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | REMU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | REMUW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | REMW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype Shift
  = SLL of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SLLI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SLLIW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SLLW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SRA of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SRAI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SRAIW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SRAW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SRL of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SRLI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SRLIW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SRLW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype ArithR
  = ADD of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | ADDW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | AND of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | OR of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SLT of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SLTU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SUB of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SUBW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | XOR of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype ArithI
  = ADDI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | ADDIW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | ANDI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | AUIPC of BitsN.nbit * BitsN.nbit
  | LUI of BitsN.nbit * BitsN.nbit
  | ORI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SLTI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SLTIU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | XORI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype instruction
  = AMO of AMO
  | ArithI of ArithI
  | ArithR of ArithR
  | Branch of Branch
  | FENCE of BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | FENCE_I of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | Internal of Internal
  | Load of Load
  | MulDiv of MulDiv
  | Shift of Shift
  | Store of Store
  | System of System
  | UnknownInstruction

datatype FetchResult = F_Error of instruction | F_Result of BitsN.nbit

(* -------------------------------------------------------------------------
   Casting maps (for enumerated types)
   ------------------------------------------------------------------------- *)

structure Cast =
struct
fun natToaccessType x =
  case Nat.toInt x of
     0 => Read | 1 => Write | _ => raise Fail "natToaccessType"

fun natTofetchType x =
  case Nat.toInt x of
     0 => Instruction | 1 => Data | _ => raise Fail "natTofetchType"

fun natToArchitecture x =
  case Nat.toInt x of
     0 => RV32I
   | 1 => RV64I
   | 2 => RV128I
   | _ => raise Fail "natToArchitecture"

fun natToPrivilege x =
  case Nat.toInt x of
     0 => User
   | 1 => Supervisor
   | 2 => Hypervisor
   | 3 => Machine
   | _ => raise Fail "natToPrivilege"

fun natToVM_Mode x =
  case Nat.toInt x of
     0 => Mbare
   | 1 => Mbb
   | 2 => Mbbid
   | 3 => Sv32
   | 4 => Sv39
   | 5 => Sv48
   | 6 => Sv57
   | 7 => Sv64
   | _ => raise Fail "natToVM_Mode"

fun natToExtStatus x =
  case Nat.toInt x of
     0 => Off
   | 1 => Initial
   | 2 => Clean
   | 3 => Dirty
   | _ => raise Fail "natToExtStatus"

fun natToInterrupt x =
  case Nat.toInt x of
     0 => Software | 1 => Timer | _ => raise Fail "natToInterrupt"

fun natToExceptionType x =
  case Nat.toInt x of
     0 => Fetch_Misaligned
   | 1 => Fetch_Fault
   | 2 => Illegal_Instr
   | 3 => Breakpoint
   | 4 => Load_Fault
   | 5 => AMO_Misaligned
   | 6 => Store_AMO_Fault
   | 7 => UMode_Env_Call
   | 8 => SMode_Env_Call
   | 9 => HMode_Env_Call
   | 10 => MMode_Env_Call
   | _ => raise Fail "natToExceptionType"

fun accessTypeToNat x =
  case x of
     Read => 0 | Write => 1

fun fetchTypeToNat x =
  case x of
     Instruction => 0 | Data => 1

fun ArchitectureToNat x =
  case x of
     RV32I => 0 | RV64I => 1 | RV128I => 2

fun PrivilegeToNat x =
  case x of
     User => 0 | Supervisor => 1 | Hypervisor => 2 | Machine => 3

fun VM_ModeToNat x =
  case x of
     Mbare => 0
   | Mbb => 1
   | Mbbid => 2
   | Sv32 => 3
   | Sv39 => 4
   | Sv48 => 5
   | Sv57 => 6
   | Sv64 => 7

fun ExtStatusToNat x =
  case x of
     Off => 0 | Initial => 1 | Clean => 2 | Dirty => 3

fun InterruptToNat x =
  case x of
     Software => 0 | Timer => 1

fun ExceptionTypeToNat x =
  case x of
     Fetch_Misaligned => 0
   | Fetch_Fault => 1
   | Illegal_Instr => 2
   | Breakpoint => 3
   | Load_Fault => 4
   | AMO_Misaligned => 5
   | Store_AMO_Fault => 6
   | UMode_Env_Call => 7
   | SMode_Env_Call => 8
   | HMode_Env_Call => 9
   | MMode_Env_Call => 10

fun accessTypeToString x =
  case x of
     Read => "Read" | Write => "Write"

fun fetchTypeToString x =
  case x of
     Instruction => "Instruction" | Data => "Data"

fun ArchitectureToString x =
  case x of
     RV32I => "RV32I" | RV64I => "RV64I" | RV128I => "RV128I"

fun PrivilegeToString x =
  case x of
     User => "User"
   | Supervisor => "Supervisor"
   | Hypervisor => "Hypervisor"
   | Machine => "Machine"

fun VM_ModeToString x =
  case x of
     Mbare => "Mbare"
   | Mbb => "Mbb"
   | Mbbid => "Mbbid"
   | Sv32 => "Sv32"
   | Sv39 => "Sv39"
   | Sv48 => "Sv48"
   | Sv57 => "Sv57"
   | Sv64 => "Sv64"

fun ExtStatusToString x =
  case x of
     Off => "Off"
   | Initial => "Initial"
   | Clean => "Clean"
   | Dirty => "Dirty"

fun InterruptToString x =
  case x of
     Software => "Software" | Timer => "Timer"

fun ExceptionTypeToString x =
  case x of
     Fetch_Misaligned => "Fetch_Misaligned"
   | Fetch_Fault => "Fetch_Fault"
   | Illegal_Instr => "Illegal_Instr"
   | Breakpoint => "Breakpoint"
   | Load_Fault => "Load_Fault"
   | AMO_Misaligned => "AMO_Misaligned"
   | Store_AMO_Fault => "Store_AMO_Fault"
   | UMode_Env_Call => "UMode_Env_Call"
   | SMode_Env_Call => "SMode_Env_Call"
   | HMode_Env_Call => "HMode_Env_Call"
   | MMode_Env_Call => "MMode_Env_Call"

fun stringToaccessType x =
  case x of
     "Read" => Read
   | "Write" => Write
   | _ => raise Fail "stringToaccessType"

fun stringTofetchType x =
  case x of
     "Instruction" => Instruction
   | "Data" => Data
   | _ => raise Fail "stringTofetchType"

fun stringToArchitecture x =
  case x of
     "RV32I" => RV32I
   | "RV64I" => RV64I
   | "RV128I" => RV128I
   | _ => raise Fail "stringToArchitecture"

fun stringToPrivilege x =
  case x of
     "User" => User
   | "Supervisor" => Supervisor
   | "Hypervisor" => Hypervisor
   | "Machine" => Machine
   | _ => raise Fail "stringToPrivilege"

fun stringToVM_Mode x =
  case x of
     "Mbare" => Mbare
   | "Mbb" => Mbb
   | "Mbbid" => Mbbid
   | "Sv32" => Sv32
   | "Sv39" => Sv39
   | "Sv48" => Sv48
   | "Sv57" => Sv57
   | "Sv64" => Sv64
   | _ => raise Fail "stringToVM_Mode"

fun stringToExtStatus x =
  case x of
     "Off" => Off
   | "Initial" => Initial
   | "Clean" => Clean
   | "Dirty" => Dirty
   | _ => raise Fail "stringToExtStatus"

fun stringToInterrupt x =
  case x of
     "Software" => Software
   | "Timer" => Timer
   | _ => raise Fail "stringToInterrupt"

fun stringToExceptionType x =
  case x of
     "Fetch_Misaligned" => Fetch_Misaligned
   | "Fetch_Fault" => Fetch_Fault
   | "Illegal_Instr" => Illegal_Instr
   | "Breakpoint" => Breakpoint
   | "Load_Fault" => Load_Fault
   | "AMO_Misaligned" => AMO_Misaligned
   | "Store_AMO_Fault" => Store_AMO_Fault
   | "UMode_Env_Call" => UMode_Env_Call
   | "SMode_Env_Call" => SMode_Env_Call
   | "HMode_Env_Call" => HMode_Env_Call
   | "MMode_Env_Call" => MMode_Env_Call
   | _ => raise Fail "stringToExceptionType"
end

(* -------------------------------------------------------------------------
   Record update functions
   ------------------------------------------------------------------------- *)

fun mcpuid_ArchBase_rupd ({ArchBase, I, M, S, U, mcpuid'rst}
  : mcpuid, x') =
  {ArchBase = x', I = I, M = M, S = S, U = U, mcpuid'rst = mcpuid'rst}
  : mcpuid

fun mcpuid_I_rupd ({ArchBase, I, M, S, U, mcpuid'rst}: mcpuid, x') =
  {ArchBase = ArchBase, I = x', M = M, S = S, U = U,
   mcpuid'rst = mcpuid'rst}: mcpuid

fun mcpuid_M_rupd ({ArchBase, I, M, S, U, mcpuid'rst}: mcpuid, x') =
  {ArchBase = ArchBase, I = I, M = x', S = S, U = U,
   mcpuid'rst = mcpuid'rst}: mcpuid

fun mcpuid_S_rupd ({ArchBase, I, M, S, U, mcpuid'rst}: mcpuid, x') =
  {ArchBase = ArchBase, I = I, M = M, S = x', U = U,
   mcpuid'rst = mcpuid'rst}: mcpuid

fun mcpuid_U_rupd ({ArchBase, I, M, S, U, mcpuid'rst}: mcpuid, x') =
  {ArchBase = ArchBase, I = I, M = M, S = S, U = x',
   mcpuid'rst = mcpuid'rst}: mcpuid

fun mcpuid_mcpuid'rst_rupd ({ArchBase, I, M, S, U, mcpuid'rst}
  : mcpuid, x') =
  {ArchBase = ArchBase, I = I, M = M, S = S, U = U, mcpuid'rst = x'}
  : mcpuid

fun mimpid_RVImpl_rupd ({RVImpl, RVSource}: mimpid, x') =
  {RVImpl = x', RVSource = RVSource}: mimpid

fun mimpid_RVSource_rupd ({RVImpl, RVSource}: mimpid, x') =
  {RVImpl = RVImpl, RVSource = x'}: mimpid

fun mstatus_MFS_rupd ({MFS, MIE, MIE1, MIE2, MIE3, MMPRV, MPRV, MPRV1,
   MPRV2, MPRV3, MSD, MXS, VM, mstatus'rst}: mstatus, x') =
  {MFS = x', MIE = MIE, MIE1 = MIE1, MIE2 = MIE2, MIE3 = MIE3,
   MMPRV = MMPRV, MPRV = MPRV, MPRV1 = MPRV1, MPRV2 = MPRV2,
   MPRV3 = MPRV3, MSD = MSD, MXS = MXS, VM = VM, mstatus'rst = mstatus'rst}
  : mstatus

fun mstatus_MIE_rupd ({MFS, MIE, MIE1, MIE2, MIE3, MMPRV, MPRV, MPRV1,
   MPRV2, MPRV3, MSD, MXS, VM, mstatus'rst}: mstatus, x') =
  {MFS = MFS, MIE = x', MIE1 = MIE1, MIE2 = MIE2, MIE3 = MIE3,
   MMPRV = MMPRV, MPRV = MPRV, MPRV1 = MPRV1, MPRV2 = MPRV2,
   MPRV3 = MPRV3, MSD = MSD, MXS = MXS, VM = VM, mstatus'rst = mstatus'rst}
  : mstatus

fun mstatus_MIE1_rupd ({MFS, MIE, MIE1, MIE2, MIE3, MMPRV, MPRV, MPRV1,
   MPRV2, MPRV3, MSD, MXS, VM, mstatus'rst}: mstatus, x') =
  {MFS = MFS, MIE = MIE, MIE1 = x', MIE2 = MIE2, MIE3 = MIE3,
   MMPRV = MMPRV, MPRV = MPRV, MPRV1 = MPRV1, MPRV2 = MPRV2,
   MPRV3 = MPRV3, MSD = MSD, MXS = MXS, VM = VM, mstatus'rst = mstatus'rst}
  : mstatus

fun mstatus_MIE2_rupd ({MFS, MIE, MIE1, MIE2, MIE3, MMPRV, MPRV, MPRV1,
   MPRV2, MPRV3, MSD, MXS, VM, mstatus'rst}: mstatus, x') =
  {MFS = MFS, MIE = MIE, MIE1 = MIE1, MIE2 = x', MIE3 = MIE3,
   MMPRV = MMPRV, MPRV = MPRV, MPRV1 = MPRV1, MPRV2 = MPRV2,
   MPRV3 = MPRV3, MSD = MSD, MXS = MXS, VM = VM, mstatus'rst = mstatus'rst}
  : mstatus

fun mstatus_MIE3_rupd ({MFS, MIE, MIE1, MIE2, MIE3, MMPRV, MPRV, MPRV1,
   MPRV2, MPRV3, MSD, MXS, VM, mstatus'rst}: mstatus, x') =
  {MFS = MFS, MIE = MIE, MIE1 = MIE1, MIE2 = MIE2, MIE3 = x',
   MMPRV = MMPRV, MPRV = MPRV, MPRV1 = MPRV1, MPRV2 = MPRV2,
   MPRV3 = MPRV3, MSD = MSD, MXS = MXS, VM = VM, mstatus'rst = mstatus'rst}
  : mstatus

fun mstatus_MMPRV_rupd ({MFS, MIE, MIE1, MIE2, MIE3, MMPRV, MPRV, MPRV1,
   MPRV2, MPRV3, MSD, MXS, VM, mstatus'rst}: mstatus, x') =
  {MFS = MFS, MIE = MIE, MIE1 = MIE1, MIE2 = MIE2, MIE3 = MIE3,
   MMPRV = x', MPRV = MPRV, MPRV1 = MPRV1, MPRV2 = MPRV2, MPRV3 = MPRV3,
   MSD = MSD, MXS = MXS, VM = VM, mstatus'rst = mstatus'rst}: mstatus

fun mstatus_MPRV_rupd ({MFS, MIE, MIE1, MIE2, MIE3, MMPRV, MPRV, MPRV1,
   MPRV2, MPRV3, MSD, MXS, VM, mstatus'rst}: mstatus, x') =
  {MFS = MFS, MIE = MIE, MIE1 = MIE1, MIE2 = MIE2, MIE3 = MIE3,
   MMPRV = MMPRV, MPRV = x', MPRV1 = MPRV1, MPRV2 = MPRV2, MPRV3 = MPRV3,
   MSD = MSD, MXS = MXS, VM = VM, mstatus'rst = mstatus'rst}: mstatus

fun mstatus_MPRV1_rupd ({MFS, MIE, MIE1, MIE2, MIE3, MMPRV, MPRV, MPRV1,
   MPRV2, MPRV3, MSD, MXS, VM, mstatus'rst}: mstatus, x') =
  {MFS = MFS, MIE = MIE, MIE1 = MIE1, MIE2 = MIE2, MIE3 = MIE3,
   MMPRV = MMPRV, MPRV = MPRV, MPRV1 = x', MPRV2 = MPRV2, MPRV3 = MPRV3,
   MSD = MSD, MXS = MXS, VM = VM, mstatus'rst = mstatus'rst}: mstatus

fun mstatus_MPRV2_rupd ({MFS, MIE, MIE1, MIE2, MIE3, MMPRV, MPRV, MPRV1,
   MPRV2, MPRV3, MSD, MXS, VM, mstatus'rst}: mstatus, x') =
  {MFS = MFS, MIE = MIE, MIE1 = MIE1, MIE2 = MIE2, MIE3 = MIE3,
   MMPRV = MMPRV, MPRV = MPRV, MPRV1 = MPRV1, MPRV2 = x', MPRV3 = MPRV3,
   MSD = MSD, MXS = MXS, VM = VM, mstatus'rst = mstatus'rst}: mstatus

fun mstatus_MPRV3_rupd ({MFS, MIE, MIE1, MIE2, MIE3, MMPRV, MPRV, MPRV1,
   MPRV2, MPRV3, MSD, MXS, VM, mstatus'rst}: mstatus, x') =
  {MFS = MFS, MIE = MIE, MIE1 = MIE1, MIE2 = MIE2, MIE3 = MIE3,
   MMPRV = MMPRV, MPRV = MPRV, MPRV1 = MPRV1, MPRV2 = MPRV2, MPRV3 = x',
   MSD = MSD, MXS = MXS, VM = VM, mstatus'rst = mstatus'rst}: mstatus

fun mstatus_MSD_rupd ({MFS, MIE, MIE1, MIE2, MIE3, MMPRV, MPRV, MPRV1,
   MPRV2, MPRV3, MSD, MXS, VM, mstatus'rst}: mstatus, x') =
  {MFS = MFS, MIE = MIE, MIE1 = MIE1, MIE2 = MIE2, MIE3 = MIE3,
   MMPRV = MMPRV, MPRV = MPRV, MPRV1 = MPRV1, MPRV2 = MPRV2,
   MPRV3 = MPRV3, MSD = x', MXS = MXS, VM = VM, mstatus'rst = mstatus'rst}
  : mstatus

fun mstatus_MXS_rupd ({MFS, MIE, MIE1, MIE2, MIE3, MMPRV, MPRV, MPRV1,
   MPRV2, MPRV3, MSD, MXS, VM, mstatus'rst}: mstatus, x') =
  {MFS = MFS, MIE = MIE, MIE1 = MIE1, MIE2 = MIE2, MIE3 = MIE3,
   MMPRV = MMPRV, MPRV = MPRV, MPRV1 = MPRV1, MPRV2 = MPRV2,
   MPRV3 = MPRV3, MSD = MSD, MXS = x', VM = VM, mstatus'rst = mstatus'rst}
  : mstatus

fun mstatus_VM_rupd ({MFS, MIE, MIE1, MIE2, MIE3, MMPRV, MPRV, MPRV1,
   MPRV2, MPRV3, MSD, MXS, VM, mstatus'rst}: mstatus, x') =
  {MFS = MFS, MIE = MIE, MIE1 = MIE1, MIE2 = MIE2, MIE3 = MIE3,
   MMPRV = MMPRV, MPRV = MPRV, MPRV1 = MPRV1, MPRV2 = MPRV2,
   MPRV3 = MPRV3, MSD = MSD, MXS = MXS, VM = x', mstatus'rst = mstatus'rst}
  : mstatus

fun mstatus_mstatus'rst_rupd ({MFS, MIE, MIE1, MIE2, MIE3, MMPRV, MPRV,
   MPRV1, MPRV2, MPRV3, MSD, MXS, VM, mstatus'rst}: mstatus, x') =
  {MFS = MFS, MIE = MIE, MIE1 = MIE1, MIE2 = MIE2, MIE3 = MIE3,
   MMPRV = MMPRV, MPRV = MPRV, MPRV1 = MPRV1, MPRV2 = MPRV2,
   MPRV3 = MPRV3, MSD = MSD, MXS = MXS, VM = VM, mstatus'rst = x'}
  : mstatus

fun mtdeleg_Exc_deleg_rupd ({Exc_deleg, Intr_deleg}: mtdeleg, x') =
  {Exc_deleg = x', Intr_deleg = Intr_deleg}: mtdeleg

fun mtdeleg_Intr_deleg_rupd ({Exc_deleg, Intr_deleg}: mtdeleg, x') =
  {Exc_deleg = Exc_deleg, Intr_deleg = x'}: mtdeleg

fun mip_HSIP_rupd ({HSIP, HTIP, MSIP, MTIP, SSIP, STIP, mip'rst}
  : mip, x') =
  {HSIP = x', HTIP = HTIP, MSIP = MSIP, MTIP = MTIP, SSIP = SSIP,
   STIP = STIP, mip'rst = mip'rst}: mip

fun mip_HTIP_rupd ({HSIP, HTIP, MSIP, MTIP, SSIP, STIP, mip'rst}
  : mip, x') =
  {HSIP = HSIP, HTIP = x', MSIP = MSIP, MTIP = MTIP, SSIP = SSIP,
   STIP = STIP, mip'rst = mip'rst}: mip

fun mip_MSIP_rupd ({HSIP, HTIP, MSIP, MTIP, SSIP, STIP, mip'rst}
  : mip, x') =
  {HSIP = HSIP, HTIP = HTIP, MSIP = x', MTIP = MTIP, SSIP = SSIP,
   STIP = STIP, mip'rst = mip'rst}: mip

fun mip_MTIP_rupd ({HSIP, HTIP, MSIP, MTIP, SSIP, STIP, mip'rst}
  : mip, x') =
  {HSIP = HSIP, HTIP = HTIP, MSIP = MSIP, MTIP = x', SSIP = SSIP,
   STIP = STIP, mip'rst = mip'rst}: mip

fun mip_SSIP_rupd ({HSIP, HTIP, MSIP, MTIP, SSIP, STIP, mip'rst}
  : mip, x') =
  {HSIP = HSIP, HTIP = HTIP, MSIP = MSIP, MTIP = MTIP, SSIP = x',
   STIP = STIP, mip'rst = mip'rst}: mip

fun mip_STIP_rupd ({HSIP, HTIP, MSIP, MTIP, SSIP, STIP, mip'rst}
  : mip, x') =
  {HSIP = HSIP, HTIP = HTIP, MSIP = MSIP, MTIP = MTIP, SSIP = SSIP,
   STIP = x', mip'rst = mip'rst}: mip

fun mip_mip'rst_rupd ({HSIP, HTIP, MSIP, MTIP, SSIP, STIP, mip'rst}
  : mip, x') =
  {HSIP = HSIP, HTIP = HTIP, MSIP = MSIP, MTIP = MTIP, SSIP = SSIP,
   STIP = STIP, mip'rst = x'}: mip

fun mie_HSIE_rupd ({HSIE, HTIE, MSIE, MTIE, SSIE, STIE, mie'rst}
  : mie, x') =
  {HSIE = x', HTIE = HTIE, MSIE = MSIE, MTIE = MTIE, SSIE = SSIE,
   STIE = STIE, mie'rst = mie'rst}: mie

fun mie_HTIE_rupd ({HSIE, HTIE, MSIE, MTIE, SSIE, STIE, mie'rst}
  : mie, x') =
  {HSIE = HSIE, HTIE = x', MSIE = MSIE, MTIE = MTIE, SSIE = SSIE,
   STIE = STIE, mie'rst = mie'rst}: mie

fun mie_MSIE_rupd ({HSIE, HTIE, MSIE, MTIE, SSIE, STIE, mie'rst}
  : mie, x') =
  {HSIE = HSIE, HTIE = HTIE, MSIE = x', MTIE = MTIE, SSIE = SSIE,
   STIE = STIE, mie'rst = mie'rst}: mie

fun mie_MTIE_rupd ({HSIE, HTIE, MSIE, MTIE, SSIE, STIE, mie'rst}
  : mie, x') =
  {HSIE = HSIE, HTIE = HTIE, MSIE = MSIE, MTIE = x', SSIE = SSIE,
   STIE = STIE, mie'rst = mie'rst}: mie

fun mie_SSIE_rupd ({HSIE, HTIE, MSIE, MTIE, SSIE, STIE, mie'rst}
  : mie, x') =
  {HSIE = HSIE, HTIE = HTIE, MSIE = MSIE, MTIE = MTIE, SSIE = x',
   STIE = STIE, mie'rst = mie'rst}: mie

fun mie_STIE_rupd ({HSIE, HTIE, MSIE, MTIE, SSIE, STIE, mie'rst}
  : mie, x') =
  {HSIE = HSIE, HTIE = HTIE, MSIE = MSIE, MTIE = MTIE, SSIE = SSIE,
   STIE = x', mie'rst = mie'rst}: mie

fun mie_mie'rst_rupd ({HSIE, HTIE, MSIE, MTIE, SSIE, STIE, mie'rst}
  : mie, x') =
  {HSIE = HSIE, HTIE = HTIE, MSIE = MSIE, MTIE = MTIE, SSIE = SSIE,
   STIE = STIE, mie'rst = x'}: mie

fun mcause_EC_rupd ({EC, Int, mcause'rst}: mcause, x') =
  {EC = x', Int = Int, mcause'rst = mcause'rst}: mcause

fun mcause_Int_rupd ({EC, Int, mcause'rst}: mcause, x') =
  {EC = EC, Int = x', mcause'rst = mcause'rst}: mcause

fun mcause_mcause'rst_rupd ({EC, Int, mcause'rst}: mcause, x') =
  {EC = EC, Int = Int, mcause'rst = x'}: mcause

fun MachineCSR_mbadaddr_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid,
   mdbase, mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie,
   mimpid, mip, mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp,
   mtohost, mtvec}: MachineCSR, x') =
  {mbadaddr = x', mbase = mbase, mbound = mbound, mcause = mcause,
   mcpuid = mcpuid, mdbase = mdbase, mdbound = mdbound, mepc = mepc,
   mfromhost = mfromhost, mhartid = mhartid, mibase = mibase,
   mibound = mibound, mie = mie, mimpid = mimpid, mip = mip,
   mscratch = mscratch, mstatus = mstatus, mtdeleg = mtdeleg,
   mtime_delta = mtime_delta, mtimecmp = mtimecmp, mtohost = mtohost,
   mtvec = mtvec}: MachineCSR

fun MachineCSR_mbase_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid,
   mdbase, mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie,
   mimpid, mip, mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp,
   mtohost, mtvec}: MachineCSR, x') =
  {mbadaddr = mbadaddr, mbase = x', mbound = mbound, mcause = mcause,
   mcpuid = mcpuid, mdbase = mdbase, mdbound = mdbound, mepc = mepc,
   mfromhost = mfromhost, mhartid = mhartid, mibase = mibase,
   mibound = mibound, mie = mie, mimpid = mimpid, mip = mip,
   mscratch = mscratch, mstatus = mstatus, mtdeleg = mtdeleg,
   mtime_delta = mtime_delta, mtimecmp = mtimecmp, mtohost = mtohost,
   mtvec = mtvec}: MachineCSR

fun MachineCSR_mbound_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid,
   mdbase, mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie,
   mimpid, mip, mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp,
   mtohost, mtvec}: MachineCSR, x') =
  {mbadaddr = mbadaddr, mbase = mbase, mbound = x', mcause = mcause,
   mcpuid = mcpuid, mdbase = mdbase, mdbound = mdbound, mepc = mepc,
   mfromhost = mfromhost, mhartid = mhartid, mibase = mibase,
   mibound = mibound, mie = mie, mimpid = mimpid, mip = mip,
   mscratch = mscratch, mstatus = mstatus, mtdeleg = mtdeleg,
   mtime_delta = mtime_delta, mtimecmp = mtimecmp, mtohost = mtohost,
   mtvec = mtvec}: MachineCSR

fun MachineCSR_mcause_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid,
   mdbase, mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie,
   mimpid, mip, mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp,
   mtohost, mtvec}: MachineCSR, x') =
  {mbadaddr = mbadaddr, mbase = mbase, mbound = mbound, mcause = x',
   mcpuid = mcpuid, mdbase = mdbase, mdbound = mdbound, mepc = mepc,
   mfromhost = mfromhost, mhartid = mhartid, mibase = mibase,
   mibound = mibound, mie = mie, mimpid = mimpid, mip = mip,
   mscratch = mscratch, mstatus = mstatus, mtdeleg = mtdeleg,
   mtime_delta = mtime_delta, mtimecmp = mtimecmp, mtohost = mtohost,
   mtvec = mtvec}: MachineCSR

fun MachineCSR_mcpuid_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid,
   mdbase, mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie,
   mimpid, mip, mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp,
   mtohost, mtvec}: MachineCSR, x') =
  {mbadaddr = mbadaddr, mbase = mbase, mbound = mbound, mcause = mcause,
   mcpuid = x', mdbase = mdbase, mdbound = mdbound, mepc = mepc,
   mfromhost = mfromhost, mhartid = mhartid, mibase = mibase,
   mibound = mibound, mie = mie, mimpid = mimpid, mip = mip,
   mscratch = mscratch, mstatus = mstatus, mtdeleg = mtdeleg,
   mtime_delta = mtime_delta, mtimecmp = mtimecmp, mtohost = mtohost,
   mtvec = mtvec}: MachineCSR

fun MachineCSR_mdbase_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid,
   mdbase, mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie,
   mimpid, mip, mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp,
   mtohost, mtvec}: MachineCSR, x') =
  {mbadaddr = mbadaddr, mbase = mbase, mbound = mbound, mcause = mcause,
   mcpuid = mcpuid, mdbase = x', mdbound = mdbound, mepc = mepc,
   mfromhost = mfromhost, mhartid = mhartid, mibase = mibase,
   mibound = mibound, mie = mie, mimpid = mimpid, mip = mip,
   mscratch = mscratch, mstatus = mstatus, mtdeleg = mtdeleg,
   mtime_delta = mtime_delta, mtimecmp = mtimecmp, mtohost = mtohost,
   mtvec = mtvec}: MachineCSR

fun MachineCSR_mdbound_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid,
   mdbase, mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie,
   mimpid, mip, mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp,
   mtohost, mtvec}: MachineCSR, x') =
  {mbadaddr = mbadaddr, mbase = mbase, mbound = mbound, mcause = mcause,
   mcpuid = mcpuid, mdbase = mdbase, mdbound = x', mepc = mepc,
   mfromhost = mfromhost, mhartid = mhartid, mibase = mibase,
   mibound = mibound, mie = mie, mimpid = mimpid, mip = mip,
   mscratch = mscratch, mstatus = mstatus, mtdeleg = mtdeleg,
   mtime_delta = mtime_delta, mtimecmp = mtimecmp, mtohost = mtohost,
   mtvec = mtvec}: MachineCSR

fun MachineCSR_mepc_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid,
   mdbase, mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie,
   mimpid, mip, mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp,
   mtohost, mtvec}: MachineCSR, x') =
  {mbadaddr = mbadaddr, mbase = mbase, mbound = mbound, mcause = mcause,
   mcpuid = mcpuid, mdbase = mdbase, mdbound = mdbound, mepc = x',
   mfromhost = mfromhost, mhartid = mhartid, mibase = mibase,
   mibound = mibound, mie = mie, mimpid = mimpid, mip = mip,
   mscratch = mscratch, mstatus = mstatus, mtdeleg = mtdeleg,
   mtime_delta = mtime_delta, mtimecmp = mtimecmp, mtohost = mtohost,
   mtvec = mtvec}: MachineCSR

fun MachineCSR_mfromhost_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid,
   mdbase, mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie,
   mimpid, mip, mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp,
   mtohost, mtvec}: MachineCSR, x') =
  {mbadaddr = mbadaddr, mbase = mbase, mbound = mbound, mcause = mcause,
   mcpuid = mcpuid, mdbase = mdbase, mdbound = mdbound, mepc = mepc,
   mfromhost = x', mhartid = mhartid, mibase = mibase, mibound = mibound,
   mie = mie, mimpid = mimpid, mip = mip, mscratch = mscratch,
   mstatus = mstatus, mtdeleg = mtdeleg, mtime_delta = mtime_delta,
   mtimecmp = mtimecmp, mtohost = mtohost, mtvec = mtvec}: MachineCSR

fun MachineCSR_mhartid_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid,
   mdbase, mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie,
   mimpid, mip, mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp,
   mtohost, mtvec}: MachineCSR, x') =
  {mbadaddr = mbadaddr, mbase = mbase, mbound = mbound, mcause = mcause,
   mcpuid = mcpuid, mdbase = mdbase, mdbound = mdbound, mepc = mepc,
   mfromhost = mfromhost, mhartid = x', mibase = mibase,
   mibound = mibound, mie = mie, mimpid = mimpid, mip = mip,
   mscratch = mscratch, mstatus = mstatus, mtdeleg = mtdeleg,
   mtime_delta = mtime_delta, mtimecmp = mtimecmp, mtohost = mtohost,
   mtvec = mtvec}: MachineCSR

fun MachineCSR_mibase_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid,
   mdbase, mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie,
   mimpid, mip, mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp,
   mtohost, mtvec}: MachineCSR, x') =
  {mbadaddr = mbadaddr, mbase = mbase, mbound = mbound, mcause = mcause,
   mcpuid = mcpuid, mdbase = mdbase, mdbound = mdbound, mepc = mepc,
   mfromhost = mfromhost, mhartid = mhartid, mibase = x',
   mibound = mibound, mie = mie, mimpid = mimpid, mip = mip,
   mscratch = mscratch, mstatus = mstatus, mtdeleg = mtdeleg,
   mtime_delta = mtime_delta, mtimecmp = mtimecmp, mtohost = mtohost,
   mtvec = mtvec}: MachineCSR

fun MachineCSR_mibound_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid,
   mdbase, mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie,
   mimpid, mip, mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp,
   mtohost, mtvec}: MachineCSR, x') =
  {mbadaddr = mbadaddr, mbase = mbase, mbound = mbound, mcause = mcause,
   mcpuid = mcpuid, mdbase = mdbase, mdbound = mdbound, mepc = mepc,
   mfromhost = mfromhost, mhartid = mhartid, mibase = mibase,
   mibound = x', mie = mie, mimpid = mimpid, mip = mip,
   mscratch = mscratch, mstatus = mstatus, mtdeleg = mtdeleg,
   mtime_delta = mtime_delta, mtimecmp = mtimecmp, mtohost = mtohost,
   mtvec = mtvec}: MachineCSR

fun MachineCSR_mie_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid, mdbase,
   mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie, mimpid, mip,
   mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp, mtohost, mtvec}
  : MachineCSR, x') =
  {mbadaddr = mbadaddr, mbase = mbase, mbound = mbound, mcause = mcause,
   mcpuid = mcpuid, mdbase = mdbase, mdbound = mdbound, mepc = mepc,
   mfromhost = mfromhost, mhartid = mhartid, mibase = mibase,
   mibound = mibound, mie = x', mimpid = mimpid, mip = mip,
   mscratch = mscratch, mstatus = mstatus, mtdeleg = mtdeleg,
   mtime_delta = mtime_delta, mtimecmp = mtimecmp, mtohost = mtohost,
   mtvec = mtvec}: MachineCSR

fun MachineCSR_mimpid_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid,
   mdbase, mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie,
   mimpid, mip, mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp,
   mtohost, mtvec}: MachineCSR, x') =
  {mbadaddr = mbadaddr, mbase = mbase, mbound = mbound, mcause = mcause,
   mcpuid = mcpuid, mdbase = mdbase, mdbound = mdbound, mepc = mepc,
   mfromhost = mfromhost, mhartid = mhartid, mibase = mibase,
   mibound = mibound, mie = mie, mimpid = x', mip = mip,
   mscratch = mscratch, mstatus = mstatus, mtdeleg = mtdeleg,
   mtime_delta = mtime_delta, mtimecmp = mtimecmp, mtohost = mtohost,
   mtvec = mtvec}: MachineCSR

fun MachineCSR_mip_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid, mdbase,
   mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie, mimpid, mip,
   mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp, mtohost, mtvec}
  : MachineCSR, x') =
  {mbadaddr = mbadaddr, mbase = mbase, mbound = mbound, mcause = mcause,
   mcpuid = mcpuid, mdbase = mdbase, mdbound = mdbound, mepc = mepc,
   mfromhost = mfromhost, mhartid = mhartid, mibase = mibase,
   mibound = mibound, mie = mie, mimpid = mimpid, mip = x',
   mscratch = mscratch, mstatus = mstatus, mtdeleg = mtdeleg,
   mtime_delta = mtime_delta, mtimecmp = mtimecmp, mtohost = mtohost,
   mtvec = mtvec}: MachineCSR

fun MachineCSR_mscratch_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid,
   mdbase, mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie,
   mimpid, mip, mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp,
   mtohost, mtvec}: MachineCSR, x') =
  {mbadaddr = mbadaddr, mbase = mbase, mbound = mbound, mcause = mcause,
   mcpuid = mcpuid, mdbase = mdbase, mdbound = mdbound, mepc = mepc,
   mfromhost = mfromhost, mhartid = mhartid, mibase = mibase,
   mibound = mibound, mie = mie, mimpid = mimpid, mip = mip,
   mscratch = x', mstatus = mstatus, mtdeleg = mtdeleg,
   mtime_delta = mtime_delta, mtimecmp = mtimecmp, mtohost = mtohost,
   mtvec = mtvec}: MachineCSR

fun MachineCSR_mstatus_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid,
   mdbase, mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie,
   mimpid, mip, mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp,
   mtohost, mtvec}: MachineCSR, x') =
  {mbadaddr = mbadaddr, mbase = mbase, mbound = mbound, mcause = mcause,
   mcpuid = mcpuid, mdbase = mdbase, mdbound = mdbound, mepc = mepc,
   mfromhost = mfromhost, mhartid = mhartid, mibase = mibase,
   mibound = mibound, mie = mie, mimpid = mimpid, mip = mip,
   mscratch = mscratch, mstatus = x', mtdeleg = mtdeleg,
   mtime_delta = mtime_delta, mtimecmp = mtimecmp, mtohost = mtohost,
   mtvec = mtvec}: MachineCSR

fun MachineCSR_mtdeleg_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid,
   mdbase, mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie,
   mimpid, mip, mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp,
   mtohost, mtvec}: MachineCSR, x') =
  {mbadaddr = mbadaddr, mbase = mbase, mbound = mbound, mcause = mcause,
   mcpuid = mcpuid, mdbase = mdbase, mdbound = mdbound, mepc = mepc,
   mfromhost = mfromhost, mhartid = mhartid, mibase = mibase,
   mibound = mibound, mie = mie, mimpid = mimpid, mip = mip,
   mscratch = mscratch, mstatus = mstatus, mtdeleg = x',
   mtime_delta = mtime_delta, mtimecmp = mtimecmp, mtohost = mtohost,
   mtvec = mtvec}: MachineCSR

fun MachineCSR_mtime_delta_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid,
   mdbase, mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie,
   mimpid, mip, mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp,
   mtohost, mtvec}: MachineCSR, x') =
  {mbadaddr = mbadaddr, mbase = mbase, mbound = mbound, mcause = mcause,
   mcpuid = mcpuid, mdbase = mdbase, mdbound = mdbound, mepc = mepc,
   mfromhost = mfromhost, mhartid = mhartid, mibase = mibase,
   mibound = mibound, mie = mie, mimpid = mimpid, mip = mip,
   mscratch = mscratch, mstatus = mstatus, mtdeleg = mtdeleg,
   mtime_delta = x', mtimecmp = mtimecmp, mtohost = mtohost, mtvec = mtvec}
  : MachineCSR

fun MachineCSR_mtimecmp_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid,
   mdbase, mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie,
   mimpid, mip, mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp,
   mtohost, mtvec}: MachineCSR, x') =
  {mbadaddr = mbadaddr, mbase = mbase, mbound = mbound, mcause = mcause,
   mcpuid = mcpuid, mdbase = mdbase, mdbound = mdbound, mepc = mepc,
   mfromhost = mfromhost, mhartid = mhartid, mibase = mibase,
   mibound = mibound, mie = mie, mimpid = mimpid, mip = mip,
   mscratch = mscratch, mstatus = mstatus, mtdeleg = mtdeleg,
   mtime_delta = mtime_delta, mtimecmp = x', mtohost = mtohost,
   mtvec = mtvec}: MachineCSR

fun MachineCSR_mtohost_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid,
   mdbase, mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie,
   mimpid, mip, mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp,
   mtohost, mtvec}: MachineCSR, x') =
  {mbadaddr = mbadaddr, mbase = mbase, mbound = mbound, mcause = mcause,
   mcpuid = mcpuid, mdbase = mdbase, mdbound = mdbound, mepc = mepc,
   mfromhost = mfromhost, mhartid = mhartid, mibase = mibase,
   mibound = mibound, mie = mie, mimpid = mimpid, mip = mip,
   mscratch = mscratch, mstatus = mstatus, mtdeleg = mtdeleg,
   mtime_delta = mtime_delta, mtimecmp = mtimecmp, mtohost = x',
   mtvec = mtvec}: MachineCSR

fun MachineCSR_mtvec_rupd ({mbadaddr, mbase, mbound, mcause, mcpuid,
   mdbase, mdbound, mepc, mfromhost, mhartid, mibase, mibound, mie,
   mimpid, mip, mscratch, mstatus, mtdeleg, mtime_delta, mtimecmp,
   mtohost, mtvec}: MachineCSR, x') =
  {mbadaddr = mbadaddr, mbase = mbase, mbound = mbound, mcause = mcause,
   mcpuid = mcpuid, mdbase = mdbase, mdbound = mdbound, mepc = mepc,
   mfromhost = mfromhost, mhartid = mhartid, mibase = mibase,
   mibound = mibound, mie = mie, mimpid = mimpid, mip = mip,
   mscratch = mscratch, mstatus = mstatus, mtdeleg = mtdeleg,
   mtime_delta = mtime_delta, mtimecmp = mtimecmp, mtohost = mtohost,
   mtvec = x'}: MachineCSR

fun HypervisorCSR_hbadaddr_rupd ({hbadaddr, hcause, hepc, hscratch,
   hstatus, htdeleg, htime_delta, htimecmp, htvec}: HypervisorCSR, x') =
  {hbadaddr = x', hcause = hcause, hepc = hepc, hscratch = hscratch,
   hstatus = hstatus, htdeleg = htdeleg, htime_delta = htime_delta,
   htimecmp = htimecmp, htvec = htvec}: HypervisorCSR

fun HypervisorCSR_hcause_rupd ({hbadaddr, hcause, hepc, hscratch, hstatus,
   htdeleg, htime_delta, htimecmp, htvec}: HypervisorCSR, x') =
  {hbadaddr = hbadaddr, hcause = x', hepc = hepc, hscratch = hscratch,
   hstatus = hstatus, htdeleg = htdeleg, htime_delta = htime_delta,
   htimecmp = htimecmp, htvec = htvec}: HypervisorCSR

fun HypervisorCSR_hepc_rupd ({hbadaddr, hcause, hepc, hscratch, hstatus,
   htdeleg, htime_delta, htimecmp, htvec}: HypervisorCSR, x') =
  {hbadaddr = hbadaddr, hcause = hcause, hepc = x', hscratch = hscratch,
   hstatus = hstatus, htdeleg = htdeleg, htime_delta = htime_delta,
   htimecmp = htimecmp, htvec = htvec}: HypervisorCSR

fun HypervisorCSR_hscratch_rupd ({hbadaddr, hcause, hepc, hscratch,
   hstatus, htdeleg, htime_delta, htimecmp, htvec}: HypervisorCSR, x') =
  {hbadaddr = hbadaddr, hcause = hcause, hepc = hepc, hscratch = x',
   hstatus = hstatus, htdeleg = htdeleg, htime_delta = htime_delta,
   htimecmp = htimecmp, htvec = htvec}: HypervisorCSR

fun HypervisorCSR_hstatus_rupd ({hbadaddr, hcause, hepc, hscratch,
   hstatus, htdeleg, htime_delta, htimecmp, htvec}: HypervisorCSR, x') =
  {hbadaddr = hbadaddr, hcause = hcause, hepc = hepc, hscratch = hscratch,
   hstatus = x', htdeleg = htdeleg, htime_delta = htime_delta,
   htimecmp = htimecmp, htvec = htvec}: HypervisorCSR

fun HypervisorCSR_htdeleg_rupd ({hbadaddr, hcause, hepc, hscratch,
   hstatus, htdeleg, htime_delta, htimecmp, htvec}: HypervisorCSR, x') =
  {hbadaddr = hbadaddr, hcause = hcause, hepc = hepc, hscratch = hscratch,
   hstatus = hstatus, htdeleg = x', htime_delta = htime_delta,
   htimecmp = htimecmp, htvec = htvec}: HypervisorCSR

fun HypervisorCSR_htime_delta_rupd ({hbadaddr, hcause, hepc, hscratch,
   hstatus, htdeleg, htime_delta, htimecmp, htvec}: HypervisorCSR, x') =
  {hbadaddr = hbadaddr, hcause = hcause, hepc = hepc, hscratch = hscratch,
   hstatus = hstatus, htdeleg = htdeleg, htime_delta = x',
   htimecmp = htimecmp, htvec = htvec}: HypervisorCSR

fun HypervisorCSR_htimecmp_rupd ({hbadaddr, hcause, hepc, hscratch,
   hstatus, htdeleg, htime_delta, htimecmp, htvec}: HypervisorCSR, x') =
  {hbadaddr = hbadaddr, hcause = hcause, hepc = hepc, hscratch = hscratch,
   hstatus = hstatus, htdeleg = htdeleg, htime_delta = htime_delta,
   htimecmp = x', htvec = htvec}: HypervisorCSR

fun HypervisorCSR_htvec_rupd ({hbadaddr, hcause, hepc, hscratch, hstatus,
   htdeleg, htime_delta, htimecmp, htvec}: HypervisorCSR, x') =
  {hbadaddr = hbadaddr, hcause = hcause, hepc = hepc, hscratch = hscratch,
   hstatus = hstatus, htdeleg = htdeleg, htime_delta = htime_delta,
   htimecmp = htimecmp, htvec = x'}: HypervisorCSR

fun sstatus_SFS_rupd ({SFS, SIE, SMPRV, SPIE, SPS, SSD, SXS, sstatus'rst}
  : sstatus, x') =
  {SFS = x', SIE = SIE, SMPRV = SMPRV, SPIE = SPIE, SPS = SPS, SSD = SSD,
   SXS = SXS, sstatus'rst = sstatus'rst}: sstatus

fun sstatus_SIE_rupd ({SFS, SIE, SMPRV, SPIE, SPS, SSD, SXS, sstatus'rst}
  : sstatus, x') =
  {SFS = SFS, SIE = x', SMPRV = SMPRV, SPIE = SPIE, SPS = SPS, SSD = SSD,
   SXS = SXS, sstatus'rst = sstatus'rst}: sstatus

fun sstatus_SMPRV_rupd ({SFS, SIE, SMPRV, SPIE, SPS, SSD, SXS, sstatus'rst}
  : sstatus, x') =
  {SFS = SFS, SIE = SIE, SMPRV = x', SPIE = SPIE, SPS = SPS, SSD = SSD,
   SXS = SXS, sstatus'rst = sstatus'rst}: sstatus

fun sstatus_SPIE_rupd ({SFS, SIE, SMPRV, SPIE, SPS, SSD, SXS, sstatus'rst}
  : sstatus, x') =
  {SFS = SFS, SIE = SIE, SMPRV = SMPRV, SPIE = x', SPS = SPS, SSD = SSD,
   SXS = SXS, sstatus'rst = sstatus'rst}: sstatus

fun sstatus_SPS_rupd ({SFS, SIE, SMPRV, SPIE, SPS, SSD, SXS, sstatus'rst}
  : sstatus, x') =
  {SFS = SFS, SIE = SIE, SMPRV = SMPRV, SPIE = SPIE, SPS = x', SSD = SSD,
   SXS = SXS, sstatus'rst = sstatus'rst}: sstatus

fun sstatus_SSD_rupd ({SFS, SIE, SMPRV, SPIE, SPS, SSD, SXS, sstatus'rst}
  : sstatus, x') =
  {SFS = SFS, SIE = SIE, SMPRV = SMPRV, SPIE = SPIE, SPS = SPS, SSD = x',
   SXS = SXS, sstatus'rst = sstatus'rst}: sstatus

fun sstatus_SXS_rupd ({SFS, SIE, SMPRV, SPIE, SPS, SSD, SXS, sstatus'rst}
  : sstatus, x') =
  {SFS = SFS, SIE = SIE, SMPRV = SMPRV, SPIE = SPIE, SPS = SPS, SSD = SSD,
   SXS = x', sstatus'rst = sstatus'rst}: sstatus

fun sstatus_sstatus'rst_rupd ({SFS, SIE, SMPRV, SPIE, SPS, SSD, SXS,
   sstatus'rst}: sstatus, x') =
  {SFS = SFS, SIE = SIE, SMPRV = SMPRV, SPIE = SPIE, SPS = SPS, SSD = SSD,
   SXS = SXS, sstatus'rst = x'}: sstatus

fun sip_SSIP_rupd ({SSIP, STIP, sip'rst}: sip, x') =
  {SSIP = x', STIP = STIP, sip'rst = sip'rst}: sip

fun sip_STIP_rupd ({SSIP, STIP, sip'rst}: sip, x') =
  {SSIP = SSIP, STIP = x', sip'rst = sip'rst}: sip

fun sip_sip'rst_rupd ({SSIP, STIP, sip'rst}: sip, x') =
  {SSIP = SSIP, STIP = STIP, sip'rst = x'}: sip

fun sie_SSIE_rupd ({SSIE, STIE, sie'rst}: sie, x') =
  {SSIE = x', STIE = STIE, sie'rst = sie'rst}: sie

fun sie_STIE_rupd ({SSIE, STIE, sie'rst}: sie, x') =
  {SSIE = SSIE, STIE = x', sie'rst = sie'rst}: sie

fun sie_sie'rst_rupd ({SSIE, STIE, sie'rst}: sie, x') =
  {SSIE = SSIE, STIE = STIE, sie'rst = x'}: sie

fun SupervisorCSR_sasid_rupd ({sasid, sbadaddr, scause, sepc, sptbr,
   sscratch, stime_delta, stimecmp, stvec}: SupervisorCSR, x') =
  {sasid = x', sbadaddr = sbadaddr, scause = scause, sepc = sepc,
   sptbr = sptbr, sscratch = sscratch, stime_delta = stime_delta,
   stimecmp = stimecmp, stvec = stvec}: SupervisorCSR

fun SupervisorCSR_sbadaddr_rupd ({sasid, sbadaddr, scause, sepc, sptbr,
   sscratch, stime_delta, stimecmp, stvec}: SupervisorCSR, x') =
  {sasid = sasid, sbadaddr = x', scause = scause, sepc = sepc,
   sptbr = sptbr, sscratch = sscratch, stime_delta = stime_delta,
   stimecmp = stimecmp, stvec = stvec}: SupervisorCSR

fun SupervisorCSR_scause_rupd ({sasid, sbadaddr, scause, sepc, sptbr,
   sscratch, stime_delta, stimecmp, stvec}: SupervisorCSR, x') =
  {sasid = sasid, sbadaddr = sbadaddr, scause = x', sepc = sepc,
   sptbr = sptbr, sscratch = sscratch, stime_delta = stime_delta,
   stimecmp = stimecmp, stvec = stvec}: SupervisorCSR

fun SupervisorCSR_sepc_rupd ({sasid, sbadaddr, scause, sepc, sptbr,
   sscratch, stime_delta, stimecmp, stvec}: SupervisorCSR, x') =
  {sasid = sasid, sbadaddr = sbadaddr, scause = scause, sepc = x',
   sptbr = sptbr, sscratch = sscratch, stime_delta = stime_delta,
   stimecmp = stimecmp, stvec = stvec}: SupervisorCSR

fun SupervisorCSR_sptbr_rupd ({sasid, sbadaddr, scause, sepc, sptbr,
   sscratch, stime_delta, stimecmp, stvec}: SupervisorCSR, x') =
  {sasid = sasid, sbadaddr = sbadaddr, scause = scause, sepc = sepc,
   sptbr = x', sscratch = sscratch, stime_delta = stime_delta,
   stimecmp = stimecmp, stvec = stvec}: SupervisorCSR

fun SupervisorCSR_sscratch_rupd ({sasid, sbadaddr, scause, sepc, sptbr,
   sscratch, stime_delta, stimecmp, stvec}: SupervisorCSR, x') =
  {sasid = sasid, sbadaddr = sbadaddr, scause = scause, sepc = sepc,
   sptbr = sptbr, sscratch = x', stime_delta = stime_delta,
   stimecmp = stimecmp, stvec = stvec}: SupervisorCSR

fun SupervisorCSR_stime_delta_rupd ({sasid, sbadaddr, scause, sepc, sptbr,
   sscratch, stime_delta, stimecmp, stvec}: SupervisorCSR, x') =
  {sasid = sasid, sbadaddr = sbadaddr, scause = scause, sepc = sepc,
   sptbr = sptbr, sscratch = sscratch, stime_delta = x',
   stimecmp = stimecmp, stvec = stvec}: SupervisorCSR

fun SupervisorCSR_stimecmp_rupd ({sasid, sbadaddr, scause, sepc, sptbr,
   sscratch, stime_delta, stimecmp, stvec}: SupervisorCSR, x') =
  {sasid = sasid, sbadaddr = sbadaddr, scause = scause, sepc = sepc,
   sptbr = sptbr, sscratch = sscratch, stime_delta = stime_delta,
   stimecmp = x', stvec = stvec}: SupervisorCSR

fun SupervisorCSR_stvec_rupd ({sasid, sbadaddr, scause, sepc, sptbr,
   sscratch, stime_delta, stimecmp, stvec}: SupervisorCSR, x') =
  {sasid = sasid, sbadaddr = sbadaddr, scause = scause, sepc = sepc,
   sptbr = sptbr, sscratch = sscratch, stime_delta = stime_delta,
   stimecmp = stimecmp, stvec = x'}: SupervisorCSR

fun UserCSR_cycle_delta_rupd ({cycle_delta, instret_delta, time_delta}
  : UserCSR, x') =
  {cycle_delta = x', instret_delta = instret_delta,
   time_delta = time_delta}: UserCSR

fun UserCSR_instret_delta_rupd ({cycle_delta, instret_delta, time_delta}
  : UserCSR, x') =
  {cycle_delta = cycle_delta, instret_delta = x', time_delta = time_delta}
  : UserCSR

fun UserCSR_time_delta_rupd ({cycle_delta, instret_delta, time_delta}
  : UserCSR, x') =
  {cycle_delta = cycle_delta, instret_delta = instret_delta,
   time_delta = x'}: UserCSR

fun SynchronousTrap_badaddr_rupd ({badaddr, trap}: SynchronousTrap, x') =
  {badaddr = x', trap = trap}: SynchronousTrap

fun SynchronousTrap_trap_rupd ({badaddr, trap}: SynchronousTrap, x') =
  {badaddr = badaddr, trap = x'}: SynchronousTrap

fun StateDelta_addr_rupd ({addr, data1, data2, exc_taken, fetch_exc,
   fp_data, pc, rinstr, st_width}: StateDelta, x') =
  {addr = x', data1 = data1, data2 = data2, exc_taken = exc_taken,
   fetch_exc = fetch_exc, fp_data = fp_data, pc = pc, rinstr = rinstr,
   st_width = st_width}: StateDelta

fun StateDelta_data1_rupd ({addr, data1, data2, exc_taken, fetch_exc,
   fp_data, pc, rinstr, st_width}: StateDelta, x') =
  {addr = addr, data1 = x', data2 = data2, exc_taken = exc_taken,
   fetch_exc = fetch_exc, fp_data = fp_data, pc = pc, rinstr = rinstr,
   st_width = st_width}: StateDelta

fun StateDelta_data2_rupd ({addr, data1, data2, exc_taken, fetch_exc,
   fp_data, pc, rinstr, st_width}: StateDelta, x') =
  {addr = addr, data1 = data1, data2 = x', exc_taken = exc_taken,
   fetch_exc = fetch_exc, fp_data = fp_data, pc = pc, rinstr = rinstr,
   st_width = st_width}: StateDelta

fun StateDelta_exc_taken_rupd ({addr, data1, data2, exc_taken, fetch_exc,
   fp_data, pc, rinstr, st_width}: StateDelta, x') =
  {addr = addr, data1 = data1, data2 = data2, exc_taken = x',
   fetch_exc = fetch_exc, fp_data = fp_data, pc = pc, rinstr = rinstr,
   st_width = st_width}: StateDelta

fun StateDelta_fetch_exc_rupd ({addr, data1, data2, exc_taken, fetch_exc,
   fp_data, pc, rinstr, st_width}: StateDelta, x') =
  {addr = addr, data1 = data1, data2 = data2, exc_taken = exc_taken,
   fetch_exc = x', fp_data = fp_data, pc = pc, rinstr = rinstr,
   st_width = st_width}: StateDelta

fun StateDelta_fp_data_rupd ({addr, data1, data2, exc_taken, fetch_exc,
   fp_data, pc, rinstr, st_width}: StateDelta, x') =
  {addr = addr, data1 = data1, data2 = data2, exc_taken = exc_taken,
   fetch_exc = fetch_exc, fp_data = x', pc = pc, rinstr = rinstr,
   st_width = st_width}: StateDelta

fun StateDelta_pc_rupd ({addr, data1, data2, exc_taken, fetch_exc,
   fp_data, pc, rinstr, st_width}: StateDelta, x') =
  {addr = addr, data1 = data1, data2 = data2, exc_taken = exc_taken,
   fetch_exc = fetch_exc, fp_data = fp_data, pc = x', rinstr = rinstr,
   st_width = st_width}: StateDelta

fun StateDelta_rinstr_rupd ({addr, data1, data2, exc_taken, fetch_exc,
   fp_data, pc, rinstr, st_width}: StateDelta, x') =
  {addr = addr, data1 = data1, data2 = data2, exc_taken = exc_taken,
   fetch_exc = fetch_exc, fp_data = fp_data, pc = pc, rinstr = x',
   st_width = st_width}: StateDelta

fun StateDelta_st_width_rupd ({addr, data1, data2, exc_taken, fetch_exc,
   fp_data, pc, rinstr, st_width}: StateDelta, x') =
  {addr = addr, data1 = data1, data2 = data2, exc_taken = exc_taken,
   fetch_exc = fetch_exc, fp_data = fp_data, pc = pc, rinstr = rinstr,
   st_width = x'}: StateDelta

fun SV_PTE_PTE_D_rupd ({PTE_D, PTE_PPNi, PTE_R, PTE_SW, PTE_T, PTE_V,
   sv_pte'rst}: SV_PTE, x') =
  {PTE_D = x', PTE_PPNi = PTE_PPNi, PTE_R = PTE_R, PTE_SW = PTE_SW,
   PTE_T = PTE_T, PTE_V = PTE_V, sv_pte'rst = sv_pte'rst}: SV_PTE

fun SV_PTE_PTE_PPNi_rupd ({PTE_D, PTE_PPNi, PTE_R, PTE_SW, PTE_T, PTE_V,
   sv_pte'rst}: SV_PTE, x') =
  {PTE_D = PTE_D, PTE_PPNi = x', PTE_R = PTE_R, PTE_SW = PTE_SW,
   PTE_T = PTE_T, PTE_V = PTE_V, sv_pte'rst = sv_pte'rst}: SV_PTE

fun SV_PTE_PTE_R_rupd ({PTE_D, PTE_PPNi, PTE_R, PTE_SW, PTE_T, PTE_V,
   sv_pte'rst}: SV_PTE, x') =
  {PTE_D = PTE_D, PTE_PPNi = PTE_PPNi, PTE_R = x', PTE_SW = PTE_SW,
   PTE_T = PTE_T, PTE_V = PTE_V, sv_pte'rst = sv_pte'rst}: SV_PTE

fun SV_PTE_PTE_SW_rupd ({PTE_D, PTE_PPNi, PTE_R, PTE_SW, PTE_T, PTE_V,
   sv_pte'rst}: SV_PTE, x') =
  {PTE_D = PTE_D, PTE_PPNi = PTE_PPNi, PTE_R = PTE_R, PTE_SW = x',
   PTE_T = PTE_T, PTE_V = PTE_V, sv_pte'rst = sv_pte'rst}: SV_PTE

fun SV_PTE_PTE_T_rupd ({PTE_D, PTE_PPNi, PTE_R, PTE_SW, PTE_T, PTE_V,
   sv_pte'rst}: SV_PTE, x') =
  {PTE_D = PTE_D, PTE_PPNi = PTE_PPNi, PTE_R = PTE_R, PTE_SW = PTE_SW,
   PTE_T = x', PTE_V = PTE_V, sv_pte'rst = sv_pte'rst}: SV_PTE

fun SV_PTE_PTE_V_rupd ({PTE_D, PTE_PPNi, PTE_R, PTE_SW, PTE_T, PTE_V,
   sv_pte'rst}: SV_PTE, x') =
  {PTE_D = PTE_D, PTE_PPNi = PTE_PPNi, PTE_R = PTE_R, PTE_SW = PTE_SW,
   PTE_T = PTE_T, PTE_V = x', sv_pte'rst = sv_pte'rst}: SV_PTE

fun SV_PTE_sv_pte'rst_rupd ({PTE_D, PTE_PPNi, PTE_R, PTE_SW, PTE_T, PTE_V,
   sv_pte'rst}: SV_PTE, x') =
  {PTE_D = PTE_D, PTE_PPNi = PTE_PPNi, PTE_R = PTE_R, PTE_SW = PTE_SW,
   PTE_T = PTE_T, PTE_V = PTE_V, sv_pte'rst = x'}: SV_PTE

fun SV_Vaddr_Sv_PgOfs_rupd ({Sv_PgOfs, Sv_VPNi, sv_vaddr'rst}
  : SV_Vaddr, x') =
  {Sv_PgOfs = x', Sv_VPNi = Sv_VPNi, sv_vaddr'rst = sv_vaddr'rst}
  : SV_Vaddr

fun SV_Vaddr_Sv_VPNi_rupd ({Sv_PgOfs, Sv_VPNi, sv_vaddr'rst}
  : SV_Vaddr, x') =
  {Sv_PgOfs = Sv_PgOfs, Sv_VPNi = x', sv_vaddr'rst = sv_vaddr'rst}
  : SV_Vaddr

fun SV_Vaddr_sv_vaddr'rst_rupd ({Sv_PgOfs, Sv_VPNi, sv_vaddr'rst}
  : SV_Vaddr, x') =
  {Sv_PgOfs = Sv_PgOfs, Sv_VPNi = Sv_VPNi, sv_vaddr'rst = x'}: SV_Vaddr

fun TLBEntry_age_rupd ({age, asid, global, pAddr, pte, pteAddr, vAddr,
   vAddrMask, vMatchMask}: TLBEntry, x') =
  {age = x', asid = asid, global = global, pAddr = pAddr, pte = pte,
   pteAddr = pteAddr, vAddr = vAddr, vAddrMask = vAddrMask,
   vMatchMask = vMatchMask}: TLBEntry

fun TLBEntry_asid_rupd ({age, asid, global, pAddr, pte, pteAddr, vAddr,
   vAddrMask, vMatchMask}: TLBEntry, x') =
  {age = age, asid = x', global = global, pAddr = pAddr, pte = pte,
   pteAddr = pteAddr, vAddr = vAddr, vAddrMask = vAddrMask,
   vMatchMask = vMatchMask}: TLBEntry

fun TLBEntry_global_rupd ({age, asid, global, pAddr, pte, pteAddr, vAddr,
   vAddrMask, vMatchMask}: TLBEntry, x') =
  {age = age, asid = asid, global = x', pAddr = pAddr, pte = pte,
   pteAddr = pteAddr, vAddr = vAddr, vAddrMask = vAddrMask,
   vMatchMask = vMatchMask}: TLBEntry

fun TLBEntry_pAddr_rupd ({age, asid, global, pAddr, pte, pteAddr, vAddr,
   vAddrMask, vMatchMask}: TLBEntry, x') =
  {age = age, asid = asid, global = global, pAddr = x', pte = pte,
   pteAddr = pteAddr, vAddr = vAddr, vAddrMask = vAddrMask,
   vMatchMask = vMatchMask}: TLBEntry

fun TLBEntry_pte_rupd ({age, asid, global, pAddr, pte, pteAddr, vAddr,
   vAddrMask, vMatchMask}: TLBEntry, x') =
  {age = age, asid = asid, global = global, pAddr = pAddr, pte = x',
   pteAddr = pteAddr, vAddr = vAddr, vAddrMask = vAddrMask,
   vMatchMask = vMatchMask}: TLBEntry

fun TLBEntry_pteAddr_rupd ({age, asid, global, pAddr, pte, pteAddr, vAddr,
   vAddrMask, vMatchMask}: TLBEntry, x') =
  {age = age, asid = asid, global = global, pAddr = pAddr, pte = pte,
   pteAddr = x', vAddr = vAddr, vAddrMask = vAddrMask,
   vMatchMask = vMatchMask}: TLBEntry

fun TLBEntry_vAddr_rupd ({age, asid, global, pAddr, pte, pteAddr, vAddr,
   vAddrMask, vMatchMask}: TLBEntry, x') =
  {age = age, asid = asid, global = global, pAddr = pAddr, pte = pte,
   pteAddr = pteAddr, vAddr = x', vAddrMask = vAddrMask,
   vMatchMask = vMatchMask}: TLBEntry

fun TLBEntry_vAddrMask_rupd ({age, asid, global, pAddr, pte, pteAddr,
   vAddr, vAddrMask, vMatchMask}: TLBEntry, x') =
  {age = age, asid = asid, global = global, pAddr = pAddr, pte = pte,
   pteAddr = pteAddr, vAddr = vAddr, vAddrMask = x',
   vMatchMask = vMatchMask}: TLBEntry

fun TLBEntry_vMatchMask_rupd ({age, asid, global, pAddr, pte, pteAddr,
   vAddr, vAddrMask, vMatchMask}: TLBEntry, x') =
  {age = age, asid = asid, global = global, pAddr = pAddr, pte = pte,
   pteAddr = pteAddr, vAddr = vAddr, vAddrMask = vAddrMask,
   vMatchMask = x'}: TLBEntry

(* -------------------------------------------------------------------------
   Exceptions
   ------------------------------------------------------------------------- *)

exception INTERNAL_ERROR of string

exception UNDEFINED of string

(* -------------------------------------------------------------------------
   Global variables (state)
   ------------------------------------------------------------------------- *)

val MEM8 = ref (Map.mkMap(SOME 18446744073709551616,BitsN.B(0x0,8)))
  : (BitsN.nbit Map.map) ref

val c_ExitCode = ref (Map.mkMap(SOME 256,BitsN.B(0x0,64)))
  : (BitsN.nbit Map.map) ref

val c_HCSR = ref
  (Map.mkMap
     (SOME 256,
      {hbadaddr = BitsN.B(0x0,64),
       hcause =
         {EC = BitsN.B(0x0,4), Int = false, mcause'rst = BitsN.B(0x0,59)},
       hepc = BitsN.B(0x0,64), hscratch = BitsN.B(0x0,64),
       hstatus =
         {MFS = BitsN.B(0x0,2), MIE = false, MIE1 = false, MIE2 = false,
          MIE3 = false, MMPRV = false, MPRV = BitsN.B(0x0,2),
          MPRV1 = BitsN.B(0x0,2), MPRV2 = BitsN.B(0x0,2),
          MPRV3 = BitsN.B(0x0,2), MSD = false, MXS = BitsN.B(0x0,2),
          VM = BitsN.B(0x0,5), mstatus'rst = BitsN.B(0x0,41)},
       htdeleg =
         {Exc_deleg = BitsN.B(0x0,16), Intr_deleg = BitsN.B(0x0,48)},
       htime_delta = BitsN.B(0x0,64), htimecmp = BitsN.B(0x0,64),
       htvec = BitsN.B(0x0,64)})): (HypervisorCSR Map.map) ref

val c_MCSR = ref
  (Map.mkMap
     (SOME 256,
      {mbadaddr = BitsN.B(0x0,64), mbase = BitsN.B(0x0,64),
       mbound = BitsN.B(0x0,64),
       mcause =
         {EC = BitsN.B(0x0,4), Int = false, mcause'rst = BitsN.B(0x0,59)},
       mcpuid =
         {ArchBase = BitsN.B(0x0,2), I = false, M = false, S = false,
          U = false, mcpuid'rst = BitsN.B(0x0,58)},
       mdbase = BitsN.B(0x0,64), mdbound = BitsN.B(0x0,64),
       mepc = BitsN.B(0x0,64), mfromhost = BitsN.B(0x0,64),
       mhartid = BitsN.B(0x0,64), mibase = BitsN.B(0x0,64),
       mibound = BitsN.B(0x0,64),
       mie =
         {HSIE = false, HTIE = false, MSIE = false, MTIE = false,
          SSIE = false, STIE = false, mie'rst = BitsN.B(0x0,58)},
       mimpid = {RVImpl = BitsN.B(0x0,48), RVSource = BitsN.B(0x0,16)},
       mip =
         {HSIP = false, HTIP = false, MSIP = false, MTIP = false,
          SSIP = false, STIP = false, mip'rst = BitsN.B(0x0,58)},
       mscratch = BitsN.B(0x0,64),
       mstatus =
         {MFS = BitsN.B(0x0,2), MIE = false, MIE1 = false, MIE2 = false,
          MIE3 = false, MMPRV = false, MPRV = BitsN.B(0x0,2),
          MPRV1 = BitsN.B(0x0,2), MPRV2 = BitsN.B(0x0,2),
          MPRV3 = BitsN.B(0x0,2), MSD = false, MXS = BitsN.B(0x0,2),
          VM = BitsN.B(0x0,5), mstatus'rst = BitsN.B(0x0,41)},
       mtdeleg =
         {Exc_deleg = BitsN.B(0x0,16), Intr_deleg = BitsN.B(0x0,48)},
       mtime_delta = BitsN.B(0x0,64), mtimecmp = BitsN.B(0x0,64),
       mtohost = BitsN.B(0x0,64), mtvec = BitsN.B(0x0,64)}))
  : (MachineCSR Map.map) ref

val c_NextFetch = ref (Map.mkMap(SOME 256,NONE))
  : ((TransferControl option) Map.map) ref

val c_PC = ref (Map.mkMap(SOME 256,BitsN.B(0x0,64)))
  : (BitsN.nbit Map.map) ref

val c_ReserveLoad = ref (Map.mkMap(SOME 256,NONE))
  : ((BitsN.nbit option) Map.map) ref

val c_SCSR = ref
  (Map.mkMap
     (SOME 256,
      {sasid = BitsN.B(0x0,64), sbadaddr = BitsN.B(0x0,64),
       scause =
         {EC = BitsN.B(0x0,4), Int = false, mcause'rst = BitsN.B(0x0,59)},
       sepc = BitsN.B(0x0,64), sptbr = BitsN.B(0x0,64),
       sscratch = BitsN.B(0x0,64), stime_delta = BitsN.B(0x0,64),
       stimecmp = BitsN.B(0x0,64), stvec = BitsN.B(0x0,64)}))
  : (SupervisorCSR Map.map) ref

val c_UCSR = ref
  (Map.mkMap
     (SOME 256,
      {cycle_delta = BitsN.B(0x0,64), instret_delta = BitsN.B(0x0,64),
       time_delta = BitsN.B(0x0,64)})): (UserCSR Map.map) ref

val c_cycles = ref (Map.mkMap(SOME 256,BitsN.B(0x0,64)))
  : (BitsN.nbit Map.map) ref

val c_gpr = ref (Map.mkMap(SOME 256,Map.mkMap(SOME 32,BitsN.B(0x0,64))))
  : ((BitsN.nbit Map.map) Map.map) ref

val c_instret = ref (Map.mkMap(SOME 256,BitsN.B(0x0,64)))
  : (BitsN.nbit Map.map) ref

val c_tlb = ref (Map.mkMap(SOME 256,Map.mkMap(SOME 16,NONE)))
  : (((TLBEntry option) Map.map) Map.map) ref

val c_update = ref
  (Map.mkMap
     (SOME 256,
      {addr = NONE, data1 = NONE, data2 = NONE, exc_taken = false,
       fetch_exc = false, fp_data = NONE, pc = BitsN.B(0x0,64),
       rinstr = BitsN.B(0x0,32), st_width = NONE}))
  : (StateDelta Map.map) ref

val clock = ref (BitsN.B(0x0,64)): BitsN.nbit ref

val done = ref (false): bool ref

val log = ref ([]): ((Nat.nat * string) list) ref

val procID = ref (BitsN.B(0x0,8)): BitsN.nbit ref

val totalCore = ref (0): Nat.nat ref

(* -------------------------------------------------------------------------
   Main specification
   ------------------------------------------------------------------------- *)

local
  fun tuple'32 [t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13,t14,t15,t16,
                t17,t18,t19,t20,t21,t22,t23,t24,t25,t26,t27,t28,t29,t30,
                t31] =
    (t0,
     (t1,
      (t2,
       (t3,
        (t4,
         (t5,
          (t6,
           (t7,
            (t8,
             (t9,
              (t10,
               (t11,
                (t12,
                 (t13,
                  (t14,
                   (t15,
                    (t16,
                     (t17,
                      (t18,
                       (t19,
                        (t20,
                         (t21,
                          (t22,
                           (t23,
                            (t24,(t25,(t26,(t27,(t28,(t29,(t30,t31)))))))))))))))))))))))))))))))
    | tuple'32 (_: bool list) = raise Fail "tuple'32"
in
  val boolify'32 = tuple'32 o BitsN.toList
end

val ASID_SIZE = 6

val PAGESIZE_BITS = 12

val LEVEL_BITS = 9

val BYTE = BitsN.B(0x0,3)

val HALFWORD = BitsN.B(0x1,3)

val WORD = BitsN.B(0x3,3)

val DOUBLEWORD = BitsN.B(0x7,3)

fun archBase a =
  case a of
     RV32I => BitsN.B(0x0,2)
   | RV64I => BitsN.B(0x2,2)
   | RV128I => BitsN.B(0x3,2);

fun architecture ab =
  case ab of
     BitsN.B(0x0,2) => RV32I
   | BitsN.B(0x2,2) => RV64I
   | BitsN.B(0x3,2) => RV128I
   | _ =>
     raise UNDEFINED
       (("Unknown architecture: ") ^ (Nat.toString(BitsN.toNat ab)));

fun archName a =
  case a of RV32I => "RV32I" | RV64I => "RV64I" | RV128I => "RV128I";

fun privLevel p =
  case p of
     User => BitsN.B(0x0,2)
   | Supervisor => BitsN.B(0x1,2)
   | Hypervisor => BitsN.B(0x2,2)
   | Machine => BitsN.B(0x3,2);

fun privilege p =
  case p of
     BitsN.B(0x0,2) => User
   | BitsN.B(0x1,2) => Supervisor
   | BitsN.B(0x2,2) => Hypervisor
   | BitsN.B(0x3,2) => Machine
   | _ => raise General.Bind;

fun privName p =
  case p of
     User => "U"
   | Supervisor => "S"
   | Hypervisor => "H"
   | Machine => "M";

fun vmType vm =
  case vm of
     BitsN.B(0x0,5) => Mbare
   | BitsN.B(0x1,5) => Mbb
   | BitsN.B(0x2,5) => Mbbid
   | BitsN.B(0x8,5) => Sv32
   | BitsN.B(0x9,5) => Sv39
   | BitsN.B(0xA,5) => Sv48
   | BitsN.B(0xB,5) => Sv57
   | BitsN.B(0xC,5) => Sv64
   | _ =>
     raise UNDEFINED
       (("Unknown address translation mode: ")
          ^
          (Nat.toString(BitsN.toNat vm)));

fun isValidVM vm =
  case vm of
     BitsN.B(0x0,5) => true
   | BitsN.B(0x1,5) => true
   | BitsN.B(0x2,5) => true
   | BitsN.B(0x8,5) => true
   | BitsN.B(0x9,5) => true
   | BitsN.B(0xA,5) => true
   | BitsN.B(0xB,5) => true
   | BitsN.B(0xC,5) => true
   | _ => false;

fun vmMode vm =
  case vm of
     Mbare => BitsN.B(0x0,5)
   | Mbb => BitsN.B(0x1,5)
   | Mbbid => BitsN.B(0x2,5)
   | Sv32 => BitsN.B(0x8,5)
   | Sv39 => BitsN.B(0x9,5)
   | Sv48 => BitsN.B(0xA,5)
   | Sv57 => BitsN.B(0xB,5)
   | Sv64 => BitsN.B(0xC,5);

fun vmModeName vm =
  case vm of
     Mbare => "Mbare"
   | Mbb => "Mbb"
   | Mbbid => "Mbbid"
   | Sv32 => "Sv32"
   | Sv39 => "Sv39"
   | Sv48 => "Sv48"
   | Sv57 => "Sv57"
   | Sv64 => "Sv64";

fun ext_status e =
  case e of
     Off => BitsN.B(0x0,2)
   | Initial => BitsN.B(0x1,2)
   | Clean => BitsN.B(0x2,2)
   | Dirty => BitsN.B(0x3,2);

fun extStatus e =
  case e of
     BitsN.B(0x0,2) => Off
   | BitsN.B(0x1,2) => Initial
   | BitsN.B(0x2,2) => Clean
   | BitsN.B(0x3,2) => Dirty
   | _ => raise General.Bind;

fun extStatusName e =
  case e of
     Off => "Off"
   | Initial => "Initial"
   | Clean => "Clean"
   | Dirty => "Dirty";

fun interruptIndex i =
  case i of Software => BitsN.B(0x0,4) | Timer => BitsN.B(0x1,4);

fun excCode e =
  case e of
     Fetch_Misaligned => BitsN.B(0x0,4)
   | Fetch_Fault => BitsN.B(0x1,4)
   | Illegal_Instr => BitsN.B(0x2,4)
   | Breakpoint => BitsN.B(0x3,4)
   | Load_Fault => BitsN.B(0x5,4)
   | AMO_Misaligned => BitsN.B(0x6,4)
   | Store_AMO_Fault => BitsN.B(0x7,4)
   | UMode_Env_Call => BitsN.B(0x8,4)
   | SMode_Env_Call => BitsN.B(0x9,4)
   | HMode_Env_Call => BitsN.B(0xA,4)
   | MMode_Env_Call => BitsN.B(0xB,4);

fun excType e =
  case e of
     BitsN.B(0x0,4) => Fetch_Misaligned
   | BitsN.B(0x1,4) => Fetch_Fault
   | BitsN.B(0x2,4) => Illegal_Instr
   | BitsN.B(0x3,4) => Breakpoint
   | BitsN.B(0x5,4) => Load_Fault
   | BitsN.B(0x6,4) => AMO_Misaligned
   | BitsN.B(0x7,4) => Store_AMO_Fault
   | BitsN.B(0x8,4) => UMode_Env_Call
   | BitsN.B(0x9,4) => SMode_Env_Call
   | BitsN.B(0xA,4) => HMode_Env_Call
   | BitsN.B(0xB,4) => MMode_Env_Call
   | _ =>
     raise UNDEFINED
       (("Unknown exception: ") ^ (Nat.toString(BitsN.toNat e)));

fun excName e =
  case e of
     Fetch_Misaligned => "MISALIGNED_FETCH"
   | Fetch_Fault => "FAULT_FETCH"
   | Illegal_Instr => "ILLEGAL_INSTRUCTION"
   | Breakpoint => "BREAKPOINT"
   | Load_Fault => "FAULT_LOAD"
   | AMO_Misaligned => "MISALIGNED_AMO"
   | Store_AMO_Fault => "FAULT_STORE_AMO"
   | UMode_Env_Call => "U-EnvCall"
   | SMode_Env_Call => "S-EnvCall"
   | HMode_Env_Call => "H-EnvCall"
   | MMode_Env_Call => "M-EnvCall";

fun rec'mcpuid x =
  {ArchBase = BitsN.bits(63,62) x, I = BitsN.bit(x,8),
   M = BitsN.bit(x,12), S = BitsN.bit(x,18), U = BitsN.bit(x,20),
   mcpuid'rst =
     BitsN.concat
       [BitsN.bits(7,0) x,BitsN.bits(11,9) x,BitsN.bits(17,13) x,
        BitsN.bits(19,19) x,BitsN.bits(61,21) x]};

fun reg'mcpuid x =
  case x of
     {ArchBase = ArchBase, I = I, M = M, S = S, U = U,
      mcpuid'rst = mcpuid'rst} =>
       BitsN.concat
         [ArchBase,BitsN.bits(40,0) mcpuid'rst,BitsN.fromBit U,
          BitsN.bits(41,41) mcpuid'rst,BitsN.fromBit S,
          BitsN.bits(46,42) mcpuid'rst,BitsN.fromBit M,
          BitsN.bits(49,47) mcpuid'rst,BitsN.fromBit I,
          BitsN.bits(57,50) mcpuid'rst];

fun write'rec'mcpuid (_,x) = reg'mcpuid x;

fun write'reg'mcpuid (_,x) = rec'mcpuid x;

fun rec'mimpid x =
  {RVImpl = BitsN.bits(63,16) x, RVSource = BitsN.bits(15,0) x};

fun reg'mimpid x =
  case x of
     {RVImpl = RVImpl, RVSource = RVSource} => BitsN.@@(RVImpl,RVSource);

fun write'rec'mimpid (_,x) = reg'mimpid x;

fun write'reg'mimpid (_,x) = rec'mimpid x;

fun rec'mstatus x =
  {MFS = BitsN.bits(13,12) x, MIE = BitsN.bit(x,0), MIE1 = BitsN.bit(x,3),
   MIE2 = BitsN.bit(x,6), MIE3 = BitsN.bit(x,9), MMPRV = BitsN.bit(x,16),
   MPRV = BitsN.bits(2,1) x, MPRV1 = BitsN.bits(5,4) x,
   MPRV2 = BitsN.bits(8,7) x, MPRV3 = BitsN.bits(11,10) x,
   MSD = BitsN.bit(x,63), MXS = BitsN.bits(15,14) x,
   VM = BitsN.bits(21,17) x, mstatus'rst = BitsN.bits(62,22) x};

fun reg'mstatus x =
  case x of
     {MFS = MFS, MIE = MIE, MIE1 = MIE1, MIE2 = MIE2, MIE3 = MIE3,
      MMPRV = MMPRV, MPRV = MPRV, MPRV1 = MPRV1, MPRV2 = MPRV2,
      MPRV3 = MPRV3, MSD = MSD, MXS = MXS, VM = VM,
      mstatus'rst = mstatus'rst} =>
       BitsN.concat
         [BitsN.fromBit MSD,mstatus'rst,VM,BitsN.fromBit MMPRV,MXS,MFS,
          MPRV3,BitsN.fromBit MIE3,MPRV2,BitsN.fromBit MIE2,MPRV1,
          BitsN.fromBit MIE1,MPRV,BitsN.fromBit MIE];

fun write'rec'mstatus (_,x) = reg'mstatus x;

fun write'reg'mstatus (_,x) = rec'mstatus x;

fun rec'mtdeleg x =
  {Exc_deleg = BitsN.bits(15,0) x, Intr_deleg = BitsN.bits(63,16) x};

fun reg'mtdeleg x =
  case x of
     {Exc_deleg = Exc_deleg, Intr_deleg = Intr_deleg} =>
       BitsN.@@(Intr_deleg,Exc_deleg);

fun write'rec'mtdeleg (_,x) = reg'mtdeleg x;

fun write'reg'mtdeleg (_,x) = rec'mtdeleg x;

fun rec'mip x =
  {HSIP = BitsN.bit(x,2), HTIP = BitsN.bit(x,6), MSIP = BitsN.bit(x,3),
   MTIP = BitsN.bit(x,7), SSIP = BitsN.bit(x,1), STIP = BitsN.bit(x,5),
   mip'rst =
     BitsN.concat[BitsN.bits(0,0) x,BitsN.bits(4,4) x,BitsN.bits(63,8) x]};

fun reg'mip x =
  case x of
     {HSIP = HSIP, HTIP = HTIP, MSIP = MSIP, MTIP = MTIP, SSIP = SSIP,
      STIP = STIP, mip'rst = mip'rst} =>
       BitsN.concat
         [BitsN.bits(55,0) mip'rst,BitsN.fromBit MTIP,BitsN.fromBit HTIP,
          BitsN.fromBit STIP,BitsN.bits(56,56) mip'rst,BitsN.fromBit MSIP,
          BitsN.fromBit HSIP,BitsN.fromBit SSIP,BitsN.bits(57,57) mip'rst];

fun write'rec'mip (_,x) = reg'mip x;

fun write'reg'mip (_,x) = rec'mip x;

fun rec'mie x =
  {HSIE = BitsN.bit(x,2), HTIE = BitsN.bit(x,6), MSIE = BitsN.bit(x,3),
   MTIE = BitsN.bit(x,7), SSIE = BitsN.bit(x,1), STIE = BitsN.bit(x,5),
   mie'rst =
     BitsN.concat[BitsN.bits(0,0) x,BitsN.bits(4,4) x,BitsN.bits(63,8) x]};

fun reg'mie x =
  case x of
     {HSIE = HSIE, HTIE = HTIE, MSIE = MSIE, MTIE = MTIE, SSIE = SSIE,
      STIE = STIE, mie'rst = mie'rst} =>
       BitsN.concat
         [BitsN.bits(55,0) mie'rst,BitsN.fromBit MTIE,BitsN.fromBit HTIE,
          BitsN.fromBit STIE,BitsN.bits(56,56) mie'rst,BitsN.fromBit MSIE,
          BitsN.fromBit HSIE,BitsN.fromBit SSIE,BitsN.bits(57,57) mie'rst];

fun write'rec'mie (_,x) = reg'mie x;

fun write'reg'mie (_,x) = rec'mie x;

fun rec'mcause x =
  {EC = BitsN.bits(3,0) x, Int = BitsN.bit(x,63),
   mcause'rst = BitsN.bits(62,4) x};

fun reg'mcause x =
  case x of
     {EC = EC, Int = Int, mcause'rst = mcause'rst} =>
       BitsN.concat[BitsN.fromBit Int,mcause'rst,EC];

fun write'rec'mcause (_,x) = reg'mcause x;

fun write'reg'mcause (_,x) = rec'mcause x;

fun rec'sstatus x =
  {SFS = BitsN.bits(13,12) x, SIE = BitsN.bit(x,0),
   SMPRV = BitsN.bit(x,16), SPIE = BitsN.bit(x,3), SPS = BitsN.bit(x,4),
   SSD = BitsN.bit(x,63), SXS = BitsN.bits(15,14) x,
   sstatus'rst =
     BitsN.concat
       [BitsN.bits(2,1) x,BitsN.bits(11,5) x,BitsN.bits(62,17) x]};

fun reg'sstatus x =
  case x of
     {SFS = SFS, SIE = SIE, SMPRV = SMPRV, SPIE = SPIE, SPS = SPS,
      SSD = SSD, SXS = SXS, sstatus'rst = sstatus'rst} =>
       BitsN.concat
         [BitsN.fromBit SSD,BitsN.bits(45,0) sstatus'rst,
          BitsN.fromBit SMPRV,SXS,SFS,BitsN.bits(52,46) sstatus'rst,
          BitsN.fromBit SPS,BitsN.fromBit SPIE,
          BitsN.bits(54,53) sstatus'rst,BitsN.fromBit SIE];

fun write'rec'sstatus (_,x) = reg'sstatus x;

fun write'reg'sstatus (_,x) = rec'sstatus x;

fun rec'sip x =
  {SSIP = BitsN.bit(x,1), STIP = BitsN.bit(x,5),
   sip'rst =
     BitsN.concat[BitsN.bits(0,0) x,BitsN.bits(4,2) x,BitsN.bits(63,6) x]};

fun reg'sip x =
  case x of
     {SSIP = SSIP, STIP = STIP, sip'rst = sip'rst} =>
       BitsN.concat
         [BitsN.bits(57,0) sip'rst,BitsN.fromBit STIP,
          BitsN.bits(60,58) sip'rst,BitsN.fromBit SSIP,
          BitsN.bits(61,61) sip'rst];

fun write'rec'sip (_,x) = reg'sip x;

fun write'reg'sip (_,x) = rec'sip x;

fun rec'sie x =
  {SSIE = BitsN.bit(x,1), STIE = BitsN.bit(x,5),
   sie'rst =
     BitsN.concat[BitsN.bits(0,0) x,BitsN.bits(4,2) x,BitsN.bits(63,6) x]};

fun reg'sie x =
  case x of
     {SSIE = SSIE, STIE = STIE, sie'rst = sie'rst} =>
       BitsN.concat
         [BitsN.bits(57,0) sie'rst,BitsN.fromBit STIE,
          BitsN.bits(60,58) sie'rst,BitsN.fromBit SSIE,
          BitsN.bits(61,61) sie'rst];

fun write'rec'sie (_,x) = reg'sie x;

fun write'reg'sie (_,x) = rec'sie x;

fun lift_mip_sip mip =
  let
    val sip = ref (rec'sip(BitsN.B(0x0,64)))
  in
    ( sip := (sip_STIP_rupd((!sip),(#STIP) mip))
    ; sip := (sip_SSIP_rupd((!sip),(#SSIP) mip))
    ; (!sip)
    )
  end;

fun lift_mie_sie mie =
  let
    val sie = ref (rec'sie(BitsN.B(0x0,64)))
  in
    ( sie := (sie_STIE_rupd((!sie),(#STIE) mie))
    ; sie := (sie_SSIE_rupd((!sie),(#SSIE) mie))
    ; (!sie)
    )
  end;

fun lower_sip_mip (sip,mip) =
  let
    val m = ref mip
  in
    ( m := (mip_STIP_rupd((!m),(#STIP) sip))
    ; m := (mip_SSIP_rupd((!m),(#SSIP) sip))
    ; (!m)
    )
  end;

fun lower_sie_mie (sie,mie) =
  let
    val m = ref mie
  in
    ( m := (mie_STIE_rupd((!m),(#STIE) sie))
    ; m := (mie_SSIE_rupd((!m),(#SSIE) sie))
    ; (!m)
    )
  end;

fun update_mstatus (orig,v) =
  let
    val mt = ref orig
  in
    ( mt := (mstatus_MIE_rupd((!mt),(#MIE) v))
    ; mt := (mstatus_MPRV_rupd((!mt),(#MPRV) v))
    ; mt := (mstatus_MIE1_rupd((!mt),(#MIE1) v))
    ; mt := (mstatus_MPRV1_rupd((!mt),(#MPRV1) v))
    ; mt := (mstatus_MIE2_rupd((!mt),(#MIE2) v))
    ; mt := (mstatus_MPRV2_rupd((!mt),(#MPRV2) v))
    ; mt := (mstatus_MIE3_rupd((!mt),(#MIE3) v))
    ; mt := (mstatus_MPRV3_rupd((!mt),(#MPRV3) v))
    ; if isValidVM((#VM) v)
        then mt := (mstatus_VM_rupd((!mt),(#VM) v))
      else ()
    ; mt := (mstatus_MMPRV_rupd((!mt),(#MMPRV) v))
    ; if ((extStatus((#MXS) (!mt))) = Dirty) orelse
         ((extStatus((#MFS) (!mt))) = Dirty)
        then mt := (mstatus_MSD_rupd((!mt),true))
      else ()
    ; (!mt)
    )
  end;

fun lift_mstatus_sstatus mst =
  let
    val st = ref (rec'sstatus(BitsN.B(0x0,64)))
  in
    ( st := (sstatus_SMPRV_rupd((!st),(#MMPRV) mst))
    ; st := (sstatus_SSD_rupd((!st),(#MSD) mst))
    ; st := (sstatus_SXS_rupd((!st),(#MXS) mst))
    ; st := (sstatus_SFS_rupd((!st),(#MFS) mst))
    ; st :=
      (sstatus_SPS_rupd((!st),not((privilege((#MPRV1) mst)) = User)))
    ; st := (sstatus_SPIE_rupd((!st),(#MIE1) mst))
    ; st := (sstatus_SIE_rupd((!st),(#MIE) mst))
    ; (!st)
    )
  end;

fun lower_sstatus_mstatus (sst,mst) =
  let
    val mt = ref (rec'mstatus(reg'mstatus mst))
  in
    ( mt := (mstatus_MMPRV_rupd((!mt),(#SMPRV) sst))
    ; mt := (mstatus_MXS_rupd((!mt),(#SXS) sst))
    ; mt := (mstatus_MFS_rupd((!mt),(#SFS) sst))
    ; mt :=
      (mstatus_MPRV1_rupd
         ((!mt),privLevel(if (#SPS) sst then Supervisor else User)))
    ; mt := (mstatus_MIE1_rupd((!mt),(#SPIE) sst))
    ; mt := (mstatus_MIE_rupd((!mt),(#SIE) sst))
    ; update_mstatus(mst,(!mt))
    )
  end;

fun popPrivilegeStack mst =
  let
    val st = ref mst
  in
    ( st := (mstatus_MIE_rupd((!st),(#MIE1) mst))
    ; st := (mstatus_MPRV_rupd((!st),(#MPRV1) mst))
    ; st := (mstatus_MIE1_rupd((!st),(#MIE2) mst))
    ; st := (mstatus_MPRV1_rupd((!st),(#MPRV2) mst))
    ; st := (mstatus_MIE2_rupd((!st),true))
    ; st := (mstatus_MPRV2_rupd((!st),privLevel User))
    ; (!st)
    )
  end;

fun pushPrivilegeStack (mst,p) =
  let
    val st = ref mst
  in
    ( st := (mstatus_MIE2_rupd((!st),(#MIE1) mst))
    ; st := (mstatus_MPRV2_rupd((!st),(#MPRV1) mst))
    ; st := (mstatus_MIE1_rupd((!st),(#MIE) mst))
    ; st := (mstatus_MPRV1_rupd((!st),(#MPRV) mst))
    ; st := (mstatus_MIE_rupd((!st),false))
    ; st := (mstatus_MPRV_rupd((!st),privLevel p))
    ; (!st)
    )
  end;

fun scheduleCore id =
  if Nat.<(id,(!totalCore)) then procID := (BitsN.fromNat(id,8)) else ();

fun gpr n =
  let
    val m = Map.copy(Map.lookup((!c_gpr),BitsN.toNat (!procID)))
  in
    Map.lookup(m,BitsN.toNat n)
  end;

fun write'gpr (value,n) =
  let
    val m = ref (Map.copy(Map.lookup((!c_gpr),BitsN.toNat (!procID))))
  in
    ( m := (Map.update((!m),BitsN.toNat n,value))
    ; c_gpr := (Map.update((!c_gpr),BitsN.toNat (!procID),Map.copy (!m)))
    )
  end;

fun PC () = Map.lookup((!c_PC),BitsN.toNat (!procID));

fun write'PC value =
  c_PC := (Map.update((!c_PC),BitsN.toNat (!procID),value));

fun UCSR () = Map.lookup((!c_UCSR),BitsN.toNat (!procID));

fun write'UCSR value =
  c_UCSR := (Map.update((!c_UCSR),BitsN.toNat (!procID),value));

fun SCSR () = Map.lookup((!c_SCSR),BitsN.toNat (!procID));

fun write'SCSR value =
  c_SCSR := (Map.update((!c_SCSR),BitsN.toNat (!procID),value));

fun HCSR () = Map.lookup((!c_HCSR),BitsN.toNat (!procID));

fun write'HCSR value =
  c_HCSR := (Map.update((!c_HCSR),BitsN.toNat (!procID),value));

fun MCSR () = Map.lookup((!c_MCSR),BitsN.toNat (!procID));

fun write'MCSR value =
  c_MCSR := (Map.update((!c_MCSR),BitsN.toNat (!procID),value));

fun NextFetch () = Map.lookup((!c_NextFetch),BitsN.toNat (!procID));

fun write'NextFetch value =
  c_NextFetch := (Map.update((!c_NextFetch),BitsN.toNat (!procID),value));

fun ReserveLoad () = Map.lookup((!c_ReserveLoad),BitsN.toNat (!procID));

fun write'ReserveLoad value =
  c_ReserveLoad :=
  (Map.update((!c_ReserveLoad),BitsN.toNat (!procID),value));

fun ExitCode () = Map.lookup((!c_ExitCode),BitsN.toNat (!procID));

fun write'ExitCode value =
  c_ExitCode := (Map.update((!c_ExitCode),BitsN.toNat (!procID),value));

fun curArch () = architecture((#ArchBase)((#mcpuid)(MCSR ())));

fun in32BitMode () = (curArch ()) = RV32I;

fun curPrivilege () = privilege((#MPRV)((#mstatus)(MCSR ())));

fun curEPC () =
  case curPrivilege () of
     User => raise INTERNAL_ERROR ("No EPC in U-mode")
   | Supervisor => (#sepc)(SCSR ())
   | Hypervisor => (#hepc)(HCSR ())
   | Machine => (#mepc)(MCSR ());

fun sendIPI core =
  let
    val id = BitsN.fromNat(BitsN.toNat core,8)
  in
    if Nat.<(BitsN.toNat id,(!totalCore))
      then let
             val x0 = Map.lookup((!c_MCSR),BitsN.toNat id)
             val x1 = (#mip) x0
           in
             c_MCSR :=
             (Map.update
                ((!c_MCSR),BitsN.toNat id,
                 MachineCSR_mip_rupd(x0,mip_MSIP_rupd(x1,true))))
           end
    else ()
  end;

fun csrRW csr = BitsN.bits(11,10) csr;

fun csrPR csr = BitsN.bits(9,8) csr;

fun check_CSR_access (rw,(pr,(p,a))) =
  ((a = Read) orelse (not(rw = (BitsN.B(0x3,2))))) andalso
  (BitsN.>=+(privLevel p,pr));

fun is_CSR_defined csr =
  ((BitsN.>=(csr,BitsN.B(0xC00,12))) andalso
   (BitsN.<=(csr,BitsN.B(0xC02,12)))) orelse
  (((BitsN.>=(csr,BitsN.B(0xC80,12))) andalso
    ((BitsN.<=(csr,BitsN.B(0xC82,12))) andalso (in32BitMode ()))) orelse
   (((BitsN.>=(csr,BitsN.B(0x100,12))) andalso
     (BitsN.<=(csr,BitsN.B(0x101,12)))) orelse
    ((csr = (BitsN.B(0x104,12))) orelse
     ((csr = (BitsN.B(0x121,12))) orelse
      ((csr = (BitsN.B(0xD01,12))) orelse
       (((csr = (BitsN.B(0xD81,12))) andalso (in32BitMode ())) orelse
        (((BitsN.>=(csr,BitsN.B(0x140,12))) andalso
          (BitsN.<=(csr,BitsN.B(0x141,12)))) orelse
         ((csr = (BitsN.B(0x144,12))) orelse
          (((BitsN.>=(csr,BitsN.B(0xD42,12))) andalso
            (BitsN.<=(csr,BitsN.B(0xD43,12)))) orelse
           (((BitsN.>=(csr,BitsN.B(0x180,12))) andalso
             (BitsN.<=(csr,BitsN.B(0x181,12)))) orelse
            (((BitsN.>=(csr,BitsN.B(0x900,12))) andalso
              (BitsN.<=(csr,BitsN.B(0x902,12)))) orelse
             (((BitsN.>=(csr,BitsN.B(0x980,12))) andalso
               ((BitsN.<=(csr,BitsN.B(0x982,12))) andalso (in32BitMode ()))) orelse
              (((BitsN.>=(csr,BitsN.B(0xF00,12))) andalso
                (BitsN.<=(csr,BitsN.B(0xF01,12)))) orelse
               ((csr = (BitsN.B(0xF10,12))) orelse
                (((BitsN.>=(csr,BitsN.B(0x300,12))) andalso
                  (BitsN.<=(csr,BitsN.B(0x302,12)))) orelse
                 ((csr = (BitsN.B(0x304,12))) orelse
                  ((csr = (BitsN.B(0x321,12))) orelse
                   ((csr = (BitsN.B(0x701,12))) orelse
                    (((csr = (BitsN.B(0x741,12))) andalso (in32BitMode ())) orelse
                     (((BitsN.>=(csr,BitsN.B(0x340,12))) andalso
                       (BitsN.<=(csr,BitsN.B(0x344,12)))) orelse
                      (((BitsN.>=(csr,BitsN.B(0x380,12))) andalso
                        (BitsN.<=(csr,BitsN.B(0x385,12)))) orelse
                       ((BitsN.>=(csr,BitsN.B(0xB01,12))) orelse
                        (((csr = (BitsN.B(0xB81,12))) andalso
                          (in32BitMode ())) orelse
                         ((BitsN.>=(csr,BitsN.B(0x780,12))) andalso
                          ((BitsN.<=(csr,BitsN.B(0x783,12))) andalso
                           (not(csr = (BitsN.B(0x782,12)))))))))))))))))))))))))))));

fun CSRMap csr =
  case csr of
     BitsN.B(0xC00,12) =>
       BitsN.+
         (Map.lookup((!c_cycles),BitsN.toNat (!procID)),
          (#cycle_delta)(Map.lookup((!c_UCSR),BitsN.toNat (!procID))))
   | BitsN.B(0xC01,12) =>
     BitsN.+
       ((!clock),
        (#time_delta)(Map.lookup((!c_UCSR),BitsN.toNat (!procID))))
   | BitsN.B(0xC02,12) =>
     BitsN.+
       (Map.lookup((!c_instret),BitsN.toNat (!procID)),
        (#instret_delta)(Map.lookup((!c_UCSR),BitsN.toNat (!procID))))
   | BitsN.B(0xC80,12) =>
     BitsN.signExtend 64
       (BitsN.bits(63,32)
          (BitsN.+
             (Map.lookup((!c_cycles),BitsN.toNat (!procID)),
              (#cycle_delta)(Map.lookup((!c_UCSR),BitsN.toNat (!procID))))))
   | BitsN.B(0xC81,12) =>
     BitsN.signExtend 64
       (BitsN.bits(63,32)
          (BitsN.+
             ((!clock),
              (#time_delta)(Map.lookup((!c_UCSR),BitsN.toNat (!procID))))))
   | BitsN.B(0xC82,12) =>
     BitsN.signExtend 64
       (BitsN.bits(63,32)
          (BitsN.+
             (Map.lookup((!c_instret),BitsN.toNat (!procID)),
              (#instret_delta)
                (Map.lookup((!c_UCSR),BitsN.toNat (!procID))))))
   | BitsN.B(0x100,12) =>
     reg'sstatus
       (lift_mstatus_sstatus
          ((#mstatus)(Map.lookup((!c_MCSR),BitsN.toNat (!procID)))))
   | BitsN.B(0x101,12) =>
     (#stvec)(Map.lookup((!c_SCSR),BitsN.toNat (!procID)))
   | BitsN.B(0x104,12) =>
     reg'sie
       (lift_mie_sie((#mie)(Map.lookup((!c_MCSR),BitsN.toNat (!procID)))))
   | BitsN.B(0x121,12) =>
     (#stimecmp)(Map.lookup((!c_SCSR),BitsN.toNat (!procID)))
   | BitsN.B(0xD01,12) =>
     BitsN.+
       ((!clock),
        (#stime_delta)(Map.lookup((!c_SCSR),BitsN.toNat (!procID))))
   | BitsN.B(0xD81,12) =>
     BitsN.signExtend 64
       (BitsN.bits(63,32)
          (BitsN.+
             ((!clock),
              (#stime_delta)(Map.lookup((!c_SCSR),BitsN.toNat (!procID))))))
   | BitsN.B(0x140,12) =>
     (#sscratch)(Map.lookup((!c_SCSR),BitsN.toNat (!procID)))
   | BitsN.B(0x141,12) =>
     (#sepc)(Map.lookup((!c_SCSR),BitsN.toNat (!procID)))
   | BitsN.B(0xD42,12) =>
     reg'mcause((#scause)(Map.lookup((!c_SCSR),BitsN.toNat (!procID))))
   | BitsN.B(0xD43,12) =>
     (#sbadaddr)(Map.lookup((!c_SCSR),BitsN.toNat (!procID)))
   | BitsN.B(0x144,12) =>
     reg'sip
       (lift_mip_sip((#mip)(Map.lookup((!c_MCSR),BitsN.toNat (!procID)))))
   | BitsN.B(0x180,12) =>
     (#sptbr)(Map.lookup((!c_SCSR),BitsN.toNat (!procID)))
   | BitsN.B(0x181,12) =>
     (#sasid)(Map.lookup((!c_SCSR),BitsN.toNat (!procID)))
   | BitsN.B(0x900,12) =>
     BitsN.+
       (Map.lookup((!c_cycles),BitsN.toNat (!procID)),
        (#cycle_delta)(Map.lookup((!c_UCSR),BitsN.toNat (!procID))))
   | BitsN.B(0x901,12) =>
     BitsN.+
       ((!clock),
        (#time_delta)(Map.lookup((!c_UCSR),BitsN.toNat (!procID))))
   | BitsN.B(0x902,12) =>
     BitsN.+
       (Map.lookup((!c_instret),BitsN.toNat (!procID)),
        (#instret_delta)(Map.lookup((!c_UCSR),BitsN.toNat (!procID))))
   | BitsN.B(0x980,12) =>
     BitsN.signExtend 64
       (BitsN.bits(63,32)
          (BitsN.+
             (Map.lookup((!c_cycles),BitsN.toNat (!procID)),
              (#cycle_delta)(Map.lookup((!c_UCSR),BitsN.toNat (!procID))))))
   | BitsN.B(0x981,12) =>
     BitsN.signExtend 64
       (BitsN.bits(63,32)
          (BitsN.+
             ((!clock),
              (#time_delta)(Map.lookup((!c_UCSR),BitsN.toNat (!procID))))))
   | BitsN.B(0x982,12) =>
     BitsN.signExtend 64
       (BitsN.bits(63,32)
          (BitsN.+
             (Map.lookup((!c_instret),BitsN.toNat (!procID)),
              (#instret_delta)
                (Map.lookup((!c_UCSR),BitsN.toNat (!procID))))))
   | BitsN.B(0x200,12) =>
     reg'mstatus((#hstatus)(Map.lookup((!c_HCSR),BitsN.toNat (!procID))))
   | BitsN.B(0x201,12) =>
     (#htvec)(Map.lookup((!c_HCSR),BitsN.toNat (!procID)))
   | BitsN.B(0x202,12) =>
     reg'mtdeleg((#htdeleg)(Map.lookup((!c_HCSR),BitsN.toNat (!procID))))
   | BitsN.B(0x221,12) =>
     (#htimecmp)(Map.lookup((!c_HCSR),BitsN.toNat (!procID)))
   | BitsN.B(0xE01,12) =>
     BitsN.+
       ((!clock),
        (#htime_delta)(Map.lookup((!c_HCSR),BitsN.toNat (!procID))))
   | BitsN.B(0xE81,12) =>
     BitsN.signExtend 64
       (BitsN.bits(63,32)
          (BitsN.+
             ((!clock),
              (#htime_delta)(Map.lookup((!c_HCSR),BitsN.toNat (!procID))))))
   | BitsN.B(0x240,12) =>
     (#hscratch)(Map.lookup((!c_HCSR),BitsN.toNat (!procID)))
   | BitsN.B(0x241,12) =>
     (#hepc)(Map.lookup((!c_HCSR),BitsN.toNat (!procID)))
   | BitsN.B(0x242,12) =>
     reg'mcause((#hcause)(Map.lookup((!c_HCSR),BitsN.toNat (!procID))))
   | BitsN.B(0x243,12) =>
     (#hbadaddr)(Map.lookup((!c_HCSR),BitsN.toNat (!procID)))
   | BitsN.B(0xA01,12) =>
     BitsN.+
       ((!clock),
        (#stime_delta)(Map.lookup((!c_SCSR),BitsN.toNat (!procID))))
   | BitsN.B(0xA81,12) =>
     BitsN.signExtend 64
       (BitsN.bits(63,32)
          (BitsN.+
             ((!clock),
              (#stime_delta)(Map.lookup((!c_SCSR),BitsN.toNat (!procID))))))
   | BitsN.B(0xF00,12) =>
     reg'mcpuid((#mcpuid)(Map.lookup((!c_MCSR),BitsN.toNat (!procID))))
   | BitsN.B(0xF01,12) =>
     reg'mimpid((#mimpid)(Map.lookup((!c_MCSR),BitsN.toNat (!procID))))
   | BitsN.B(0xF10,12) =>
     (#mhartid)(Map.lookup((!c_MCSR),BitsN.toNat (!procID)))
   | BitsN.B(0x300,12) =>
     reg'mstatus((#mstatus)(Map.lookup((!c_MCSR),BitsN.toNat (!procID))))
   | BitsN.B(0x301,12) =>
     (#mtvec)(Map.lookup((!c_MCSR),BitsN.toNat (!procID)))
   | BitsN.B(0x302,12) =>
     reg'mtdeleg((#mtdeleg)(Map.lookup((!c_MCSR),BitsN.toNat (!procID))))
   | BitsN.B(0x304,12) =>
     reg'mie((#mie)(Map.lookup((!c_MCSR),BitsN.toNat (!procID))))
   | BitsN.B(0x321,12) =>
     (#mtimecmp)(Map.lookup((!c_MCSR),BitsN.toNat (!procID)))
   | BitsN.B(0x701,12) =>
     BitsN.+
       ((!clock),
        (#mtime_delta)(Map.lookup((!c_MCSR),BitsN.toNat (!procID))))
   | BitsN.B(0x741,12) =>
     BitsN.signExtend 64
       (BitsN.bits(63,32)
          (BitsN.+
             ((!clock),
              (#mtime_delta)(Map.lookup((!c_MCSR),BitsN.toNat (!procID))))))
   | BitsN.B(0x340,12) =>
     (#mscratch)(Map.lookup((!c_MCSR),BitsN.toNat (!procID)))
   | BitsN.B(0x341,12) =>
     (#mepc)(Map.lookup((!c_MCSR),BitsN.toNat (!procID)))
   | BitsN.B(0x342,12) =>
     reg'mcause((#mcause)(Map.lookup((!c_MCSR),BitsN.toNat (!procID))))
   | BitsN.B(0x343,12) =>
     (#mbadaddr)(Map.lookup((!c_MCSR),BitsN.toNat (!procID)))
   | BitsN.B(0x344,12) =>
     reg'mip((#mip)(Map.lookup((!c_MCSR),BitsN.toNat (!procID))))
   | BitsN.B(0x380,12) =>
     (#mbase)(Map.lookup((!c_MCSR),BitsN.toNat (!procID)))
   | BitsN.B(0x381,12) =>
     (#mbound)(Map.lookup((!c_MCSR),BitsN.toNat (!procID)))
   | BitsN.B(0x382,12) =>
     (#mibase)(Map.lookup((!c_MCSR),BitsN.toNat (!procID)))
   | BitsN.B(0x383,12) =>
     (#mibound)(Map.lookup((!c_MCSR),BitsN.toNat (!procID)))
   | BitsN.B(0x384,12) =>
     (#mdbase)(Map.lookup((!c_MCSR),BitsN.toNat (!procID)))
   | BitsN.B(0x385,12) =>
     (#mdbound)(Map.lookup((!c_MCSR),BitsN.toNat (!procID)))
   | BitsN.B(0xB01,12) =>
     BitsN.+
       ((!clock),
        (#htime_delta)(Map.lookup((!c_HCSR),BitsN.toNat (!procID))))
   | BitsN.B(0xB81,12) =>
     BitsN.signExtend 64
       (BitsN.bits(63,32)
          (BitsN.+
             ((!clock),
              (#htime_delta)(Map.lookup((!c_HCSR),BitsN.toNat (!procID))))))
   | BitsN.B(0x780,12) =>
     (#mtohost)(Map.lookup((!c_MCSR),BitsN.toNat (!procID)))
   | BitsN.B(0x781,12) =>
     (#mfromhost)(Map.lookup((!c_MCSR),BitsN.toNat (!procID)))
   | BitsN.B(0x783,12) => BitsN.B(0x0,64)
   | _ =>
     raise UNDEFINED
       (("unexpected CSR read at ") ^ (BitsN.toHexString csr));

fun write'CSRMap (value,csr) =
  case csr of
     BitsN.B(0x100,12) =>
       let
         val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
       in
         c_MCSR :=
         (Map.update
            ((!c_MCSR),BitsN.toNat (!procID),
             MachineCSR_mstatus_rupd
               (x0,
                lower_sstatus_mstatus
                  (rec'sstatus value,
                   (#mstatus)(Map.lookup((!c_MCSR),BitsN.toNat (!procID)))))))
       end
   | BitsN.B(0x101,12) =>
     let
       val x0 = Map.lookup((!c_SCSR),BitsN.toNat (!procID))
     in
       c_SCSR :=
       (Map.update
          ((!c_SCSR),BitsN.toNat (!procID),
           SupervisorCSR_stvec_rupd(x0,value)))
     end
   | BitsN.B(0x104,12) =>
     let
       val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
     in
       c_MCSR :=
       (Map.update
          ((!c_MCSR),BitsN.toNat (!procID),
           MachineCSR_mie_rupd
             (x0,
              lower_sie_mie
                (rec'sie value,
                 (#mie)(Map.lookup((!c_MCSR),BitsN.toNat (!procID)))))))
     end
   | BitsN.B(0x121,12) =>
     ( let
         val x0 = Map.lookup((!c_SCSR),BitsN.toNat (!procID))
       in
         c_SCSR :=
         (Map.update
            ((!c_SCSR),BitsN.toNat (!procID),
             SupervisorCSR_stimecmp_rupd(x0,value)))
       end
     ; let
         val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
         val x1 = (#mip) x0
       in
         c_MCSR :=
         (Map.update
            ((!c_MCSR),BitsN.toNat (!procID),
             MachineCSR_mip_rupd(x0,mip_STIP_rupd(x1,false))))
       end
     )
   | BitsN.B(0x140,12) =>
     let
       val x0 = Map.lookup((!c_SCSR),BitsN.toNat (!procID))
     in
       c_SCSR :=
       (Map.update
          ((!c_SCSR),BitsN.toNat (!procID),
           SupervisorCSR_sscratch_rupd(x0,value)))
     end
   | BitsN.B(0x141,12) =>
     let
       val x0 = Map.lookup((!c_SCSR),BitsN.toNat (!procID))
     in
       c_SCSR :=
       (Map.update
          ((!c_SCSR),BitsN.toNat (!procID),
           SupervisorCSR_sepc_rupd
             (x0,BitsN.&&(value,BitsN.signExtend 64 (BitsN.B(0x4,3))))))
     end
   | BitsN.B(0x144,12) =>
     let
       val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
     in
       c_MCSR :=
       (Map.update
          ((!c_MCSR),BitsN.toNat (!procID),
           MachineCSR_mip_rupd
             (x0,
              lower_sip_mip
                (rec'sip value,
                 (#mip)(Map.lookup((!c_MCSR),BitsN.toNat (!procID)))))))
     end
   | BitsN.B(0x180,12) =>
     let
       val x0 = Map.lookup((!c_SCSR),BitsN.toNat (!procID))
     in
       c_SCSR :=
       (Map.update
          ((!c_SCSR),BitsN.toNat (!procID),
           SupervisorCSR_sptbr_rupd(x0,value)))
     end
   | BitsN.B(0x181,12) =>
     let
       val x0 = Map.lookup((!c_SCSR),BitsN.toNat (!procID))
     in
       c_SCSR :=
       (Map.update
          ((!c_SCSR),BitsN.toNat (!procID),
           SupervisorCSR_sasid_rupd(x0,value)))
     end
   | BitsN.B(0x900,12) =>
     let
       val x0 = Map.lookup((!c_UCSR),BitsN.toNat (!procID))
     in
       c_UCSR :=
       (Map.update
          ((!c_UCSR),BitsN.toNat (!procID),
           UserCSR_cycle_delta_rupd
             (x0,
              BitsN.-(value,Map.lookup((!c_cycles),BitsN.toNat (!procID))))))
     end
   | BitsN.B(0x901,12) =>
     let
       val x0 = Map.lookup((!c_UCSR),BitsN.toNat (!procID))
     in
       c_UCSR :=
       (Map.update
          ((!c_UCSR),BitsN.toNat (!procID),
           UserCSR_time_delta_rupd(x0,BitsN.-(value,(!clock)))))
     end
   | BitsN.B(0x902,12) =>
     let
       val x0 = Map.lookup((!c_UCSR),BitsN.toNat (!procID))
     in
       c_UCSR :=
       (Map.update
          ((!c_UCSR),BitsN.toNat (!procID),
           UserCSR_instret_delta_rupd
             (x0,
              BitsN.-
                (value,Map.lookup((!c_instret),BitsN.toNat (!procID))))))
     end
   | BitsN.B(0x980,12) =>
     let
       val x0 = Map.lookup((!c_UCSR),BitsN.toNat (!procID))
       val w = (#cycle_delta) x0
     in
       c_UCSR :=
       (Map.update
          ((!c_UCSR),BitsN.toNat (!procID),
           UserCSR_cycle_delta_rupd
             (x0,
              BitsN.bitFieldInsert(63,32)
                (w,
                 BitsN.<<
                   (BitsN.-
                      (BitsN.bits(31,0) value,
                       BitsN.bits(63,32)
                         (Map.lookup((!c_cycles),BitsN.toNat (!procID)))),
                    32)))))
     end
   | BitsN.B(0x981,12) =>
     let
       val x0 = Map.lookup((!c_UCSR),BitsN.toNat (!procID))
       val w = (#time_delta) x0
     in
       c_UCSR :=
       (Map.update
          ((!c_UCSR),BitsN.toNat (!procID),
           UserCSR_time_delta_rupd
             (x0,
              BitsN.bitFieldInsert(63,32)
                (w,
                 BitsN.<<
                   (BitsN.-
                      (BitsN.bits(31,0) value,BitsN.bits(63,32) (!clock)),
                    32)))))
     end
   | BitsN.B(0x982,12) =>
     let
       val x0 = Map.lookup((!c_UCSR),BitsN.toNat (!procID))
       val w = (#instret_delta) x0
     in
       c_UCSR :=
       (Map.update
          ((!c_UCSR),BitsN.toNat (!procID),
           UserCSR_instret_delta_rupd
             (x0,
              BitsN.bitFieldInsert(63,32)
                (w,
                 BitsN.<<
                   (BitsN.-
                      (BitsN.bits(31,0) value,
                       BitsN.bits(63,32)
                         (Map.lookup((!c_instret),BitsN.toNat (!procID)))),
                    32)))))
     end
   | BitsN.B(0x300,12) =>
     let
       val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
     in
       c_MCSR :=
       (Map.update
          ((!c_MCSR),BitsN.toNat (!procID),
           MachineCSR_mstatus_rupd
             (x0,
              update_mstatus
                ((#mstatus)(Map.lookup((!c_MCSR),BitsN.toNat (!procID))),
                 rec'mstatus value))))
     end
   | BitsN.B(0x301,12) =>
     let
       val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
     in
       c_MCSR :=
       (Map.update
          ((!c_MCSR),BitsN.toNat (!procID),MachineCSR_mtvec_rupd(x0,value)))
     end
   | BitsN.B(0x302,12) =>
     let
       val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
     in
       c_MCSR :=
       (Map.update
          ((!c_MCSR),BitsN.toNat (!procID),
           MachineCSR_mtdeleg_rupd(x0,rec'mtdeleg value)))
     end
   | BitsN.B(0x304,12) =>
     let
       val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
     in
       c_MCSR :=
       (Map.update
          ((!c_MCSR),BitsN.toNat (!procID),
           MachineCSR_mie_rupd(x0,rec'mie value)))
     end
   | BitsN.B(0x321,12) =>
     ( let
         val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
       in
         c_MCSR :=
         (Map.update
            ((!c_MCSR),BitsN.toNat (!procID),
             MachineCSR_mtimecmp_rupd(x0,value)))
       end
     ; let
         val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
         val x1 = (#mip) x0
       in
         c_MCSR :=
         (Map.update
            ((!c_MCSR),BitsN.toNat (!procID),
             MachineCSR_mip_rupd(x0,mip_MTIP_rupd(x1,false))))
       end
     )
   | BitsN.B(0x701,12) =>
     let
       val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
     in
       c_MCSR :=
       (Map.update
          ((!c_MCSR),BitsN.toNat (!procID),
           MachineCSR_mtime_delta_rupd(x0,BitsN.-(value,(!clock)))))
     end
   | BitsN.B(0x741,12) =>
     let
       val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
       val w = (#mtime_delta) x0
     in
       c_MCSR :=
       (Map.update
          ((!c_MCSR),BitsN.toNat (!procID),
           MachineCSR_mtime_delta_rupd
             (x0,
              BitsN.bitFieldInsert(63,32)
                (w,
                 BitsN.<<
                   (BitsN.-
                      (BitsN.bits(31,0) value,BitsN.bits(63,32) (!clock)),
                    32)))))
     end
   | BitsN.B(0x340,12) =>
     let
       val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
     in
       c_MCSR :=
       (Map.update
          ((!c_MCSR),BitsN.toNat (!procID),
           MachineCSR_mscratch_rupd(x0,value)))
     end
   | BitsN.B(0x341,12) =>
     let
       val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
     in
       c_MCSR :=
       (Map.update
          ((!c_MCSR),BitsN.toNat (!procID),
           MachineCSR_mepc_rupd
             (x0,BitsN.&&(value,BitsN.signExtend 64 (BitsN.B(0x4,3))))))
     end
   | BitsN.B(0x342,12) =>
     let
       val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
     in
       c_MCSR :=
       (Map.update
          ((!c_MCSR),BitsN.toNat (!procID),
           MachineCSR_mcause_rupd(x0,rec'mcause value)))
     end
   | BitsN.B(0x343,12) =>
     let
       val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
     in
       c_MCSR :=
       (Map.update
          ((!c_MCSR),BitsN.toNat (!procID),
           MachineCSR_mbadaddr_rupd(x0,value)))
     end
   | BitsN.B(0x344,12) =>
     let
       val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
     in
       c_MCSR :=
       (Map.update
          ((!c_MCSR),BitsN.toNat (!procID),
           MachineCSR_mip_rupd(x0,rec'mip value)))
     end
   | BitsN.B(0x380,12) =>
     let
       val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
     in
       c_MCSR :=
       (Map.update
          ((!c_MCSR),BitsN.toNat (!procID),MachineCSR_mbase_rupd(x0,value)))
     end
   | BitsN.B(0x381,12) =>
     let
       val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
     in
       c_MCSR :=
       (Map.update
          ((!c_MCSR),BitsN.toNat (!procID),
           MachineCSR_mbound_rupd(x0,value)))
     end
   | BitsN.B(0x382,12) =>
     let
       val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
     in
       c_MCSR :=
       (Map.update
          ((!c_MCSR),BitsN.toNat (!procID),
           MachineCSR_mibase_rupd(x0,value)))
     end
   | BitsN.B(0x383,12) =>
     let
       val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
     in
       c_MCSR :=
       (Map.update
          ((!c_MCSR),BitsN.toNat (!procID),
           MachineCSR_mibound_rupd(x0,value)))
     end
   | BitsN.B(0x384,12) =>
     let
       val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
     in
       c_MCSR :=
       (Map.update
          ((!c_MCSR),BitsN.toNat (!procID),
           MachineCSR_mdbase_rupd(x0,value)))
     end
   | BitsN.B(0x385,12) =>
     let
       val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
     in
       c_MCSR :=
       (Map.update
          ((!c_MCSR),BitsN.toNat (!procID),
           MachineCSR_mdbound_rupd(x0,value)))
     end
   | BitsN.B(0xB01,12) =>
     let
       val x0 = Map.lookup((!c_HCSR),BitsN.toNat (!procID))
     in
       c_HCSR :=
       (Map.update
          ((!c_HCSR),BitsN.toNat (!procID),
           HypervisorCSR_htime_delta_rupd(x0,BitsN.-(value,(!clock)))))
     end
   | BitsN.B(0xB81,12) =>
     let
       val x0 = Map.lookup((!c_HCSR),BitsN.toNat (!procID))
       val w = (#htime_delta) x0
     in
       c_HCSR :=
       (Map.update
          ((!c_HCSR),BitsN.toNat (!procID),
           HypervisorCSR_htime_delta_rupd
             (x0,
              BitsN.bitFieldInsert(63,32)
                (w,
                 BitsN.<<
                   (BitsN.-
                      (BitsN.bits(31,0) value,BitsN.bits(63,32) (!clock)),
                    32)))))
     end
   | BitsN.B(0x780,12) =>
     let
       val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
     in
       c_MCSR :=
       (Map.update
          ((!c_MCSR),BitsN.toNat (!procID),
           MachineCSR_mtohost_rupd(x0,value)))
     end
   | BitsN.B(0x781,12) =>
     let
       val x0 = Map.lookup((!c_MCSR),BitsN.toNat (!procID))
     in
       c_MCSR :=
       (Map.update
          ((!c_MCSR),BitsN.toNat (!procID),
           MachineCSR_mfromhost_rupd(x0,value)))
     end
   | BitsN.B(0x783,12) => sendIPI value
   | _ =>
     raise INTERNAL_ERROR
       (("unexpected CSR write to ") ^ (BitsN.toHexString csr));

fun csrName csr =
  case csr of
     BitsN.B(0xC00,12) => "cycle"
   | BitsN.B(0xC01,12) => "time"
   | BitsN.B(0xC02,12) => "instret"
   | BitsN.B(0xC80,12) => "cycleh"
   | BitsN.B(0xC81,12) => "timeh"
   | BitsN.B(0xC82,12) => "instreth"
   | BitsN.B(0x100,12) => "sstatus"
   | BitsN.B(0x101,12) => "stvec"
   | BitsN.B(0x104,12) => "sie"
   | BitsN.B(0x121,12) => "stimecmp"
   | BitsN.B(0xD01,12) => "stime"
   | BitsN.B(0xD81,12) => "stimeh"
   | BitsN.B(0x140,12) => "sscratch"
   | BitsN.B(0x141,12) => "sepc"
   | BitsN.B(0xD42,12) => "scause"
   | BitsN.B(0xD43,12) => "sbadaddr"
   | BitsN.B(0x144,12) => "mip"
   | BitsN.B(0x180,12) => "sptbr"
   | BitsN.B(0x181,12) => "sasid"
   | BitsN.B(0x900,12) => "cycle"
   | BitsN.B(0x901,12) => "time"
   | BitsN.B(0x902,12) => "instret"
   | BitsN.B(0x980,12) => "cycleh"
   | BitsN.B(0x981,12) => "timeh"
   | BitsN.B(0x982,12) => "instreth"
   | BitsN.B(0x200,12) => "hstatus"
   | BitsN.B(0x201,12) => "htvec"
   | BitsN.B(0x202,12) => "htdeleg"
   | BitsN.B(0x221,12) => "htimecmp"
   | BitsN.B(0xE01,12) => "htime"
   | BitsN.B(0xE81,12) => "htimeh"
   | BitsN.B(0x240,12) => "hscratch"
   | BitsN.B(0x241,12) => "hepc"
   | BitsN.B(0x242,12) => "hcause"
   | BitsN.B(0x243,12) => "hbadaddr"
   | BitsN.B(0xA01,12) => "stime"
   | BitsN.B(0xA81,12) => "stimeh"
   | BitsN.B(0xF00,12) => "mcpuid"
   | BitsN.B(0xF01,12) => "mimpid"
   | BitsN.B(0xF10,12) => "mhartid"
   | BitsN.B(0x300,12) => "mstatus"
   | BitsN.B(0x301,12) => "mtvec"
   | BitsN.B(0x302,12) => "mtdeleg"
   | BitsN.B(0x304,12) => "mie"
   | BitsN.B(0x321,12) => "mtimecmp"
   | BitsN.B(0x701,12) => "mtime"
   | BitsN.B(0x741,12) => "mtimeh"
   | BitsN.B(0x340,12) => "mscratch"
   | BitsN.B(0x341,12) => "mepc"
   | BitsN.B(0x342,12) => "mcause"
   | BitsN.B(0x343,12) => "mbadaddr"
   | BitsN.B(0x344,12) => "mip"
   | BitsN.B(0x380,12) => "mbase"
   | BitsN.B(0x381,12) => "mbound"
   | BitsN.B(0x382,12) => "mibase"
   | BitsN.B(0x383,12) => "mibound"
   | BitsN.B(0x384,12) => "mdbase"
   | BitsN.B(0x385,12) => "mdbound"
   | BitsN.B(0xB01,12) => "htime"
   | BitsN.B(0xB81,12) => "htimeh"
   | BitsN.B(0x780,12) => "mtohost"
   | BitsN.B(0x781,12) => "mfromhost"
   | BitsN.B(0x783,12) => "send_ipi"
   | _ => "UNKNOWN";

fun Delta () = Map.lookup((!c_update),BitsN.toNat (!procID));

fun write'Delta value =
  c_update := (Map.update((!c_update),BitsN.toNat (!procID),value));

fun hex32 x = L3.padLeftString(#"0",(8,BitsN.toHexString x));

fun hex64 x = L3.padLeftString(#"0",(16,BitsN.toHexString x));

fun log_w_csr (csr,data) =
  String.concat["CSR (",csrName csr,") <- 0x",hex64 data];

fun reg r =
  if r = (BitsN.B(0x0,5))
    then "$0"
  else if r = (BitsN.B(0x1,5))
    then "ra"
  else if r = (BitsN.B(0x2,5))
    then "sp"
  else if r = (BitsN.B(0x3,5))
    then "gp"
  else if r = (BitsN.B(0x4,5))
    then "tp"
  else if r = (BitsN.B(0x5,5))
    then "t0"
  else if r = (BitsN.B(0x6,5))
    then "t1"
  else if r = (BitsN.B(0x7,5))
    then "t2"
  else if r = (BitsN.B(0x8,5))
    then "fp"
  else if r = (BitsN.B(0x9,5))
    then "s1"
  else if r = (BitsN.B(0xA,5))
    then "a0"
  else if r = (BitsN.B(0xB,5))
    then "a1"
  else if r = (BitsN.B(0xC,5))
    then "a2"
  else if r = (BitsN.B(0xD,5))
    then "a3"
  else if r = (BitsN.B(0xE,5))
    then "a4"
  else if r = (BitsN.B(0xF,5))
    then "a5"
  else if r = (BitsN.B(0x10,5))
    then "a6"
  else if r = (BitsN.B(0x11,5))
    then "a7"
  else if r = (BitsN.B(0x12,5))
    then "s2"
  else if r = (BitsN.B(0x13,5))
    then "s3"
  else if r = (BitsN.B(0x14,5))
    then "s4"
  else if r = (BitsN.B(0x15,5))
    then "s5"
  else if r = (BitsN.B(0x16,5))
    then "s6"
  else if r = (BitsN.B(0x17,5))
    then "s7"
  else if r = (BitsN.B(0x18,5))
    then "s8"
  else if r = (BitsN.B(0x19,5))
    then "s9"
  else if r = (BitsN.B(0x1A,5))
    then "s10"
  else if r = (BitsN.B(0x1B,5))
    then "s11"
  else if r = (BitsN.B(0x1C,5))
    then "t3"
  else if r = (BitsN.B(0x1D,5))
    then "t4"
  else if r = (BitsN.B(0x1E,5)) then "t5" else "t6";

fun log_w_gpr (r,data) =
  String.concat
    ["Reg ",reg r," (",Nat.toString(BitsN.toNat r),") <- 0x",hex64 data];

fun log_w_mem_mask (pAddrIdx,(vAddr,(mask,(data,(old,new))))) =
  String.concat
    ["MEM[0x",hex64(BitsN.fromNat(BitsN.toNat pAddrIdx,64)),"/",
     hex64 vAddr,"] <- (data: 0x",hex64 data,", mask: 0x",hex64 mask,
     ", old: 0x",hex64 old,", new: 0x",hex64 new,")"];

fun log_w_mem_mask_misaligned
  (pAddrIdx,(vAddr,(mask,(data,(align,(old,new)))))) =
  String.concat
    ["MEM[0x",hex64(BitsN.fromNat(BitsN.toNat pAddrIdx,64)),"/",
     hex64 vAddr,"/ misaligned@",Nat.toString align,"] <- (data: 0x",
     hex64 data,", mask: 0x",hex64 mask,", old: 0x",hex64 old,", new: 0x",
     hex64 new,")"];

fun log_w_mem (pAddrIdx,(vAddr,data)) =
  String.concat
    ["MEM[0x",hex64(BitsN.fromNat(BitsN.toNat pAddrIdx,64)),"/",
     hex64 vAddr,"] <- (data: 0x",hex64 data,")"];

fun log_r_mem (pAddrIdx,(vAddr,data)) =
  String.concat
    ["data <- MEM[0x",
     L3.padLeftString(#"0",(10,BitsN.toHexString pAddrIdx)),"/",
     hex64 vAddr,"]: 0x",hex64 data];

fun log_exc e = String.concat[" Exception ",excName e," raised!"];

fun log_tohost tohost =
  ("-> host: ")
    ^
    (String.str((L3.chr o BitsN.toNat) (BitsN.bits(7,0) tohost)));

fun clear_logs () = log := [];

fun setTrap (e,badaddr) =
  let
    val trap = ref {badaddr = NONE, trap = AMO_Misaligned}
  in
    ( trap := (SynchronousTrap_trap_rupd((!trap),e))
    ; trap := (SynchronousTrap_badaddr_rupd((!trap),badaddr))
    ; write'NextFetch(Option.SOME(Trap (!trap)))
    )
  end;

fun signalException e =
  ( log := ((1,("signalling exception ") ^ (excName e)) :: (!log))
  ; setTrap(e,NONE)
  ; let
      val x = Delta ()
    in
      write'Delta(StateDelta_exc_taken_rupd(x,true))
    end
  );

fun signalAddressException (e,vAddr) =
  ( log :=
    ((1,
      String.concat
        ["signalling address exception ",excName e," at ",
         BitsN.toHexString vAddr])
       ::
       (!log))
  ; setTrap(e,Option.SOME vAddr)
  ; let
      val x = Delta ()
    in
      write'Delta(StateDelta_exc_taken_rupd(x,true))
    end
  );

fun signalEnvCall () =
  let
    val e =
      case privilege((#MPRV)((#mstatus)(MCSR ()))) of
         User => UMode_Env_Call
       | Supervisor => SMode_Env_Call
       | Hypervisor => HMode_Env_Call
       | Machine => MMode_Env_Call
  in
    signalException e
  end;

fun checkDelegation (curPriv,(intr,ec)) =
  let
    val e = BitsN.toNat ec
  in
    case curPriv of
       User => raise INTERNAL_ERROR ("No user-level delegation!")
     | Supervisor =>
       raise INTERNAL_ERROR ("No supervisor-level delegation!")
     | Hypervisor =>
       if (intr andalso (BitsN.bit((#Intr_deleg)((#htdeleg)(HCSR ())),e))) orelse
          ((not intr) andalso
           (BitsN.bit((#Exc_deleg)((#htdeleg)(HCSR ())),e)))
         then Supervisor
       else curPriv
     | Machine =>
       if (intr andalso (BitsN.bit((#Intr_deleg)((#mtdeleg)(MCSR ())),e))) orelse
          ((not intr) andalso
           (BitsN.bit((#Exc_deleg)((#mtdeleg)(MCSR ())),e)))
         then checkDelegation(Hypervisor,(intr,ec))
       else curPriv
  end;

fun checkPrivInterrupt curPriv =
  let
    val ip = (#mip)(MCSR ())
    val ie = (#mie)(MCSR ())
  in
    case curPriv of
       User => raise INTERNAL_ERROR ("No user-level interrupts!")
     | Supervisor =>
       if ((#STIP) ip) andalso ((#STIE) ie)
         then Option.SOME(Timer,curPriv)
       else if ((#SSIP) ip) andalso ((#SSIE) ie)
         then Option.SOME(Software,curPriv)
       else NONE
     | Hypervisor =>
       if ((#HTIP) ip) andalso ((#HTIE) ie)
         then Option.SOME(Timer,curPriv)
       else if ((#HSIP) ip) andalso ((#HSIE) ie)
         then Option.SOME(Software,curPriv)
       else NONE
     | Machine =>
       if ((#MTIP) ip) andalso ((#MTIE) ie)
         then Option.SOME(Timer,curPriv)
       else if ((#MSIP) ip) andalso ((#MSIE) ie)
         then Option.SOME(Software,curPriv)
       else NONE
  end;

fun checkInterrupts () =
  let
    val curIE = (#MIE)((#mstatus)(MCSR ()))
    val p = curPrivilege ()
  in
    case p of
       User =>
         (case checkPrivInterrupt Machine of
             NONE =>
               (case checkPrivInterrupt Hypervisor of
                   NONE =>
                     if (p = User) orelse curIE
                       then checkPrivInterrupt Supervisor
                     else NONE
                 | i => i)
           | i => i)
     | Supervisor =>
       (case checkPrivInterrupt Machine of
           NONE =>
             (case checkPrivInterrupt Hypervisor of
                 NONE =>
                   if (p = User) orelse curIE
                     then checkPrivInterrupt Supervisor
                   else NONE
               | i => i)
         | i => i)
     | Hypervisor =>
       (case checkPrivInterrupt Machine of
           NONE => if curIE then checkPrivInterrupt Hypervisor else NONE
         | i => i)
     | Machine => if curIE then checkPrivInterrupt Machine else NONE
  end;

fun takeTrap (intr,(ec,(epc,(badaddr,toPriv)))) =
  let
    val fromP = curPrivilege ()
  in
    ( log :=
      ((1,
        String.concat
          ["trapping from ",privName fromP," to ",privName toPriv,
           " at pc ",BitsN.toHexString epc,
           if intr then " [intr] " else " [exc] ",
           Nat.toString(BitsN.toNat ec)])
         ::
         (!log))
    ; write'ReserveLoad NONE
    ; let
        val x = MCSR ()
        val x0 = (#mstatus) x
      in
        write'MCSR
          (MachineCSR_mstatus_rupd(x,mstatus_MMPRV_rupd(x0,false)))
      end
    ; let
        val x = MCSR ()
      in
        write'MCSR
          (MachineCSR_mstatus_rupd
             (x,pushPrivilegeStack((#mstatus)(MCSR ()),toPriv)))
      end
    ; case toPriv of
         User => raise INTERNAL_ERROR ("Illegal trap to U-mode")
       | Supervisor =>
         ( let
             val x = SCSR ()
             val x0 = (#scause) x
           in
             write'SCSR
               (SupervisorCSR_scause_rupd(x,mcause_Int_rupd(x0,intr)))
           end
         ; let
             val x = SCSR ()
             val x0 = (#scause) x
           in
             write'SCSR
               (SupervisorCSR_scause_rupd(x,mcause_EC_rupd(x0,ec)))
           end
         ; let
             val x = SCSR ()
           in
             write'SCSR(SupervisorCSR_sepc_rupd(x,epc))
           end
         ; if Option.isSome badaddr
             then let
                    val x = SCSR ()
                  in
                    write'SCSR
                      (SupervisorCSR_sbadaddr_rupd(x,Option.valOf badaddr))
                  end
           else ()
         ; write'PC((#stvec)(SCSR ()))
         )
       | Hypervisor => raise INTERNAL_ERROR ("Unsupported trap to H-mode")
       | Machine =>
         ( let
             val x = MCSR ()
             val x0 = (#mcause) x
           in
             write'MCSR
               (MachineCSR_mcause_rupd(x,mcause_Int_rupd(x0,intr)))
           end
         ; let
             val x = MCSR ()
             val x0 = (#mcause) x
           in
             write'MCSR(MachineCSR_mcause_rupd(x,mcause_EC_rupd(x0,ec)))
           end
         ; let
             val x = MCSR ()
           in
             write'MCSR(MachineCSR_mepc_rupd(x,epc))
           end
         ; if Option.isSome badaddr
             then let
                    val x = MCSR ()
                  in
                    write'MCSR
                      (MachineCSR_mbadaddr_rupd(x,Option.valOf badaddr))
                  end
           else ()
         ; write'PC
             (BitsN.+
                ((#mtvec)(MCSR ()),
                 BitsN.*
                   (BitsN.fromNat(BitsN.toNat(privLevel fromP),64),
                    BitsN.B(0x40,64))))
         )
    )
  end;

fun CSR n = CSRMap n;

fun write'CSR (value,n) =
  ( write'CSRMap(value,n); log := ((2,log_w_csr(n,value)) :: (!log)) );

fun writeCSR (csr,val') =
  ( write'CSR(val',csr)
  ; let
      val x = Delta ()
    in
      write'Delta
        (StateDelta_addr_rupd(x,Option.SOME(BitsN.zeroExtend 64 csr)))
    end
  ; let
      val x = Delta ()
    in
      write'Delta(StateDelta_data2_rupd(x,Option.SOME(CSR csr)))
    end
  );

fun GPR n = if n = (BitsN.B(0x0,5)) then BitsN.B(0x0,64) else gpr n;

fun write'GPR (value,n) =
  if not(n = (BitsN.B(0x0,5)))
    then ( write'gpr(value,n); log := ((2,log_w_gpr(n,value)) :: (!log)) )
  else ();

fun MEM a =
  let
    val b = BitsN.<<(BitsN.fromNat(BitsN.toNat a,64),3)
  in
    BitsN.concat
      [Map.lookup((!MEM8),BitsN.toNat(BitsN.+(b,BitsN.B(0x7,64)))),
       Map.lookup((!MEM8),BitsN.toNat(BitsN.+(b,BitsN.B(0x6,64)))),
       Map.lookup((!MEM8),BitsN.toNat(BitsN.+(b,BitsN.B(0x5,64)))),
       Map.lookup((!MEM8),BitsN.toNat(BitsN.+(b,BitsN.B(0x4,64)))),
       Map.lookup((!MEM8),BitsN.toNat(BitsN.+(b,BitsN.B(0x3,64)))),
       Map.lookup((!MEM8),BitsN.toNat(BitsN.+(b,BitsN.B(0x2,64)))),
       Map.lookup((!MEM8),BitsN.toNat(BitsN.+(b,BitsN.B(0x1,64)))),
       Map.lookup((!MEM8),BitsN.toNat b)]
  end;

fun write'MEM (val',a) =
  let
    val b = BitsN.<<(BitsN.fromNat(BitsN.toNat a,64),3)
  in
    ( let
        val x = BitsN.+(b,BitsN.B(0x7,64))
      in
        MEM8 := (Map.update((!MEM8),BitsN.toNat x,BitsN.bits(63,56) val'))
      end
    ; let
        val x = BitsN.+(b,BitsN.B(0x6,64))
      in
        MEM8 := (Map.update((!MEM8),BitsN.toNat x,BitsN.bits(55,48) val'))
      end
    ; let
        val x = BitsN.+(b,BitsN.B(0x5,64))
      in
        MEM8 := (Map.update((!MEM8),BitsN.toNat x,BitsN.bits(47,40) val'))
      end
    ; let
        val x = BitsN.+(b,BitsN.B(0x4,64))
      in
        MEM8 := (Map.update((!MEM8),BitsN.toNat x,BitsN.bits(39,32) val'))
      end
    ; let
        val x = BitsN.+(b,BitsN.B(0x3,64))
      in
        MEM8 := (Map.update((!MEM8),BitsN.toNat x,BitsN.bits(31,24) val'))
      end
    ; let
        val x = BitsN.+(b,BitsN.B(0x2,64))
      in
        MEM8 := (Map.update((!MEM8),BitsN.toNat x,BitsN.bits(23,16) val'))
      end
    ; let
        val x = BitsN.+(b,BitsN.B(0x1,64))
      in
        MEM8 := (Map.update((!MEM8),BitsN.toNat x,BitsN.bits(15,8) val'))
      end
    ; MEM8 := (Map.update((!MEM8),BitsN.toNat b,BitsN.bits(7,0) val'))
    )
  end;

fun rawReadData pAddr =
  let
    val pAddrIdx = BitsN.bits(63,3) pAddr
    val align = BitsN.toNat(BitsN.bits(2,0) pAddr)
  in
    if align = 0
      then let
             val data = MEM pAddrIdx
           in
             ( log := ((3,log_r_mem(pAddrIdx,(pAddr,data))) :: (!log))
             ; data
             )
           end
    else let
           val dw0 = MEM pAddrIdx
           val dw1 = MEM(BitsN.+(pAddrIdx,BitsN.B(0x1,61)))
           val ddw = BitsN.>>(BitsN.@@(dw1,dw0),Nat.*(align,8))
           val data = BitsN.bits(63,0) ddw
         in
           ( log := ((3,log_r_mem(pAddrIdx,(pAddr,dw0))) :: (!log))
           ; log :=
             ((3,log_r_mem(BitsN.+(pAddrIdx,BitsN.B(0x1,61)),(pAddr,dw1)))
                ::
                (!log))
           ; log := ((3,log_r_mem(pAddrIdx,(pAddr,data))) :: (!log))
           ; data
           )
         end
  end;

fun rawWriteData (pAddr,(data,nbytes)) =
  let
    val mask =
      BitsN.-
        (BitsN.<<(BitsN.zeroExtend 64 (BitsN.B(0x1,1)),Nat.*(nbytes,8)),
         BitsN.B(0x1,64))
    val pAddrIdx = BitsN.bits(63,3) pAddr
    val align = BitsN.toNat(BitsN.bits(2,0) pAddr)
    val old = MEM pAddrIdx
  in
    ( log := ((3,log_r_mem(pAddrIdx,(pAddr,old))) :: (!log))
    ; if align = 0
        then let
               val new =
                 BitsN.||(BitsN.&&(old,BitsN.~ mask),BitsN.&&(data,mask))
             in
               ( write'MEM(new,pAddrIdx)
               ; log :=
                 ((3,
                   log_w_mem_mask
                     (pAddrIdx,(pAddr,(mask,(data,(old,new))))))
                    ::
                    (!log))
               )
             end
      else if Nat.<=(Nat.+(align,nbytes),Nat.div(BitsN.size mask,8))
        then let
               val new =
                 BitsN.||
                   (BitsN.&&(old,BitsN.~(BitsN.<<(mask,Nat.*(align,8)))),
                    BitsN.<<(BitsN.&&(data,mask),Nat.*(align,8)))
             in
               ( write'MEM(new,pAddrIdx)
               ; log :=
                 ((3,
                   log_w_mem_mask_misaligned
                     (pAddrIdx,(pAddr,(mask,(data,(align,(old,new)))))))
                    ::
                    (!log))
               )
             end
      else let
             val dw_old =
               BitsN.@@(MEM(BitsN.+(pAddrIdx,BitsN.B(0x1,61))),old)
             val dw_data =
               BitsN.<<(BitsN.zeroExtend 128 data,Nat.*(align,8))
             val dw_mask =
               BitsN.<<(BitsN.zeroExtend 128 mask,Nat.*(align,8))
             val dw_new =
               BitsN.||
                 (BitsN.&&(dw_old,BitsN.~ dw_mask),
                  BitsN.&&(dw_data,dw_mask))
           in
             ( let
                 val x = BitsN.+(pAddrIdx,BitsN.B(0x1,61))
               in
                 write'MEM
                   (BitsN.resize 64
                      (BitsN.bits
                         (Nat.-(Nat.*(2,BitsN.size data),1),
                          BitsN.size data)
                         dw_new),x)
               end
             ; write'MEM
                 (BitsN.resize 64
                    (BitsN.bits(Nat.-(BitsN.size data,1),0) dw_new),
                  pAddrIdx)
             )
           end
    )
  end;

fun rawReadInst pAddr =
  let
    val pAddrIdx = BitsN.bits(63,3) pAddr
    val data = MEM pAddrIdx
  in
    ( log := ((3,log_r_mem(pAddrIdx,(pAddr,data))) :: (!log))
    ; if BitsN.bit(pAddr,2)
        then BitsN.bits(63,32) data
      else BitsN.bits(31,0) data
    )
  end;

fun rawWriteMem (pAddr,data) =
  let
    val pAddrIdx = BitsN.bits(63,3) pAddr
  in
    ( write'MEM(data,pAddrIdx)
    ; log := ((3,log_w_mem(pAddrIdx,(pAddr,data))) :: (!log))
    )
  end;

fun checkMemPermission (ft,(ac,(priv,perm))) =
  case perm of
     BitsN.B(0x0,4) =>
       raise INTERNAL_ERROR ("Checking perm on Page-Table pointer!")
   | BitsN.B(0x1,4) =>
     raise INTERNAL_ERROR ("Checking perm on Page-Table pointer!")
   | BitsN.B(0x2,4) =>
     if priv = User
       then not(ac = Write)
     else (ac = Read) andalso (ft = Data)
   | BitsN.B(0x3,4) => if priv = User then true else not(ft = Instruction)
   | BitsN.B(0x4,4) => (ac = Read) andalso (ft = Data)
   | BitsN.B(0x5,4) => not(ft = Instruction)
   | BitsN.B(0x6,4) => not(ac = Write)
   | BitsN.B(0x7,4) => true
   | BitsN.B(0x8,4) =>
     (not(priv = User)) andalso ((ac = Read) andalso (ft = Data))
   | BitsN.B(0x9,4) => (not(priv = User)) andalso (not(ft = Instruction))
   | BitsN.B(0xA,4) => (not(priv = User)) andalso (not(ac = Write))
   | BitsN.B(0xB,4) => not(priv = User)
   | BitsN.B(0xC,4) =>
     (not(priv = User)) andalso ((ac = Read) andalso (ft = Data))
   | BitsN.B(0xD,4) => (not(priv = User)) andalso (not(ft = Instruction))
   | BitsN.B(0xE,4) => (not(priv = User)) andalso (not(ac = Write))
   | BitsN.B(0xF,4) => not(priv = User)
   | _ => raise General.Bind;

fun isGlobal perm = (BitsN.bits(3,2) perm) = (BitsN.B(0x3,2));

fun rec'SV_PTE x =
  {PTE_D = BitsN.bit(x,6), PTE_PPNi = BitsN.bits(47,10) x,
   PTE_R = BitsN.bit(x,5), PTE_SW = BitsN.bits(9,7) x,
   PTE_T = BitsN.bits(4,1) x, PTE_V = BitsN.bit(x,0),
   sv_pte'rst = BitsN.bits(63,48) x};

fun reg'SV_PTE x =
  case x of
     {PTE_D = PTE_D, PTE_PPNi = PTE_PPNi, PTE_R = PTE_R, PTE_SW = PTE_SW,
      PTE_T = PTE_T, PTE_V = PTE_V, sv_pte'rst = sv_pte'rst} =>
       BitsN.concat
         [sv_pte'rst,PTE_PPNi,PTE_SW,BitsN.fromBit PTE_D,
          BitsN.fromBit PTE_R,PTE_T,BitsN.fromBit PTE_V];

fun write'rec'SV_PTE (_,x) = reg'SV_PTE x;

fun write'reg'SV_PTE (_,x) = rec'SV_PTE x;

fun rec'SV_Vaddr x =
  {Sv_PgOfs = BitsN.bits(11,0) x, Sv_VPNi = BitsN.bits(47,12) x,
   sv_vaddr'rst = BitsN.bits(63,48) x};

fun reg'SV_Vaddr x =
  case x of
     {Sv_PgOfs = Sv_PgOfs, Sv_VPNi = Sv_VPNi, sv_vaddr'rst = sv_vaddr'rst} =>
       BitsN.concat[sv_vaddr'rst,Sv_VPNi,Sv_PgOfs];

fun write'rec'SV_Vaddr (_,x) = reg'SV_Vaddr x;

fun write'reg'SV_Vaddr (_,x) = rec'SV_Vaddr x;

fun walk64 (vAddr,(ft,(ac,(priv,(ptb,level))))) =
  let
    val va = rec'SV_Vaddr vAddr
    val pt_ofs =
      BitsN.<<
        (BitsN.zeroExtend 64
           (BitsN.bits(Nat.-(LEVEL_BITS,1),0)
              (BitsN.>>+((#Sv_VPNi) va,Nat.*(level,LEVEL_BITS)))),3)
    val pte_addr = BitsN.+(ptb,pt_ofs)
    val pte = rec'SV_PTE(rawReadData pte_addr)
  in
    ( log :=
      ((4,
        String.concat
          ["translate(vaddr=0x",
           L3.padLeftString(#"0",(16,BitsN.toHexString vAddr)),
           "): level=",Nat.toString level," pt_base=0x",
           L3.padLeftString(#"0",(16,BitsN.toHexString ptb))," pt_ofs=",
           Nat.toString(BitsN.toNat pt_ofs)," pte_addr=0x",
           L3.padLeftString(#"0",(16,BitsN.toHexString pte_addr)),
           " pte=0x",
           L3.padLeftString(#"0",(16,BitsN.toHexString(reg'SV_PTE pte)))])
         ::
         (!log))
    ; if not((#PTE_V) pte)
        then ( log := ((4,"addr_translate: invalid PTE") :: (!log))
             ; NONE
             )
      else if (((#PTE_T) pte) = (BitsN.B(0x0,4))) orelse
         (((#PTE_T) pte) = (BitsN.B(0x1,4)))
        then if level = 0
               then ( log :=
                      ((4,"last-level pt contains a pointer PTE!")
                         ::
                         (!log))
                    ; NONE
                    )
             else walk64
                    (vAddr,
                     (ft,
                      (ac,
                       (priv,
                        (BitsN.zeroExtend 64
                           (BitsN.<<((#PTE_PPNi) pte,PAGESIZE_BITS)),
                         Nat.-(level,1))))))
      else if not(checkMemPermission(ft,(ac,(priv,(#PTE_T) pte))))
        then ( log := ((4,"PTE permission check failure!") :: (!log))
             ; NONE
             )
      else let
             val pte_w = ref pte
           in
             let
               val old_r = (#PTE_R) pte
               val old_d = (#PTE_D) pte
             in
               ( pte_w := (SV_PTE_PTE_R_rupd((!pte_w),true))
               ; if ac = Write
                   then pte_w := (SV_PTE_PTE_D_rupd((!pte_w),true))
                 else ()
               ; if (not(old_r = ((#PTE_R) (!pte_w)))) orelse
                    (not(old_d = ((#PTE_D) (!pte_w))))
                   then rawWriteData(pte_addr,(reg'SV_PTE (!pte_w),8))
                 else ()
               ; let
                   val ppn =
                     if Nat.>(level,0)
                       then BitsN.||
                              (BitsN.zeroExtend 38
                                 (BitsN.<<
                                    (BitsN.>>+
                                       ((#PTE_PPNi) pte,
                                        Nat.*(level,LEVEL_BITS)),
                                     Nat.*(level,LEVEL_BITS))),
                               BitsN.zeroExtend 38
                                 (BitsN.&&
                                    ((#Sv_VPNi) va,
                                     BitsN.-
                                       (BitsN.<<
                                          (BitsN.B(0x1,36),
                                           Nat.*(level,LEVEL_BITS)),
                                        BitsN.B(0x1,36)))))
                     else (#PTE_PPNi) pte
                 in
                   Option.SOME
                     (BitsN.zeroExtend 64 (BitsN.@@(ppn,(#Sv_PgOfs) va)),
                      ((!pte_w),(level,(isGlobal((#PTE_T) pte),pte_addr))))
                 end
               )
             end
           end
    )
  end;

fun curASID () = BitsN.bits(Nat.-(ASID_SIZE,1),0) ((#sasid)(SCSR ()));

fun mkTLBEntry (asid,(global,(vAddr,(pAddr,(pte,(i,pteAddr)))))) =
  let
    val ent = ref {age = BitsN.B(0x0,64), asid = BitsN.B(0x0,6),
     global = false, pAddr = BitsN.B(0x0,64),
     pte =
       {PTE_D = false, PTE_PPNi = BitsN.B(0x0,38), PTE_R = false,
        PTE_SW = BitsN.B(0x0,3), PTE_T = BitsN.B(0x0,4), PTE_V = false,
        sv_pte'rst = BitsN.B(0x0,16)}, pteAddr = BitsN.B(0x0,64),
     vAddr = BitsN.B(0x0,64), vAddrMask = BitsN.B(0x0,64),
     vMatchMask = BitsN.B(0x0,64)}
  in
    ( ent := (TLBEntry_asid_rupd((!ent),asid))
    ; ent := (TLBEntry_global_rupd((!ent),global))
    ; ent := (TLBEntry_pte_rupd((!ent),pte))
    ; ent := (TLBEntry_pteAddr_rupd((!ent),pteAddr))
    ; ent :=
      (TLBEntry_vAddrMask_rupd
         ((!ent),
          BitsN.-
            (BitsN.<<
               (BitsN.B(0x1,64),Nat.+(Nat.*(LEVEL_BITS,i),PAGESIZE_BITS)),
             BitsN.B(0x1,64))))
    ; ent :=
      (TLBEntry_vMatchMask_rupd
         ((!ent),
          BitsN.??
            (BitsN.signExtend 64 (BitsN.B(0x1,1)),(#vAddrMask) (!ent))))
    ; ent :=
      (TLBEntry_vAddr_rupd((!ent),BitsN.&&(vAddr,(#vMatchMask) (!ent))))
    ; ent :=
      (TLBEntry_pAddr_rupd
         ((!ent),
          BitsN.<<
            (BitsN.>>(pAddr,Nat.+(PAGESIZE_BITS,Nat.*(LEVEL_BITS,i))),
             Nat.+(PAGESIZE_BITS,Nat.*(LEVEL_BITS,i)))))
    ; ent :=
      (TLBEntry_age_rupd
         ((!ent),Map.lookup((!c_cycles),BitsN.toNat (!procID))))
    ; (!ent)
    )
  end;

val TLBEntries = 16

fun lookupTLB (asid,(vAddr,tlb)) =
  let
    val ent = ref NONE
  in
    ( L3.for
        (0,Nat.-(TLBEntries,1),
         fn i =>
           case Map.lookup(tlb,BitsN.toNat(BitsN.fromNat(i,4))) of
              Option.SOME e =>
                (if ((!ent) = NONE) andalso
                    ((((#global) e) orelse (((#asid) e) = asid)) andalso
                     (((#vAddr) e) = (BitsN.&&(vAddr,(#vMatchMask) e))))
                   then ent := (Option.SOME(e,BitsN.fromNat(i,4)))
                 else ())
            | NONE => ())
    ; (!ent)
    )
  end;

fun addToTLB (asid,(vAddr,(pAddr,(pte,(pteAddr,(i,(global,curTLB))))))) =
  Map.copy
    (let
       val ent = ref (mkTLBEntry
          (asid,(global,(vAddr,(pAddr,(pte,(i,pteAddr)))))))
     in
       let
         val tlb = ref (Map.copy curTLB)
       in
         let
           val oldest = ref (BitsN.signExtend 64 (BitsN.B(0x1,1)))
         in
           let
             val addIdx = ref 0
           in
             let
               val added = ref false
             in
               ( L3.for
                   (0,Nat.-(TLBEntries,1),
                    fn i =>
                      case Map.lookup
                        ((!tlb),BitsN.toNat(BitsN.fromNat(i,4))) of
                         Option.SOME e =>
                           (if BitsN.<+((#age) e,(!oldest))
                              then ( oldest := ((#age) e); addIdx := i )
                            else ())
                       | NONE =>
                         if not (!added)
                           then ( let
                                    val x = BitsN.fromNat(i,4)
                                  in
                                    tlb :=
                                    (Map.update
                                       ((!tlb),BitsN.toNat x,
                                        Option.SOME (!ent)))
                                  end
                                ; added := true
                                )
                         else ())
               ; if not (!added)
                   then let
                          val x = BitsN.fromNat((!addIdx),4)
                        in
                          tlb :=
                          (Map.update
                             ((!tlb),BitsN.toNat x,Option.SOME (!ent)))
                        end
                 else ()
               ; (!tlb)
               )
             end
           end
         end
       end
     end);

fun flushTLB (asid,(addr,curTLB)) =
  Map.copy
    (let
       val tlb = ref (Map.copy curTLB)
     in
       ( L3.for
           (0,Nat.-(TLBEntries,1),
            fn i =>
              case (Map.lookup((!tlb),BitsN.toNat(BitsN.fromNat(i,4))),
               addr) of
                 (Option.SOME e,Option.SOME va) =>
                   (if ((asid = (BitsN.B(0x0,6))) orelse
                        ((asid = ((#asid) e)) andalso (not((#global) e)))) andalso
                       (((#vAddr) e) = (BitsN.&&(va,(#vMatchMask) e)))
                      then let
                             val x = BitsN.fromNat(i,4)
                           in
                             tlb :=
                             (Map.update((!tlb),BitsN.toNat x,NONE))
                           end
                    else ())
               | (Option.SOME e,NONE) =>
                 (if (asid = (BitsN.B(0x0,6))) orelse
                     ((asid = ((#asid) e)) andalso (not((#global) e)))
                    then let
                           val x = BitsN.fromNat(i,4)
                         in
                           tlb := (Map.update((!tlb),BitsN.toNat x,NONE))
                         end
                  else ())
               | (NONE,_) => ())
       ; (!tlb)
       )
     end);

fun TLB () = Map.copy(Map.lookup((!c_tlb),BitsN.toNat (!procID)));

fun write'TLB value =
  c_tlb := (Map.update((!c_tlb),BitsN.toNat (!procID),Map.copy value));

fun translate64 (vAddr,(ft,(ac,(priv,level)))) =
  let
    val asid = curASID ()
  in
    case lookupTLB(asid,(vAddr,TLB ())) of
       Option.SOME(e,idx) =>
         (if checkMemPermission(ft,(ac,(priv,(#PTE_T)((#pte) e))))
            then ( log := ((4,"TLB hit!") :: (!log))
                 ; if (ac = Write) andalso (not((#PTE_D)((#pte) e)))
                     then let
                            val ent = ref e
                          in
                            ( let
                                val x0 = (#pte) (!ent)
                              in
                                ent :=
                                (TLBEntry_pte_rupd
                                   ((!ent),SV_PTE_PTE_D_rupd(x0,true)))
                              end
                            ; rawWriteData
                                ((#pteAddr) (!ent),
                                 (reg'SV_PTE((#pte) (!ent)),8))
                            ; let
                                val tlb = ref (Map.copy(TLB ()))
                              in
                                ( let
                                    val x = idx
                                  in
                                    tlb :=
                                    (Map.update
                                       ((!tlb),BitsN.toNat x,
                                        Option.SOME (!ent)))
                                  end
                                ; write'TLB (!tlb)
                                )
                              end
                            )
                          end
                   else ()
                 ; Option.SOME
                     (BitsN.||((#pAddr) e,BitsN.&&(vAddr,(#vAddrMask) e)))
                 )
          else ( log := ((4,"TLB permission check failure") :: (!log))
               ; NONE
               ))
     | NONE =>
       ( log := ((4,"TLB miss!") :: (!log))
       ; case walk64(vAddr,(ft,(ac,(priv,((#sptbr)(SCSR ()),level))))) of
            Option.SOME(pAddr,(pte,(i,(global,pteAddr)))) =>
              ( write'TLB
                  (addToTLB
                     (asid,
                      (vAddr,(pAddr,(pte,(pteAddr,(i,(global,TLB ()))))))))
              ; Option.SOME pAddr
              )
          | NONE => NONE
       )
  end;

fun translateAddr (vAddr,(ft,ac)) =
  let
    val priv =
      privilege
        (if ((#MMPRV)((#mstatus)(MCSR ()))) andalso (ft = Data)
           then (#MPRV1)((#mstatus)(MCSR ()))
         else (#MPRV)((#mstatus)(MCSR ())))
  in
    case (vmType((#VM)((#mstatus)(MCSR ()))),priv) of
       (Mbare,_) => Option.SOME vAddr
     | (_,Machine) => Option.SOME vAddr
     | (Sv39,_) => translate64(vAddr,(ft,(ac,(priv,2))))
     | (Sv48,_) => translate64(vAddr,(ft,(ac,(priv,3))))
     | _ => NONE
  end;

fun matchLoadReservation vAddr =
  (Option.isSome(ReserveLoad ())) andalso
  ((Option.valOf(ReserveLoad ())) = vAddr);

fun branchTo newPC =
  ( write'NextFetch(Option.SOME(BranchTo newPC))
  ; let
      val x = Delta ()
    in
      write'Delta(StateDelta_addr_rupd(x,Option.SOME newPC))
    end
  );

fun dfn'ADDI (rd,(rs1,imm)) =
  ( write'GPR(BitsN.+(GPR rs1,BitsN.signExtend 64 imm),rd)
  ; let
      val x = Delta ()
    in
      write'Delta
        (StateDelta_data1_rupd
           (x,Option.SOME(BitsN.+(GPR rs1,BitsN.signExtend 64 imm))))
    end
  );

fun dfn'ADDIW (rd,(rs1,imm)) =
  if in32BitMode ()
    then signalException Illegal_Instr
  else let
         val temp = BitsN.+(GPR rs1,BitsN.signExtend 64 imm)
       in
         ( write'GPR(BitsN.signExtend 64 (BitsN.bits(31,0) temp),rd)
         ; let
             val x = Delta ()
           in
             write'Delta
               (StateDelta_data1_rupd
                  (x,
                   Option.SOME
                     (BitsN.signExtend 64 (BitsN.bits(31,0) temp))))
           end
         )
       end;

fun dfn'SLTI (rd,(rs1,imm)) =
  let
    val v1 =
      if in32BitMode ()
        then BitsN.signExtend 64 (BitsN.bits(31,0) (GPR rs1))
      else GPR rs1
  in
    ( write'GPR
        (BitsN.fromBool 64 (BitsN.<(v1,BitsN.signExtend 64 imm)),rd)
    ; let
        val x = Delta ()
      in
        write'Delta
          (StateDelta_data1_rupd
             (x,
              Option.SOME
                (BitsN.fromBool 64 (BitsN.<(v1,BitsN.signExtend 64 imm)))))
      end
    )
  end;

fun dfn'SLTIU (rd,(rs1,imm)) =
  let
    val v1 =
      if in32BitMode ()
        then BitsN.signExtend 64 (BitsN.bits(31,0) (GPR rs1))
      else GPR rs1
  in
    ( write'GPR
        (BitsN.fromBool 64 (BitsN.<+(v1,BitsN.signExtend 64 imm)),rd)
    ; let
        val x = Delta ()
      in
        write'Delta
          (StateDelta_data1_rupd
             (x,
              Option.SOME
                (BitsN.fromBool 64 (BitsN.<+(v1,BitsN.signExtend 64 imm)))))
      end
    )
  end;

fun dfn'ANDI (rd,(rs1,imm)) =
  ( write'GPR(BitsN.&&(GPR rs1,BitsN.signExtend 64 imm),rd)
  ; let
      val x = Delta ()
    in
      write'Delta
        (StateDelta_data1_rupd
           (x,Option.SOME(BitsN.&&(GPR rs1,BitsN.signExtend 64 imm))))
    end
  );

fun dfn'ORI (rd,(rs1,imm)) =
  ( write'GPR(BitsN.||(GPR rs1,BitsN.signExtend 64 imm),rd)
  ; let
      val x = Delta ()
    in
      write'Delta
        (StateDelta_data1_rupd
           (x,Option.SOME(BitsN.||(GPR rs1,BitsN.signExtend 64 imm))))
    end
  );

fun dfn'XORI (rd,(rs1,imm)) =
  ( write'GPR(BitsN.??(GPR rs1,BitsN.signExtend 64 imm),rd)
  ; let
      val x = Delta ()
    in
      write'Delta
        (StateDelta_data1_rupd
           (x,Option.SOME(BitsN.??(GPR rs1,BitsN.signExtend 64 imm))))
    end
  );

fun dfn'SLLI (rd,(rs1,imm)) =
  if (in32BitMode ()) andalso (BitsN.bit(imm,5))
    then signalException Illegal_Instr
  else ( write'GPR(BitsN.<<(GPR rs1,BitsN.toNat imm),rd)
       ; let
           val x = Delta ()
         in
           write'Delta
             (StateDelta_data1_rupd
                (x,Option.SOME(BitsN.<<(GPR rs1,BitsN.toNat imm))))
         end
       );

fun dfn'SRLI (rd,(rs1,imm)) =
  if (in32BitMode ()) andalso (BitsN.bit(imm,5))
    then signalException Illegal_Instr
  else let
         val v1 =
           if in32BitMode ()
             then BitsN.zeroExtend 64 (BitsN.bits(31,0) (GPR rs1))
           else GPR rs1
       in
         ( write'GPR(BitsN.>>+(v1,BitsN.toNat imm),rd)
         ; let
             val x = Delta ()
           in
             write'Delta
               (StateDelta_data1_rupd
                  (x,Option.SOME(BitsN.>>+(v1,BitsN.toNat imm))))
           end
         )
       end;

fun dfn'SRAI (rd,(rs1,imm)) =
  if (in32BitMode ()) andalso (BitsN.bit(imm,5))
    then signalException Illegal_Instr
  else let
         val v1 =
           if in32BitMode ()
             then BitsN.signExtend 64 (BitsN.bits(31,0) (GPR rs1))
           else GPR rs1
       in
         ( write'GPR(BitsN.>>(v1,BitsN.toNat imm),rd)
         ; let
             val x = Delta ()
           in
             write'Delta
               (StateDelta_data1_rupd
                  (x,Option.SOME(BitsN.>>(v1,BitsN.toNat imm))))
           end
         )
       end;

fun dfn'SLLIW (rd,(rs1,imm)) =
  if in32BitMode ()
    then signalException Illegal_Instr
  else ( write'GPR
           (BitsN.signExtend 64
              (BitsN.<<(BitsN.bits(31,0) (GPR rs1),BitsN.toNat imm)),rd)
       ; let
           val x = Delta ()
         in
           write'Delta
             (StateDelta_data1_rupd
                (x,
                 Option.SOME
                   (BitsN.signExtend 64
                      (BitsN.<<
                         (BitsN.bits(31,0) (GPR rs1),BitsN.toNat imm)))))
         end
       );

fun dfn'SRLIW (rd,(rs1,imm)) =
  if in32BitMode ()
    then signalException Illegal_Instr
  else ( write'GPR
           (BitsN.signExtend 64
              (BitsN.>>+(BitsN.bits(31,0) (GPR rs1),BitsN.toNat imm)),rd)
       ; let
           val x = Delta ()
         in
           write'Delta
             (StateDelta_data1_rupd
                (x,
                 Option.SOME
                   (BitsN.signExtend 64
                      (BitsN.>>+
                         (BitsN.bits(31,0) (GPR rs1),BitsN.toNat imm)))))
         end
       );

fun dfn'SRAIW (rd,(rs1,imm)) =
  if in32BitMode ()
    then signalException Illegal_Instr
  else ( write'GPR
           (BitsN.signExtend 64
              (BitsN.>>(BitsN.bits(31,0) (GPR rs1),BitsN.toNat imm)),rd)
       ; let
           val x = Delta ()
         in
           write'Delta
             (StateDelta_data1_rupd
                (x,
                 Option.SOME
                   (BitsN.signExtend 64
                      (BitsN.>>
                         (BitsN.bits(31,0) (GPR rs1),BitsN.toNat imm)))))
         end
       );

fun dfn'LUI (rd,imm) =
  ( write'GPR(BitsN.signExtend 64 (BitsN.@@(imm,BitsN.B(0x0,12))),rd)
  ; let
      val x = Delta ()
    in
      write'Delta
        (StateDelta_data1_rupd
           (x,
            Option.SOME
              (BitsN.signExtend 64 (BitsN.@@(imm,BitsN.B(0x0,12))))))
    end
  );

fun dfn'AUIPC (rd,imm) =
  ( write'GPR
      (BitsN.+(PC (),BitsN.signExtend 64 (BitsN.@@(imm,BitsN.B(0x0,12)))),
       rd)
  ; let
      val x = Delta ()
    in
      write'Delta
        (StateDelta_data1_rupd
           (x,
            Option.SOME
              (BitsN.+
                 (PC (),
                  BitsN.signExtend 64 (BitsN.@@(imm,BitsN.B(0x0,12)))))))
    end
  );

fun dfn'ADD (rd,(rs1,rs2)) =
  ( write'GPR(BitsN.+(GPR rs1,GPR rs2),rd)
  ; let
      val x = Delta ()
    in
      write'Delta
        (StateDelta_data1_rupd(x,Option.SOME(BitsN.+(GPR rs1,GPR rs2))))
    end
  );

fun dfn'ADDW (rd,(rs1,rs2)) =
  if in32BitMode ()
    then signalException Illegal_Instr
  else ( write'GPR
           (BitsN.signExtend 64
              (BitsN.+
                 (BitsN.bits(31,0) (GPR rs1),BitsN.bits(31,0) (GPR rs2))),
            rd)
       ; let
           val x = Delta ()
         in
           write'Delta
             (StateDelta_data1_rupd
                (x,
                 Option.SOME
                   (BitsN.signExtend 64
                      (BitsN.+
                         (BitsN.bits(31,0) (GPR rs1),
                          BitsN.bits(31,0) (GPR rs2))))))
         end
       );

fun dfn'SUB (rd,(rs1,rs2)) =
  ( write'GPR(BitsN.-(GPR rs1,GPR rs2),rd)
  ; let
      val x = Delta ()
    in
      write'Delta
        (StateDelta_data1_rupd(x,Option.SOME(BitsN.-(GPR rs1,GPR rs2))))
    end
  );

fun dfn'SUBW (rd,(rs1,rs2)) =
  if in32BitMode ()
    then signalException Illegal_Instr
  else ( write'GPR
           (BitsN.signExtend 64
              (BitsN.-
                 (BitsN.bits(31,0) (GPR rs1),BitsN.bits(31,0) (GPR rs2))),
            rd)
       ; let
           val x = Delta ()
         in
           write'Delta
             (StateDelta_data1_rupd
                (x,
                 Option.SOME
                   (BitsN.signExtend 64
                      (BitsN.-
                         (BitsN.bits(31,0) (GPR rs1),
                          BitsN.bits(31,0) (GPR rs2))))))
         end
       );

fun dfn'SLT (rd,(rs1,rs2)) =
  let
    val v1 =
      if in32BitMode ()
        then BitsN.signExtend 64 (BitsN.bits(31,0) (GPR rs1))
      else GPR rs1
    val v2 =
      if in32BitMode ()
        then BitsN.signExtend 64 (BitsN.bits(31,0) (GPR rs2))
      else GPR rs2
  in
    ( write'GPR(BitsN.fromBool 64 (BitsN.<(v1,v2)),rd)
    ; let
        val x = Delta ()
      in
        write'Delta
          (StateDelta_data1_rupd
             (x,Option.SOME(BitsN.fromBool 64 (BitsN.<(v1,v2)))))
      end
    )
  end;

fun dfn'SLTU (rd,(rs1,rs2)) =
  let
    val v1 =
      if in32BitMode ()
        then BitsN.zeroExtend 64 (BitsN.bits(31,0) (GPR rs1))
      else GPR rs1
    val v2 =
      if in32BitMode ()
        then BitsN.zeroExtend 64 (BitsN.bits(31,0) (GPR rs2))
      else GPR rs2
  in
    ( write'GPR(BitsN.fromBool 64 (BitsN.<+(v1,v2)),rd)
    ; let
        val x = Delta ()
      in
        write'Delta
          (StateDelta_data1_rupd
             (x,Option.SOME(BitsN.fromBool 64 (BitsN.<+(v1,v2)))))
      end
    )
  end;

fun dfn'AND (rd,(rs1,rs2)) =
  ( write'GPR(BitsN.&&(GPR rs1,GPR rs2),rd)
  ; let
      val x = Delta ()
    in
      write'Delta
        (StateDelta_data1_rupd(x,Option.SOME(BitsN.&&(GPR rs1,GPR rs2))))
    end
  );

fun dfn'OR (rd,(rs1,rs2)) =
  ( write'GPR(BitsN.||(GPR rs1,GPR rs2),rd)
  ; let
      val x = Delta ()
    in
      write'Delta
        (StateDelta_data1_rupd(x,Option.SOME(BitsN.||(GPR rs1,GPR rs2))))
    end
  );

fun dfn'XOR (rd,(rs1,rs2)) =
  ( write'GPR(BitsN.??(GPR rs1,GPR rs2),rd)
  ; let
      val x = Delta ()
    in
      write'Delta
        (StateDelta_data1_rupd(x,Option.SOME(BitsN.??(GPR rs1,GPR rs2))))
    end
  );

fun dfn'SLL (rd,(rs1,rs2)) =
  if in32BitMode ()
    then ( write'GPR
             (BitsN.<<^
                (GPR rs1,BitsN.zeroExtend 64 (BitsN.bits(4,0) (GPR rs2))),
              rd)
         ; let
             val x = Delta ()
           in
             write'Delta
               (StateDelta_data1_rupd
                  (x,
                   Option.SOME
                     (BitsN.<<^
                        (GPR rs1,
                         BitsN.zeroExtend 64 (BitsN.bits(4,0) (GPR rs2))))))
           end
         )
  else ( write'GPR
           (BitsN.<<^
              (GPR rs1,BitsN.zeroExtend 64 (BitsN.bits(5,0) (GPR rs2))),rd)
       ; let
           val x = Delta ()
         in
           write'Delta
             (StateDelta_data1_rupd
                (x,
                 Option.SOME
                   (BitsN.<<^
                      (GPR rs1,
                       BitsN.zeroExtend 64 (BitsN.bits(5,0) (GPR rs2))))))
         end
       );

fun dfn'SLLW (rd,(rs1,rs2)) =
  if in32BitMode ()
    then signalException Illegal_Instr
  else ( write'GPR
           (BitsN.signExtend 64
              (BitsN.<<^
                 (BitsN.bits(31,0) (GPR rs1),
                  BitsN.zeroExtend 32 (BitsN.bits(4,0) (GPR rs2)))),rd)
       ; let
           val x = Delta ()
         in
           write'Delta
             (StateDelta_data1_rupd
                (x,
                 Option.SOME
                   (BitsN.signExtend 64
                      (BitsN.<<^
                         (BitsN.bits(31,0) (GPR rs1),
                          BitsN.zeroExtend 32 (BitsN.bits(4,0) (GPR rs2)))))))
         end
       );

fun dfn'SRL (rd,(rs1,rs2)) =
  if in32BitMode ()
    then ( write'GPR
             (BitsN.zeroExtend 64
                (BitsN.>>+^
                   (BitsN.bits(31,0) (GPR rs1),
                    BitsN.zeroExtend 32 (BitsN.bits(4,0) (GPR rs2)))),rd)
         ; let
             val x = Delta ()
           in
             write'Delta
               (StateDelta_data1_rupd
                  (x,
                   Option.SOME
                     (BitsN.zeroExtend 64
                        (BitsN.>>+^
                           (BitsN.bits(31,0) (GPR rs1),
                            BitsN.zeroExtend 32
                              (BitsN.bits(4,0) (GPR rs2)))))))
           end
         )
  else ( write'GPR
           (BitsN.>>+^
              (GPR rs1,BitsN.zeroExtend 64 (BitsN.bits(5,0) (GPR rs2))),rd)
       ; let
           val x = Delta ()
         in
           write'Delta
             (StateDelta_data1_rupd
                (x,
                 Option.SOME
                   (BitsN.>>+^
                      (GPR rs1,
                       BitsN.zeroExtend 64 (BitsN.bits(5,0) (GPR rs2))))))
         end
       );

fun dfn'SRLW (rd,(rs1,rs2)) =
  if in32BitMode ()
    then signalException Illegal_Instr
  else ( write'GPR
           (BitsN.signExtend 64
              (BitsN.>>+^
                 (BitsN.bits(31,0) (GPR rs1),
                  BitsN.zeroExtend 32 (BitsN.bits(4,0) (GPR rs2)))),rd)
       ; let
           val x = Delta ()
         in
           write'Delta
             (StateDelta_data1_rupd
                (x,
                 Option.SOME
                   (BitsN.signExtend 64
                      (BitsN.>>+^
                         (BitsN.bits(31,0) (GPR rs1),
                          BitsN.zeroExtend 32 (BitsN.bits(4,0) (GPR rs2)))))))
         end
       );

fun dfn'SRA (rd,(rs1,rs2)) =
  if in32BitMode ()
    then ( write'GPR
             (BitsN.signExtend 64
                (BitsN.>>^
                   (BitsN.bits(31,0) (GPR rs1),
                    BitsN.zeroExtend 32 (BitsN.bits(4,0) (GPR rs2)))),rd)
         ; let
             val x = Delta ()
           in
             write'Delta
               (StateDelta_data1_rupd
                  (x,
                   Option.SOME
                     (BitsN.signExtend 64
                        (BitsN.>>^
                           (BitsN.bits(31,0) (GPR rs1),
                            BitsN.zeroExtend 32
                              (BitsN.bits(4,0) (GPR rs2)))))))
           end
         )
  else ( write'GPR
           (BitsN.>>^
              (GPR rs1,BitsN.zeroExtend 64 (BitsN.bits(5,0) (GPR rs2))),rd)
       ; let
           val x = Delta ()
         in
           write'Delta
             (StateDelta_data1_rupd
                (x,
                 Option.SOME
                   (BitsN.>>^
                      (GPR rs1,
                       BitsN.zeroExtend 64 (BitsN.bits(5,0) (GPR rs2))))))
         end
       );

fun dfn'SRAW (rd,(rs1,rs2)) =
  if in32BitMode ()
    then signalException Illegal_Instr
  else ( write'GPR
           (BitsN.signExtend 64
              (BitsN.>>^
                 (BitsN.bits(31,0) (GPR rs1),
                  BitsN.zeroExtend 32 (BitsN.bits(4,0) (GPR rs2)))),rd)
       ; let
           val x = Delta ()
         in
           write'Delta
             (StateDelta_data1_rupd
                (x,
                 Option.SOME
                   (BitsN.signExtend 64
                      (BitsN.>>^
                         (BitsN.bits(31,0) (GPR rs1),
                          BitsN.zeroExtend 32 (BitsN.bits(4,0) (GPR rs2)))))))
         end
       );

fun dfn'MUL (rd,(rs1,rs2)) =
  ( write'GPR(BitsN.*(GPR rs1,GPR rs2),rd)
  ; let
      val x = Delta ()
    in
      write'Delta
        (StateDelta_data1_rupd(x,Option.SOME(BitsN.*(GPR rs1,GPR rs2))))
    end
  );

fun dfn'MULH (rd,(rs1,rs2)) =
  let
    val v1 =
      if in32BitMode ()
        then BitsN.signExtend 64 (BitsN.bits(31,0) (GPR rs1))
      else GPR rs1
    val v2 =
      if in32BitMode ()
        then BitsN.signExtend 64 (BitsN.bits(31,0) (GPR rs2))
      else GPR rs2
    val prod = BitsN.*(BitsN.signExtend 128 v1,BitsN.signExtend 128 v2)
    val res =
      if in32BitMode ()
        then BitsN.signExtend 64 (BitsN.bits(63,32) prod)
      else BitsN.signExtend 64 (BitsN.bits(127,64) prod)
  in
    ( write'GPR(res,rd)
    ; let
        val x = Delta ()
      in
        write'Delta(StateDelta_data1_rupd(x,Option.SOME res))
      end
    )
  end;

fun dfn'MULHU (rd,(rs1,rs2)) =
  let
    val v1 =
      if in32BitMode ()
        then BitsN.zeroExtend 128 (BitsN.bits(31,0) (GPR rs1))
      else BitsN.zeroExtend 128 (GPR rs1)
    val v2 =
      if in32BitMode ()
        then BitsN.zeroExtend 128 (BitsN.bits(31,0) (GPR rs2))
      else BitsN.zeroExtend 128 (GPR rs2)
    val prod = BitsN.*(v1,v2)
    val res =
      if in32BitMode ()
        then BitsN.zeroExtend 64 (BitsN.bits(63,32) prod)
      else BitsN.bits(127,64) prod
  in
    ( write'GPR(res,rd)
    ; let
        val x = Delta ()
      in
        write'Delta(StateDelta_data1_rupd(x,Option.SOME res))
      end
    )
  end;

fun dfn'MULHSU (rd,(rs1,rs2)) =
  let
    val v1 =
      if in32BitMode ()
        then BitsN.signExtend 128 (BitsN.bits(31,0) (GPR rs1))
      else BitsN.signExtend 128 (GPR rs1)
    val v2 =
      if in32BitMode ()
        then BitsN.zeroExtend 128 (BitsN.bits(31,0) (GPR rs2))
      else BitsN.zeroExtend 128 (GPR rs2)
    val prod = BitsN.*(v1,v2)
    val res =
      if in32BitMode ()
        then BitsN.signExtend 64 (BitsN.bits(63,32) prod)
      else BitsN.bits(127,64) prod
  in
    ( write'GPR(res,rd)
    ; let
        val x = Delta ()
      in
        write'Delta(StateDelta_data1_rupd(x,Option.SOME res))
      end
    )
  end;

fun dfn'MULW (rd,(rs1,rs2)) =
  if in32BitMode ()
    then signalException Illegal_Instr
  else let
         val prod =
           BitsN.signExtend 64
             (BitsN.*
                (BitsN.bits(31,0) (GPR rs1),BitsN.bits(31,0) (GPR rs2)))
       in
         ( write'GPR(BitsN.signExtend 64 (BitsN.bits(31,0) prod),rd)
         ; let
             val x = Delta ()
           in
             write'Delta
               (StateDelta_data1_rupd
                  (x,
                   Option.SOME
                     (BitsN.signExtend 64 (BitsN.bits(31,0) prod))))
           end
         )
       end;

fun dfn'DIV (rd,(rs1,rs2)) =
  if (GPR rs2) = (BitsN.B(0x0,64))
    then ( write'GPR(BitsN.signExtend 64 (BitsN.B(0x1,1)),rd)
         ; let
             val x = Delta ()
           in
             write'Delta
               (StateDelta_data1_rupd
                  (x,Option.SOME(BitsN.signExtend 64 (BitsN.B(0x1,1)))))
           end
         )
  else let
         val minus_one = BitsN.signExtend 64 (BitsN.B(0x1,1))
         val minus_max =
           BitsN.<<(BitsN.B(0x1,64),Nat.-(BitsN.size(GPR rs1),1))
       in
         if ((GPR rs1) = minus_max) andalso ((GPR rs2) = minus_one)
           then ( write'GPR(minus_max,rd)
                ; let
                    val x = Delta ()
                  in
                    write'Delta
                      (StateDelta_data1_rupd(x,Option.SOME minus_max))
                  end
                )
         else ( write'GPR(BitsN.quot(GPR rs1,GPR rs2),rd)
              ; let
                  val x = Delta ()
                in
                  write'Delta
                    (StateDelta_data1_rupd
                       (x,Option.SOME(BitsN.quot(GPR rs1,GPR rs2))))
                end
              )
       end;

fun dfn'REM (rd,(rs1,rs2)) =
  if (GPR rs2) = (BitsN.B(0x0,64))
    then ( write'GPR(GPR rs1,rd)
         ; let
             val x = Delta ()
           in
             write'Delta(StateDelta_data1_rupd(x,Option.SOME(GPR rs1)))
           end
         )
  else let
         val minus_one = BitsN.signExtend 64 (BitsN.B(0x1,1))
         val minus_max =
           BitsN.<<(BitsN.B(0x1,64),Nat.-(BitsN.size(GPR rs1),1))
       in
         if ((GPR rs1) = minus_max) andalso ((GPR rs2) = minus_one)
           then ( write'GPR(BitsN.B(0x0,64),rd)
                ; let
                    val x = Delta ()
                  in
                    write'Delta
                      (StateDelta_data1_rupd
                         (x,Option.SOME(BitsN.B(0x0,64))))
                  end
                )
         else ( write'GPR(BitsN.rem(GPR rs1,GPR rs2),rd)
              ; let
                  val x = Delta ()
                in
                  write'Delta
                    (StateDelta_data1_rupd
                       (x,Option.SOME(BitsN.rem(GPR rs1,GPR rs2))))
                end
              )
       end;

fun dfn'DIVU (rd,(rs1,rs2)) =
  let
    val v1 =
      if in32BitMode ()
        then BitsN.zeroExtend 64 (BitsN.bits(31,0) (GPR rs1))
      else GPR rs1
    val v2 =
      if in32BitMode ()
        then BitsN.zeroExtend 64 (BitsN.bits(31,0) (GPR rs2))
      else GPR rs2
  in
    if v2 = (BitsN.B(0x0,64))
      then ( write'GPR(BitsN.signExtend 64 (BitsN.B(0x1,1)),rd)
           ; let
               val x = Delta ()
             in
               write'Delta
                 (StateDelta_data1_rupd
                    (x,Option.SOME(BitsN.signExtend 64 (BitsN.B(0x1,1)))))
             end
           )
    else ( write'GPR(BitsN.div(v1,v2),rd)
         ; let
             val x = Delta ()
           in
             write'Delta
               (StateDelta_data1_rupd(x,Option.SOME(BitsN.div(v1,v2))))
           end
         )
  end;

fun dfn'REMU (rd,(rs1,rs2)) =
  if (GPR rs2) = (BitsN.B(0x0,64))
    then ( write'GPR(GPR rs1,rd)
         ; let
             val x = Delta ()
           in
             write'Delta(StateDelta_data1_rupd(x,Option.SOME(GPR rs1)))
           end
         )
  else ( write'GPR(BitsN.mod(GPR rs1,GPR rs2),rd)
       ; let
           val x = Delta ()
         in
           write'Delta
             (StateDelta_data1_rupd
                (x,Option.SOME(BitsN.mod(GPR rs1,GPR rs2))))
         end
       );

fun dfn'DIVW (rd,(rs1,rs2)) =
  if in32BitMode ()
    then signalException Illegal_Instr
  else let
         val s1 = BitsN.bits(31,0) (GPR rs1)
         val s2 = BitsN.bits(31,0) (GPR rs2)
       in
         if s2 = (BitsN.B(0x0,32))
           then ( write'GPR(BitsN.signExtend 64 (BitsN.B(0x1,1)),rd)
                ; let
                    val x = Delta ()
                  in
                    write'Delta
                      (StateDelta_data1_rupd
                         (x,
                          Option.SOME
                            (BitsN.signExtend 64 (BitsN.B(0x1,1)))))
                  end
                )
         else let
                val minus_one = BitsN.signExtend 32 (BitsN.B(0x1,1))
                val minus_max =
                  BitsN.<<(BitsN.B(0x1,32),Nat.-(BitsN.size s1,1))
              in
                if (s1 = minus_max) andalso (s2 = minus_one)
                  then ( write'GPR(BitsN.signExtend 64 minus_max,rd)
                       ; let
                           val x = Delta ()
                         in
                           write'Delta
                             (StateDelta_data1_rupd
                                (x,
                                 Option.SOME
                                   (BitsN.signExtend 64 minus_max)))
                         end
                       )
                else ( write'GPR
                         (BitsN.signExtend 64 (BitsN.quot(s1,s2)),rd)
                     ; let
                         val x = Delta ()
                       in
                         write'Delta
                           (StateDelta_data1_rupd
                              (x,
                               Option.SOME
                                 (BitsN.signExtend 64 (BitsN.quot(s1,s2)))))
                       end
                     )
              end
       end;

fun dfn'REMW (rd,(rs1,rs2)) =
  if in32BitMode ()
    then signalException Illegal_Instr
  else let
         val s1 = BitsN.bits(31,0) (GPR rs1)
         val s2 = BitsN.bits(31,0) (GPR rs2)
       in
         if s2 = (BitsN.B(0x0,32))
           then ( write'GPR(BitsN.signExtend 64 s1,rd)
                ; let
                    val x = Delta ()
                  in
                    write'Delta
                      (StateDelta_data1_rupd
                         (x,Option.SOME(BitsN.signExtend 64 s1)))
                  end
                )
         else ( write'GPR(BitsN.signExtend 64 (BitsN.rem(s1,s2)),rd)
              ; let
                  val x = Delta ()
                in
                  write'Delta
                    (StateDelta_data1_rupd
                       (x,
                        Option.SOME
                          (BitsN.signExtend 64 (BitsN.rem(s1,s2)))))
                end
              )
       end;

fun dfn'DIVUW (rd,(rs1,rs2)) =
  if in32BitMode ()
    then signalException Illegal_Instr
  else let
         val s1 = BitsN.bits(31,0) (GPR rs1)
         val s2 = BitsN.bits(31,0) (GPR rs2)
       in
         if s2 = (BitsN.B(0x0,32))
           then ( write'GPR(BitsN.signExtend 64 (BitsN.B(0x1,1)),rd)
                ; let
                    val x = Delta ()
                  in
                    write'Delta
                      (StateDelta_data1_rupd
                         (x,
                          Option.SOME
                            (BitsN.signExtend 64 (BitsN.B(0x1,1)))))
                  end
                )
         else ( write'GPR(BitsN.signExtend 64 (BitsN.div(s1,s2)),rd)
              ; let
                  val x = Delta ()
                in
                  write'Delta
                    (StateDelta_data1_rupd
                       (x,
                        Option.SOME
                          (BitsN.signExtend 64 (BitsN.div(s1,s2)))))
                end
              )
       end;

fun dfn'REMUW (rd,(rs1,rs2)) =
  if in32BitMode ()
    then signalException Illegal_Instr
  else let
         val s1 = BitsN.bits(31,0) (GPR rs1)
         val s2 = BitsN.bits(31,0) (GPR rs2)
       in
         if s2 = (BitsN.B(0x0,32))
           then ( write'GPR(BitsN.signExtend 64 s1,rd)
                ; let
                    val x = Delta ()
                  in
                    write'Delta
                      (StateDelta_data1_rupd
                         (x,Option.SOME(BitsN.signExtend 64 s1)))
                  end
                )
         else ( write'GPR(BitsN.signExtend 64 (BitsN.mod(s1,s2)),rd)
              ; let
                  val x = Delta ()
                in
                  write'Delta
                    (StateDelta_data1_rupd
                       (x,
                        Option.SOME
                          (BitsN.signExtend 64 (BitsN.mod(s1,s2)))))
                end
              )
       end;

fun dfn'JAL (rd,imm) =
  let
    val addr = BitsN.+(PC (),BitsN.<<(BitsN.signExtend 64 imm,1))
  in
    if not((BitsN.bits(1,0) addr) = (BitsN.B(0x0,2)))
      then signalAddressException(Fetch_Misaligned,addr)
    else ( ( write'GPR(BitsN.+(PC (),BitsN.B(0x4,64)),rd)
           ; let
               val x = Delta ()
             in
               write'Delta
                 (StateDelta_data1_rupd
                    (x,Option.SOME(BitsN.+(PC (),BitsN.B(0x4,64)))))
             end
           )
         ; branchTo addr
         )
  end;

fun dfn'JALR (rd,(rs1,imm)) =
  let
    val addr =
      BitsN.&&
        (BitsN.+(GPR rs1,BitsN.signExtend 64 imm),
         BitsN.signExtend 64 (BitsN.B(0x2,2)))
  in
    if not((BitsN.bits(1,0) addr) = (BitsN.B(0x0,2)))
      then signalAddressException(Fetch_Misaligned,addr)
    else ( ( write'GPR(BitsN.+(PC (),BitsN.B(0x4,64)),rd)
           ; let
               val x = Delta ()
             in
               write'Delta
                 (StateDelta_data1_rupd
                    (x,Option.SOME(BitsN.+(PC (),BitsN.B(0x4,64)))))
             end
           )
         ; branchTo addr
         )
  end;

fun dfn'BEQ (rs1,(rs2,offs)) =
  let
    val v1 =
      if in32BitMode ()
        then BitsN.signExtend 64 (BitsN.bits(31,0) (GPR rs1))
      else GPR rs1
    val v2 =
      if in32BitMode ()
        then BitsN.signExtend 64 (BitsN.bits(31,0) (GPR rs2))
      else GPR rs2
  in
    if v1 = v2
      then branchTo(BitsN.+(PC (),BitsN.<<(BitsN.signExtend 64 offs,1)))
    else let
           val x = Delta ()
         in
           write'Delta
             (StateDelta_addr_rupd
                (x,Option.SOME(BitsN.+(PC (),BitsN.B(0x4,64)))))
         end
  end;

fun dfn'BNE (rs1,(rs2,offs)) =
  let
    val v1 =
      if in32BitMode ()
        then BitsN.signExtend 64 (BitsN.bits(31,0) (GPR rs1))
      else GPR rs1
    val v2 =
      if in32BitMode ()
        then BitsN.signExtend 64 (BitsN.bits(31,0) (GPR rs2))
      else GPR rs2
  in
    if not(v1 = v2)
      then branchTo(BitsN.+(PC (),BitsN.<<(BitsN.signExtend 64 offs,1)))
    else let
           val x = Delta ()
         in
           write'Delta
             (StateDelta_addr_rupd
                (x,Option.SOME(BitsN.+(PC (),BitsN.B(0x4,64)))))
         end
  end;

fun dfn'BLT (rs1,(rs2,offs)) =
  let
    val v1 =
      if in32BitMode ()
        then BitsN.signExtend 64 (BitsN.bits(31,0) (GPR rs1))
      else GPR rs1
    val v2 =
      if in32BitMode ()
        then BitsN.signExtend 64 (BitsN.bits(31,0) (GPR rs2))
      else GPR rs2
  in
    if BitsN.<(v1,v2)
      then branchTo(BitsN.+(PC (),BitsN.<<(BitsN.signExtend 64 offs,1)))
    else let
           val x = Delta ()
         in
           write'Delta
             (StateDelta_addr_rupd
                (x,Option.SOME(BitsN.+(PC (),BitsN.B(0x4,64)))))
         end
  end;

fun dfn'BLTU (rs1,(rs2,offs)) =
  let
    val v1 =
      if in32BitMode ()
        then BitsN.signExtend 64 (BitsN.bits(31,0) (GPR rs1))
      else GPR rs1
    val v2 =
      if in32BitMode ()
        then BitsN.signExtend 64 (BitsN.bits(31,0) (GPR rs2))
      else GPR rs2
  in
    if BitsN.<+(v1,v2)
      then branchTo(BitsN.+(PC (),BitsN.<<(BitsN.signExtend 64 offs,1)))
    else let
           val x = Delta ()
         in
           write'Delta
             (StateDelta_addr_rupd
                (x,Option.SOME(BitsN.+(PC (),BitsN.B(0x4,64)))))
         end
  end;

fun dfn'BGE (rs1,(rs2,offs)) =
  let
    val v1 =
      if in32BitMode ()
        then BitsN.signExtend 64 (BitsN.bits(31,0) (GPR rs1))
      else GPR rs1
    val v2 =
      if in32BitMode ()
        then BitsN.signExtend 64 (BitsN.bits(31,0) (GPR rs2))
      else GPR rs2
  in
    if BitsN.>=(v1,v2)
      then branchTo(BitsN.+(PC (),BitsN.<<(BitsN.signExtend 64 offs,1)))
    else let
           val x = Delta ()
         in
           write'Delta
             (StateDelta_addr_rupd
                (x,Option.SOME(BitsN.+(PC (),BitsN.B(0x4,64)))))
         end
  end;

fun dfn'BGEU (rs1,(rs2,offs)) =
  let
    val v1 =
      if in32BitMode ()
        then BitsN.signExtend 64 (BitsN.bits(31,0) (GPR rs1))
      else GPR rs1
    val v2 =
      if in32BitMode ()
        then BitsN.signExtend 64 (BitsN.bits(31,0) (GPR rs2))
      else GPR rs2
  in
    if BitsN.>=+(v1,v2)
      then branchTo(BitsN.+(PC (),BitsN.<<(BitsN.signExtend 64 offs,1)))
    else let
           val x = Delta ()
         in
           write'Delta
             (StateDelta_addr_rupd
                (x,Option.SOME(BitsN.+(PC (),BitsN.B(0x4,64)))))
         end
  end;

fun dfn'LW (rd,(rs1,offs)) =
  let
    val vAddr = BitsN.+(GPR rs1,BitsN.signExtend 64 offs)
  in
    case translateAddr(vAddr,(Data,Read)) of
       Option.SOME pAddr =>
         let
           val val' =
             BitsN.signExtend 64 (BitsN.bits(31,0) (rawReadData pAddr))
         in
           ( write'GPR(val',rd)
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_addr_rupd(x,Option.SOME vAddr))
             end
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_data1_rupd(x,Option.SOME val'))
             end
           )
         end
     | NONE => signalAddressException(Load_Fault,vAddr)
  end;

fun dfn'LWU (rd,(rs1,offs)) =
  if in32BitMode ()
    then signalException Illegal_Instr
  else let
         val vAddr = BitsN.+(GPR rs1,BitsN.signExtend 64 offs)
       in
         case translateAddr(vAddr,(Data,Read)) of
            Option.SOME pAddr =>
              let
                val val' =
                  BitsN.zeroExtend 64
                    (BitsN.bits(31,0) (rawReadData pAddr))
              in
                ( write'GPR(val',rd)
                ; let
                    val x = Delta ()
                  in
                    write'Delta(StateDelta_addr_rupd(x,Option.SOME vAddr))
                  end
                ; let
                    val x = Delta ()
                  in
                    write'Delta(StateDelta_data1_rupd(x,Option.SOME val'))
                  end
                )
              end
          | NONE => signalAddressException(Load_Fault,vAddr)
       end;

fun dfn'LH (rd,(rs1,offs)) =
  let
    val vAddr = BitsN.+(GPR rs1,BitsN.signExtend 64 offs)
  in
    case translateAddr(vAddr,(Data,Read)) of
       Option.SOME pAddr =>
         let
           val val' =
             BitsN.signExtend 64 (BitsN.bits(15,0) (rawReadData pAddr))
         in
           ( write'GPR(val',rd)
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_addr_rupd(x,Option.SOME vAddr))
             end
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_data1_rupd(x,Option.SOME val'))
             end
           )
         end
     | NONE => signalAddressException(Load_Fault,vAddr)
  end;

fun dfn'LHU (rd,(rs1,offs)) =
  let
    val vAddr = BitsN.+(GPR rs1,BitsN.signExtend 64 offs)
  in
    case translateAddr(vAddr,(Data,Read)) of
       Option.SOME pAddr =>
         let
           val val' =
             BitsN.zeroExtend 64 (BitsN.bits(15,0) (rawReadData pAddr))
         in
           ( write'GPR(val',rd)
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_addr_rupd(x,Option.SOME vAddr))
             end
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_data1_rupd(x,Option.SOME val'))
             end
           )
         end
     | NONE => signalAddressException(Load_Fault,vAddr)
  end;

fun dfn'LB (rd,(rs1,offs)) =
  let
    val vAddr = BitsN.+(GPR rs1,BitsN.signExtend 64 offs)
  in
    case translateAddr(vAddr,(Data,Read)) of
       Option.SOME pAddr =>
         let
           val val' =
             BitsN.signExtend 64 (BitsN.bits(7,0) (rawReadData pAddr))
         in
           ( write'GPR(val',rd)
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_addr_rupd(x,Option.SOME vAddr))
             end
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_data1_rupd(x,Option.SOME val'))
             end
           )
         end
     | NONE => signalAddressException(Load_Fault,vAddr)
  end;

fun dfn'LBU (rd,(rs1,offs)) =
  let
    val vAddr = BitsN.+(GPR rs1,BitsN.signExtend 64 offs)
  in
    case translateAddr(vAddr,(Data,Read)) of
       Option.SOME pAddr =>
         let
           val val' =
             BitsN.zeroExtend 64 (BitsN.bits(7,0) (rawReadData pAddr))
         in
           ( write'GPR(val',rd)
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_addr_rupd(x,Option.SOME vAddr))
             end
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_data1_rupd(x,Option.SOME val'))
             end
           )
         end
     | NONE => signalAddressException(Load_Fault,vAddr)
  end;

fun dfn'LD (rd,(rs1,offs)) =
  if in32BitMode ()
    then signalException Illegal_Instr
  else let
         val vAddr = BitsN.+(GPR rs1,BitsN.signExtend 64 offs)
       in
         case translateAddr(vAddr,(Data,Read)) of
            Option.SOME pAddr =>
              let
                val val' = rawReadData pAddr
              in
                ( write'GPR(val',rd)
                ; let
                    val x = Delta ()
                  in
                    write'Delta(StateDelta_addr_rupd(x,Option.SOME vAddr))
                  end
                ; let
                    val x = Delta ()
                  in
                    write'Delta(StateDelta_data1_rupd(x,Option.SOME val'))
                  end
                )
              end
          | NONE => signalAddressException(Load_Fault,vAddr)
       end;

fun dfn'SW (rs1,(rs2,offs)) =
  let
    val vAddr = BitsN.+(GPR rs1,BitsN.signExtend 64 offs)
  in
    case translateAddr(vAddr,(Data,Write)) of
       Option.SOME pAddr =>
         let
           val data = GPR rs2
         in
           ( rawWriteData(pAddr,(data,4))
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_addr_rupd(x,Option.SOME vAddr))
             end
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_data2_rupd(x,Option.SOME data))
             end
           ; let
               val x = Delta ()
             in
               write'Delta
                 (StateDelta_st_width_rupd(x,Option.SOME(BitsN.B(0x4,32))))
             end
           )
         end
     | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'SH (rs1,(rs2,offs)) =
  let
    val vAddr = BitsN.+(GPR rs1,BitsN.signExtend 64 offs)
  in
    case translateAddr(vAddr,(Data,Write)) of
       Option.SOME pAddr =>
         let
           val data = GPR rs2
         in
           ( rawWriteData(pAddr,(data,2))
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_addr_rupd(x,Option.SOME vAddr))
             end
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_data2_rupd(x,Option.SOME data))
             end
           ; let
               val x = Delta ()
             in
               write'Delta
                 (StateDelta_st_width_rupd(x,Option.SOME(BitsN.B(0x2,32))))
             end
           )
         end
     | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'SB (rs1,(rs2,offs)) =
  let
    val vAddr = BitsN.+(GPR rs1,BitsN.signExtend 64 offs)
  in
    case translateAddr(vAddr,(Data,Write)) of
       Option.SOME pAddr =>
         let
           val data = GPR rs2
         in
           ( rawWriteData(pAddr,(data,1))
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_addr_rupd(x,Option.SOME vAddr))
             end
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_data2_rupd(x,Option.SOME data))
             end
           ; let
               val x = Delta ()
             in
               write'Delta
                 (StateDelta_st_width_rupd(x,Option.SOME(BitsN.B(0x1,32))))
             end
           )
         end
     | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'SD (rs1,(rs2,offs)) =
  if in32BitMode ()
    then signalException Illegal_Instr
  else let
         val vAddr = BitsN.+(GPR rs1,BitsN.signExtend 64 offs)
       in
         case translateAddr(vAddr,(Data,Write)) of
            Option.SOME pAddr =>
              let
                val data = GPR rs2
              in
                ( rawWriteData(pAddr,(data,8))
                ; let
                    val x = Delta ()
                  in
                    write'Delta(StateDelta_addr_rupd(x,Option.SOME vAddr))
                  end
                ; let
                    val x = Delta ()
                  in
                    write'Delta(StateDelta_data2_rupd(x,Option.SOME data))
                  end
                ; let
                    val x = Delta ()
                  in
                    write'Delta
                      (StateDelta_st_width_rupd
                         (x,Option.SOME(BitsN.B(0x8,32))))
                  end
                )
              end
          | NONE => signalAddressException(Store_AMO_Fault,vAddr)
       end;

fun dfn'FENCE (rd,(rs1,(pred,succ))) = ();

fun dfn'FENCE_I (rd,(rs1,imm)) = ();

fun dfn'LR_W (aq,(rl,(rd,rs1))) =
  let
    val vAddr = GPR rs1
  in
    if not((BitsN.bits(1,0) vAddr) = (BitsN.B(0x0,2)))
      then signalAddressException(AMO_Misaligned,vAddr)
    else case translateAddr(vAddr,(Data,Read)) of
            Option.SOME pAddr =>
              ( ( write'GPR
                    (BitsN.signExtend 64
                       (BitsN.bits(31,0) (rawReadData pAddr)),rd)
                ; let
                    val x = Delta ()
                  in
                    write'Delta
                      (StateDelta_data1_rupd
                         (x,
                          Option.SOME
                            (BitsN.signExtend 64
                               (BitsN.bits(31,0) (rawReadData pAddr)))))
                  end
                )
              ; write'ReserveLoad(Option.SOME vAddr)
              )
          | NONE => signalAddressException(Load_Fault,vAddr)
  end;

fun dfn'LR_D (aq,(rl,(rd,rs1))) =
  if in32BitMode ()
    then signalException Illegal_Instr
  else let
         val vAddr = GPR rs1
       in
         if not((BitsN.bits(2,0) vAddr) = (BitsN.B(0x0,3)))
           then signalAddressException(AMO_Misaligned,vAddr)
         else case translateAddr(vAddr,(Data,Read)) of
                 Option.SOME pAddr =>
                   ( ( write'GPR(rawReadData pAddr,rd)
                     ; let
                         val x = Delta ()
                       in
                         write'Delta
                           (StateDelta_data1_rupd
                              (x,Option.SOME(rawReadData pAddr)))
                       end
                     )
                   ; write'ReserveLoad(Option.SOME vAddr)
                   )
               | NONE => signalAddressException(Load_Fault,vAddr)
       end;

fun dfn'SC_W (aq,(rl,(rd,(rs1,rs2)))) =
  let
    val vAddr = GPR rs1
  in
    if not((BitsN.bits(1,0) vAddr) = (BitsN.B(0x0,2)))
      then signalAddressException(AMO_Misaligned,vAddr)
    else if not(matchLoadReservation vAddr)
      then ( write'GPR(BitsN.B(0x1,64),rd)
           ; let
               val x = Delta ()
             in
               write'Delta
                 (StateDelta_data1_rupd(x,Option.SOME(BitsN.B(0x1,64))))
             end
           )
    else case translateAddr(vAddr,(Data,Read)) of
            Option.SOME pAddr =>
              let
                val data = GPR rs2
              in
                ( rawWriteData(pAddr,(data,4))
                ; ( let
                      val x = Delta ()
                    in
                      write'Delta
                        (StateDelta_addr_rupd(x,Option.SOME vAddr))
                    end
                  ; let
                      val x = Delta ()
                    in
                      write'Delta
                        (StateDelta_data2_rupd(x,Option.SOME data))
                    end
                  ; let
                      val x = Delta ()
                    in
                      write'Delta
                        (StateDelta_st_width_rupd
                           (x,Option.SOME(BitsN.B(0x4,32))))
                    end
                  )
                ; ( write'GPR(BitsN.B(0x0,64),rd)
                  ; let
                      val x = Delta ()
                    in
                      write'Delta
                        (StateDelta_data1_rupd
                           (x,Option.SOME(BitsN.B(0x0,64))))
                    end
                  )
                ; write'ReserveLoad NONE
                )
              end
          | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'SC_D (aq,(rl,(rd,(rs1,rs2)))) =
  if in32BitMode ()
    then signalException Illegal_Instr
  else let
         val vAddr = GPR rs1
       in
         if not((BitsN.bits(2,0) vAddr) = (BitsN.B(0x0,3)))
           then signalAddressException(AMO_Misaligned,vAddr)
         else if not(matchLoadReservation vAddr)
           then ( write'GPR(BitsN.B(0x1,64),rd)
                ; let
                    val x = Delta ()
                  in
                    write'Delta
                      (StateDelta_data1_rupd
                         (x,Option.SOME(BitsN.B(0x1,64))))
                  end
                )
         else case translateAddr(vAddr,(Data,Read)) of
                 Option.SOME pAddr =>
                   let
                     val data = GPR rs2
                   in
                     ( rawWriteData(pAddr,(data,4))
                     ; ( let
                           val x = Delta ()
                         in
                           write'Delta
                             (StateDelta_addr_rupd(x,Option.SOME vAddr))
                         end
                       ; let
                           val x = Delta ()
                         in
                           write'Delta
                             (StateDelta_data2_rupd(x,Option.SOME data))
                         end
                       ; let
                           val x = Delta ()
                         in
                           write'Delta
                             (StateDelta_st_width_rupd
                                (x,Option.SOME(BitsN.B(0x4,32))))
                         end
                       )
                     ; ( write'GPR(BitsN.B(0x0,64),rd)
                       ; let
                           val x = Delta ()
                         in
                           write'Delta
                             (StateDelta_data1_rupd
                                (x,Option.SOME(BitsN.B(0x0,64))))
                         end
                       )
                     ; write'ReserveLoad NONE
                     )
                   end
               | NONE => signalAddressException(Store_AMO_Fault,vAddr)
       end;

fun dfn'AMOSWAP_W (aq,(rl,(rd,(rs1,rs2)))) =
  let
    val vAddr = GPR rs1
  in
    if not((BitsN.bits(1,0) vAddr) = (BitsN.B(0x0,2)))
      then signalAddressException(AMO_Misaligned,vAddr)
    else case translateAddr(vAddr,(Data,Write)) of
            Option.SOME pAddr =>
              let
                val memv =
                  BitsN.signExtend 64
                    (BitsN.bits(31,0) (rawReadData pAddr))
                val data = GPR rs2
              in
                ( write'GPR(memv,rd)
                ; rawWriteData(pAddr,(data,4))
                ; ( let
                      val x = Delta ()
                    in
                      write'Delta
                        (StateDelta_addr_rupd(x,Option.SOME vAddr))
                    end
                  ; let
                      val x = Delta ()
                    in
                      write'Delta
                        (StateDelta_data1_rupd(x,Option.SOME memv))
                    end
                  )
                ; let
                    val x = Delta ()
                  in
                    write'Delta(StateDelta_addr_rupd(x,Option.SOME vAddr))
                  end
                ; let
                    val x = Delta ()
                  in
                    write'Delta(StateDelta_data2_rupd(x,Option.SOME data))
                  end
                ; let
                    val x = Delta ()
                  in
                    write'Delta
                      (StateDelta_st_width_rupd
                         (x,Option.SOME(BitsN.B(0x4,32))))
                  end
                )
              end
          | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'AMOSWAP_D (aq,(rl,(rd,(rs1,rs2)))) =
  let
    val vAddr = GPR rs1
  in
    if not((BitsN.bits(2,0) vAddr) = (BitsN.B(0x0,3)))
      then signalAddressException(AMO_Misaligned,vAddr)
    else case translateAddr(vAddr,(Data,Write)) of
            Option.SOME pAddr =>
              let
                val memv = rawReadData pAddr
                val data = GPR rs2
              in
                ( write'GPR(memv,rd)
                ; rawWriteData(pAddr,(data,8))
                ; ( let
                      val x = Delta ()
                    in
                      write'Delta
                        (StateDelta_addr_rupd(x,Option.SOME vAddr))
                    end
                  ; let
                      val x = Delta ()
                    in
                      write'Delta
                        (StateDelta_data1_rupd(x,Option.SOME memv))
                    end
                  )
                ; let
                    val x = Delta ()
                  in
                    write'Delta(StateDelta_addr_rupd(x,Option.SOME vAddr))
                  end
                ; let
                    val x = Delta ()
                  in
                    write'Delta(StateDelta_data2_rupd(x,Option.SOME data))
                  end
                ; let
                    val x = Delta ()
                  in
                    write'Delta
                      (StateDelta_st_width_rupd
                         (x,Option.SOME(BitsN.B(0x8,32))))
                  end
                )
              end
          | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'AMOADD_W (aq,(rl,(rd,(rs1,rs2)))) =
  let
    val vAddr = GPR rs1
  in
    if not((BitsN.bits(1,0) vAddr) = (BitsN.B(0x0,2)))
      then signalAddressException(AMO_Misaligned,vAddr)
    else case translateAddr(vAddr,(Data,Write)) of
            Option.SOME pAddr =>
              let
                val memv =
                  BitsN.signExtend 64
                    (BitsN.bits(31,0) (rawReadData pAddr))
                val data = GPR rs2
              in
                ( write'GPR(memv,rd)
                ; let
                    val val' = BitsN.+(data,memv)
                  in
                    ( rawWriteData(pAddr,(val',4))
                    ; ( let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_addr_rupd(x,Option.SOME vAddr))
                        end
                      ; let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_data1_rupd(x,Option.SOME memv))
                        end
                      )
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_addr_rupd(x,Option.SOME vAddr))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_data2_rupd(x,Option.SOME val'))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_st_width_rupd
                             (x,Option.SOME(BitsN.B(0x4,32))))
                      end
                    )
                  end
                )
              end
          | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'AMOADD_D (aq,(rl,(rd,(rs1,rs2)))) =
  let
    val vAddr = GPR rs1
  in
    if not((BitsN.bits(2,0) vAddr) = (BitsN.B(0x0,3)))
      then signalAddressException(AMO_Misaligned,vAddr)
    else case translateAddr(vAddr,(Data,Write)) of
            Option.SOME pAddr =>
              let
                val memv = rawReadData pAddr
                val data = GPR rs2
              in
                ( write'GPR(memv,rd)
                ; let
                    val val' = BitsN.+(data,memv)
                  in
                    ( rawWriteData(pAddr,(val',8))
                    ; ( let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_addr_rupd(x,Option.SOME vAddr))
                        end
                      ; let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_data1_rupd(x,Option.SOME memv))
                        end
                      )
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_addr_rupd(x,Option.SOME vAddr))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_data2_rupd(x,Option.SOME val'))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_st_width_rupd
                             (x,Option.SOME(BitsN.B(0x8,32))))
                      end
                    )
                  end
                )
              end
          | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'AMOXOR_W (aq,(rl,(rd,(rs1,rs2)))) =
  let
    val vAddr = GPR rs1
  in
    if not((BitsN.bits(1,0) vAddr) = (BitsN.B(0x0,2)))
      then signalAddressException(AMO_Misaligned,vAddr)
    else case translateAddr(vAddr,(Data,Write)) of
            Option.SOME pAddr =>
              let
                val memv =
                  BitsN.signExtend 64
                    (BitsN.bits(31,0) (rawReadData pAddr))
                val data = GPR rs2
              in
                ( write'GPR(memv,rd)
                ; let
                    val val' = BitsN.??(data,memv)
                  in
                    ( rawWriteData(pAddr,(val',4))
                    ; ( let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_addr_rupd(x,Option.SOME vAddr))
                        end
                      ; let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_data1_rupd(x,Option.SOME memv))
                        end
                      )
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_addr_rupd(x,Option.SOME vAddr))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_data2_rupd(x,Option.SOME val'))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_st_width_rupd
                             (x,Option.SOME(BitsN.B(0x4,32))))
                      end
                    )
                  end
                )
              end
          | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'AMOXOR_D (aq,(rl,(rd,(rs1,rs2)))) =
  let
    val vAddr = GPR rs1
  in
    if not((BitsN.bits(2,0) vAddr) = (BitsN.B(0x0,3)))
      then signalAddressException(AMO_Misaligned,vAddr)
    else case translateAddr(vAddr,(Data,Write)) of
            Option.SOME pAddr =>
              let
                val memv = rawReadData pAddr
                val data = GPR rs2
              in
                ( write'GPR(memv,rd)
                ; let
                    val val' = BitsN.??(data,memv)
                  in
                    ( rawWriteData(pAddr,(val',8))
                    ; ( let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_addr_rupd(x,Option.SOME vAddr))
                        end
                      ; let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_data1_rupd(x,Option.SOME memv))
                        end
                      )
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_addr_rupd(x,Option.SOME vAddr))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_data2_rupd(x,Option.SOME val'))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_st_width_rupd
                             (x,Option.SOME(BitsN.B(0x8,32))))
                      end
                    )
                  end
                )
              end
          | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'AMOAND_W (aq,(rl,(rd,(rs1,rs2)))) =
  let
    val vAddr = GPR rs1
  in
    if not((BitsN.bits(1,0) vAddr) = (BitsN.B(0x0,2)))
      then signalAddressException(AMO_Misaligned,vAddr)
    else case translateAddr(vAddr,(Data,Write)) of
            Option.SOME pAddr =>
              let
                val memv =
                  BitsN.signExtend 64
                    (BitsN.bits(31,0) (rawReadData pAddr))
                val data = GPR rs2
              in
                ( write'GPR(memv,rd)
                ; let
                    val val' = BitsN.&&(data,memv)
                  in
                    ( rawWriteData(pAddr,(val',4))
                    ; ( let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_addr_rupd(x,Option.SOME vAddr))
                        end
                      ; let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_data1_rupd(x,Option.SOME memv))
                        end
                      )
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_addr_rupd(x,Option.SOME vAddr))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_data2_rupd(x,Option.SOME val'))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_st_width_rupd
                             (x,Option.SOME(BitsN.B(0x4,32))))
                      end
                    )
                  end
                )
              end
          | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'AMOAND_D (aq,(rl,(rd,(rs1,rs2)))) =
  let
    val vAddr = GPR rs1
  in
    if not((BitsN.bits(2,0) vAddr) = (BitsN.B(0x0,3)))
      then signalAddressException(AMO_Misaligned,vAddr)
    else case translateAddr(vAddr,(Data,Write)) of
            Option.SOME pAddr =>
              let
                val memv = rawReadData pAddr
                val data = GPR rs2
              in
                ( write'GPR(memv,rd)
                ; let
                    val val' = BitsN.&&(data,memv)
                  in
                    ( rawWriteData(pAddr,(val',8))
                    ; ( let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_addr_rupd(x,Option.SOME vAddr))
                        end
                      ; let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_data1_rupd(x,Option.SOME memv))
                        end
                      )
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_addr_rupd(x,Option.SOME vAddr))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_data2_rupd(x,Option.SOME val'))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_st_width_rupd
                             (x,Option.SOME(BitsN.B(0x8,32))))
                      end
                    )
                  end
                )
              end
          | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'AMOOR_W (aq,(rl,(rd,(rs1,rs2)))) =
  let
    val vAddr = GPR rs1
  in
    if not((BitsN.bits(1,0) vAddr) = (BitsN.B(0x0,2)))
      then signalAddressException(AMO_Misaligned,vAddr)
    else case translateAddr(vAddr,(Data,Write)) of
            Option.SOME pAddr =>
              let
                val memv =
                  BitsN.signExtend 64
                    (BitsN.bits(31,0) (rawReadData pAddr))
                val data = GPR rs2
              in
                ( write'GPR(memv,rd)
                ; let
                    val val' = BitsN.||(data,memv)
                  in
                    ( rawWriteData(pAddr,(val',4))
                    ; ( let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_addr_rupd(x,Option.SOME vAddr))
                        end
                      ; let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_data1_rupd(x,Option.SOME memv))
                        end
                      )
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_addr_rupd(x,Option.SOME vAddr))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_data2_rupd(x,Option.SOME val'))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_st_width_rupd
                             (x,Option.SOME(BitsN.B(0x4,32))))
                      end
                    )
                  end
                )
              end
          | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'AMOOR_D (aq,(rl,(rd,(rs1,rs2)))) =
  let
    val vAddr = GPR rs1
  in
    if not((BitsN.bits(2,0) vAddr) = (BitsN.B(0x0,3)))
      then signalAddressException(AMO_Misaligned,vAddr)
    else case translateAddr(vAddr,(Data,Write)) of
            Option.SOME pAddr =>
              let
                val memv = rawReadData pAddr
                val data = GPR rs2
              in
                ( write'GPR(memv,rd)
                ; let
                    val val' = BitsN.||(data,memv)
                  in
                    ( rawWriteData(pAddr,(val',8))
                    ; ( let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_addr_rupd(x,Option.SOME vAddr))
                        end
                      ; let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_data1_rupd(x,Option.SOME memv))
                        end
                      )
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_addr_rupd(x,Option.SOME vAddr))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_data2_rupd(x,Option.SOME val'))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_st_width_rupd
                             (x,Option.SOME(BitsN.B(0x8,32))))
                      end
                    )
                  end
                )
              end
          | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'AMOMIN_W (aq,(rl,(rd,(rs1,rs2)))) =
  let
    val vAddr = GPR rs1
  in
    if not((BitsN.bits(1,0) vAddr) = (BitsN.B(0x0,2)))
      then signalAddressException(AMO_Misaligned,vAddr)
    else case translateAddr(vAddr,(Data,Write)) of
            Option.SOME pAddr =>
              let
                val memv =
                  BitsN.signExtend 64
                    (BitsN.bits(31,0) (rawReadData pAddr))
                val data = GPR rs2
              in
                ( write'GPR(memv,rd)
                ; let
                    val val' = BitsN.smin(data,memv)
                  in
                    ( rawWriteData(pAddr,(val',4))
                    ; ( let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_addr_rupd(x,Option.SOME vAddr))
                        end
                      ; let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_data1_rupd(x,Option.SOME memv))
                        end
                      )
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_addr_rupd(x,Option.SOME vAddr))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_data2_rupd(x,Option.SOME val'))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_st_width_rupd
                             (x,Option.SOME(BitsN.B(0x4,32))))
                      end
                    )
                  end
                )
              end
          | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'AMOMIN_D (aq,(rl,(rd,(rs1,rs2)))) =
  let
    val vAddr = GPR rs1
  in
    if not((BitsN.bits(2,0) vAddr) = (BitsN.B(0x0,3)))
      then signalAddressException(AMO_Misaligned,vAddr)
    else case translateAddr(vAddr,(Data,Write)) of
            Option.SOME pAddr =>
              let
                val memv = rawReadData pAddr
                val data = GPR rs2
              in
                ( write'GPR(memv,rd)
                ; let
                    val val' = BitsN.smin(data,memv)
                  in
                    ( rawWriteData(pAddr,(val',8))
                    ; ( let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_addr_rupd(x,Option.SOME vAddr))
                        end
                      ; let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_data1_rupd(x,Option.SOME memv))
                        end
                      )
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_addr_rupd(x,Option.SOME vAddr))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_data2_rupd(x,Option.SOME val'))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_st_width_rupd
                             (x,Option.SOME(BitsN.B(0x8,32))))
                      end
                    )
                  end
                )
              end
          | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'AMOMAX_W (aq,(rl,(rd,(rs1,rs2)))) =
  let
    val vAddr = GPR rs1
  in
    if not((BitsN.bits(1,0) vAddr) = (BitsN.B(0x0,2)))
      then signalAddressException(AMO_Misaligned,vAddr)
    else case translateAddr(vAddr,(Data,Write)) of
            Option.SOME pAddr =>
              let
                val memv =
                  BitsN.signExtend 64
                    (BitsN.bits(31,0) (rawReadData pAddr))
                val data = GPR rs2
              in
                ( write'GPR(memv,rd)
                ; let
                    val val' = BitsN.smax(data,memv)
                  in
                    ( rawWriteData(pAddr,(val',4))
                    ; ( let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_addr_rupd(x,Option.SOME vAddr))
                        end
                      ; let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_data1_rupd(x,Option.SOME memv))
                        end
                      )
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_addr_rupd(x,Option.SOME vAddr))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_data2_rupd(x,Option.SOME val'))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_st_width_rupd
                             (x,Option.SOME(BitsN.B(0x4,32))))
                      end
                    )
                  end
                )
              end
          | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'AMOMAX_D (aq,(rl,(rd,(rs1,rs2)))) =
  let
    val vAddr = GPR rs1
  in
    if not((BitsN.bits(2,0) vAddr) = (BitsN.B(0x0,3)))
      then signalAddressException(AMO_Misaligned,vAddr)
    else case translateAddr(vAddr,(Data,Write)) of
            Option.SOME pAddr =>
              let
                val memv = rawReadData pAddr
                val data = GPR rs2
              in
                ( write'GPR(memv,rd)
                ; let
                    val val' = BitsN.smax(data,memv)
                  in
                    ( rawWriteData(pAddr,(val',8))
                    ; ( let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_addr_rupd(x,Option.SOME vAddr))
                        end
                      ; let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_data1_rupd(x,Option.SOME memv))
                        end
                      )
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_addr_rupd(x,Option.SOME vAddr))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_data2_rupd(x,Option.SOME val'))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_st_width_rupd
                             (x,Option.SOME(BitsN.B(0x8,32))))
                      end
                    )
                  end
                )
              end
          | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'AMOMINU_W (aq,(rl,(rd,(rs1,rs2)))) =
  let
    val vAddr = GPR rs1
  in
    if not((BitsN.bits(1,0) vAddr) = (BitsN.B(0x0,2)))
      then signalAddressException(AMO_Misaligned,vAddr)
    else case translateAddr(vAddr,(Data,Write)) of
            Option.SOME pAddr =>
              let
                val memv =
                  BitsN.signExtend 64
                    (BitsN.bits(31,0) (rawReadData pAddr))
                val data = GPR rs2
              in
                ( write'GPR(memv,rd)
                ; let
                    val val' = BitsN.min(data,memv)
                  in
                    ( rawWriteData(pAddr,(val',4))
                    ; ( let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_addr_rupd(x,Option.SOME vAddr))
                        end
                      ; let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_data1_rupd(x,Option.SOME memv))
                        end
                      )
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_addr_rupd(x,Option.SOME vAddr))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_data2_rupd(x,Option.SOME val'))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_st_width_rupd
                             (x,Option.SOME(BitsN.B(0x4,32))))
                      end
                    )
                  end
                )
              end
          | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'AMOMINU_D (aq,(rl,(rd,(rs1,rs2)))) =
  let
    val vAddr = GPR rs1
  in
    if not((BitsN.bits(2,0) vAddr) = (BitsN.B(0x0,3)))
      then signalAddressException(AMO_Misaligned,vAddr)
    else case translateAddr(vAddr,(Data,Write)) of
            Option.SOME pAddr =>
              let
                val memv = rawReadData pAddr
                val data = GPR rs2
              in
                ( write'GPR(memv,rd)
                ; let
                    val val' = BitsN.min(data,memv)
                  in
                    ( rawWriteData(pAddr,(val',8))
                    ; ( let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_addr_rupd(x,Option.SOME vAddr))
                        end
                      ; let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_data1_rupd(x,Option.SOME memv))
                        end
                      )
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_addr_rupd(x,Option.SOME vAddr))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_data2_rupd(x,Option.SOME val'))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_st_width_rupd
                             (x,Option.SOME(BitsN.B(0x8,32))))
                      end
                    )
                  end
                )
              end
          | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'AMOMAXU_W (aq,(rl,(rd,(rs1,rs2)))) =
  let
    val vAddr = GPR rs1
  in
    if not((BitsN.bits(1,0) vAddr) = (BitsN.B(0x0,2)))
      then signalAddressException(AMO_Misaligned,vAddr)
    else case translateAddr(vAddr,(Data,Write)) of
            Option.SOME pAddr =>
              let
                val memv =
                  BitsN.signExtend 64
                    (BitsN.bits(31,0) (rawReadData pAddr))
                val data = GPR rs2
              in
                ( write'GPR(memv,rd)
                ; let
                    val val' = BitsN.max(data,memv)
                  in
                    ( rawWriteData(pAddr,(val',4))
                    ; ( let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_addr_rupd(x,Option.SOME vAddr))
                        end
                      ; let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_data1_rupd(x,Option.SOME memv))
                        end
                      )
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_addr_rupd(x,Option.SOME vAddr))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_data2_rupd(x,Option.SOME val'))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_st_width_rupd
                             (x,Option.SOME(BitsN.B(0x4,32))))
                      end
                    )
                  end
                )
              end
          | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'AMOMAXU_D (aq,(rl,(rd,(rs1,rs2)))) =
  let
    val vAddr = GPR rs1
  in
    if not((BitsN.bits(2,0) vAddr) = (BitsN.B(0x0,3)))
      then signalAddressException(AMO_Misaligned,vAddr)
    else case translateAddr(vAddr,(Data,Write)) of
            Option.SOME pAddr =>
              let
                val memv = rawReadData pAddr
                val data = GPR rs2
              in
                ( write'GPR(memv,rd)
                ; let
                    val val' = BitsN.max(data,memv)
                  in
                    ( rawWriteData(pAddr,(val',8))
                    ; ( let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_addr_rupd(x,Option.SOME vAddr))
                        end
                      ; let
                          val x = Delta ()
                        in
                          write'Delta
                            (StateDelta_data1_rupd(x,Option.SOME memv))
                        end
                      )
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_addr_rupd(x,Option.SOME vAddr))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_data2_rupd(x,Option.SOME val'))
                      end
                    ; let
                        val x = Delta ()
                      in
                        write'Delta
                          (StateDelta_st_width_rupd
                             (x,Option.SOME(BitsN.B(0x8,32))))
                      end
                    )
                  end
                )
              end
          | NONE => signalAddressException(Store_AMO_Fault,vAddr)
  end;

fun dfn'ECALL () = signalEnvCall ();

fun dfn'EBREAK () = signalException Breakpoint;

fun dfn'ERET () = write'NextFetch(Option.SOME Ereturn);

fun dfn'MRTS () =
  ( let
      val x = SCSR ()
    in
      write'SCSR(SupervisorCSR_scause_rupd(x,(#mcause)(MCSR ())))
    end
  ; let
      val x = SCSR ()
    in
      write'SCSR(SupervisorCSR_sbadaddr_rupd(x,(#mbadaddr)(MCSR ())))
    end
  ; let
      val x = SCSR ()
    in
      write'SCSR(SupervisorCSR_sepc_rupd(x,(#mepc)(MCSR ())))
    end
  ; let
      val x = MCSR ()
      val x0 = (#mstatus) x
    in
      write'MCSR
        (MachineCSR_mstatus_rupd
           (x,mstatus_MPRV_rupd(x0,privLevel Supervisor)))
    end
  ; write'NextFetch(Option.SOME Mrts)
  );

val dfn'WFI = ()

fun checkCSROp (csr,(rs1,a)) =
  (is_CSR_defined csr) andalso
  (check_CSR_access(csrRW csr,(csrPR csr,(curPrivilege (),a))));

fun dfn'CSRRW (rd,(rs1,csr)) =
  if checkCSROp(csr,(rs1,Write))
    then let
           val val' = CSR csr
         in
           ( writeCSR(csr,GPR rs1)
           ; write'GPR(val',rd)
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_data1_rupd(x,Option.SOME val'))
             end
           )
         end
  else signalException Illegal_Instr;

fun dfn'CSRRS (rd,(rs1,csr)) =
  if checkCSROp(csr,(rs1,if rs1 = (BitsN.B(0x0,5)) then Read else Write))
    then let
           val val' = CSR csr
         in
           ( if not(rs1 = (BitsN.B(0x0,5)))
               then writeCSR(csr,BitsN.||(val',GPR rs1))
             else ()
           ; write'GPR(val',rd)
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_data1_rupd(x,Option.SOME val'))
             end
           )
         end
  else signalException Illegal_Instr;

fun dfn'CSRRC (rd,(rs1,csr)) =
  if checkCSROp(csr,(rs1,if rs1 = (BitsN.B(0x0,5)) then Read else Write))
    then let
           val val' = CSR csr
         in
           ( if not(rs1 = (BitsN.B(0x0,5)))
               then writeCSR(csr,BitsN.&&(val',BitsN.~(GPR rs1)))
             else ()
           ; write'GPR(val',rd)
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_data1_rupd(x,Option.SOME val'))
             end
           )
         end
  else signalException Illegal_Instr;

fun dfn'CSRRWI (rd,(zimm,csr)) =
  if checkCSROp
       (csr,(zimm,if zimm = (BitsN.B(0x0,5)) then Read else Write))
    then let
           val val' = CSR csr
         in
           ( if not(zimm = (BitsN.B(0x0,5)))
               then writeCSR(csr,BitsN.zeroExtend 64 zimm)
             else ()
           ; write'GPR(val',rd)
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_data1_rupd(x,Option.SOME val'))
             end
           )
         end
  else signalException Illegal_Instr;

fun dfn'CSRRSI (rd,(zimm,csr)) =
  if checkCSROp
       (csr,(zimm,if zimm = (BitsN.B(0x0,5)) then Read else Write))
    then let
           val val' = CSR csr
         in
           ( if not(zimm = (BitsN.B(0x0,5)))
               then writeCSR(csr,BitsN.||(val',BitsN.zeroExtend 64 zimm))
             else ()
           ; write'GPR(val',rd)
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_data1_rupd(x,Option.SOME val'))
             end
           )
         end
  else signalException Illegal_Instr;

fun dfn'CSRRCI (rd,(zimm,csr)) =
  if checkCSROp
       (csr,(zimm,if zimm = (BitsN.B(0x0,5)) then Read else Write))
    then let
           val val' = CSR csr
         in
           ( if not(zimm = (BitsN.B(0x0,5)))
               then writeCSR
                      (csr,
                       BitsN.&&(val',BitsN.~(BitsN.zeroExtend 64 zimm)))
             else ()
           ; write'GPR(val',rd)
           ; let
               val x = Delta ()
             in
               write'Delta(StateDelta_data1_rupd(x,Option.SOME val'))
             end
           )
         end
  else signalException Illegal_Instr;

fun dfn'SFENCE_VM rs1 =
  let
    val addr =
      if rs1 = (BitsN.B(0x0,5)) then NONE else Option.SOME(GPR rs1)
  in
    write'TLB(flushTLB(curASID (),(addr,TLB ())))
  end;

fun dfn'UnknownInstruction () = signalException Illegal_Instr;

fun dfn'FETCH_MISALIGNED addr =
  ( signalAddressException(Fetch_Misaligned,addr)
  ; let
      val x = Delta ()
    in
      write'Delta(StateDelta_fetch_exc_rupd(x,true))
    end
  ; let val x = Delta () in write'Delta(StateDelta_pc_rupd(x,addr)) end
  );

fun dfn'FETCH_FAULT addr =
  ( signalAddressException(Fetch_Fault,addr)
  ; let
      val x = Delta ()
    in
      write'Delta(StateDelta_fetch_exc_rupd(x,true))
    end
  ; let val x = Delta () in write'Delta(StateDelta_pc_rupd(x,addr)) end
  );

fun Run v0 =
  case v0 of
     UnknownInstruction => dfn'UnknownInstruction ()
   | FENCE v104 => dfn'FENCE v104
   | FENCE_I v105 => dfn'FENCE_I v105
   | AMO v1 =>
     (case v1 of
         AMOADD_D v2 => dfn'AMOADD_D v2
       | AMOADD_W v3 => dfn'AMOADD_W v3
       | AMOAND_D v4 => dfn'AMOAND_D v4
       | AMOAND_W v5 => dfn'AMOAND_W v5
       | AMOMAXU_D v6 => dfn'AMOMAXU_D v6
       | AMOMAXU_W v7 => dfn'AMOMAXU_W v7
       | AMOMAX_D v8 => dfn'AMOMAX_D v8
       | AMOMAX_W v9 => dfn'AMOMAX_W v9
       | AMOMINU_D v10 => dfn'AMOMINU_D v10
       | AMOMINU_W v11 => dfn'AMOMINU_W v11
       | AMOMIN_D v12 => dfn'AMOMIN_D v12
       | AMOMIN_W v13 => dfn'AMOMIN_W v13
       | AMOOR_D v14 => dfn'AMOOR_D v14
       | AMOOR_W v15 => dfn'AMOOR_W v15
       | AMOSWAP_D v16 => dfn'AMOSWAP_D v16
       | AMOSWAP_W v17 => dfn'AMOSWAP_W v17
       | AMOXOR_D v18 => dfn'AMOXOR_D v18
       | AMOXOR_W v19 => dfn'AMOXOR_W v19
       | LR_D v20 => dfn'LR_D v20
       | LR_W v21 => dfn'LR_W v21
       | SC_D v22 => dfn'SC_D v22
       | SC_W v23 => dfn'SC_W v23)
   | ArithI v24 =>
     (case v24 of
         ADDI v25 => dfn'ADDI v25
       | ADDIW v26 => dfn'ADDIW v26
       | ANDI v27 => dfn'ANDI v27
       | AUIPC v28 => dfn'AUIPC v28
       | LUI v29 => dfn'LUI v29
       | ORI v30 => dfn'ORI v30
       | SLTI v31 => dfn'SLTI v31
       | SLTIU v32 => dfn'SLTIU v32
       | XORI v33 => dfn'XORI v33)
   | ArithR v34 =>
     (case v34 of
         ADD v35 => dfn'ADD v35
       | ADDW v36 => dfn'ADDW v36
       | AND v37 => dfn'AND v37
       | OR v38 => dfn'OR v38
       | SLT v39 => dfn'SLT v39
       | SLTU v40 => dfn'SLTU v40
       | SUB v41 => dfn'SUB v41
       | SUBW v42 => dfn'SUBW v42
       | XOR v43 => dfn'XOR v43)
   | Branch v44 =>
     (case v44 of
         BEQ v45 => dfn'BEQ v45
       | BGE v46 => dfn'BGE v46
       | BGEU v47 => dfn'BGEU v47
       | BLT v48 => dfn'BLT v48
       | BLTU v49 => dfn'BLTU v49
       | BNE v50 => dfn'BNE v50
       | JAL v51 => dfn'JAL v51
       | JALR v52 => dfn'JALR v52)
   | Internal v53 =>
     (case v53 of
         FETCH_FAULT v54 => dfn'FETCH_FAULT v54
       | FETCH_MISALIGNED v55 => dfn'FETCH_MISALIGNED v55)
   | Load v56 =>
     (case v56 of
         LB v57 => dfn'LB v57
       | LBU v58 => dfn'LBU v58
       | LD v59 => dfn'LD v59
       | LH v60 => dfn'LH v60
       | LHU v61 => dfn'LHU v61
       | LW v62 => dfn'LW v62
       | LWU v63 => dfn'LWU v63)
   | MulDiv v64 =>
     (case v64 of
         DIV v65 => dfn'DIV v65
       | DIVU v66 => dfn'DIVU v66
       | DIVUW v67 => dfn'DIVUW v67
       | DIVW v68 => dfn'DIVW v68
       | MUL v69 => dfn'MUL v69
       | MULH v70 => dfn'MULH v70
       | MULHSU v71 => dfn'MULHSU v71
       | MULHU v72 => dfn'MULHU v72
       | MULW v73 => dfn'MULW v73
       | REM v74 => dfn'REM v74
       | REMU v75 => dfn'REMU v75
       | REMUW v76 => dfn'REMUW v76
       | REMW v77 => dfn'REMW v77)
   | Shift v78 =>
     (case v78 of
         SLL v79 => dfn'SLL v79
       | SLLI v80 => dfn'SLLI v80
       | SLLIW v81 => dfn'SLLIW v81
       | SLLW v82 => dfn'SLLW v82
       | SRA v83 => dfn'SRA v83
       | SRAI v84 => dfn'SRAI v84
       | SRAIW v85 => dfn'SRAIW v85
       | SRAW v86 => dfn'SRAW v86
       | SRL v87 => dfn'SRL v87
       | SRLI v88 => dfn'SRLI v88
       | SRLIW v89 => dfn'SRLIW v89
       | SRLW v90 => dfn'SRLW v90)
   | Store v91 =>
     (case v91 of
         SB v92 => dfn'SB v92
       | SD v93 => dfn'SD v93
       | SH v94 => dfn'SH v94
       | SW v95 => dfn'SW v95)
   | System v96 =>
     (case v96 of
         EBREAK => dfn'EBREAK ()
       | ECALL => dfn'ECALL ()
       | ERET => dfn'ERET ()
       | MRTS => dfn'MRTS ()
       | WFI => dfn'WFI
       | CSRRC v97 => dfn'CSRRC v97
       | CSRRCI v98 => dfn'CSRRCI v98
       | CSRRS v99 => dfn'CSRRS v99
       | CSRRSI v100 => dfn'CSRRSI v100
       | CSRRW v101 => dfn'CSRRW v101
       | CSRRWI v102 => dfn'CSRRWI v102
       | SFENCE_VM v103 => dfn'SFENCE_VM v103);

fun Fetch () =
  let
    val vPC = PC ()
  in
    if not((BitsN.bits(1,0) vPC) = (BitsN.B(0x0,2)))
      then F_Error(Internal(FETCH_MISALIGNED vPC))
    else case translateAddr(vPC,(Instruction,Read)) of
            Option.SOME pPC =>
              let
                val instw = rawReadInst pPC
              in
                ( ( let
                      val x = Delta ()
                    in
                      write'Delta(StateDelta_exc_taken_rupd(x,false))
                    end
                  ; let
                      val x = Delta ()
                    in
                      write'Delta(StateDelta_fetch_exc_rupd(x,false))
                    end
                  ; let
                      val x = Delta ()
                    in
                      write'Delta(StateDelta_pc_rupd(x,vPC))
                    end
                  ; let
                      val x = Delta ()
                    in
                      write'Delta(StateDelta_rinstr_rupd(x,instw))
                    end
                  ; let
                      val x = Delta ()
                    in
                      write'Delta(StateDelta_addr_rupd(x,NONE))
                    end
                  ; let
                      val x = Delta ()
                    in
                      write'Delta(StateDelta_data1_rupd(x,NONE))
                    end
                  ; let
                      val x = Delta ()
                    in
                      write'Delta(StateDelta_data2_rupd(x,NONE))
                    end
                  ; let
                      val x = Delta ()
                    in
                      write'Delta(StateDelta_fp_data_rupd(x,NONE))
                    end
                  ; let
                      val x = Delta ()
                    in
                      write'Delta(StateDelta_st_width_rupd(x,NONE))
                    end
                  )
                ; F_Result instw
                )
              end
          | NONE => F_Error(Internal(FETCH_FAULT vPC))
  end;

fun asImm12 (imm12,(imm11,(immhi,immlo))) =
  BitsN.concat[imm12,imm11,immhi,immlo];

fun asImm20 (imm20,(immhi,(imm11,immlo))) =
  BitsN.concat[imm20,immhi,imm11,immlo];

fun asSImm12 (immhi,immlo) = BitsN.@@(immhi,immlo);

fun Decode w =
  case boolify'32 w of
     (i12'0,
      (ihi'5,
       (ihi'4,
        (ihi'3,
         (ihi'2,
          (ihi'1,
           (ihi'0,
            (rs2'4,
             (rs2'3,
              (rs2'2,
               (rs2'1,
                (rs2'0,
                 (rs1'4,
                  (rs1'3,
                   (rs1'2,
                    (rs1'1,
                     (rs1'0,
                      (false,
                       (false,
                        (false,
                         (ilo'3,
                          (ilo'2,
                           (ilo'1,
                            (ilo'0,
                             (i11'0,
                              (true,
                               (true,(false,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
       Branch
         (BEQ(BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
              (BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5),
               asImm12
                 (BitsN.fromBitstring([i12'0],1),
                  (BitsN.fromBitstring([i11'0],1),
                   (BitsN.fromBitstring
                      ([ihi'5,ihi'4,ihi'3,ihi'2,ihi'1,ihi'0],6),
                    BitsN.fromBitstring([ilo'3,ilo'2,ilo'1,ilo'0],4)))))))
   | (i12'0,
    (ihi'5,
     (ihi'4,
      (ihi'3,
       (ihi'2,
        (ihi'1,
         (ihi'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (true,
                       (ilo'3,
                        (ilo'2,
                         (ilo'1,
                          (ilo'0,
                           (i11'0,
                            (true,
                             (true,(false,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Branch
       (BNE(BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            (BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5),
             asImm12
               (BitsN.fromBitstring([i12'0],1),
                (BitsN.fromBitstring([i11'0],1),
                 (BitsN.fromBitstring
                    ([ihi'5,ihi'4,ihi'3,ihi'2,ihi'1,ihi'0],6),
                  BitsN.fromBitstring([ilo'3,ilo'2,ilo'1,ilo'0],4)))))))
   | (i12'0,
    (ihi'5,
     (ihi'4,
      (ihi'3,
       (ihi'2,
        (ihi'1,
         (ihi'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (false,
                      (false,
                       (ilo'3,
                        (ilo'2,
                         (ilo'1,
                          (ilo'0,
                           (i11'0,
                            (true,
                             (true,(false,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Branch
       (BLT(BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            (BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5),
             asImm12
               (BitsN.fromBitstring([i12'0],1),
                (BitsN.fromBitstring([i11'0],1),
                 (BitsN.fromBitstring
                    ([ihi'5,ihi'4,ihi'3,ihi'2,ihi'1,ihi'0],6),
                  BitsN.fromBitstring([ilo'3,ilo'2,ilo'1,ilo'0],4)))))))
   | (i12'0,
    (ihi'5,
     (ihi'4,
      (ihi'3,
       (ihi'2,
        (ihi'1,
         (ihi'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (false,
                      (true,
                       (ilo'3,
                        (ilo'2,
                         (ilo'1,
                          (ilo'0,
                           (i11'0,
                            (true,
                             (true,(false,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Branch
       (BGE(BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            (BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5),
             asImm12
               (BitsN.fromBitstring([i12'0],1),
                (BitsN.fromBitstring([i11'0],1),
                 (BitsN.fromBitstring
                    ([ihi'5,ihi'4,ihi'3,ihi'2,ihi'1,ihi'0],6),
                  BitsN.fromBitstring([ilo'3,ilo'2,ilo'1,ilo'0],4)))))))
   | (i12'0,
    (ihi'5,
     (ihi'4,
      (ihi'3,
       (ihi'2,
        (ihi'1,
         (ihi'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (true,
                      (false,
                       (ilo'3,
                        (ilo'2,
                         (ilo'1,
                          (ilo'0,
                           (i11'0,
                            (true,
                             (true,(false,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Branch
       (BLTU
          (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
           (BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5),
            asImm12
              (BitsN.fromBitstring([i12'0],1),
               (BitsN.fromBitstring([i11'0],1),
                (BitsN.fromBitstring
                   ([ihi'5,ihi'4,ihi'3,ihi'2,ihi'1,ihi'0],6),
                 BitsN.fromBitstring([ilo'3,ilo'2,ilo'1,ilo'0],4)))))))
   | (i12'0,
    (ihi'5,
     (ihi'4,
      (ihi'3,
       (ihi'2,
        (ihi'1,
         (ihi'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (true,
                      (true,
                       (ilo'3,
                        (ilo'2,
                         (ilo'1,
                          (ilo'0,
                           (i11'0,
                            (true,
                             (true,(false,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Branch
       (BGEU
          (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
           (BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5),
            asImm12
              (BitsN.fromBitstring([i12'0],1),
               (BitsN.fromBitstring([i11'0],1),
                (BitsN.fromBitstring
                   ([ihi'5,ihi'4,ihi'3,ihi'2,ihi'1,ihi'0],6),
                 BitsN.fromBitstring([ilo'3,ilo'2,ilo'1,ilo'0],4)))))))
   | (imm'11,
    (imm'10,
     (imm'9,
      (imm'8,
       (imm'7,
        (imm'6,
         (imm'5,
          (imm'4,
           (imm'3,
            (imm'2,
             (imm'1,
              (imm'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (true,
                             (true,(false,(false,(true,(true,true))))))))))))))))))))))))))))))) =>
     Branch
       (JALR
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring
              ([imm'11,imm'10,imm'9,imm'8,imm'7,imm'6,imm'5,imm'4,imm'3,
                imm'2,imm'1,imm'0],12))))
   | (i20'0,
    (ilo'9,
     (ilo'8,
      (ilo'7,
       (ilo'6,
        (ilo'5,
         (ilo'4,
          (ilo'3,
           (ilo'2,
            (ilo'1,
             (ilo'0,
              (i11'0,
               (ihi'7,
                (ihi'6,
                 (ihi'5,
                  (ihi'4,
                   (ihi'3,
                    (ihi'2,
                     (ihi'1,
                      (ihi'0,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (true,(true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     Branch
       (JAL(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
            asImm20
              (BitsN.fromBitstring([i20'0],1),
               (BitsN.fromBitstring
                  ([ihi'7,ihi'6,ihi'5,ihi'4,ihi'3,ihi'2,ihi'1,ihi'0],8),
                (BitsN.fromBitstring([i11'0],1),
                 BitsN.fromBitstring
                   ([ilo'9,ilo'8,ilo'7,ilo'6,ilo'5,ilo'4,ilo'3,ilo'2,
                     ilo'1,ilo'0],10))))))
   | (imm'19,
    (imm'18,
     (imm'17,
      (imm'16,
       (imm'15,
        (imm'14,
         (imm'13,
          (imm'12,
           (imm'11,
            (imm'10,
             (imm'9,
              (imm'8,
               (imm'7,
                (imm'6,
                 (imm'5,
                  (imm'4,
                   (imm'3,
                    (imm'2,
                     (imm'1,
                      (imm'0,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(false,(true,(true,true))))))))))))))))))))))))))))))) =>
     ArithI
       (LUI(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
            BitsN.fromBitstring
              ([imm'19,imm'18,imm'17,imm'16,imm'15,imm'14,imm'13,imm'12,
                imm'11,imm'10,imm'9,imm'8,imm'7,imm'6,imm'5,imm'4,imm'3,
                imm'2,imm'1,imm'0],20)))
   | (imm'19,
    (imm'18,
     (imm'17,
      (imm'16,
       (imm'15,
        (imm'14,
         (imm'13,
          (imm'12,
           (imm'11,
            (imm'10,
             (imm'9,
              (imm'8,
               (imm'7,
                (imm'6,
                 (imm'5,
                  (imm'4,
                   (imm'3,
                    (imm'2,
                     (imm'1,
                      (imm'0,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(true,(false,(true,(true,true))))))))))))))))))))))))))))))) =>
     ArithI
       (AUIPC
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           BitsN.fromBitstring
             ([imm'19,imm'18,imm'17,imm'16,imm'15,imm'14,imm'13,imm'12,
               imm'11,imm'10,imm'9,imm'8,imm'7,imm'6,imm'5,imm'4,imm'3,
               imm'2,imm'1,imm'0],20)))
   | (imm'11,
    (imm'10,
     (imm'9,
      (imm'8,
       (imm'7,
        (imm'6,
         (imm'5,
          (imm'4,
           (imm'3,
            (imm'2,
             (imm'1,
              (imm'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     ArithI
       (ADDI
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring
              ([imm'11,imm'10,imm'9,imm'8,imm'7,imm'6,imm'5,imm'4,imm'3,
                imm'2,imm'1,imm'0],12))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (shamt'5,
          (shamt'4,
           (shamt'3,
            (shamt'2,
             (shamt'1,
              (shamt'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Shift
       (SLLI
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring
              ([shamt'5,shamt'4,shamt'3,shamt'2,shamt'1,shamt'0],6))))
   | (imm'11,
    (imm'10,
     (imm'9,
      (imm'8,
       (imm'7,
        (imm'6,
         (imm'5,
          (imm'4,
           (imm'3,
            (imm'2,
             (imm'1,
              (imm'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     ArithI
       (SLTI
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring
              ([imm'11,imm'10,imm'9,imm'8,imm'7,imm'6,imm'5,imm'4,imm'3,
                imm'2,imm'1,imm'0],12))))
   | (imm'11,
    (imm'10,
     (imm'9,
      (imm'8,
       (imm'7,
        (imm'6,
         (imm'5,
          (imm'4,
           (imm'3,
            (imm'2,
             (imm'1,
              (imm'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     ArithI
       (SLTIU
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring
              ([imm'11,imm'10,imm'9,imm'8,imm'7,imm'6,imm'5,imm'4,imm'3,
                imm'2,imm'1,imm'0],12))))
   | (imm'11,
    (imm'10,
     (imm'9,
      (imm'8,
       (imm'7,
        (imm'6,
         (imm'5,
          (imm'4,
           (imm'3,
            (imm'2,
             (imm'1,
              (imm'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (false,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     ArithI
       (XORI
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring
              ([imm'11,imm'10,imm'9,imm'8,imm'7,imm'6,imm'5,imm'4,imm'3,
                imm'2,imm'1,imm'0],12))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (shamt'5,
          (shamt'4,
           (shamt'3,
            (shamt'2,
             (shamt'1,
              (shamt'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (false,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Shift
       (SRLI
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring
              ([shamt'5,shamt'4,shamt'3,shamt'2,shamt'1,shamt'0],6))))
   | (false,
    (true,
     (false,
      (false,
       (false,
        (false,
         (shamt'5,
          (shamt'4,
           (shamt'3,
            (shamt'2,
             (shamt'1,
              (shamt'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (false,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Shift
       (SRAI
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring
              ([shamt'5,shamt'4,shamt'3,shamt'2,shamt'1,shamt'0],6))))
   | (imm'11,
    (imm'10,
     (imm'9,
      (imm'8,
       (imm'7,
        (imm'6,
         (imm'5,
          (imm'4,
           (imm'3,
            (imm'2,
             (imm'1,
              (imm'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     ArithI
       (ORI(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
            (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
             BitsN.fromBitstring
               ([imm'11,imm'10,imm'9,imm'8,imm'7,imm'6,imm'5,imm'4,imm'3,
                 imm'2,imm'1,imm'0],12))))
   | (imm'11,
    (imm'10,
     (imm'9,
      (imm'8,
       (imm'7,
        (imm'6,
         (imm'5,
          (imm'4,
           (imm'3,
            (imm'2,
             (imm'1,
              (imm'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (true,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     ArithI
       (ANDI
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring
              ([imm'11,imm'10,imm'9,imm'8,imm'7,imm'6,imm'5,imm'4,imm'3,
                imm'2,imm'1,imm'0],12))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (false,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     ArithR
       (ADD(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
            (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
             BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (true,
     (false,
      (false,
       (false,
        (false,
         (false,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     ArithR
       (SUB(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
            (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
             BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (false,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Shift
       (SLL(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
            (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
             BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (false,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     ArithR
       (SLT(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
            (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
             BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (false,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     ArithR
       (SLTU
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (false,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (false,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     ArithR
       (XOR(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
            (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
             BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (false,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (false,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Shift
       (SRL(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
            (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
             BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (true,
     (false,
      (false,
       (false,
        (false,
         (false,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (false,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Shift
       (SRA(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
            (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
             BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (false,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     ArithR
       (OR(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (false,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (true,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     ArithR
       (AND(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
            (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
             BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (imm'11,
    (imm'10,
     (imm'9,
      (imm'8,
       (imm'7,
        (imm'6,
         (imm'5,
          (imm'4,
           (imm'3,
            (imm'2,
             (imm'1,
              (imm'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(true,(true,(false,(true,true))))))))))))))))))))))))))))))) =>
     ArithI
       (ADDIW
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring
              ([imm'11,imm'10,imm'9,imm'8,imm'7,imm'6,imm'5,imm'4,imm'3,
                imm'2,imm'1,imm'0],12))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (false,
          (shamt'4,
           (shamt'3,
            (shamt'2,
             (shamt'1,
              (shamt'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(true,(true,(false,(true,true))))))))))))))))))))))))))))))) =>
     Shift
       (SLLIW
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring
              ([shamt'4,shamt'3,shamt'2,shamt'1,shamt'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (false,
          (shamt'4,
           (shamt'3,
            (shamt'2,
             (shamt'1,
              (shamt'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (false,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(true,(true,(false,(true,true))))))))))))))))))))))))))))))) =>
     Shift
       (SRLIW
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring
              ([shamt'4,shamt'3,shamt'2,shamt'1,shamt'0],5))))
   | (false,
    (true,
     (false,
      (false,
       (false,
        (false,
         (false,
          (shamt'4,
           (shamt'3,
            (shamt'2,
             (shamt'1,
              (shamt'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (false,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(true,(true,(false,(true,true))))))))))))))))))))))))))))))) =>
     Shift
       (SRAIW
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring
              ([shamt'4,shamt'3,shamt'2,shamt'1,shamt'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (false,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(true,(false,(true,true))))))))))))))))))))))))))))))) =>
     ArithR
       (ADDW
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (true,
     (false,
      (false,
       (false,
        (false,
         (false,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(true,(false,(true,true))))))))))))))))))))))))))))))) =>
     ArithR
       (SUBW
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (false,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(true,(false,(true,true))))))))))))))))))))))))))))))) =>
     Shift
       (SLLW
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (false,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (false,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(true,(false,(true,true))))))))))))))))))))))))))))))) =>
     Shift
       (SRLW
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (true,
     (false,
      (false,
       (false,
        (false,
         (false,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (false,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(true,(false,(true,true))))))))))))))))))))))))))))))) =>
     Shift
       (SRAW
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (true,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     MulDiv
       (MUL(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
            (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
             BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (true,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     MulDiv
       (MULH
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (true,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     MulDiv
       (MULHSU
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (true,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     MulDiv
       (MULHU
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (true,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (false,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     MulDiv
       (DIV(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
            (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
             BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (true,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (false,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     MulDiv
       (DIVU
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (true,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     MulDiv
       (REM(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
            (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
             BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (true,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (true,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     MulDiv
       (REMU
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (true,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(true,(false,(true,true))))))))))))))))))))))))))))))) =>
     MulDiv
       (MULW
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (true,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (false,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(true,(false,(true,true))))))))))))))))))))))))))))))) =>
     MulDiv
       (DIVW
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (true,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (false,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(true,(false,(true,true))))))))))))))))))))))))))))))) =>
     MulDiv
       (DIVUW
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (true,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(true,(false,(true,true))))))))))))))))))))))))))))))) =>
     MulDiv
       (REMW
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (true,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (true,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(true,(true,(false,(true,true))))))))))))))))))))))))))))))) =>
     MulDiv
       (REMUW
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))
   | (imm'11,
    (imm'10,
     (imm'9,
      (imm'8,
       (imm'7,
        (imm'6,
         (imm'5,
          (imm'4,
           (imm'3,
            (imm'2,
             (imm'1,
              (imm'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(false,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Load
       (LB(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring
              ([imm'11,imm'10,imm'9,imm'8,imm'7,imm'6,imm'5,imm'4,imm'3,
                imm'2,imm'1,imm'0],12))))
   | (imm'11,
    (imm'10,
     (imm'9,
      (imm'8,
       (imm'7,
        (imm'6,
         (imm'5,
          (imm'4,
           (imm'3,
            (imm'2,
             (imm'1,
              (imm'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(false,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Load
       (LH(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring
              ([imm'11,imm'10,imm'9,imm'8,imm'7,imm'6,imm'5,imm'4,imm'3,
                imm'2,imm'1,imm'0],12))))
   | (imm'11,
    (imm'10,
     (imm'9,
      (imm'8,
       (imm'7,
        (imm'6,
         (imm'5,
          (imm'4,
           (imm'3,
            (imm'2,
             (imm'1,
              (imm'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(false,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Load
       (LW(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring
              ([imm'11,imm'10,imm'9,imm'8,imm'7,imm'6,imm'5,imm'4,imm'3,
                imm'2,imm'1,imm'0],12))))
   | (imm'11,
    (imm'10,
     (imm'9,
      (imm'8,
       (imm'7,
        (imm'6,
         (imm'5,
          (imm'4,
           (imm'3,
            (imm'2,
             (imm'1,
              (imm'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(false,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Load
       (LD(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring
              ([imm'11,imm'10,imm'9,imm'8,imm'7,imm'6,imm'5,imm'4,imm'3,
                imm'2,imm'1,imm'0],12))))
   | (imm'11,
    (imm'10,
     (imm'9,
      (imm'8,
       (imm'7,
        (imm'6,
         (imm'5,
          (imm'4,
           (imm'3,
            (imm'2,
             (imm'1,
              (imm'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (false,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(false,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Load
       (LBU(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
            (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
             BitsN.fromBitstring
               ([imm'11,imm'10,imm'9,imm'8,imm'7,imm'6,imm'5,imm'4,imm'3,
                 imm'2,imm'1,imm'0],12))))
   | (imm'11,
    (imm'10,
     (imm'9,
      (imm'8,
       (imm'7,
        (imm'6,
         (imm'5,
          (imm'4,
           (imm'3,
            (imm'2,
             (imm'1,
              (imm'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (false,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(false,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Load
       (LHU(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
            (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
             BitsN.fromBitstring
               ([imm'11,imm'10,imm'9,imm'8,imm'7,imm'6,imm'5,imm'4,imm'3,
                 imm'2,imm'1,imm'0],12))))
   | (imm'11,
    (imm'10,
     (imm'9,
      (imm'8,
       (imm'7,
        (imm'6,
         (imm'5,
          (imm'4,
           (imm'3,
            (imm'2,
             (imm'1,
              (imm'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (true,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(false,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Load
       (LWU(BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
            (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
             BitsN.fromBitstring
               ([imm'11,imm'10,imm'9,imm'8,imm'7,imm'6,imm'5,imm'4,imm'3,
                 imm'2,imm'1,imm'0],12))))
   | (ihi'6,
    (ihi'5,
     (ihi'4,
      (ihi'3,
       (ihi'2,
        (ihi'1,
         (ihi'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (false,
                       (ilo'4,
                        (ilo'3,
                         (ilo'2,
                          (ilo'1,
                           (ilo'0,
                            (false,
                             (true,(false,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Store
       (SB(BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
           (BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5),
            asSImm12
              (BitsN.fromBitstring
                 ([ihi'6,ihi'5,ihi'4,ihi'3,ihi'2,ihi'1,ihi'0],7),
               BitsN.fromBitstring([ilo'4,ilo'3,ilo'2,ilo'1,ilo'0],5)))))
   | (ihi'6,
    (ihi'5,
     (ihi'4,
      (ihi'3,
       (ihi'2,
        (ihi'1,
         (ihi'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (true,
                       (ilo'4,
                        (ilo'3,
                         (ilo'2,
                          (ilo'1,
                           (ilo'0,
                            (false,
                             (true,(false,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Store
       (SH(BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
           (BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5),
            asSImm12
              (BitsN.fromBitstring
                 ([ihi'6,ihi'5,ihi'4,ihi'3,ihi'2,ihi'1,ihi'0],7),
               BitsN.fromBitstring([ilo'4,ilo'3,ilo'2,ilo'1,ilo'0],5)))))
   | (ihi'6,
    (ihi'5,
     (ihi'4,
      (ihi'3,
       (ihi'2,
        (ihi'1,
         (ihi'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (false,
                       (ilo'4,
                        (ilo'3,
                         (ilo'2,
                          (ilo'1,
                           (ilo'0,
                            (false,
                             (true,(false,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Store
       (SW(BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
           (BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5),
            asSImm12
              (BitsN.fromBitstring
                 ([ihi'6,ihi'5,ihi'4,ihi'3,ihi'2,ihi'1,ihi'0],7),
               BitsN.fromBitstring([ilo'4,ilo'3,ilo'2,ilo'1,ilo'0],5)))))
   | (ihi'6,
    (ihi'5,
     (ihi'4,
      (ihi'3,
       (ihi'2,
        (ihi'1,
         (ihi'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (true,
                       (ilo'4,
                        (ilo'3,
                         (ilo'2,
                          (ilo'1,
                           (ilo'0,
                            (false,
                             (true,(false,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     Store
       (SD(BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
           (BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5),
            asSImm12
              (BitsN.fromBitstring
                 ([ihi'6,ihi'5,ihi'4,ihi'3,ihi'2,ihi'1,ihi'0],7),
               BitsN.fromBitstring([ilo'4,ilo'3,ilo'2,ilo'1,ilo'0],5)))))
   | (_,
    (_,
     (_,
      (_,
       (pred'3,
        (pred'2,
         (pred'1,
          (pred'0,
           (succ'3,
            (succ'2,
             (succ'1,
              (succ'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     FENCE
       (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
        (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
         (BitsN.fromBitstring([pred'3,pred'2,pred'1,pred'0],4),
          BitsN.fromBitstring([succ'3,succ'2,succ'1,succ'0],4))))
   | (imm'11,
    (imm'10,
     (imm'9,
      (imm'8,
       (imm'7,
        (imm'6,
         (imm'5,
          (imm'4,
           (imm'3,
            (imm'2,
             (imm'1,
              (imm'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (false,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     FENCE_I
       (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
        (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
         BitsN.fromBitstring
           ([imm'11,imm'10,imm'9,imm'8,imm'7,imm'6,imm'5,imm'4,imm'3,
             imm'2,imm'1,imm'0],12)))
   | (false,
    (false,
     (false,
      (true,
       (false,
        (aq'0,
         (rl'0,
          (false,
           (false,
            (false,
             (false,
              (false,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(LR_W
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5)))))
   | (false,
    (false,
     (false,
      (true,
       (false,
        (aq'0,
         (rl'0,
          (false,
           (false,
            (false,
             (false,
              (false,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(LR_D
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5)))))
   | (false,
    (false,
     (false,
      (true,
       (true,
        (aq'0,
         (rl'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(SC_W
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
               BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))))
   | (false,
    (false,
     (false,
      (true,
       (true,
        (aq'0,
         (rl'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(SC_D
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
               BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))))
   | (false,
    (false,
     (false,
      (false,
       (true,
        (aq'0,
         (rl'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(AMOSWAP_W
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
               BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (aq'0,
         (rl'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(AMOADD_W
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
               BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))))
   | (false,
    (false,
     (true,
      (false,
       (false,
        (aq'0,
         (rl'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(AMOXOR_W
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
               BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))))
   | (false,
    (true,
     (true,
      (false,
       (false,
        (aq'0,
         (rl'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(AMOAND_W
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
               BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))))
   | (false,
    (true,
     (false,
      (false,
       (false,
        (aq'0,
         (rl'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(AMOOR_W
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
               BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))))
   | (true,
    (false,
     (false,
      (false,
       (false,
        (aq'0,
         (rl'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(AMOMIN_W
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
               BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))))
   | (true,
    (false,
     (true,
      (false,
       (false,
        (aq'0,
         (rl'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(AMOMAX_W
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
               BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))))
   | (true,
    (true,
     (false,
      (false,
       (false,
        (aq'0,
         (rl'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(AMOMINU_W
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
               BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))))
   | (true,
    (true,
     (true,
      (false,
       (false,
        (aq'0,
         (rl'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(AMOMAXU_W
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
               BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))))
   | (false,
    (false,
     (false,
      (false,
       (true,
        (aq'0,
         (rl'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(AMOSWAP_D
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
               BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (aq'0,
         (rl'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(AMOADD_D
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
               BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))))
   | (false,
    (false,
     (true,
      (false,
       (false,
        (aq'0,
         (rl'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(AMOXOR_D
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
               BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))))
   | (false,
    (true,
     (true,
      (false,
       (false,
        (aq'0,
         (rl'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(AMOAND_D
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
               BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))))
   | (false,
    (true,
     (false,
      (false,
       (false,
        (aq'0,
         (rl'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(AMOOR_D
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
               BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))))
   | (true,
    (false,
     (false,
      (false,
       (false,
        (aq'0,
         (rl'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(AMOMIN_D
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
               BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))))
   | (true,
    (false,
     (true,
      (false,
       (false,
        (aq'0,
         (rl'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(AMOMAX_D
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
               BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))))
   | (true,
    (true,
     (false,
      (false,
       (false,
        (aq'0,
         (rl'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(AMOMINU_D
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
               BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))))
   | (true,
    (true,
     (true,
      (false,
       (false,
        (aq'0,
         (rl'0,
          (rs2'4,
           (rs2'3,
            (rs2'2,
             (rs2'1,
              (rs2'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (false,
                             (true,(false,(true,(true,(true,true))))))))))))))))))))))))))))))) =>
     AMO(AMOMAXU_D
           (BitsN.fromBitstring([aq'0],1),
            (BitsN.fromBitstring([rl'0],1),
             (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
              (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
               BitsN.fromBitstring([rs2'4,rs2'3,rs2'2,rs2'1,rs2'0],5))))))
   | (csr'11,
    (csr'10,
     (csr'9,
      (csr'8,
       (csr'7,
        (csr'6,
         (csr'5,
          (csr'4,
           (csr'3,
            (csr'2,
             (csr'1,
              (csr'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (true,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     System
       (CSRRW
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring
              ([csr'11,csr'10,csr'9,csr'8,csr'7,csr'6,csr'5,csr'4,csr'3,
                csr'2,csr'1,csr'0],12))))
   | (csr'11,
    (csr'10,
     (csr'9,
      (csr'8,
       (csr'7,
        (csr'6,
         (csr'5,
          (csr'4,
           (csr'3,
            (csr'2,
             (csr'1,
              (csr'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (true,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     System
       (CSRRS
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring
              ([csr'11,csr'10,csr'9,csr'8,csr'7,csr'6,csr'5,csr'4,csr'3,
                csr'2,csr'1,csr'0],12))))
   | (csr'11,
    (csr'10,
     (csr'9,
      (csr'8,
       (csr'7,
        (csr'6,
         (csr'5,
          (csr'4,
           (csr'3,
            (csr'2,
             (csr'1,
              (csr'0,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (true,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (true,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     System
       (CSRRC
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5),
            BitsN.fromBitstring
              ([csr'11,csr'10,csr'9,csr'8,csr'7,csr'6,csr'5,csr'4,csr'3,
                csr'2,csr'1,csr'0],12))))
   | (csr'11,
    (csr'10,
     (csr'9,
      (csr'8,
       (csr'7,
        (csr'6,
         (csr'5,
          (csr'4,
           (csr'3,
            (csr'2,
             (csr'1,
              (csr'0,
               (imm'4,
                (imm'3,
                 (imm'2,
                  (imm'1,
                   (imm'0,
                    (true,
                     (false,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (true,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     System
       (CSRRWI
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([imm'4,imm'3,imm'2,imm'1,imm'0],5),
            BitsN.fromBitstring
              ([csr'11,csr'10,csr'9,csr'8,csr'7,csr'6,csr'5,csr'4,csr'3,
                csr'2,csr'1,csr'0],12))))
   | (csr'11,
    (csr'10,
     (csr'9,
      (csr'8,
       (csr'7,
        (csr'6,
         (csr'5,
          (csr'4,
           (csr'3,
            (csr'2,
             (csr'1,
              (csr'0,
               (imm'4,
                (imm'3,
                 (imm'2,
                  (imm'1,
                   (imm'0,
                    (true,
                     (true,
                      (false,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (true,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     System
       (CSRRSI
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([imm'4,imm'3,imm'2,imm'1,imm'0],5),
            BitsN.fromBitstring
              ([csr'11,csr'10,csr'9,csr'8,csr'7,csr'6,csr'5,csr'4,csr'3,
                csr'2,csr'1,csr'0],12))))
   | (csr'11,
    (csr'10,
     (csr'9,
      (csr'8,
       (csr'7,
        (csr'6,
         (csr'5,
          (csr'4,
           (csr'3,
            (csr'2,
             (csr'1,
              (csr'0,
               (imm'4,
                (imm'3,
                 (imm'2,
                  (imm'1,
                   (imm'0,
                    (true,
                     (true,
                      (true,
                       (rd'4,
                        (rd'3,
                         (rd'2,
                          (rd'1,
                           (rd'0,
                            (true,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     System
       (CSRRCI
          (BitsN.fromBitstring([rd'4,rd'3,rd'2,rd'1,rd'0],5),
           (BitsN.fromBitstring([imm'4,imm'3,imm'2,imm'1,imm'0],5),
            BitsN.fromBitstring
              ([csr'11,csr'10,csr'9,csr'8,csr'7,csr'6,csr'5,csr'4,csr'3,
                csr'2,csr'1,csr'0],12))))
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (false,
          (false,
           (false,
            (false,
             (false,
              (false,
               (false,
                (false,
                 (false,
                  (false,
                   (false,
                    (false,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (true,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     System ECALL
   | (false,
    (false,
     (false,
      (false,
       (false,
        (false,
         (false,
          (false,
           (false,
            (false,
             (false,
              (true,
               (false,
                (false,
                 (false,
                  (false,
                   (false,
                    (false,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (true,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     System EBREAK
   | (false,
    (false,
     (false,
      (true,
       (false,
        (false,
         (false,
          (false,
           (false,
            (false,
             (false,
              (false,
               (false,
                (false,
                 (false,
                  (false,
                   (false,
                    (false,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (true,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     System ERET
   | (false,
    (false,
     (true,
      (true,
       (false,
        (false,
         (false,
          (false,
           (false,
            (true,
             (false,
              (true,
               (false,
                (false,
                 (false,
                  (false,
                   (false,
                    (false,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (true,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     System MRTS
   | (false,
    (false,
     (false,
      (true,
       (false,
        (false,
         (false,
          (false,
           (false,
            (false,
             (true,
              (false,
               (false,
                (false,
                 (false,
                  (false,
                   (false,
                    (false,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (true,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     System WFI
   | (false,
    (false,
     (false,
      (true,
       (false,
        (false,
         (false,
          (false,
           (false,
            (false,
             (false,
              (true,
               (rs1'4,
                (rs1'3,
                 (rs1'2,
                  (rs1'1,
                   (rs1'0,
                    (false,
                     (false,
                      (false,
                       (false,
                        (false,
                         (false,
                          (false,
                           (false,
                            (true,
                             (true,(true,(false,(false,(true,true))))))))))))))))))))))))))))))) =>
     System
       (SFENCE_VM(BitsN.fromBitstring([rs1'4,rs1'3,rs1'2,rs1'1,rs1'0],5)))
   | _ => UnknownInstruction;

fun imm N i = ("0x") ^ (BitsN.toHexString i);

fun instr o' = L3.padRightString(#" ",(12,o'));

fun amotype (aq,rl) =
  case (aq,rl) of
     (BitsN.B(0x0,1),BitsN.B(0x0,1)) => ""
   | (BitsN.B(0x1,1),BitsN.B(0x0,1)) => ".aq"
   | (BitsN.B(0x0,1),BitsN.B(0x1,1)) => ".rl"
   | (BitsN.B(0x1,1),BitsN.B(0x1,1)) => ".sc";

fun pRtype (o',(rd,(rs1,rs2))) =
  String.concat[instr o'," ",reg rd,", ",reg rs1,", ",reg rs2];

fun pARtype (o',(aq,(rl,(rd,(rs1,rs2))))) =
  pRtype(o' ^ (amotype(aq,rl)),(rd,(rs1,rs2)));

fun pLRtype (o',(aq,(rl,(rd,rs1)))) =
  String.concat[instr(o' ^ (amotype(aq,rl)))," ",reg rd,", ",reg rs1];

fun pItype N (o',(rd,(rs1,i))) =
  String.concat[instr o'," ",reg rd,", ",reg rs1,", ",imm N i];

fun pCSRtype (o',(rd,(rs1,csr))) =
  String.concat[instr o'," ",reg rd,", ",reg rs1,", ",csrName csr];

fun pCSRItype N (o',(rd,(i,csr))) =
  String.concat[instr o'," ",reg rd,", ",imm N i,", ",csrName csr];

fun pStype N (o',(rs1,(rs2,i))) =
  String.concat[instr o'," ",reg rs1,", ",reg rs2,", ",imm N i];

fun pSBtype N (o',(rs1,(rs2,i))) =
  String.concat
    [instr o'," ",reg rs1,", ",reg rs2,", ",imm N (BitsN.<<(i,1))];

fun pUtype N (o',(rd,i)) =
  String.concat[instr o'," ",reg rd,", ",imm N i];

fun pUJtype N (o',(rd,i)) =
  String.concat[instr o'," ",reg rd,", ",imm N (BitsN.<<(i,1))];

fun pN0type o' = instr o';

fun pN1type (o',r) = String.concat[instr o'," ",reg r];

fun instructionToString i =
  case i of
     Branch(BEQ(rs1,(rs2,imm))) => pSBtype 12 ("BEQ",(rs1,(rs2,imm)))
   | Branch(BNE(rs1,(rs2,imm))) => pSBtype 12 ("BNE",(rs1,(rs2,imm)))
   | Branch(BLT(rs1,(rs2,imm))) => pSBtype 12 ("BLT",(rs1,(rs2,imm)))
   | Branch(BGE(rs1,(rs2,imm))) => pSBtype 12 ("BGE",(rs1,(rs2,imm)))
   | Branch(BLTU(rs1,(rs2,imm))) => pSBtype 12 ("BLTU",(rs1,(rs2,imm)))
   | Branch(BGEU(rs1,(rs2,imm))) => pSBtype 12 ("BGEU",(rs1,(rs2,imm)))
   | Branch(JALR(rd,(rs1,imm))) => pItype 12 ("JALR",(rd,(rs1,imm)))
   | Branch(JAL(rd,imm)) => pUJtype 20 ("JAL",(rd,imm))
   | ArithI(LUI(rd,imm)) => pUtype 20 ("LUI",(rd,imm))
   | ArithI(AUIPC(rd,imm)) => pUtype 20 ("AUIPC",(rd,imm))
   | ArithI(ADDI(rd,(rs1,imm))) => pItype 12 ("ADDI",(rd,(rs1,imm)))
   | Shift(SLLI(rd,(rs1,imm))) => pItype 6 ("SLLI",(rd,(rs1,imm)))
   | ArithI(SLTI(rd,(rs1,imm))) => pItype 12 ("SLTI",(rd,(rs1,imm)))
   | ArithI(SLTIU(rd,(rs1,imm))) => pItype 12 ("SLTIU",(rd,(rs1,imm)))
   | ArithI(XORI(rd,(rs1,imm))) => pItype 12 ("XORI",(rd,(rs1,imm)))
   | Shift(SRLI(rd,(rs1,imm))) => pItype 6 ("SRLI",(rd,(rs1,imm)))
   | Shift(SRAI(rd,(rs1,imm))) => pItype 6 ("SRAI",(rd,(rs1,imm)))
   | ArithI(ORI(rd,(rs1,imm))) => pItype 12 ("ORI",(rd,(rs1,imm)))
   | ArithI(ANDI(rd,(rs1,imm))) => pItype 12 ("ANDI",(rd,(rs1,imm)))
   | ArithR(ADD(rd,(rs1,rs2))) => pRtype("ADD",(rd,(rs1,rs2)))
   | ArithR(SUB(rd,(rs1,rs2))) => pRtype("SUB",(rd,(rs1,rs2)))
   | Shift(SLL(rd,(rs1,rs2))) => pRtype("SLL",(rd,(rs1,rs2)))
   | ArithR(SLT(rd,(rs1,rs2))) => pRtype("SLT",(rd,(rs1,rs2)))
   | ArithR(SLTU(rd,(rs1,rs2))) => pRtype("SLTU",(rd,(rs1,rs2)))
   | ArithR(XOR(rd,(rs1,rs2))) => pRtype("XOR",(rd,(rs1,rs2)))
   | Shift(SRL(rd,(rs1,rs2))) => pRtype("SRL",(rd,(rs1,rs2)))
   | Shift(SRA(rd,(rs1,rs2))) => pRtype("SRA",(rd,(rs1,rs2)))
   | ArithR(OR(rd,(rs1,rs2))) => pRtype("OR",(rd,(rs1,rs2)))
   | ArithR(AND(rd,(rs1,rs2))) => pRtype("AND",(rd,(rs1,rs2)))
   | ArithI(ADDIW(rd,(rs1,imm))) => pItype 12 ("ADDIW",(rd,(rs1,imm)))
   | Shift(SLLIW(rd,(rs1,imm))) => pItype 5 ("SLLIW",(rd,(rs1,imm)))
   | Shift(SRLIW(rd,(rs1,imm))) => pItype 5 ("SRLIW",(rd,(rs1,imm)))
   | Shift(SRAIW(rd,(rs1,imm))) => pItype 5 ("SRAIW",(rd,(rs1,imm)))
   | ArithR(ADDW(rd,(rs1,rs2))) => pRtype("ADDW",(rd,(rs1,rs2)))
   | ArithR(SUBW(rd,(rs1,rs2))) => pRtype("SUBW",(rd,(rs1,rs2)))
   | Shift(SLLW(rd,(rs1,rs2))) => pRtype("SLLW",(rd,(rs1,rs2)))
   | Shift(SRLW(rd,(rs1,rs2))) => pRtype("SRLW",(rd,(rs1,rs2)))
   | Shift(SRAW(rd,(rs1,rs2))) => pRtype("SRAW",(rd,(rs1,rs2)))
   | MulDiv(MUL(rd,(rs1,rs2))) => pRtype("MUL",(rd,(rs1,rs2)))
   | MulDiv(MULH(rd,(rs1,rs2))) => pRtype("MULH",(rd,(rs1,rs2)))
   | MulDiv(MULHSU(rd,(rs1,rs2))) => pRtype("MULHSU",(rd,(rs1,rs2)))
   | MulDiv(MULHU(rd,(rs1,rs2))) => pRtype("MULHU",(rd,(rs1,rs2)))
   | MulDiv(DIV(rd,(rs1,rs2))) => pRtype("DIV",(rd,(rs1,rs2)))
   | MulDiv(DIVU(rd,(rs1,rs2))) => pRtype("DIVU",(rd,(rs1,rs2)))
   | MulDiv(REM(rd,(rs1,rs2))) => pRtype("REM",(rd,(rs1,rs2)))
   | MulDiv(REMU(rd,(rs1,rs2))) => pRtype("REMU",(rd,(rs1,rs2)))
   | MulDiv(MULW(rd,(rs1,rs2))) => pRtype("MULW",(rd,(rs1,rs2)))
   | MulDiv(DIVW(rd,(rs1,rs2))) => pRtype("DIVW",(rd,(rs1,rs2)))
   | MulDiv(DIVUW(rd,(rs1,rs2))) => pRtype("DIVUW",(rd,(rs1,rs2)))
   | MulDiv(REMW(rd,(rs1,rs2))) => pRtype("REMW",(rd,(rs1,rs2)))
   | MulDiv(REMUW(rd,(rs1,rs2))) => pRtype("REMUW",(rd,(rs1,rs2)))
   | Load(LB(rd,(rs1,imm))) => pItype 12 ("LB",(rd,(rs1,imm)))
   | Load(LH(rd,(rs1,imm))) => pItype 12 ("LH",(rd,(rs1,imm)))
   | Load(LW(rd,(rs1,imm))) => pItype 12 ("LW",(rd,(rs1,imm)))
   | Load(LD(rd,(rs1,imm))) => pItype 12 ("LD",(rd,(rs1,imm)))
   | Load(LBU(rd,(rs1,imm))) => pItype 12 ("LBU",(rd,(rs1,imm)))
   | Load(LHU(rd,(rs1,imm))) => pItype 12 ("LHU",(rd,(rs1,imm)))
   | Load(LWU(rd,(rs1,imm))) => pItype 12 ("LWU",(rd,(rs1,imm)))
   | Store(SB(rs1,(rs2,imm))) => pStype 12 ("SB",(rs1,(rs2,imm)))
   | Store(SH(rs1,(rs2,imm))) => pStype 12 ("SH",(rs1,(rs2,imm)))
   | Store(SW(rs1,(rs2,imm))) => pStype 12 ("SW",(rs1,(rs2,imm)))
   | Store(SD(rs1,(rs2,imm))) => pStype 12 ("SD",(rs1,(rs2,imm)))
   | FENCE(rd,(rs1,(pred,succ))) => pN0type("FENCE")
   | FENCE_I(rd,(rs1,imm)) => pN0type("FENCE.I")
   | AMO(LR_W(aq,(rl,(rd,rs1)))) => pLRtype("LR.W",(aq,(rl,(rd,rs1))))
   | AMO(LR_D(aq,(rl,(rd,rs1)))) => pLRtype("LR.D",(aq,(rl,(rd,rs1))))
   | AMO(SC_W(aq,(rl,(rd,(rs1,rs2))))) =>
     pARtype("SC.W",(aq,(rl,(rd,(rs1,rs2)))))
   | AMO(SC_D(aq,(rl,(rd,(rs1,rs2))))) =>
     pARtype("SC.D",(aq,(rl,(rd,(rs1,rs2)))))
   | AMO(AMOSWAP_W(aq,(rl,(rd,(rs1,rs2))))) =>
     pARtype("AMOSWAP.W",(aq,(rl,(rd,(rs1,rs2)))))
   | AMO(AMOADD_W(aq,(rl,(rd,(rs1,rs2))))) =>
     pARtype("AMOADD.W",(aq,(rl,(rd,(rs1,rs2)))))
   | AMO(AMOXOR_W(aq,(rl,(rd,(rs1,rs2))))) =>
     pARtype("AMOXOR.W",(aq,(rl,(rd,(rs1,rs2)))))
   | AMO(AMOAND_W(aq,(rl,(rd,(rs1,rs2))))) =>
     pARtype("AMOAND.W",(aq,(rl,(rd,(rs1,rs2)))))
   | AMO(AMOOR_W(aq,(rl,(rd,(rs1,rs2))))) =>
     pARtype("AMOOR.W",(aq,(rl,(rd,(rs1,rs2)))))
   | AMO(AMOMIN_W(aq,(rl,(rd,(rs1,rs2))))) =>
     pARtype("AMOMIN.W",(aq,(rl,(rd,(rs1,rs2)))))
   | AMO(AMOMAX_W(aq,(rl,(rd,(rs1,rs2))))) =>
     pARtype("AMOMAX.W",(aq,(rl,(rd,(rs1,rs2)))))
   | AMO(AMOMINU_W(aq,(rl,(rd,(rs1,rs2))))) =>
     pARtype("AMOMINU.W",(aq,(rl,(rd,(rs1,rs2)))))
   | AMO(AMOMAXU_W(aq,(rl,(rd,(rs1,rs2))))) =>
     pARtype("AMOMAXU.W",(aq,(rl,(rd,(rs1,rs2)))))
   | AMO(AMOSWAP_D(aq,(rl,(rd,(rs1,rs2))))) =>
     pARtype("AMOSWAP.D",(aq,(rl,(rd,(rs1,rs2)))))
   | AMO(AMOADD_D(aq,(rl,(rd,(rs1,rs2))))) =>
     pARtype("AMOADD.D",(aq,(rl,(rd,(rs1,rs2)))))
   | AMO(AMOXOR_D(aq,(rl,(rd,(rs1,rs2))))) =>
     pARtype("AMOXOR.D",(aq,(rl,(rd,(rs1,rs2)))))
   | AMO(AMOAND_D(aq,(rl,(rd,(rs1,rs2))))) =>
     pARtype("AMOAND.D",(aq,(rl,(rd,(rs1,rs2)))))
   | AMO(AMOOR_D(aq,(rl,(rd,(rs1,rs2))))) =>
     pARtype("AMOOR.D",(aq,(rl,(rd,(rs1,rs2)))))
   | AMO(AMOMIN_D(aq,(rl,(rd,(rs1,rs2))))) =>
     pARtype("AMOMIN.D",(aq,(rl,(rd,(rs1,rs2)))))
   | AMO(AMOMAX_D(aq,(rl,(rd,(rs1,rs2))))) =>
     pARtype("AMOMAX.D",(aq,(rl,(rd,(rs1,rs2)))))
   | AMO(AMOMINU_D(aq,(rl,(rd,(rs1,rs2))))) =>
     pARtype("AMOMINU.D",(aq,(rl,(rd,(rs1,rs2)))))
   | AMO(AMOMAXU_D(aq,(rl,(rd,(rs1,rs2))))) =>
     pARtype("AMOMAXU.D",(aq,(rl,(rd,(rs1,rs2)))))
   | System ECALL => pN0type("ECALL")
   | System EBREAK => pN0type("EBREAK")
   | System ERET => pN0type("ERET")
   | System MRTS => pN0type("MRTS")
   | System WFI => pN0type("WFI")
   | System(CSRRW(rd,(rs1,csr))) => pCSRtype("CSRRW",(rd,(rs1,csr)))
   | System(CSRRS(rd,(rs1,csr))) => pCSRtype("CSRRS",(rd,(rs1,csr)))
   | System(CSRRC(rd,(rs1,csr))) => pCSRtype("CSRRC",(rd,(rs1,csr)))
   | System(CSRRWI(rd,(imm,csr))) => pCSRItype 5 ("CSRRWI",(rd,(imm,csr)))
   | System(CSRRSI(rd,(imm,csr))) => pCSRItype 5 ("CSRRSI",(rd,(imm,csr)))
   | System(CSRRCI(rd,(imm,csr))) => pCSRItype 5 ("CSRRCI",(rd,(imm,csr)))
   | System(SFENCE_VM rs1) => pN1type("SFENCE.VM",rs1)
   | UnknownInstruction => pN0type("UNKNOWN")
   | Internal(FETCH_MISALIGNED _) => pN0type("FETCH_MISALIGNED")
   | Internal(FETCH_FAULT _) => pN0type("FETCH_FAULT");

fun Rtype (o',(f3,(rd,(rs1,(rs2,f7))))) =
  BitsN.concat[f7,rs2,rs1,f3,rd,o'];

fun Itype (o',(f3,(rd,(rs1,imm)))) = BitsN.concat[imm,rs1,f3,rd,o'];

fun Stype (o',(f3,(rs1,(rs2,imm)))) =
  BitsN.concat[BitsN.bits(11,5) imm,rs2,rs1,f3,BitsN.bits(4,0) imm,o'];

fun SBtype (o',(f3,(rs1,(rs2,imm)))) =
  BitsN.concat
    [BitsN.fromBit(BitsN.bit(imm,11)),BitsN.bits(9,4) imm,rs2,rs1,f3,
     BitsN.bits(3,0) imm,BitsN.fromBit(BitsN.bit(imm,10)),o'];

fun Utype (o',(rd,imm)) = BitsN.concat[imm,rd,o'];

fun UJtype (o',(rd,imm)) =
  BitsN.concat
    [BitsN.fromBit(BitsN.bit(imm,19)),BitsN.bits(9,0) imm,
     BitsN.fromBit(BitsN.bit(imm,10)),BitsN.bits(18,11) imm,rd,o'];

fun opc code = BitsN.@@(BitsN.bits(4,0) code,BitsN.B(0x3,2));

fun amofunc (code,(aq,rl)) = BitsN.concat[code,aq,rl];

fun Encode i =
  case i of
     Branch(BEQ(rs1,(rs2,imm))) =>
       SBtype(opc(BitsN.B(0x18,8)),(BitsN.B(0x0,3),(rs1,(rs2,imm))))
   | Branch(BNE(rs1,(rs2,imm))) =>
     SBtype(opc(BitsN.B(0x18,8)),(BitsN.B(0x1,3),(rs1,(rs2,imm))))
   | Branch(BLT(rs1,(rs2,imm))) =>
     SBtype(opc(BitsN.B(0x18,8)),(BitsN.B(0x4,3),(rs1,(rs2,imm))))
   | Branch(BGE(rs1,(rs2,imm))) =>
     SBtype(opc(BitsN.B(0x18,8)),(BitsN.B(0x5,3),(rs1,(rs2,imm))))
   | Branch(BLTU(rs1,(rs2,imm))) =>
     SBtype(opc(BitsN.B(0x18,8)),(BitsN.B(0x6,3),(rs1,(rs2,imm))))
   | Branch(BGEU(rs1,(rs2,imm))) =>
     SBtype(opc(BitsN.B(0x18,8)),(BitsN.B(0x7,3),(rs1,(rs2,imm))))
   | Branch(JALR(rd,(rs1,imm))) =>
     Itype(opc(BitsN.B(0x19,8)),(BitsN.B(0x0,3),(rd,(rs1,imm))))
   | Branch(JAL(rd,imm)) => UJtype(opc(BitsN.B(0x1B,8)),(rd,imm))
   | ArithI(LUI(rd,imm)) => Utype(opc(BitsN.B(0xD,8)),(rd,imm))
   | ArithI(AUIPC(rd,imm)) => Utype(opc(BitsN.B(0x5,8)),(rd,imm))
   | ArithI(ADDI(rd,(rs1,imm))) =>
     Itype(opc(BitsN.B(0x4,8)),(BitsN.B(0x0,3),(rd,(rs1,imm))))
   | Shift(SLLI(rd,(rs1,imm))) =>
     Itype
       (opc(BitsN.B(0x4,8)),
        (BitsN.B(0x1,3),(rd,(rs1,BitsN.@@(BitsN.B(0x0,6),imm)))))
   | ArithI(SLTI(rd,(rs1,imm))) =>
     Itype(opc(BitsN.B(0x4,8)),(BitsN.B(0x2,3),(rd,(rs1,imm))))
   | ArithI(SLTIU(rd,(rs1,imm))) =>
     Itype(opc(BitsN.B(0x4,8)),(BitsN.B(0x3,3),(rd,(rs1,imm))))
   | ArithI(XORI(rd,(rs1,imm))) =>
     Itype(opc(BitsN.B(0x4,8)),(BitsN.B(0x4,3),(rd,(rs1,imm))))
   | Shift(SRLI(rd,(rs1,imm))) =>
     Itype
       (opc(BitsN.B(0x4,8)),
        (BitsN.B(0x5,3),(rd,(rs1,BitsN.@@(BitsN.B(0x0,6),imm)))))
   | Shift(SRAI(rd,(rs1,imm))) =>
     Itype
       (opc(BitsN.B(0x4,8)),
        (BitsN.B(0x5,3),(rd,(rs1,BitsN.@@(BitsN.B(0x10,6),imm)))))
   | ArithI(ORI(rd,(rs1,imm))) =>
     Itype(opc(BitsN.B(0x4,8)),(BitsN.B(0x6,3),(rd,(rs1,imm))))
   | ArithI(ANDI(rd,(rs1,imm))) =>
     Itype(opc(BitsN.B(0x4,8)),(BitsN.B(0x7,3),(rd,(rs1,imm))))
   | ArithR(ADD(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xC,8)),
        (BitsN.B(0x0,3),(rd,(rs1,(rs2,BitsN.B(0x0,7))))))
   | ArithR(SUB(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xC,8)),
        (BitsN.B(0x0,3),(rd,(rs1,(rs2,BitsN.B(0x20,7))))))
   | Shift(SLL(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xC,8)),
        (BitsN.B(0x1,3),(rd,(rs1,(rs2,BitsN.B(0x0,7))))))
   | ArithR(SLT(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xC,8)),
        (BitsN.B(0x2,3),(rd,(rs1,(rs2,BitsN.B(0x0,7))))))
   | ArithR(SLTU(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xC,8)),
        (BitsN.B(0x3,3),(rd,(rs1,(rs2,BitsN.B(0x0,7))))))
   | ArithR(XOR(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xC,8)),
        (BitsN.B(0x4,3),(rd,(rs1,(rs2,BitsN.B(0x0,7))))))
   | Shift(SRL(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xC,8)),
        (BitsN.B(0x5,3),(rd,(rs1,(rs2,BitsN.B(0x0,7))))))
   | Shift(SRA(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xC,8)),
        (BitsN.B(0x5,3),(rd,(rs1,(rs2,BitsN.B(0x20,7))))))
   | ArithR(OR(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xC,8)),
        (BitsN.B(0x6,3),(rd,(rs1,(rs2,BitsN.B(0x0,7))))))
   | ArithR(AND(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xC,8)),
        (BitsN.B(0x7,3),(rd,(rs1,(rs2,BitsN.B(0x0,7))))))
   | ArithI(ADDIW(rd,(rs1,imm))) =>
     Itype(opc(BitsN.B(0x6,8)),(BitsN.B(0x0,3),(rd,(rs1,imm))))
   | Shift(SLLIW(rd,(rs1,imm))) =>
     Itype
       (opc(BitsN.B(0x6,8)),
        (BitsN.B(0x1,3),(rd,(rs1,BitsN.@@(BitsN.B(0x0,7),imm)))))
   | Shift(SRLIW(rd,(rs1,imm))) =>
     Itype
       (opc(BitsN.B(0x6,8)),
        (BitsN.B(0x5,3),(rd,(rs1,BitsN.@@(BitsN.B(0x0,7),imm)))))
   | Shift(SRAIW(rd,(rs1,imm))) =>
     Itype
       (opc(BitsN.B(0x6,8)),
        (BitsN.B(0x5,3),(rd,(rs1,BitsN.@@(BitsN.B(0x20,7),imm)))))
   | ArithR(ADDW(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xE,8)),
        (BitsN.B(0x0,3),(rd,(rs1,(rs2,BitsN.B(0x0,7))))))
   | ArithR(SUBW(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xE,8)),
        (BitsN.B(0x0,3),(rd,(rs1,(rs2,BitsN.B(0x20,7))))))
   | Shift(SLLW(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xE,8)),
        (BitsN.B(0x1,3),(rd,(rs1,(rs2,BitsN.B(0x0,7))))))
   | Shift(SRLW(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xE,8)),
        (BitsN.B(0x5,3),(rd,(rs1,(rs2,BitsN.B(0x0,7))))))
   | Shift(SRAW(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xE,8)),
        (BitsN.B(0x5,3),(rd,(rs1,(rs2,BitsN.B(0x20,7))))))
   | MulDiv(MUL(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xC,8)),
        (BitsN.B(0x0,3),(rd,(rs1,(rs2,BitsN.B(0x1,7))))))
   | MulDiv(MULH(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xC,8)),
        (BitsN.B(0x1,3),(rd,(rs1,(rs2,BitsN.B(0x1,7))))))
   | MulDiv(MULHSU(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xC,8)),
        (BitsN.B(0x2,3),(rd,(rs1,(rs2,BitsN.B(0x1,7))))))
   | MulDiv(MULHU(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xC,8)),
        (BitsN.B(0x3,3),(rd,(rs1,(rs2,BitsN.B(0x1,7))))))
   | MulDiv(DIV(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xC,8)),
        (BitsN.B(0x4,3),(rd,(rs1,(rs2,BitsN.B(0x1,7))))))
   | MulDiv(DIVU(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xC,8)),
        (BitsN.B(0x5,3),(rd,(rs1,(rs2,BitsN.B(0x1,7))))))
   | MulDiv(REM(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xC,8)),
        (BitsN.B(0x6,3),(rd,(rs1,(rs2,BitsN.B(0x1,7))))))
   | MulDiv(REMU(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xC,8)),
        (BitsN.B(0x7,3),(rd,(rs1,(rs2,BitsN.B(0x1,7))))))
   | MulDiv(MULW(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xE,8)),
        (BitsN.B(0x0,3),(rd,(rs1,(rs2,BitsN.B(0x1,7))))))
   | MulDiv(DIVW(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xE,8)),
        (BitsN.B(0x4,3),(rd,(rs1,(rs2,BitsN.B(0x1,7))))))
   | MulDiv(DIVUW(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xE,8)),
        (BitsN.B(0x5,3),(rd,(rs1,(rs2,BitsN.B(0x1,7))))))
   | MulDiv(REMW(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xE,8)),
        (BitsN.B(0x6,3),(rd,(rs1,(rs2,BitsN.B(0x1,7))))))
   | MulDiv(REMUW(rd,(rs1,rs2))) =>
     Rtype
       (opc(BitsN.B(0xE,8)),
        (BitsN.B(0x7,3),(rd,(rs1,(rs2,BitsN.B(0x1,7))))))
   | Load(LB(rd,(rs1,imm))) =>
     Itype(opc(BitsN.B(0x0,8)),(BitsN.B(0x0,3),(rd,(rs1,imm))))
   | Load(LH(rd,(rs1,imm))) =>
     Itype(opc(BitsN.B(0x0,8)),(BitsN.B(0x1,3),(rd,(rs1,imm))))
   | Load(LW(rd,(rs1,imm))) =>
     Itype(opc(BitsN.B(0x0,8)),(BitsN.B(0x2,3),(rd,(rs1,imm))))
   | Load(LD(rd,(rs1,imm))) =>
     Itype(opc(BitsN.B(0x0,8)),(BitsN.B(0x3,3),(rd,(rs1,imm))))
   | Load(LBU(rd,(rs1,imm))) =>
     Itype(opc(BitsN.B(0x0,8)),(BitsN.B(0x4,3),(rd,(rs1,imm))))
   | Load(LHU(rd,(rs1,imm))) =>
     Itype(opc(BitsN.B(0x0,8)),(BitsN.B(0x5,3),(rd,(rs1,imm))))
   | Load(LWU(rd,(rs1,imm))) =>
     Itype(opc(BitsN.B(0x0,8)),(BitsN.B(0x6,3),(rd,(rs1,imm))))
   | Store(SB(rs1,(rs2,imm))) =>
     Stype(opc(BitsN.B(0x8,8)),(BitsN.B(0x0,3),(rs1,(rs2,imm))))
   | Store(SH(rs1,(rs2,imm))) =>
     Stype(opc(BitsN.B(0x8,8)),(BitsN.B(0x1,3),(rs1,(rs2,imm))))
   | Store(SW(rs1,(rs2,imm))) =>
     Stype(opc(BitsN.B(0x8,8)),(BitsN.B(0x2,3),(rs1,(rs2,imm))))
   | Store(SD(rs1,(rs2,imm))) =>
     Stype(opc(BitsN.B(0x8,8)),(BitsN.B(0x3,3),(rs1,(rs2,imm))))
   | FENCE(rd,(rs1,(pred,succ))) =>
     Itype
       (opc(BitsN.B(0x3,8)),
        (BitsN.B(0x0,3),(rd,(rs1,BitsN.concat[BitsN.B(0x0,4),pred,succ]))))
   | FENCE_I(rd,(rs1,imm)) =>
     Itype(opc(BitsN.B(0x3,8)),(BitsN.B(0x1,3),(rd,(rs1,imm))))
   | AMO(LR_W(aq,(rl,(rd,rs1)))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x2,3),
         (rd,(rs1,(BitsN.B(0x0,5),amofunc(BitsN.B(0x2,5),(aq,rl)))))))
   | AMO(LR_D(aq,(rl,(rd,rs1)))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x3,3),
         (rd,(rs1,(BitsN.B(0x0,5),amofunc(BitsN.B(0x2,5),(aq,rl)))))))
   | AMO(SC_W(aq,(rl,(rd,(rs1,rs2))))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x2,3),(rd,(rs1,(rs2,amofunc(BitsN.B(0x3,5),(aq,rl)))))))
   | AMO(SC_D(aq,(rl,(rd,(rs1,rs2))))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x3,3),(rd,(rs1,(rs2,amofunc(BitsN.B(0x2,5),(aq,rl)))))))
   | AMO(AMOSWAP_W(aq,(rl,(rd,(rs1,rs2))))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x2,3),(rd,(rs1,(rs2,amofunc(BitsN.B(0x1,5),(aq,rl)))))))
   | AMO(AMOADD_W(aq,(rl,(rd,(rs1,rs2))))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x2,3),(rd,(rs1,(rs2,amofunc(BitsN.B(0x0,5),(aq,rl)))))))
   | AMO(AMOXOR_W(aq,(rl,(rd,(rs1,rs2))))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x2,3),(rd,(rs1,(rs2,amofunc(BitsN.B(0x4,5),(aq,rl)))))))
   | AMO(AMOAND_W(aq,(rl,(rd,(rs1,rs2))))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x2,3),(rd,(rs1,(rs2,amofunc(BitsN.B(0xC,5),(aq,rl)))))))
   | AMO(AMOOR_W(aq,(rl,(rd,(rs1,rs2))))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x2,3),(rd,(rs1,(rs2,amofunc(BitsN.B(0x8,5),(aq,rl)))))))
   | AMO(AMOMIN_W(aq,(rl,(rd,(rs1,rs2))))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x2,3),(rd,(rs1,(rs2,amofunc(BitsN.B(0x10,5),(aq,rl)))))))
   | AMO(AMOMAX_W(aq,(rl,(rd,(rs1,rs2))))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x2,3),(rd,(rs1,(rs2,amofunc(BitsN.B(0x14,5),(aq,rl)))))))
   | AMO(AMOMINU_W(aq,(rl,(rd,(rs1,rs2))))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x2,3),(rd,(rs1,(rs2,amofunc(BitsN.B(0x18,5),(aq,rl)))))))
   | AMO(AMOMAXU_W(aq,(rl,(rd,(rs1,rs2))))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x2,3),(rd,(rs1,(rs2,amofunc(BitsN.B(0x1C,5),(aq,rl)))))))
   | AMO(AMOSWAP_D(aq,(rl,(rd,(rs1,rs2))))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x3,3),(rd,(rs1,(rs2,amofunc(BitsN.B(0x1,5),(aq,rl)))))))
   | AMO(AMOADD_D(aq,(rl,(rd,(rs1,rs2))))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x3,3),(rd,(rs1,(rs2,amofunc(BitsN.B(0x0,5),(aq,rl)))))))
   | AMO(AMOXOR_D(aq,(rl,(rd,(rs1,rs2))))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x3,3),(rd,(rs1,(rs2,amofunc(BitsN.B(0x4,5),(aq,rl)))))))
   | AMO(AMOAND_D(aq,(rl,(rd,(rs1,rs2))))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x3,3),(rd,(rs1,(rs2,amofunc(BitsN.B(0xC,5),(aq,rl)))))))
   | AMO(AMOOR_D(aq,(rl,(rd,(rs1,rs2))))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x3,3),(rd,(rs1,(rs2,amofunc(BitsN.B(0x8,5),(aq,rl)))))))
   | AMO(AMOMIN_D(aq,(rl,(rd,(rs1,rs2))))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x3,3),(rd,(rs1,(rs2,amofunc(BitsN.B(0x10,5),(aq,rl)))))))
   | AMO(AMOMAX_D(aq,(rl,(rd,(rs1,rs2))))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x3,3),(rd,(rs1,(rs2,amofunc(BitsN.B(0x14,5),(aq,rl)))))))
   | AMO(AMOMINU_D(aq,(rl,(rd,(rs1,rs2))))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x3,3),(rd,(rs1,(rs2,amofunc(BitsN.B(0x18,5),(aq,rl)))))))
   | AMO(AMOMAXU_D(aq,(rl,(rd,(rs1,rs2))))) =>
     Rtype
       (opc(BitsN.B(0xB,8)),
        (BitsN.B(0x3,3),(rd,(rs1,(rs2,amofunc(BitsN.B(0x1C,5),(aq,rl)))))))
   | System ECALL =>
     Itype
       (opc(BitsN.B(0x1C,8)),
        (BitsN.B(0x0,3),(BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x0,12)))))
   | System EBREAK =>
     Itype
       (opc(BitsN.B(0x1C,8)),
        (BitsN.B(0x0,3),(BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x1,12)))))
   | System ERET =>
     Itype
       (opc(BitsN.B(0x1C,8)),
        (BitsN.B(0x0,3),
         (BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x100,12)))))
   | System MRTS =>
     Itype
       (opc(BitsN.B(0x1C,8)),
        (BitsN.B(0x0,3),
         (BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x305,12)))))
   | System WFI =>
     Itype
       (opc(BitsN.B(0x1C,8)),
        (BitsN.B(0x0,3),
         (BitsN.B(0x0,5),(BitsN.B(0x0,5),BitsN.B(0x102,12)))))
   | System(SFENCE_VM rs1) =>
     Itype
       (opc(BitsN.B(0x1C,8)),
        (BitsN.B(0x0,3),(BitsN.B(0x0,5),(rs1,BitsN.B(0x101,12)))))
   | System(CSRRW(rd,(rs1,csr))) =>
     Itype(opc(BitsN.B(0x1C,8)),(BitsN.B(0x1,3),(rd,(rs1,csr))))
   | System(CSRRS(rd,(rs1,csr))) =>
     Itype(opc(BitsN.B(0x1C,8)),(BitsN.B(0x2,3),(rd,(rs1,csr))))
   | System(CSRRC(rd,(rs1,csr))) =>
     Itype(opc(BitsN.B(0x1C,8)),(BitsN.B(0x3,3),(rd,(rs1,csr))))
   | System(CSRRWI(rd,(imm,csr))) =>
     Itype(opc(BitsN.B(0x1C,8)),(BitsN.B(0x5,3),(rd,(imm,csr))))
   | System(CSRRSI(rd,(imm,csr))) =>
     Itype(opc(BitsN.B(0x1C,8)),(BitsN.B(0x6,3),(rd,(imm,csr))))
   | System(CSRRCI(rd,(imm,csr))) =>
     Itype(opc(BitsN.B(0x1C,8)),(BitsN.B(0x7,3),(rd,(imm,csr))))
   | UnknownInstruction => BitsN.B(0x0,32)
   | Internal(FETCH_MISALIGNED _) => BitsN.B(0x0,32)
   | Internal(FETCH_FAULT _) => BitsN.B(0x0,32);

fun log_instruction (w,inst) =
  String.concat
    ["instr ",BitsN.toHexString (!procID)," ",
     Nat.toString
       (BitsN.toNat(Map.lookup((!c_instret),BitsN.toNat (!procID)))),
     " 0x",hex64(PC ())," : ",hex32 w,"   ",instructionToString inst];

fun exitCode () = BitsN.toNat(ExitCode ());

val CYCLES_PER_TIMER_TICK = 200

fun tickClock () =
  let
    val cycles =
      BitsN.+
        (Map.lookup((!c_cycles),BitsN.toNat (!procID)),BitsN.B(0x1,64))
  in
    ( c_cycles := (Map.update((!c_cycles),BitsN.toNat (!procID),cycles))
    ; clock := (BitsN.div(cycles,BitsN.fromNat(CYCLES_PER_TIMER_TICK,64)))
    )
  end;

fun incrInstret () =
  c_instret :=
  (Map.update
     ((!c_instret),BitsN.toNat (!procID),
      BitsN.+
        (Map.lookup((!c_instret),BitsN.toNat (!procID)),BitsN.B(0x1,64))));

fun checkTimers () =
  ( if BitsN.>+
         ((!clock),BitsN.+((#mtimecmp)(MCSR ()),(#mtime_delta)(MCSR ())))
      then let
             val x = MCSR ()
             val x0 = (#mip) x
           in
             write'MCSR(MachineCSR_mip_rupd(x,mip_MTIP_rupd(x0,true)))
           end
    else ()
  ; if BitsN.>+
         ((!clock),BitsN.+((#stimecmp)(SCSR ()),(#stime_delta)(SCSR ())))
      then let
             val x = MCSR ()
             val x0 = (#mip) x
           in
             write'MCSR(MachineCSR_mip_rupd(x,mip_STIP_rupd(x0,true)))
           end
    else ()
  );

fun Next () =
  ( clear_logs ()
  ; if not(((#mtohost)(MCSR ())) = (BitsN.B(0x0,64)))
      then ( log := ((0,log_tohost((#mtohost)(MCSR ()))) :: (!log))
           ; if BitsN.bit((#mtohost)(MCSR ()),0)
               then ( done := true
                    ; write'ExitCode(BitsN.>>((#mtohost)(MCSR ()),1))
                    )
             else let
                    val x = MCSR ()
                  in
                    write'MCSR(MachineCSR_mtohost_rupd(x,BitsN.B(0x0,64)))
                  end
           )
    else ()
  ; case Fetch () of
       F_Result w =>
         let
           val inst = Decode w
         in
           ( log := ((1,log_instruction(w,inst)) :: (!log)); Run inst )
         end
     | F_Error inst =>
       ( log := ((1,log_instruction(BitsN.B(0x0,32),inst)) :: (!log))
       ; Run inst
       )
  ; checkTimers ()
  ; case (NextFetch (),checkInterrupts ()) of
       (NONE,NONE) =>
         ( incrInstret (); write'PC(BitsN.+(PC (),BitsN.B(0x4,64))) )
     | (NONE,Option.SOME(i,p)) =>
       ( incrInstret ()
       ; takeTrap
           (true,
            (interruptIndex i,(BitsN.+(PC (),BitsN.B(0x4,64)),(NONE,p))))
       )
     | (Option.SOME(BranchTo addr),_) =>
       ( incrInstret (); write'NextFetch NONE; write'PC addr )
     | (Option.SOME Ereturn,_) =>
       ( incrInstret ()
       ; write'NextFetch NONE
       ; write'PC(curEPC ())
       ; let
           val from = curPrivilege ()
         in
           ( let
               val x = MCSR ()
             in
               write'MCSR
                 (MachineCSR_mstatus_rupd
                    (x,popPrivilegeStack((#mstatus)(MCSR ()))))
             end
           ; let
               val to = curPrivilege ()
             in
               log :=
               ((1,
                 String.concat
                   ["exception return from ",privName from," to ",
                    privName to])
                  ::
                  (!log))
             end
           )
         end
       )
     | (Option.SOME(Trap t),_) =>
       ( write'NextFetch NONE
       ; takeTrap
           (false,(excCode((#trap) t),(PC (),((#badaddr) t,Machine))))
       )
     | (Option.SOME Mrts,_) =>
       ( incrInstret ()
       ; write'NextFetch NONE
       ; write'PC((#stvec)(SCSR ()))
       )
  ; tickClock ()
  );

fun initIdent arch =
  ( let
      val x = MCSR ()
      val x0 = (#mcpuid) x
    in
      write'MCSR
        (MachineCSR_mcpuid_rupd(x,mcpuid_ArchBase_rupd(x0,archBase arch)))
    end
  ; let
      val x = MCSR ()
      val x0 = (#mcpuid) x
    in
      write'MCSR(MachineCSR_mcpuid_rupd(x,mcpuid_U_rupd(x0,true)))
    end
  ; let
      val x = MCSR ()
      val x0 = (#mcpuid) x
    in
      write'MCSR(MachineCSR_mcpuid_rupd(x,mcpuid_S_rupd(x0,true)))
    end
  ; let
      val x = MCSR ()
      val x0 = (#mcpuid) x
    in
      write'MCSR(MachineCSR_mcpuid_rupd(x,mcpuid_M_rupd(x0,true)))
    end
  ; let
      val x = MCSR ()
      val x0 = (#mcpuid) x
    in
      write'MCSR(MachineCSR_mcpuid_rupd(x,mcpuid_I_rupd(x0,true)))
    end
  ; let
      val x = MCSR ()
      val x0 = (#mimpid) x
    in
      write'MCSR
        (MachineCSR_mimpid_rupd
           (x,mimpid_RVSource_rupd(x0,BitsN.B(0x8000,16))))
    end
  ; let
      val x = MCSR ()
      val x0 = (#mimpid) x
    in
      write'MCSR
        (MachineCSR_mimpid_rupd(x,mimpid_RVImpl_rupd(x0,BitsN.B(0x0,48))))
    end
  );

fun initMachine hartid =
  ( let
      val x = MCSR ()
      val x0 = (#mstatus) x
    in
      write'MCSR
        (MachineCSR_mstatus_rupd(x,mstatus_VM_rupd(x0,vmMode Mbare)))
    end
  ; let
      val x = MCSR ()
      val x0 = (#mstatus) x
    in
      write'MCSR
        (MachineCSR_mstatus_rupd
           (x,mstatus_MPRV_rupd(x0,privLevel Machine)))
    end
  ; let
      val x = MCSR ()
      val x0 = (#mstatus) x
    in
      write'MCSR(MachineCSR_mstatus_rupd(x,mstatus_MIE_rupd(x0,false)))
    end
  ; let
      val x = MCSR ()
    in
      write'MCSR(MachineCSR_mhartid_rupd(x,BitsN.zeroExtend 64 hartid))
    end
  ; let
      val x = MCSR ()
    in
      write'MCSR
        (MachineCSR_mtvec_rupd(x,BitsN.zeroExtend 64 (BitsN.B(0x100,16))))
    end
  );

fun initRegs pc =
  ( L3.for
      (0,31,
       fn i =>
         let
           val x = BitsN.fromNat(i,5)
         in
           write'gpr(BitsN.B(0x0,64),x)
         end)
  ; write'PC(BitsN.fromNat(pc,64))
  ; write'NextFetch NONE
  ; done := false
  );

end