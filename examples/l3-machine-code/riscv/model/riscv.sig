(* riscv - generated by L3 - Mon May 23 12:34:14 2016 *)

signature riscv =
sig

structure Map: MutableMap

(* -------------------------------------------------------------------------
   Types
   ------------------------------------------------------------------------- *)

datatype accessType = Read | Write

datatype fetchType = Instruction | Data

datatype Architecture = RV32I | RV64I | RV128I

datatype Privilege = User | Supervisor | Hypervisor | Machine

datatype VM_Mode = Mbare | Mbb | Mbbid | Sv32 | Sv39 | Sv48 | Sv57 | Sv64

datatype ExtStatus = Off | Initial | Clean | Dirty

datatype Interrupt = Software | Timer

datatype ExceptionType
  = Fetch_Misaligned | Fetch_Fault | Illegal_Instr | Breakpoint
  | Load_Fault | AMO_Misaligned | Store_AMO_Fault | UMode_Env_Call
  | SMode_Env_Call | HMode_Env_Call | MMode_Env_Call

type mcpuid =
  { ArchBase: BitsN.nbit, I: bool, M: bool, S: bool, U: bool,
    mcpuid'rst: BitsN.nbit }

type mimpid = { RVImpl: BitsN.nbit, RVSource: BitsN.nbit }

type mstatus =
  { MFS: BitsN.nbit, MIE: bool, MIE1: bool, MIE2: bool, MIE3: bool,
    MMPRV: bool, MPRV: BitsN.nbit, MPRV1: BitsN.nbit, MPRV2: BitsN.nbit,
    MPRV3: BitsN.nbit, MSD: bool, MXS: BitsN.nbit, VM: BitsN.nbit,
    mstatus'rst: BitsN.nbit }

type mtdeleg = { Exc_deleg: BitsN.nbit, Intr_deleg: BitsN.nbit }

type mip =
  { HSIP: bool, HTIP: bool, MSIP: bool, MTIP: bool, SSIP: bool,
    STIP: bool, mip'rst: BitsN.nbit }

type mie =
  { HSIE: bool, HTIE: bool, MSIE: bool, MTIE: bool, SSIE: bool,
    STIE: bool, mie'rst: BitsN.nbit }

type mcause = { EC: BitsN.nbit, Int: bool, mcause'rst: BitsN.nbit }

type MachineCSR =
  { mbadaddr: BitsN.nbit, mbase: BitsN.nbit, mbound: BitsN.nbit,
    mcause: mcause, mcpuid: mcpuid, mdbase: BitsN.nbit,
    mdbound: BitsN.nbit, mepc: BitsN.nbit, mfromhost: BitsN.nbit,
    mhartid: BitsN.nbit, mibase: BitsN.nbit, mibound: BitsN.nbit,
    mie: mie, mimpid: mimpid, mip: mip, mscratch: BitsN.nbit,
    mstatus: mstatus, mtdeleg: mtdeleg, mtime_delta: BitsN.nbit,
    mtimecmp: BitsN.nbit, mtohost: BitsN.nbit, mtvec: BitsN.nbit }

type HypervisorCSR =
  { hbadaddr: BitsN.nbit, hcause: mcause, hepc: BitsN.nbit,
    hscratch: BitsN.nbit, hstatus: mstatus, htdeleg: mtdeleg,
    htime_delta: BitsN.nbit, htimecmp: BitsN.nbit, htvec: BitsN.nbit }

type sstatus =
  { SFS: BitsN.nbit, SIE: bool, SMPRV: bool, SPIE: bool, SPS: bool,
    SSD: bool, SXS: BitsN.nbit, sstatus'rst: BitsN.nbit }

type sip = { SSIP: bool, STIP: bool, sip'rst: BitsN.nbit }

type sie = { SSIE: bool, STIE: bool, sie'rst: BitsN.nbit }

type SupervisorCSR =
  { sasid: BitsN.nbit, sbadaddr: BitsN.nbit, scause: mcause,
    sepc: BitsN.nbit, sptbr: BitsN.nbit, sscratch: BitsN.nbit,
    stime_delta: BitsN.nbit, stimecmp: BitsN.nbit, stvec: BitsN.nbit }

type UserCSR =
  { cycle_delta: BitsN.nbit, instret_delta: BitsN.nbit,
    time_delta: BitsN.nbit }

type SynchronousTrap = { badaddr: BitsN.nbit option, trap: ExceptionType }

datatype TransferControl
  = BranchTo of BitsN.nbit | Ereturn | Mrts | Trap of SynchronousTrap

type StateDelta =
  { addr: BitsN.nbit option, data1: BitsN.nbit option,
    data2: BitsN.nbit option, exc_taken: bool, fetch_exc: bool,
    fp_data: BitsN.nbit option, pc: BitsN.nbit, rinstr: BitsN.nbit,
    st_width: BitsN.nbit option }

type SV_PTE =
  { PTE_D: bool, PTE_PPNi: BitsN.nbit, PTE_R: bool, PTE_SW: BitsN.nbit,
    PTE_T: BitsN.nbit, PTE_V: bool, sv_pte'rst: BitsN.nbit }

type SV_Vaddr =
  { Sv_PgOfs: BitsN.nbit, Sv_VPNi: BitsN.nbit, sv_vaddr'rst: BitsN.nbit }

type TLBEntry =
  { age: BitsN.nbit, asid: BitsN.nbit, global: bool, pAddr: BitsN.nbit,
    pte: SV_PTE, pteAddr: BitsN.nbit, vAddr: BitsN.nbit,
    vAddrMask: BitsN.nbit, vMatchMask: BitsN.nbit }

datatype Internal
  = FETCH_FAULT of BitsN.nbit | FETCH_MISALIGNED of BitsN.nbit

datatype System
  = CSRRC of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | CSRRCI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | CSRRS of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | CSRRSI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | CSRRW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | CSRRWI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | EBREAK
  | ECALL
  | ERET
  | MRTS
  | SFENCE_VM of BitsN.nbit
  | WFI

datatype AMO
  = AMOADD_D of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOADD_W of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOAND_D of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOAND_W of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOMAXU_D of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOMAXU_W of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOMAX_D of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOMAX_W of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOMINU_D of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOMINU_W of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOMIN_D of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOMIN_W of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOOR_D of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOOR_W of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOSWAP_D of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOSWAP_W of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOXOR_D of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | AMOXOR_W of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | LR_D of BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | LR_W of BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | SC_D of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))
  | SC_W of
      BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))

datatype Store
  = SB of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SD of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SH of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype Load
  = LB of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LBU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LD of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LH of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LHU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | LWU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype Branch
  = BEQ of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | BGE of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | BGEU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | BLT of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | BLTU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | BNE of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | JAL of BitsN.nbit * BitsN.nbit
  | JALR of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype MulDiv
  = DIV of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | DIVU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | DIVUW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | DIVW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | MUL of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | MULH of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | MULHSU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | MULHU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | MULW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | REM of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | REMU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | REMUW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | REMW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype Shift
  = SLL of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SLLI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SLLIW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SLLW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SRA of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SRAI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SRAIW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SRAW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SRL of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SRLI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SRLIW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SRLW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype ArithR
  = ADD of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | ADDW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | AND of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | OR of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SLT of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SLTU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SUB of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SUBW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | XOR of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype ArithI
  = ADDI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | ADDIW of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | ANDI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | AUIPC of BitsN.nbit * BitsN.nbit
  | LUI of BitsN.nbit * BitsN.nbit
  | ORI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SLTI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | SLTIU of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | XORI of BitsN.nbit * (BitsN.nbit * BitsN.nbit)

datatype instruction
  = AMO of AMO
  | ArithI of ArithI
  | ArithR of ArithR
  | Branch of Branch
  | FENCE of BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))
  | FENCE_I of BitsN.nbit * (BitsN.nbit * BitsN.nbit)
  | Internal of Internal
  | Load of Load
  | MulDiv of MulDiv
  | Shift of Shift
  | Store of Store
  | System of System
  | UnknownInstruction

datatype FetchResult = F_Error of instruction | F_Result of BitsN.nbit

(* -------------------------------------------------------------------------
   Exceptions
   ------------------------------------------------------------------------- *)

exception INTERNAL_ERROR of string

exception UNDEFINED of string

(* -------------------------------------------------------------------------
   Functions
   ------------------------------------------------------------------------- *)

structure Cast:
sig

val natToaccessType:Nat.nat -> accessType
val accessTypeToNat:accessType-> Nat.nat
val stringToaccessType:string -> accessType
val accessTypeToString:accessType-> string
val natTofetchType:Nat.nat -> fetchType
val fetchTypeToNat:fetchType-> Nat.nat
val stringTofetchType:string -> fetchType
val fetchTypeToString:fetchType-> string
val natToArchitecture:Nat.nat -> Architecture
val ArchitectureToNat:Architecture-> Nat.nat
val stringToArchitecture:string -> Architecture
val ArchitectureToString:Architecture-> string
val natToPrivilege:Nat.nat -> Privilege
val PrivilegeToNat:Privilege-> Nat.nat
val stringToPrivilege:string -> Privilege
val PrivilegeToString:Privilege-> string
val natToVM_Mode:Nat.nat -> VM_Mode
val VM_ModeToNat:VM_Mode-> Nat.nat
val stringToVM_Mode:string -> VM_Mode
val VM_ModeToString:VM_Mode-> string
val natToExtStatus:Nat.nat -> ExtStatus
val ExtStatusToNat:ExtStatus-> Nat.nat
val stringToExtStatus:string -> ExtStatus
val ExtStatusToString:ExtStatus-> string
val natToInterrupt:Nat.nat -> Interrupt
val InterruptToNat:Interrupt-> Nat.nat
val stringToInterrupt:string -> Interrupt
val InterruptToString:Interrupt-> string
val natToExceptionType:Nat.nat -> ExceptionType
val ExceptionTypeToNat:ExceptionType-> Nat.nat
val stringToExceptionType:string -> ExceptionType
val ExceptionTypeToString:ExceptionType-> string

end

val MEM8: (BitsN.nbit Map.map) ref
val c_ExitCode: (BitsN.nbit Map.map) ref
val c_HCSR: (HypervisorCSR Map.map) ref
val c_MCSR: (MachineCSR Map.map) ref
val c_NextFetch: ((TransferControl option) Map.map) ref
val c_PC: (BitsN.nbit Map.map) ref
val c_ReserveLoad: ((BitsN.nbit option) Map.map) ref
val c_SCSR: (SupervisorCSR Map.map) ref
val c_UCSR: (UserCSR Map.map) ref
val c_cycles: (BitsN.nbit Map.map) ref
val c_gpr: ((BitsN.nbit Map.map) Map.map) ref
val c_instret: (BitsN.nbit Map.map) ref
val c_tlb: (((TLBEntry option) Map.map) Map.map) ref
val c_update: (StateDelta Map.map) ref
val clock: BitsN.nbit ref
val done: bool ref
val log: ((Nat.nat * string) list) ref
val procID: BitsN.nbit ref
val totalCore: Nat.nat ref
val mcpuid_ArchBase_rupd: mcpuid * BitsN.nbit -> mcpuid
val mcpuid_I_rupd: mcpuid * bool -> mcpuid
val mcpuid_M_rupd: mcpuid * bool -> mcpuid
val mcpuid_S_rupd: mcpuid * bool -> mcpuid
val mcpuid_U_rupd: mcpuid * bool -> mcpuid
val mcpuid_mcpuid'rst_rupd: mcpuid * BitsN.nbit -> mcpuid
val mimpid_RVImpl_rupd: mimpid * BitsN.nbit -> mimpid
val mimpid_RVSource_rupd: mimpid * BitsN.nbit -> mimpid
val mstatus_MFS_rupd: mstatus * BitsN.nbit -> mstatus
val mstatus_MIE_rupd: mstatus * bool -> mstatus
val mstatus_MIE1_rupd: mstatus * bool -> mstatus
val mstatus_MIE2_rupd: mstatus * bool -> mstatus
val mstatus_MIE3_rupd: mstatus * bool -> mstatus
val mstatus_MMPRV_rupd: mstatus * bool -> mstatus
val mstatus_MPRV_rupd: mstatus * BitsN.nbit -> mstatus
val mstatus_MPRV1_rupd: mstatus * BitsN.nbit -> mstatus
val mstatus_MPRV2_rupd: mstatus * BitsN.nbit -> mstatus
val mstatus_MPRV3_rupd: mstatus * BitsN.nbit -> mstatus
val mstatus_MSD_rupd: mstatus * bool -> mstatus
val mstatus_MXS_rupd: mstatus * BitsN.nbit -> mstatus
val mstatus_VM_rupd: mstatus * BitsN.nbit -> mstatus
val mstatus_mstatus'rst_rupd: mstatus * BitsN.nbit -> mstatus
val mtdeleg_Exc_deleg_rupd: mtdeleg * BitsN.nbit -> mtdeleg
val mtdeleg_Intr_deleg_rupd: mtdeleg * BitsN.nbit -> mtdeleg
val mip_HSIP_rupd: mip * bool -> mip
val mip_HTIP_rupd: mip * bool -> mip
val mip_MSIP_rupd: mip * bool -> mip
val mip_MTIP_rupd: mip * bool -> mip
val mip_SSIP_rupd: mip * bool -> mip
val mip_STIP_rupd: mip * bool -> mip
val mip_mip'rst_rupd: mip * BitsN.nbit -> mip
val mie_HSIE_rupd: mie * bool -> mie
val mie_HTIE_rupd: mie * bool -> mie
val mie_MSIE_rupd: mie * bool -> mie
val mie_MTIE_rupd: mie * bool -> mie
val mie_SSIE_rupd: mie * bool -> mie
val mie_STIE_rupd: mie * bool -> mie
val mie_mie'rst_rupd: mie * BitsN.nbit -> mie
val mcause_EC_rupd: mcause * BitsN.nbit -> mcause
val mcause_Int_rupd: mcause * bool -> mcause
val mcause_mcause'rst_rupd: mcause * BitsN.nbit -> mcause
val MachineCSR_mbadaddr_rupd: MachineCSR * BitsN.nbit -> MachineCSR
val MachineCSR_mbase_rupd: MachineCSR * BitsN.nbit -> MachineCSR
val MachineCSR_mbound_rupd: MachineCSR * BitsN.nbit -> MachineCSR
val MachineCSR_mcause_rupd: MachineCSR * mcause -> MachineCSR
val MachineCSR_mcpuid_rupd: MachineCSR * mcpuid -> MachineCSR
val MachineCSR_mdbase_rupd: MachineCSR * BitsN.nbit -> MachineCSR
val MachineCSR_mdbound_rupd: MachineCSR * BitsN.nbit -> MachineCSR
val MachineCSR_mepc_rupd: MachineCSR * BitsN.nbit -> MachineCSR
val MachineCSR_mfromhost_rupd: MachineCSR * BitsN.nbit -> MachineCSR
val MachineCSR_mhartid_rupd: MachineCSR * BitsN.nbit -> MachineCSR
val MachineCSR_mibase_rupd: MachineCSR * BitsN.nbit -> MachineCSR
val MachineCSR_mibound_rupd: MachineCSR * BitsN.nbit -> MachineCSR
val MachineCSR_mie_rupd: MachineCSR * mie -> MachineCSR
val MachineCSR_mimpid_rupd: MachineCSR * mimpid -> MachineCSR
val MachineCSR_mip_rupd: MachineCSR * mip -> MachineCSR
val MachineCSR_mscratch_rupd: MachineCSR * BitsN.nbit -> MachineCSR
val MachineCSR_mstatus_rupd: MachineCSR * mstatus -> MachineCSR
val MachineCSR_mtdeleg_rupd: MachineCSR * mtdeleg -> MachineCSR
val MachineCSR_mtime_delta_rupd: MachineCSR * BitsN.nbit -> MachineCSR
val MachineCSR_mtimecmp_rupd: MachineCSR * BitsN.nbit -> MachineCSR
val MachineCSR_mtohost_rupd: MachineCSR * BitsN.nbit -> MachineCSR
val MachineCSR_mtvec_rupd: MachineCSR * BitsN.nbit -> MachineCSR
val HypervisorCSR_hbadaddr_rupd:
  HypervisorCSR * BitsN.nbit -> HypervisorCSR
val HypervisorCSR_hcause_rupd: HypervisorCSR * mcause -> HypervisorCSR
val HypervisorCSR_hepc_rupd: HypervisorCSR * BitsN.nbit -> HypervisorCSR
val HypervisorCSR_hscratch_rupd:
  HypervisorCSR * BitsN.nbit -> HypervisorCSR
val HypervisorCSR_hstatus_rupd: HypervisorCSR * mstatus -> HypervisorCSR
val HypervisorCSR_htdeleg_rupd: HypervisorCSR * mtdeleg -> HypervisorCSR
val HypervisorCSR_htime_delta_rupd:
  HypervisorCSR * BitsN.nbit -> HypervisorCSR
val HypervisorCSR_htimecmp_rupd:
  HypervisorCSR * BitsN.nbit -> HypervisorCSR
val HypervisorCSR_htvec_rupd: HypervisorCSR * BitsN.nbit -> HypervisorCSR
val sstatus_SFS_rupd: sstatus * BitsN.nbit -> sstatus
val sstatus_SIE_rupd: sstatus * bool -> sstatus
val sstatus_SMPRV_rupd: sstatus * bool -> sstatus
val sstatus_SPIE_rupd: sstatus * bool -> sstatus
val sstatus_SPS_rupd: sstatus * bool -> sstatus
val sstatus_SSD_rupd: sstatus * bool -> sstatus
val sstatus_SXS_rupd: sstatus * BitsN.nbit -> sstatus
val sstatus_sstatus'rst_rupd: sstatus * BitsN.nbit -> sstatus
val sip_SSIP_rupd: sip * bool -> sip
val sip_STIP_rupd: sip * bool -> sip
val sip_sip'rst_rupd: sip * BitsN.nbit -> sip
val sie_SSIE_rupd: sie * bool -> sie
val sie_STIE_rupd: sie * bool -> sie
val sie_sie'rst_rupd: sie * BitsN.nbit -> sie
val SupervisorCSR_sasid_rupd: SupervisorCSR * BitsN.nbit -> SupervisorCSR
val SupervisorCSR_sbadaddr_rupd:
  SupervisorCSR * BitsN.nbit -> SupervisorCSR
val SupervisorCSR_scause_rupd: SupervisorCSR * mcause -> SupervisorCSR
val SupervisorCSR_sepc_rupd: SupervisorCSR * BitsN.nbit -> SupervisorCSR
val SupervisorCSR_sptbr_rupd: SupervisorCSR * BitsN.nbit -> SupervisorCSR
val SupervisorCSR_sscratch_rupd:
  SupervisorCSR * BitsN.nbit -> SupervisorCSR
val SupervisorCSR_stime_delta_rupd:
  SupervisorCSR * BitsN.nbit -> SupervisorCSR
val SupervisorCSR_stimecmp_rupd:
  SupervisorCSR * BitsN.nbit -> SupervisorCSR
val SupervisorCSR_stvec_rupd: SupervisorCSR * BitsN.nbit -> SupervisorCSR
val UserCSR_cycle_delta_rupd: UserCSR * BitsN.nbit -> UserCSR
val UserCSR_instret_delta_rupd: UserCSR * BitsN.nbit -> UserCSR
val UserCSR_time_delta_rupd: UserCSR * BitsN.nbit -> UserCSR
val SynchronousTrap_badaddr_rupd:
  SynchronousTrap * (BitsN.nbit option) -> SynchronousTrap
val SynchronousTrap_trap_rupd:
  SynchronousTrap * ExceptionType -> SynchronousTrap
val StateDelta_addr_rupd: StateDelta * (BitsN.nbit option) -> StateDelta
val StateDelta_data1_rupd: StateDelta * (BitsN.nbit option) -> StateDelta
val StateDelta_data2_rupd: StateDelta * (BitsN.nbit option) -> StateDelta
val StateDelta_exc_taken_rupd: StateDelta * bool -> StateDelta
val StateDelta_fetch_exc_rupd: StateDelta * bool -> StateDelta
val StateDelta_fp_data_rupd:
  StateDelta * (BitsN.nbit option) -> StateDelta
val StateDelta_pc_rupd: StateDelta * BitsN.nbit -> StateDelta
val StateDelta_rinstr_rupd: StateDelta * BitsN.nbit -> StateDelta
val StateDelta_st_width_rupd:
  StateDelta * (BitsN.nbit option) -> StateDelta
val SV_PTE_PTE_D_rupd: SV_PTE * bool -> SV_PTE
val SV_PTE_PTE_PPNi_rupd: SV_PTE * BitsN.nbit -> SV_PTE
val SV_PTE_PTE_R_rupd: SV_PTE * bool -> SV_PTE
val SV_PTE_PTE_SW_rupd: SV_PTE * BitsN.nbit -> SV_PTE
val SV_PTE_PTE_T_rupd: SV_PTE * BitsN.nbit -> SV_PTE
val SV_PTE_PTE_V_rupd: SV_PTE * bool -> SV_PTE
val SV_PTE_sv_pte'rst_rupd: SV_PTE * BitsN.nbit -> SV_PTE
val SV_Vaddr_Sv_PgOfs_rupd: SV_Vaddr * BitsN.nbit -> SV_Vaddr
val SV_Vaddr_Sv_VPNi_rupd: SV_Vaddr * BitsN.nbit -> SV_Vaddr
val SV_Vaddr_sv_vaddr'rst_rupd: SV_Vaddr * BitsN.nbit -> SV_Vaddr
val TLBEntry_age_rupd: TLBEntry * BitsN.nbit -> TLBEntry
val TLBEntry_asid_rupd: TLBEntry * BitsN.nbit -> TLBEntry
val TLBEntry_global_rupd: TLBEntry * bool -> TLBEntry
val TLBEntry_pAddr_rupd: TLBEntry * BitsN.nbit -> TLBEntry
val TLBEntry_pte_rupd: TLBEntry * SV_PTE -> TLBEntry
val TLBEntry_pteAddr_rupd: TLBEntry * BitsN.nbit -> TLBEntry
val TLBEntry_vAddr_rupd: TLBEntry * BitsN.nbit -> TLBEntry
val TLBEntry_vAddrMask_rupd: TLBEntry * BitsN.nbit -> TLBEntry
val TLBEntry_vMatchMask_rupd: TLBEntry * BitsN.nbit -> TLBEntry
val boolify'32:
  BitsN.nbit ->
  bool *
  (bool *
   (bool *
    (bool *
     (bool *
      (bool *
       (bool *
        (bool *
         (bool *
          (bool *
           (bool *
            (bool *
             (bool *
              (bool *
               (bool *
                (bool *
                 (bool *
                  (bool *
                   (bool *
                    (bool *
                     (bool *
                      (bool *
                       (bool *
                        (bool *
                         (bool *
                          (bool *
                           (bool *
                            (bool * (bool * (bool * (bool * bool))))))))))))))))))))))))))))))
val ASID_SIZE: Nat.nat
val PAGESIZE_BITS: Nat.nat
val LEVEL_BITS: Nat.nat
val BYTE: BitsN.nbit
val HALFWORD: BitsN.nbit
val WORD: BitsN.nbit
val DOUBLEWORD: BitsN.nbit
val archBase: Architecture -> BitsN.nbit
val architecture: BitsN.nbit -> Architecture
val archName: Architecture -> string
val privLevel: Privilege -> BitsN.nbit
val privilege: BitsN.nbit -> Privilege
val privName: Privilege -> string
val vmType: BitsN.nbit -> VM_Mode
val isValidVM: BitsN.nbit -> bool
val vmMode: VM_Mode -> BitsN.nbit
val vmModeName: VM_Mode -> string
val ext_status: ExtStatus -> BitsN.nbit
val extStatus: BitsN.nbit -> ExtStatus
val extStatusName: ExtStatus -> string
val interruptIndex: Interrupt -> BitsN.nbit
val excCode: ExceptionType -> BitsN.nbit
val excType: BitsN.nbit -> ExceptionType
val excName: ExceptionType -> string
val rec'mcpuid: BitsN.nbit -> mcpuid
val reg'mcpuid: mcpuid -> BitsN.nbit
val write'rec'mcpuid: (BitsN.nbit * mcpuid) -> BitsN.nbit
val write'reg'mcpuid: (mcpuid * BitsN.nbit) -> mcpuid
val rec'mimpid: BitsN.nbit -> mimpid
val reg'mimpid: mimpid -> BitsN.nbit
val write'rec'mimpid: (BitsN.nbit * mimpid) -> BitsN.nbit
val write'reg'mimpid: (mimpid * BitsN.nbit) -> mimpid
val rec'mstatus: BitsN.nbit -> mstatus
val reg'mstatus: mstatus -> BitsN.nbit
val write'rec'mstatus: (BitsN.nbit * mstatus) -> BitsN.nbit
val write'reg'mstatus: (mstatus * BitsN.nbit) -> mstatus
val rec'mtdeleg: BitsN.nbit -> mtdeleg
val reg'mtdeleg: mtdeleg -> BitsN.nbit
val write'rec'mtdeleg: (BitsN.nbit * mtdeleg) -> BitsN.nbit
val write'reg'mtdeleg: (mtdeleg * BitsN.nbit) -> mtdeleg
val rec'mip: BitsN.nbit -> mip
val reg'mip: mip -> BitsN.nbit
val write'rec'mip: (BitsN.nbit * mip) -> BitsN.nbit
val write'reg'mip: (mip * BitsN.nbit) -> mip
val rec'mie: BitsN.nbit -> mie
val reg'mie: mie -> BitsN.nbit
val write'rec'mie: (BitsN.nbit * mie) -> BitsN.nbit
val write'reg'mie: (mie * BitsN.nbit) -> mie
val rec'mcause: BitsN.nbit -> mcause
val reg'mcause: mcause -> BitsN.nbit
val write'rec'mcause: (BitsN.nbit * mcause) -> BitsN.nbit
val write'reg'mcause: (mcause * BitsN.nbit) -> mcause
val rec'sstatus: BitsN.nbit -> sstatus
val reg'sstatus: sstatus -> BitsN.nbit
val write'rec'sstatus: (BitsN.nbit * sstatus) -> BitsN.nbit
val write'reg'sstatus: (sstatus * BitsN.nbit) -> sstatus
val rec'sip: BitsN.nbit -> sip
val reg'sip: sip -> BitsN.nbit
val write'rec'sip: (BitsN.nbit * sip) -> BitsN.nbit
val write'reg'sip: (sip * BitsN.nbit) -> sip
val rec'sie: BitsN.nbit -> sie
val reg'sie: sie -> BitsN.nbit
val write'rec'sie: (BitsN.nbit * sie) -> BitsN.nbit
val write'reg'sie: (sie * BitsN.nbit) -> sie
val lift_mip_sip: mip -> sip
val lift_mie_sie: mie -> sie
val lower_sip_mip: (sip * mip) -> mip
val lower_sie_mie: (sie * mie) -> mie
val update_mstatus: (mstatus * mstatus) -> mstatus
val lift_mstatus_sstatus: mstatus -> sstatus
val lower_sstatus_mstatus: (sstatus * mstatus) -> mstatus
val popPrivilegeStack: mstatus -> mstatus
val pushPrivilegeStack: (mstatus * Privilege) -> mstatus
val scheduleCore: Nat.nat -> unit
val gpr: BitsN.nbit -> BitsN.nbit
val write'gpr: (BitsN.nbit * BitsN.nbit) -> unit
val PC: unit -> BitsN.nbit
val write'PC: BitsN.nbit -> unit
val UCSR: unit -> UserCSR
val write'UCSR: UserCSR -> unit
val SCSR: unit -> SupervisorCSR
val write'SCSR: SupervisorCSR -> unit
val HCSR: unit -> HypervisorCSR
val write'HCSR: HypervisorCSR -> unit
val MCSR: unit -> MachineCSR
val write'MCSR: MachineCSR -> unit
val NextFetch: unit -> (TransferControl option)
val write'NextFetch: (TransferControl option) -> unit
val ReserveLoad: unit -> (BitsN.nbit option)
val write'ReserveLoad: (BitsN.nbit option) -> unit
val ExitCode: unit -> BitsN.nbit
val write'ExitCode: BitsN.nbit -> unit
val curArch: unit -> Architecture
val in32BitMode: unit -> bool
val curPrivilege: unit -> Privilege
val curEPC: unit -> BitsN.nbit
val sendIPI: BitsN.nbit -> unit
val csrRW: BitsN.nbit -> BitsN.nbit
val csrPR: BitsN.nbit -> BitsN.nbit
val check_CSR_access:
  (BitsN.nbit * (BitsN.nbit * (Privilege * accessType))) -> bool
val is_CSR_defined: BitsN.nbit -> bool
val CSRMap: BitsN.nbit -> BitsN.nbit
val write'CSRMap: (BitsN.nbit * BitsN.nbit) -> unit
val csrName: BitsN.nbit -> string
val Delta: unit -> StateDelta
val write'Delta: StateDelta -> unit
val hex32: BitsN.nbit -> string
val hex64: BitsN.nbit -> string
val log_w_csr: (BitsN.nbit * BitsN.nbit) -> string
val reg: BitsN.nbit -> string
val log_w_gpr: (BitsN.nbit * BitsN.nbit) -> string
val log_w_mem_mask:
  (BitsN.nbit *
   (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))))) ->
  string
val log_w_mem_mask_misaligned:
  (BitsN.nbit *
   (BitsN.nbit *
    (BitsN.nbit * (BitsN.nbit * (Nat.nat * (BitsN.nbit * BitsN.nbit)))))) ->
  string
val log_w_mem: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> string
val log_r_mem: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> string
val log_exc: ExceptionType -> string
val log_tohost: BitsN.nbit -> string
val clear_logs: unit -> unit
val setTrap: (ExceptionType * (BitsN.nbit option)) -> unit
val signalException: ExceptionType -> unit
val signalAddressException: (ExceptionType * BitsN.nbit) -> unit
val signalEnvCall: unit -> unit
val checkDelegation: (Privilege * (bool * BitsN.nbit)) -> Privilege
val checkPrivInterrupt: Privilege -> ((Interrupt * Privilege) option)
val checkInterrupts: unit -> ((Interrupt * Privilege) option)
val takeTrap:
  (bool * (BitsN.nbit * (BitsN.nbit * ((BitsN.nbit option) * Privilege)))) ->
  unit
val CSR: BitsN.nbit -> BitsN.nbit
val write'CSR: (BitsN.nbit * BitsN.nbit) -> unit
val writeCSR: (BitsN.nbit * BitsN.nbit) -> unit
val GPR: BitsN.nbit -> BitsN.nbit
val write'GPR: (BitsN.nbit * BitsN.nbit) -> unit
val MEM: BitsN.nbit -> BitsN.nbit
val write'MEM: (BitsN.nbit * BitsN.nbit) -> unit
val rawReadData: BitsN.nbit -> BitsN.nbit
val rawWriteData: (BitsN.nbit * (BitsN.nbit * Nat.nat)) -> unit
val rawReadInst: BitsN.nbit -> BitsN.nbit
val rawWriteMem: (BitsN.nbit * BitsN.nbit) -> unit
val checkMemPermission:
  (fetchType * (accessType * (Privilege * BitsN.nbit))) -> bool
val isGlobal: BitsN.nbit -> bool
val rec'SV_PTE: BitsN.nbit -> SV_PTE
val reg'SV_PTE: SV_PTE -> BitsN.nbit
val write'rec'SV_PTE: (BitsN.nbit * SV_PTE) -> BitsN.nbit
val write'reg'SV_PTE: (SV_PTE * BitsN.nbit) -> SV_PTE
val rec'SV_Vaddr: BitsN.nbit -> SV_Vaddr
val reg'SV_Vaddr: SV_Vaddr -> BitsN.nbit
val write'rec'SV_Vaddr: (BitsN.nbit * SV_Vaddr) -> BitsN.nbit
val write'reg'SV_Vaddr: (SV_Vaddr * BitsN.nbit) -> SV_Vaddr
val walk64:
  (BitsN.nbit *
   (fetchType * (accessType * (Privilege * (BitsN.nbit * Nat.nat))))) ->
  ((BitsN.nbit * (SV_PTE * (Nat.nat * (bool * BitsN.nbit)))) option)
val curASID: unit -> BitsN.nbit
val mkTLBEntry:
  (BitsN.nbit *
   (bool * (BitsN.nbit * (BitsN.nbit * (SV_PTE * (Nat.nat * BitsN.nbit)))))) ->
  TLBEntry
val TLBEntries: Nat.nat
val lookupTLB:
  (BitsN.nbit * (BitsN.nbit * ((TLBEntry option) Map.map))) ->
  ((TLBEntry * BitsN.nbit) option)
val addToTLB:
  (BitsN.nbit *
   (BitsN.nbit *
    (BitsN.nbit *
     (SV_PTE *
      (BitsN.nbit * (Nat.nat * (bool * ((TLBEntry option) Map.map)))))))) ->
  ((TLBEntry option) Map.map)
val flushTLB:
  (BitsN.nbit * ((BitsN.nbit option) * ((TLBEntry option) Map.map))) ->
  ((TLBEntry option) Map.map)
val TLB: unit -> ((TLBEntry option) Map.map)
val write'TLB: ((TLBEntry option) Map.map) -> unit
val translate64:
  (BitsN.nbit * (fetchType * (accessType * (Privilege * Nat.nat)))) ->
  (BitsN.nbit option)
val translateAddr:
  (BitsN.nbit * (fetchType * accessType)) -> (BitsN.nbit option)
val matchLoadReservation: BitsN.nbit -> bool
val branchTo: BitsN.nbit -> unit
val dfn'ADDI: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'ADDIW: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SLTI: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SLTIU: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'ANDI: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'ORI: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'XORI: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SLLI: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SRLI: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SRAI: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SLLIW: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SRLIW: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SRAIW: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'LUI: (BitsN.nbit * BitsN.nbit) -> unit
val dfn'AUIPC: (BitsN.nbit * BitsN.nbit) -> unit
val dfn'ADD: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'ADDW: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SUB: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SUBW: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SLT: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SLTU: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'AND: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'OR: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'XOR: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SLL: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SLLW: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SRL: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SRLW: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SRA: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SRAW: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'MUL: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'MULH: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'MULHU: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'MULHSU: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'MULW: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'DIV: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'REM: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'DIVU: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'REMU: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'DIVW: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'REMW: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'DIVUW: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'REMUW: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'JAL: (BitsN.nbit * BitsN.nbit) -> unit
val dfn'JALR: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'BEQ: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'BNE: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'BLT: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'BLTU: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'BGE: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'BGEU: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'LW: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'LWU: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'LH: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'LHU: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'LB: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'LBU: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'LD: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SW: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SH: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SB: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SD: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'FENCE:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))) -> unit
val dfn'FENCE_I: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'LR_W:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))) -> unit
val dfn'LR_D:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))) -> unit
val dfn'SC_W:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  unit
val dfn'SC_D:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  unit
val dfn'AMOSWAP_W:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  unit
val dfn'AMOSWAP_D:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  unit
val dfn'AMOADD_W:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  unit
val dfn'AMOADD_D:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  unit
val dfn'AMOXOR_W:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  unit
val dfn'AMOXOR_D:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  unit
val dfn'AMOAND_W:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  unit
val dfn'AMOAND_D:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  unit
val dfn'AMOOR_W:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  unit
val dfn'AMOOR_D:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  unit
val dfn'AMOMIN_W:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  unit
val dfn'AMOMIN_D:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  unit
val dfn'AMOMAX_W:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  unit
val dfn'AMOMAX_D:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  unit
val dfn'AMOMINU_W:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  unit
val dfn'AMOMINU_D:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  unit
val dfn'AMOMAXU_W:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  unit
val dfn'AMOMAXU_D:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  unit
val dfn'ECALL: unit -> unit
val dfn'EBREAK: unit -> unit
val dfn'ERET: unit -> unit
val dfn'MRTS: unit -> unit
val dfn'WFI: unit
val checkCSROp: (BitsN.nbit * (BitsN.nbit * accessType)) -> bool
val dfn'CSRRW: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'CSRRS: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'CSRRC: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'CSRRWI: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'CSRRSI: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'CSRRCI: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> unit
val dfn'SFENCE_VM: BitsN.nbit -> unit
val dfn'UnknownInstruction: unit -> unit
val dfn'FETCH_MISALIGNED: BitsN.nbit -> unit
val dfn'FETCH_FAULT: BitsN.nbit -> unit
val Run: instruction -> unit
val Fetch: unit -> FetchResult
val asImm12:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))) -> BitsN.nbit
val asImm20:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))) -> BitsN.nbit
val asSImm12: (BitsN.nbit * BitsN.nbit) -> BitsN.nbit
val Decode: BitsN.nbit -> instruction
val imm:Nat.nat-> BitsN.nbit -> string
val instr: string -> string
val amotype: (BitsN.nbit * BitsN.nbit) -> string
val pRtype: (string * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))) -> string
val pARtype:
  (string *
   (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))))) ->
  string
val pLRtype:
  (string * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  string
val pItype:Nat.nat->
  (string * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))) -> string
val pCSRtype:
  (string * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))) -> string
val pCSRItype:Nat.nat->
  (string * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))) -> string
val pStype:Nat.nat->
  (string * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))) -> string
val pSBtype:Nat.nat->
  (string * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))) -> string
val pUtype:Nat.nat-> (string * (BitsN.nbit * BitsN.nbit)) -> string
val pUJtype:Nat.nat-> (string * (BitsN.nbit * BitsN.nbit)) -> string
val pN0type: string -> string
val pN1type: (string * BitsN.nbit) -> string
val instructionToString: instruction -> string
val Rtype:
  (BitsN.nbit *
   (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit))))) ->
  BitsN.nbit
val Itype:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  BitsN.nbit
val Stype:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  BitsN.nbit
val SBtype:
  (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * (BitsN.nbit * BitsN.nbit)))) ->
  BitsN.nbit
val Utype: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> BitsN.nbit
val UJtype: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> BitsN.nbit
val opc: BitsN.nbit -> BitsN.nbit
val amofunc: (BitsN.nbit * (BitsN.nbit * BitsN.nbit)) -> BitsN.nbit
val Encode: instruction -> BitsN.nbit
val log_instruction: (BitsN.nbit * instruction) -> string
val exitCode: unit -> Nat.nat
val CYCLES_PER_TIMER_TICK: Nat.nat
val tickClock: unit -> unit
val incrInstret: unit -> unit
val checkTimers: unit -> unit
val Next: unit -> unit
val initIdent: Architecture -> unit
val initMachine: BitsN.nbit -> unit
val initRegs: Nat.nat -> unit

end