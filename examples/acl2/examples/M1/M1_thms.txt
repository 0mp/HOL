lox% hol

---------------------------------------------------------------------
       HOL-4 [Kananaskis 6 (stdknl, built Thu Mar 11 18:29:45 2010)]

       For introductory HOL help, type: help "hol";

---------------------------------------------------------------------

[loading theories and proof tools ............... ]
[closing file "/local/scratch/mjcg/HOL98/hol4/HOL/tools/end-init-boss.sml"]
- load "M1Theory";
> val it = () : unit
- open M1Theory;
> type thm = thm
  val test_ifact_examples =
    |- (|= equal (test_ifact (nat 5)) (exclaim (nat 5))) ∧
       (|= equal (test_ifact (nat 10)) (exclaim (nat 10))) ∧
       |= equal (test_ifact (nat 100)) (exclaim (nat 100)) : thm
  val M1_grammars =
    (Rules:
       (50)   TY  ::=  TY -> TY [fun] (R-associative)
       (60)   TY  ::=  TY + TY [sum] (R-associative)
       (70)   TY  ::=  TY # TY [prod] (R-associative)
       (99)   TY  ::=  TY[TY] (array type)
       (100)  TY  ::=  sexp | name | packagename | char | string |
                       complex_rational | rat | frac | int | TY polynom |
                       TY varmap | index | ordering | TY list | TY set |
                       TY canonical_sum | TY spolynom | TY ring |
                       TY semi_ring | TY recspace | one | unit |
                       (TY, TY)sum | TY option | num | (TY, TY)prod | label |
                       TY itself | (TY, TY)fun | ind | bool
       
     Type abbreviations:
       name = char list
       packagename = char list     (not printed)
       'a set = α -> bool     (not printed)
       string = char list     (not printed)
       unit = one,
     (0)    TM  ::=  "exists" <..binders..> "." TM |
                     "forall" <..binders..> "." TM |
                     "?!!" <..binders..> "." TM |
                     "LEAST" <..binders..> "." TM |
                     "?!" <..binders..> "." TM | "?" <..binders..> "." TM |
                     "!" <..binders..> "." TM | "@" <..binders..> "." TM |
                     "\" <..binders..> "." TM
     (2)    TM  ::=  "let" TM "in" TM  [ _ let]
     (4)    TM  ::=  TM "::" TM (restricted quantification operator)
     (5)    TM  ::=  TM TM  (binder argument concatenation)
     (7)    TM  ::=  "case" TM "of" TM  [case__magic]
     (8)    TM  ::=  TM "||" TM  [case_split__magic]   (R-associative)
     (9)    TM  ::=  TM "and" TM  [ _ and]   (L-associative)
     (10)   TM  ::=  TM "->" TM  [case_arrow__magic]   (R-associative)
     (11)   TM  ::=  "|=" TM
     (50)   TM  ::=  TM "," TM   (R-associative)
     (70)   TM  ::=  "if" TM "then" TM "else" TM  [COND]
     (80)   TM  ::=  TM ":-" TM   (non-associative)
     (100)  TM  ::=  TM "=" TM   (non-associative)
     (200)  TM  ::=  TM "==>" TM   (R-associative)
     (300)  TM  ::=  TM "\/" TM   (R-associative)
     (310)  TM  ::=  TM ":>" TM   (L-associative)
     (320)  TM  ::=  TM "=+" TM   (non-associative)
     (400)  TM  ::=  TM "/\" TM   (R-associative)
     (425)  TM  ::=  TM "equiv_on" TM | TM "IN" TM   (non-associative)
     (450)  TM  ::=  TM "int_divides" TM | TM "<<=" TM | TM "SUBSET" TM |
                     TM "PSUBSET" TM | TM ">=" TM | TM "<=" TM | TM ">" TM |
                     TM "<" TM | TM "RSUBSET" TM
                     (non-associative)
     (460)  TM  ::=  TM "with" TM  [record update] |
                     TM ":=" TM  [record field update] |
                     TM "updated_by" TM  [functional record update]
                     (R-associative)
     (480)  TM  ::=  TM "+++" TM | TM "++" TM   (L-associative)
     (490)  TM  ::=  TM "-->" TM | TM "===>" TM | TM "###" TM |
                     TM "::" TM  [CONS] | TM "INSERT" TM | TM "LEX" TM |
                     TM "##" TM
                     (R-associative)
     (500)  TM  ::=  TM "tint_add" TM | TM "int_sub" TM | TM "UNION" TM |
                     TM "DIFF" TM | TM "DELETE" TM | TM "-" TM | TM "+" TM |
                     TM "RUNION" TM
                     (L-associative)
     (600)  TM  ::=  TM "tint_mul" TM | TM "/" TM | TM "quot" TM |
                     TM "//" TM | TM "INTER" TM | TM "CROSS" TM |
                     TM "DIV" TM | TM "*" TM | TM "RINTER" TM
                     (L-associative)
     (601)  TM  ::=  TM "*," TM   (R-associative)
     (650)  TM  ::=  TM "%" TM | TM "rem" TM | TM "MOD" TM   (L-associative)
     (700)  TM  ::=  TM "int_exp" TM | TM "**" TM | TM "EXP" TM
                     (R-associative)
     (800)  TM  ::=  TM "O" TM | TM "o" TM   (R-associative)
     (899)  TM  ::=  TM ":" TY  (type annotation)
     (900)  TM  ::=  "&" TM | "-" TM  [numeric_negate] | "~" TM
     (2000) TM  ::=  TM TM  (function application)   (L-associative)
     (2100) TM  ::=  TM "^="  [EQC] | TM "^*" | TM "^+"
     (2500) TM  ::=  TM "." TM  [record field selection]   (L-associative)
            TM  ::=  "[" ... "]"  (separator = ";") |
                     "{" ... "}"  (separator = ";") |
                     "<|" ... "|>"  (separator = ";")
            TM  ::=  "{" TM "|" TM "}"  [gspec special] |
                     "{" TM "|" TM "|" TM "}"  [gspec2 special] |
                     "(" ")"  [one] |
                     "(" TM ")"  [just parentheses, no term produced]
     Known constants:
        _ record fupdateR0  _ record fupdateR1  _ record fupdateRM
        _ record fupdateRN  _ record fupdateRP  _ record fupdateSR0
        _ record fupdateSR1  _ record fupdateSRM  _ record fupdateSRP
        _ record selectR0  _ record selectR1  _ record selectRM
        _ record selectRN  _ record selectRP  _ record selectSR0
        _ record selectSR1  _ record selectSRM  _ record selectSRP ! ## ### %
       & () * ** *, + ++ +++ , - --> / // /\ 0 :- :> < <<= <= = =+ ===> ==> >
       >= ? ?! ?!! @ ABS ABS_num ABS_prod ABS_sum AC ACL2 ACL2::ACL2-NUMBERP
       ACL2::ALISTP ACL2::ALPHORDER ACL2::AND-MACRO ACL2::ATOM-LISTP
       ACL2::BAD-ATOM ACL2::BAD-ATOM<= ACL2::BINARY-* ACL2::BINARY-+
       ACL2::BINARY-APPEND ACL2::BOOLEANP ACL2::CHARACTER-LISTP
       ACL2::COMPLEX-RATIONALP ACL2::COND-CLAUSESP ACL2::EQLABLE-ALISTP
       ACL2::EQLABLE-LISTP ACL2::EQLABLEP ACL2::FIX ACL2::HIDE ACL2::IFF
       ACL2::IFIX ACL2::IMPLIES ACL2::INTEGER-ABS
       ACL2::INTERN-IN-PACKAGE-OF-SYMBOL ACL2::LEN ACL2::LEXORDER
       ACL2::LIST-MACRO ACL2::MAKE-CHARACTER-LIST ACL2::MEMBER-EQUAL
       ACL2::MEMBER-SYMBOL-NAME ACL2::MV-NTH ACL2::NATP ACL2::NFIX
       ACL2::NONNEGATIVE-INTEGER-QUOTIENT ACL2::O-FINP ACL2::O-FIRST-COEFF
       ACL2::O-FIRST-EXPT ACL2::O-RST ACL2::OR-MACRO ACL2::OUR-DIGIT-CHAR-P
       ACL2::PKG-WITNESS ACL2::POSP ACL2::REALFIX ACL2::RFIX
       ACL2::STANDARD-CHAR-LISTP ACL2::STRING-DOWNCASE1 ACL2::STRING-UPCASE1
       ACL2::STRING<-L ACL2::SYMBOL-PACKAGE-NAME ACL2::SYMBOL::-<
       ACL2::TRUE-LISTP ACL2::UNARY-- ACL2::UNARY-/ ACL2::XXXJOIN ACL2::ZIP
       ACL2::ZP ACL2_CHARACTER ACL2_CL ACL2_KNOWN_PACKAGES ACL2_NUMBER
       ACL2_OUTPUT_CHANNEL ACL2_PACKAGE_ALIST ACL2_PAIR ACL2_STRING
       ACL2_SYMBOL ACL2_USER ACL2_USER_CL ALL_DISTINCT ALL_EL AND_EL APPEND
       ARB ASSOC Abbrev BASIC_INTERN BIGINTER BIGUNION BIJ BIT1 BIT2 BOUNDED
       BUTFIRSTN BUTLAST BUTLASTN C CARD CHOICE CHR COMM COMMON-LISP::<
       COMMON-LISP::= COMMON-LISP::ACONS COMMON-LISP::ALPHA-CHAR-P
       COMMON-LISP::ASSOC COMMON-LISP::ATOM COMMON-LISP::CAR COMMON-LISP::CDR
       COMMON-LISP::CHAR-CODE COMMON-LISP::CHAR-DOWNCASE
       COMMON-LISP::CHAR-EQUAL COMMON-LISP::CHAR-UPCASE COMMON-LISP::CHAR<
       COMMON-LISP::CHARACTERP COMMON-LISP::CODE-CHAR COMMON-LISP::COERCE
       COMMON-LISP::COMPLEX COMMON-LISP::CONSP COMMON-LISP::DENOMINATOR
       COMMON-LISP::ENDP COMMON-LISP::EQ COMMON-LISP::EQL COMMON-LISP::EQUAL
       COMMON-LISP::EXPT COMMON-LISP::FLOOR COMMON-LISP::IF
       COMMON-LISP::IMAGPART COMMON-LISP::INTEGERP COMMON-LISP::LENGTH
       COMMON-LISP::LOWER-CASE-P COMMON-LISP::MEMBER COMMON-LISP::MOD
       COMMON-LISP::NIL COMMON-LISP::NOT COMMON-LISP::NULL
       COMMON-LISP::NUMERATOR COMMON-LISP::QUOTE COMMON-LISP::RATIONALP
       COMMON-LISP::REALPART COMMON-LISP::STANDARD-CHAR-P COMMON-LISP::STRING
       COMMON-LISP::STRING-DOWNCASE COMMON-LISP::STRING-UPCASE
       COMMON-LISP::STRING< COMMON-LISP::STRING<= COMMON-LISP::STRINGP
       COMMON-LISP::SYMBOL-NAME COMMON-LISP::SYMBOLP COMMON-LISP::T
       COMMON-LISP::UPPER-CASE-P COMMON_LISP COMPL COMPLEX_ADD
       COMPLEX_ADD_tupled COMPLEX_DIV COMPLEX_GE COMPLEX_GE_tupled COMPLEX_GT
       COMPLEX_GT_tupled COMPLEX_LE COMPLEX_LE_tupled COMPLEX_LT
       COMPLEX_LT_tupled COMPLEX_MULT COMPLEX_MULT_tupled COMPLEX_NEG
       COMPLEX_RATIONAL COMPLEX_RECIPROCAL COMPLEX_SUB COMPLEX_SUB_tupled
       CONCAT COND CONS CR CROSS CURRY Cong Cons_monom Cons_varlist DATATYPE
       DELETE DEST_STRING DIFF DISJOINT DIV DIV2 DIVIDES DIVMOD DIV_2EXP DROP
       EL ELL EMPTY EMPTYSTRING EMPTY_REL EQC EQUAL EQUIV EVEN EVERY EXISTS
       EXP EXPLODE EXTRACT EXT_POINT Empty_vm End_idx F FACT FAIL FCOMM
       FIELDS FIELDS_tupled FILTER FINITE FIRSTN FLAT FOLDL FOLDR FRONT FST
       FUNPOW GENLIST GREATER GSPEC HD HOARE_SPEC I IDEM IMAGE IMPLODE IN
       INDUCTIVE_INVARIANT INDUCTIVE_INVARIANT_ON INFINITE INJ INL INR INSERT
       INTER INVOL ISL ISR IS_EL IS_INT IS_NONE IS_NUM_REP IS_PREFIX IS_SOME
       IS_SUBLIST IS_SUFFIX IS_SUM_REP ITSET ITSET_tupled Id IfCases K
       KEYWORD LAST LASTN LEAST LEFT_ID LEN LENGTH LESS LET LEX LINV
       LIST_ELEM_COUNT LIST_LEX_ORDER LIST_LEX_ORDER_tupled LIST_REL
       LIST_REL_tupled LIST_TO_SET LOOKUP LOOKUP_tupled LRC Left_idx
       LinearOrder List M1::! M1::ACTUAL M1::APP M1::ARG1 M1::ARG2 M1::ARG3
       M1::BIND M1::BINDING M1::BOUNDP M1::COLLECT-AT-END
       M1::COLLECT-VARS-IN-EXPR M1::COLLECT-VARS-IN-STMT
       M1::COLLECT-VARS-IN-STMT* M1::COMPILE M1::CONCAT-SYMBOLS M1::DO-INST
       M1::EVEN-SCHED M1::EXECUTE-GOTO M1::EXECUTE-IADD M1::EXECUTE-ICONST
       M1::EXECUTE-IFLE M1::EXECUTE-ILOAD M1::EXECUTE-IMUL M1::EXECUTE-ISTORE
       M1::EXECUTE-ISUB M1::EXPR! M1::FREV M1::GOTO! M1::ICONST! M1::IFACT
       M1::IFACT-LOOP-SCHED M1::IFACT-SCHED M1::IFLE! M1::ILOAD! M1::INDEX
       M1::ISTORE! M1::LEN M1::LOCALS M1::MAKE-DEFUN M1::MAKE-STATE
       M1::MEMBER M1::NEXT-INST M1::NEXTN M1::NTH M1::OP! M1::OP-CODE
       M1::PATTERN-BINDINGS M1::PC M1::POP M1::POPN M1::PROGRAM M1::PUSH
       M1::REPEAT M1::REV M1::REV1 M1::RUN M1::S-BIG M1::S-FIX M1::SKIPN
       M1::STACK M1::STEP M1::STMT! M1::STMT*! M1::SUPPLIEDP M1::TEST!
       M1::TEST-EVEN M1::TEST-IFACT M1::TOP M1::U-BIG M1::U-BIG1 M1::U-FIX
       M1::UPDATE-NTH M1::WHILE! MAP MAP2 MAP2_tupled MAX MAX_SET MEM MIN
       MIN_SET MOD MOD_2EXP MONOID NIL NONE NRC NULL NUMERAL NUMFST NUMLEFT
       NUMRIGHT NUMSND Nil_monom Node_vm Num O ODD ONE_ONE ONTO OPTION_BIND
       OPTION_JOIN OPTION_MAP OPTION_MAP2 OPTION_REL OPTION_REL_tupled OPTREL
       ORD OR_EL OUTL OUTR OWHILE Order PARTIAL_EQUIV POW PRE PREFIX PRIMES
       PRIM_REC PRIM_REC_FUN PSUBSET Pconst Pmult Popp Pplus PreOrder Pvar
       QUOTIENT R0 R0_fupd R1 R1_fupd RC RCOMPL RDOM RELPOW REMPTY
       REPLACE_ELEMENT REPLICATE REP_num REP_prod REP_sum REST RESTRICT
       RES_ABSTRACT RES_EXISTS RES_EXISTS_EQUIV RES_EXISTS_UNIQUE RES_FORALL
       RES_SELECT REV REVERSE RIGHT_ID RINTER RINV RM RM_fupd RN RN_fupd RP
       RPROD RP_fupd RRANGE RSUBSET RTC RUNION RUNIV Right_idx S SC SCANL
       SCANR SEG SET_TO_LIST SEXP_SYM_LESS SEXP_SYM_LESS_EQ
       SEXP_SYM_LESS_tupled SGN SIGMA SIMP_REC SIMP_REC_REL SING SN SND SNOC
       SOME SOME_EL SPLITP SPconst SPmult SPplus SPvar SR0 SR0_fupd SR1
       SR1_fupd SRM SRM_fupd SRP SRP_fupd STR STRCAT STRING STRING_LESS
       STRING_LESS_EQ STRLEN STRORD SUB SUBSET SUBSTRING SUC SUC_REP SUFFIX
       SUM SUM_IMAGE SUM_REL_tupled SUM_SET SURJ StrongLinearOrder
       StrongOrder T TAKE TC THE TL TOKENS TOKENS_tupled TRANSLATE
       TYPE_DEFINITION U UNCURRY UNION UNIV UNIV_POINT UNZIP UNZIP_FST
       UNZIP_SND UPDATE VALID_PKG_TRIPLES VALID_PKG_TRIPLES_AUX
       VALID_PKG_TRIPLES_AUX_tupled W WCR WF WFP WFREC WHILE WeakLinearOrder
       WeakOrder ZERO ZERO_REP ZIP ZRECSPACE \/ ^* ^+ _ inject_number
       abs_frac abs_rat abs_rat_CLASS acl2_make_character_list acl2_numberp
       acons actual add add_tupled alistp alpha_char_p alphorder and_macro
       andl antisymmetric app approx arg1 arg2 arg3 assoc assoc_tupled asym
       atom atom_listp bad_atom bad_atom_less_equal binary_append
       binary_append_tupled bind binding bmarker bool_case bool_size
       bool_to_sexp booleanp boundp caaaar caaadr caaar caadar caaddr caadr
       caar cadaar cadadr cadar caddar cadddr caddr cadr calc_nightmare
       calc_nightmare_tupled canonical_sum_case canonical_sum_merge
       canonical_sum_merge_tupled canonical_sum_prod canonical_sum_scalar
       canonical_sum_scalar2 canonical_sum_scalar3 canonical_sum_simplify
       canonical_sum_size car case case__magic case_arrow__magic
       case_split__magic cdaaar cdaadr cdaar cdadar cdaddr cdadr cdar cddaar
       cddadr cddar cdddar cddddr cdddr cddr cdr char_code char_downcase
       char_equal char_ge char_gt char_le char_less char_lt char_size
       char_upcase character_listp characterp chooser chr code_char coerce
       coerce_list_to_string coerce_string_to_list coerce_tupled
       collect_at_end collect_vars_in_expr collect_vars_in_stmt
       collect_vars_in_stmt_star com com_0 com_1 common_lisp_equal compare
       compile complex complex_rational_case complex_rational_size
       complex_rationalp complex_tupled concat_symbols cond_clausesp cons
       consp count countable cpx csym dark_shadow dark_shadow_cond_row
       dark_shadow_cond_row_tupled dark_shadow_condition
       dark_shadow_condition_tupled dark_shadow_row dark_shadow_row_tupled
       dark_shadow_tupled denominator dest_canonical_sum
       dest_complex_rational dest_index dest_list dest_polynom dest_rec
       dest_ring dest_semi_ring dest_sexp dest_spolynom dest_varmap diag
       diamond divides do_inst endp eq eql eqlable_alistp eqlable_listp
       eqlablep equal equiv_on equivalence evallower evallower_tupled
       evalupper evalupper_tupled even_sched exclaim execute_goto
       execute_iadd execute_iconst execute_ifle execute_iload execute_imul
       execute_istore execute_isub exists expr_exclaim expt findq fix floor
       forall force frac_0 frac_1 frac_add frac_ainv frac_div frac_dnm
       frac_minv frac_mul frac_nmr frac_save frac_sgn frac_sub frev fst1
       fst_nzero gcd gcd_tupled goto_exclaim hide iBIT_cases iconst_exclaim
       ics_aux ifact ifact_loop_sched ifact_sched iff ifix ifle_exclaim
       iload_exclaim imagpart implies imported_symbol_names
       imported_symbol_names_tupled index index_case index_compare
       index_compare_tupled index_lt index_size int int_0 int_1 int_ABS
       int_ABS_CLASS int_REP int_REP_CLASS int_add int_div int_divides
       int_exp int_ge int_gt int_interp_p int_le int_lt int_max int_min
       int_mod int_mul int_neg int_of_num int_polynom_normalize
       int_polynom_simplify int_quot int_r_canonical_sum_merge
       int_r_canonical_sum_prod int_r_canonical_sum_scalar
       int_r_canonical_sum_scalar2 int_r_canonical_sum_scalar3
       int_r_canonical_sum_simplify int_r_ics_aux int_r_interp_cs
       int_r_interp_m int_r_interp_sp int_r_interp_vl int_r_ivl_aux
       int_r_monom_insert int_r_spolynom_normalize int_r_spolynom_simplify
       int_r_varlist_insert int_rem int_sub integer_abs integerp
       intern_in_package_of_symbol intern_in_package_of_symbol_tupled
       internal_mult interp_cs interp_m interp_p interp_sp interp_vl inv
       inv_image invtri invtri0 invtri0_tupled irreflexive isAlpha isAlphaNum
       isAscii isCntrl isDigit isGraph isHexDigit isLower isPREFIX isPrint
       isPunct isSpace isUpper is_gcd is_ring is_semi_ring istore_exclaim ite
       itel itel_tupled itself_case ivl_aux ksym lcm len length les_abs less
       less_tupled lexorder lexorder_tupled listRel list_case list_compare
       list_compare_tupled list_macro list_merge list_merge_tupled list_size
       list_to_sexp literal_case locals lower_case_p m1_len m1_member
       make_character_list make_defun make_state measure member member_equal
       member_equal_tupled member_symbol_name member_symbol_name_tupled
       member_tupled mk_canonical_sum mk_complex_rational mk_index mk_list
       mk_polynom mk_rec mk_ring mk_semi_ring mk_sexp mk_spolynom mk_varmap
       mod modhat monom_insert monom_insert_tupled mult mult_tupled mv_nth
       mv_nth_tupled napp nat nat_elim__magic natp ncons next_inst nextn nf
       nfix nfoldl nfst nightmare nightmare_tupled nil nlen nlistrec
       nlistrec_tupled nmap nnil nonnegative_integer_quotient not npair nsnd
       nth null num num2ordering num_canonical_sum_merge
       num_canonical_sum_prod num_canonical_sum_scalar
       num_canonical_sum_scalar2 num_canonical_sum_scalar3
       num_canonical_sum_simplify num_case num_ics_aux num_interp_cs
       num_interp_m num_interp_sp num_interp_vl num_ivl_aux num_monom_insert
       num_spolynom_normalize num_spolynom_simplify num_to_pair
       num_varlist_insert numerator numeric_negate o o_finp o_first_coeff
       o_first_expt o_rst one one_case one_size op_code op_exclaim option_ABS
       option_REP option_case option_size or_macro ordering2num ordering_case
       ordering_size osym our_digit_char_p pair_case pair_size pair_to_num
       partition pattern_bindings pc pkg_witness polynom_case
       polynom_normalize polynom_simplify polynom_size pop popn posp prime
       program push quot quote r_canonical_sum_merge r_canonical_sum_prod
       r_canonical_sum_scalar r_canonical_sum_scalar2 r_canonical_sum_scalar3
       r_canonical_sum_simplify r_ics_aux r_interp_cs r_interp_m r_interp_sp
       r_interp_vl r_ivl_aux r_monom_insert r_spolynom_normalize
       r_spolynom_simplify r_varlist_insert rat rat_0 rat_1 rat_add rat_ainv
       rat_cons rat_div rat_dnm rat_equiv rat_geq rat_gre rat_leq rat_les
       rat_minv rat_mul rat_nmr rat_of_num rat_sgn rat_sub rationalp
       rcdiamond real_shadow realfix realpart reciprocal reduce reduced_dnm
       reduced_nmr reflexive rem rep_frac rep_rat rep_rat_CLASS repeat
       respects rev rev1 rfix ring ring_R0 ring_R0_fupd ring_R1 ring_R1_fupd
       ring_RM ring_RM_fupd ring_RN ring_RN_fupd ring_RP ring_RP_fupd
       ring_case ring_size rshadow_row rshadow_row_tupled run s_big s_fix
       semi_ring semi_ring_SR0 semi_ring_SR0_fupd semi_ring_SR1
       semi_ring_SR1_fupd semi_ring_SRM semi_ring_SRM_fupd semi_ring_SRP
       semi_ring_SRP_fupd semi_ring_case semi_ring_of semi_ring_size set
       sexp_case sexp_size skipn spolynom_case spolynom_normalize
       spolynom_simplify spolynom_size stack standard_char_listp
       standard_char_p step stmarker stmt_exclaim stmt_star_exclaim str
       string string_downcase string_downcase1 string_ge string_gt string_le
       string_less string_less_equal string_less_l string_less_l_tupled
       string_lt string_lt_tupled string_upcase string_upcase1 stringp
       sum_case sum_size sumc sumc_tupled suppliedp sym symbol_less
       symbol_name symbol_package_name symbolp symmetric t test_even
       test_exclaim test_ifact the_fun the_value tint_0 tint_1 tint_add
       tint_eq tint_lt tint_mul tint_neg tint_of_num toLower toUpper top
       total transitive tri trichotomous true_listp u_big u_big1 u_fix
       unary_minus unint update_nth upper_case_p varlist_insert
       varlist_insert_tupled varmap_case varmap_find varmap_find_tupled
       varmap_size wellfounded while_exclaim xxxjoin xxxjoin_tupled zip zp |=
       ~
     Overloading:
        _ record fupdateR0          ->  ring_R0_fupd
        _ record fupdateR1          ->  ring_R1_fupd
        _ record fupdateRM          ->  ring_RM_fupd
        _ record fupdateRN          ->  ring_RN_fupd
        _ record fupdateRP          ->  ring_RP_fupd
        _ record fupdateSR0         ->  semi_ring_SR0_fupd
        _ record fupdateSR1         ->  semi_ring_SR1_fupd
        _ record fupdateSRM         ->  semi_ring_SRM_fupd
        _ record fupdateSRP         ->  semi_ring_SRP_fupd
        _ record selectR0           ->  ring_R0
        _ record selectR1           ->  ring_R1
        _ record selectRM           ->  ring_RM
        _ record selectRN           ->  ring_RN
        _ record selectRP           ->  ring_RP
        _ record selectSR0          ->  semi_ring_SR0
        _ record selectSR1          ->  semi_ring_SR1
        _ record selectSRM          ->  semi_ring_SRM
        _ record selectSRP          ->  semi_ring_SRP
       %                            ->  int_mod
       &                            ->  rat_of_num int_of_num nat_elim__magic
       ()                           ->  one
       *                            ->  COMPLEX_MULT rat_mul int_mul *
       **                           ->  int_exp EXP
       *,                           ->  npair
       +                            ->  COMPLEX_ADD rat_add int_add +
       ++                           ->  APPEND ++
       -                            ->  COMPLEX_SUB rat_sub int_sub -
       /                            ->  COMPLEX_DIV rat_div int_div
       //                           ->  rat_cons
       <                            -> 
         string_lt char_lt COMPLEX_LT rat_les int_lt <
       <<=                          -> 
         (\(x :α list) (y :α list). list$isPREFIX x y) isPREFIX
       <=                           -> 
         string_le char_le COMPLEX_LE rat_leq int_le <=
       =+                           ->  UPDATE
       >                            -> 
         string_gt char_gt COMPLEX_GT rat_gre int_gt >
       >=                           -> 
         string_ge char_ge COMPLEX_GE rat_geq int_ge >=
       ALL_EL                       ->  EVERY
       BUTFIRSTN                    ->  DROP
       BUTLAST                      ->  FRONT
       CONCAT                       ->  FLAT
       EMPTYSTRING                  ->  NIL
       FIRSTN                       ->  TAKE
       IS_EL                        ->  MEM
       IS_PREFIX                    -> 
         (\(x :α list) (y :α list). list$isPREFIX y x)
       Id                           ->  =
       MAP2                         ->  Omega$MAP2 list$MAP2
       R0                           ->  ring_R0
       R0_fupd                      ->  ring_R0_fupd
       R1                           ->  ring_R1
       R1_fupd                      ->  ring_R1_fupd
       RELPOW                       ->  NRC
       REMPTY                       ->  EMPTY_REL
       RM                           ->  ring_RM
       RM_fupd                      ->  ring_RM_fupd
       RN                           ->  ring_RN
       RN_fupd                      ->  ring_RN_fupd
       RP                           ->  ring_RP
       RP_fupd                      ->  ring_RP_fupd
       SIGMA                        ->  SUM_IMAGE
       SOME_EL                      ->  EXISTS
       SR0                          ->  semi_ring_SR0
       SR0_fupd                     ->  semi_ring_SR0_fupd
       SR1                          ->  semi_ring_SR1
       SR1_fupd                     ->  semi_ring_SR1_fupd
       SRM                          ->  semi_ring_SRM
       SRM_fupd                     ->  semi_ring_SRM_fupd
       SRP                          ->  semi_ring_SRP
       SRP_fupd                     ->  semi_ring_SRP_fupd
       STRCAT                       ->  APPEND
       STRING                       ->  CONS
       STRLEN                       ->  LENGTH
       U                            -> 
         (\(x :α itself). (pred_set$UNIV :α -> bool))
       ^*                           ->  RTC
       ^+                           ->  TC
       _ inject_number              ->  rat_of_num int_of_num nat_elim__magic
       acl2_make_character_list     ->  ACL2::MAKE-CHARACTER-LIST
       acl2_numberp                 ->  ACL2::ACL2-NUMBERP
       acons                        ->  COMMON-LISP::ACONS
       actual                       ->  M1::ACTUAL
       add                          ->  ACL2::BINARY-+
       alistp                       ->  ACL2::ALISTP
       alpha_char_p                 ->  COMMON-LISP::ALPHA-CHAR-P
       alphorder                    ->  ACL2::ALPHORDER
       and_macro                    ->  ACL2::AND-MACRO
       app                          ->  M1::APP
       arg1                         ->  M1::ARG1
       arg2                         ->  M1::ARG2
       arg3                         ->  M1::ARG3
       assoc                        ->  COMMON-LISP::ASSOC
       atom                         ->  COMMON-LISP::ATOM
       atom_listp                   ->  ACL2::ATOM-LISTP
       bad_atom                     ->  ACL2::BAD-ATOM
       bad_atom_less_equal          ->  ACL2::BAD-ATOM<=
       binary_append                ->  ACL2::BINARY-APPEND
       bind                         ->  M1::BIND
       binding                      ->  M1::BINDING
       booleanp                     ->  ACL2::BOOLEANP
       boundp                       ->  M1::BOUNDP
       car                          ->  COMMON-LISP::CAR
       case                         ->  literal_case
       cdr                          ->  COMMON-LISP::CDR
       char_code                    ->  COMMON-LISP::CHAR-CODE
       char_downcase                ->  COMMON-LISP::CHAR-DOWNCASE
       char_equal                   ->  COMMON-LISP::CHAR-EQUAL
       char_less                    ->  COMMON-LISP::CHAR<
       char_upcase                  ->  COMMON-LISP::CHAR-UPCASE
       character_listp              ->  ACL2::CHARACTER-LISTP
       characterp                   ->  COMMON-LISP::CHARACTERP
       chr                          ->  ACL2_CHARACTER
       code_char                    ->  COMMON-LISP::CODE-CHAR
       coerce                       ->  COMMON-LISP::COERCE
       collect_at_end               ->  M1::COLLECT-AT-END
       collect_vars_in_expr         ->  M1::COLLECT-VARS-IN-EXPR
       collect_vars_in_stmt         ->  M1::COLLECT-VARS-IN-STMT
       collect_vars_in_stmt_star    ->  M1::COLLECT-VARS-IN-STMT*
       com                          ->  COMPLEX_RATIONAL
       common_lisp_equal            ->  COMMON-LISP::=
       compile                      ->  M1::COMPILE
       complex                      ->  COMMON-LISP::COMPLEX
       complex_rationalp            ->  ACL2::COMPLEX-RATIONALP
       concat_symbols               ->  M1::CONCAT-SYMBOLS
       cond_clausesp                ->  ACL2::COND-CLAUSESP
       cons                         ->  ACL2_PAIR
       consp                        ->  COMMON-LISP::CONSP
       denominator                  ->  COMMON-LISP::DENOMINATOR
       do_inst                      ->  M1::DO-INST
       endp                         ->  COMMON-LISP::ENDP
       eq                           ->  COMMON-LISP::EQ
       eql                          ->  COMMON-LISP::EQL
       eqlable_alistp               ->  ACL2::EQLABLE-ALISTP
       eqlable_listp                ->  ACL2::EQLABLE-LISTP
       eqlablep                     ->  ACL2::EQLABLEP
       equal                        ->  COMMON-LISP::EQUAL
       even_sched                   ->  M1::EVEN-SCHED
       exclaim                      ->  M1::!
       execute_goto                 ->  M1::EXECUTE-GOTO
       execute_iadd                 ->  M1::EXECUTE-IADD
       execute_iconst               ->  M1::EXECUTE-ICONST
       execute_ifle                 ->  M1::EXECUTE-IFLE
       execute_iload                ->  M1::EXECUTE-ILOAD
       execute_imul                 ->  M1::EXECUTE-IMUL
       execute_istore               ->  M1::EXECUTE-ISTORE
       execute_isub                 ->  M1::EXECUTE-ISUB
       expr_exclaim                 ->  M1::EXPR!
       expt                         ->  COMMON-LISP::EXPT
       fix                          ->  ACL2::FIX
       floor                        ->  COMMON-LISP::FLOOR
       frev                         ->  M1::FREV
       goto_exclaim                 ->  M1::GOTO!
       hide                         ->  ACL2::HIDE
       iconst_exclaim               ->  M1::ICONST!
       ifact                        ->  M1::IFACT
       ifact_loop_sched             ->  M1::IFACT-LOOP-SCHED
       ifact_sched                  ->  M1::IFACT-SCHED
       iff                          ->  ACL2::IFF
       ifix                         ->  ACL2::IFIX
       ifle_exclaim                 ->  M1::IFLE!
       iload_exclaim                ->  M1::ILOAD!
       imagpart                     ->  COMMON-LISP::IMAGPART
       implies                      ->  ACL2::IMPLIES
       index                        ->  M1::INDEX
       integer_abs                  ->  ACL2::INTEGER-ABS
       integerp                     ->  COMMON-LISP::INTEGERP
       intern_in_package_of_symbol  ->  ACL2::INTERN-IN-PACKAGE-OF-SYMBOL
       istore_exclaim               ->  M1::ISTORE!
       ite                          ->  COMMON-LISP::IF
       len                          ->  ACL2::LEN
       length                       ->  COMMON-LISP::LENGTH
       less                         ->  COMMON-LISP::<
       lexorder                     ->  ACL2::LEXORDER
       list_macro                   ->  ACL2::LIST-MACRO
       locals                       ->  M1::LOCALS
       lower_case_p                 ->  COMMON-LISP::LOWER-CASE-P
       m1_len                       ->  M1::LEN
       m1_member                    ->  M1::MEMBER
       make_defun                   ->  M1::MAKE-DEFUN
       make_state                   ->  M1::MAKE-STATE
       member                       ->  COMMON-LISP::MEMBER
       member_equal                 ->  ACL2::MEMBER-EQUAL
       member_symbol_name           ->  ACL2::MEMBER-SYMBOL-NAME
       mod                          ->  COMMON-LISP::MOD
       mult                         ->  ACL2::BINARY-*
       mv_nth                       ->  ACL2::MV-NTH
       natp                         ->  ACL2::NATP
       next_inst                    ->  M1::NEXT-INST
       nextn                        ->  M1::NEXTN
       nfix                         ->  ACL2::NFIX
       nil                          ->  COMMON-LISP::NIL
       nnil                         ->  0
       nonnegative_integer_quotient ->  ACL2::NONNEGATIVE-INTEGER-QUOTIENT
       not                          ->  COMMON-LISP::NOT
       nth                          ->  M1::NTH
       null                         ->  COMMON-LISP::NULL
       num                          ->  ACL2_NUMBER
       numerator                    ->  COMMON-LISP::NUMERATOR
       numeric_negate               ->  rat_ainv int_neg
       o_finp                       ->  ACL2::O-FINP
       o_first_coeff                ->  ACL2::O-FIRST-COEFF
       o_first_expt                 ->  ACL2::O-FIRST-EXPT
       o_rst                        ->  ACL2::O-RST
       op_code                      ->  M1::OP-CODE
       op_exclaim                   ->  M1::OP!
       or_macro                     ->  ACL2::OR-MACRO
       our_digit_char_p             ->  ACL2::OUR-DIGIT-CHAR-P
       pattern_bindings             ->  M1::PATTERN-BINDINGS
       pc                           ->  M1::PC
       pkg_witness                  ->  ACL2::PKG-WITNESS
       pop                          ->  M1::POP
       popn                         ->  M1::POPN
       posp                         ->  ACL2::POSP
       program                      ->  M1::PROGRAM
       push                         ->  M1::PUSH
       quot                         ->  int_quot
       quote                        ->  COMMON-LISP::QUOTE
       rationalp                    ->  COMMON-LISP::RATIONALP
       realfix                      ->  ACL2::REALFIX
       realpart                     ->  COMMON-LISP::REALPART
       reciprocal                   ->  ACL2::UNARY-/
       rem                          ->  int_rem
       repeat                       ->  M1::REPEAT
       rev                          ->  M1::REV
       rev1                         ->  M1::REV1
       rfix                         ->  ACL2::RFIX
       run                          ->  M1::RUN
       s_big                        ->  M1::S-BIG
       s_fix                        ->  M1::S-FIX
       set                          ->  LIST_TO_SET
       skipn                        ->  M1::SKIPN
       stack                        ->  M1::STACK
       standard_char_listp          ->  ACL2::STANDARD-CHAR-LISTP
       standard_char_p              ->  COMMON-LISP::STANDARD-CHAR-P
       step                         ->  M1::STEP
       stmt_exclaim                 ->  M1::STMT!
       stmt_star_exclaim            ->  M1::STMT*!
       str                          ->  ACL2_STRING
       string                       ->  COMMON-LISP::STRING
       string_downcase              ->  COMMON-LISP::STRING-DOWNCASE
       string_downcase1             ->  ACL2::STRING-DOWNCASE1
       string_less                  ->  COMMON-LISP::STRING<
       string_less_equal            ->  COMMON-LISP::STRING<=
       string_less_l                ->  ACL2::STRING<-L
       string_upcase                ->  COMMON-LISP::STRING-UPCASE
       string_upcase1               ->  ACL2::STRING-UPCASE1
       stringp                      ->  COMMON-LISP::STRINGP
       suppliedp                    ->  M1::SUPPLIEDP
       sym                          ->  ACL2_SYMBOL
       symbol_less                  ->  ACL2::SYMBOL::-<
       symbol_name                  ->  COMMON-LISP::SYMBOL-NAME
       symbol_package_name          ->  ACL2::SYMBOL-PACKAGE-NAME
       symbolp                      ->  COMMON-LISP::SYMBOLP
       t                            ->  COMMON-LISP::T
       test_even                    ->  M1::TEST-EVEN
       test_exclaim                 ->  M1::TEST!
       test_ifact                   ->  M1::TEST-IFACT
       top                          ->  M1::TOP
       true_listp                   ->  ACL2::TRUE-LISTP
       u_big                        ->  M1::U-BIG
       u_big1                       ->  M1::U-BIG1
       u_fix                        ->  M1::U-FIX
       unary_minus                  ->  ACL2::UNARY--
       update_nth                   ->  M1::UPDATE-NTH
       upper_case_p                 ->  COMMON-LISP::UPPER-CASE-P
       while_exclaim                ->  M1::WHILE!
       xxxjoin                      ->  ACL2::XXXJOIN
       zip                          ->  ACL2::ZIP
       zp                           ->  ACL2::ZP
       ~                            ->  COMPLEX_NEG rat_ainv int_neg ~) :
  grammar * grammar/1
  val ifact_lemma =
    |- ∀stack a n.
         (|= natp n) ⇒
         |= equal
              (run (ifact_sched n)
                 (make_state (nat 0) (List [n; a]) stack
                    (List
                       [List [sym "M1" "ICONST"; nat 1];
                        List [sym "M1" "ISTORE"; nat 1];
                        List [sym "M1" "ILOAD"; nat 0];
                        List [sym "M1" "IFLE"; nat 10];
                        List [sym "M1" "ILOAD"; nat 0];
                        List [sym "M1" "ILOAD"; nat 1];
                        List [sym "M1" "IMUL"];
                        List [sym "M1" "ISTORE"; nat 1];
                        List [sym "M1" "ILOAD"; nat 0];
                        List [sym "M1" "ICONST"; nat 1];
                        List [sym "M1" "ISUB"];
                        List [sym "M1" "ISTORE"; nat 0];
                        List [sym "M1" "GOTO"; int (-10)];
                        List [sym "M1" "ILOAD"; nat 1];
                        List [sym "M1" "HALT"]])))
              (make_state (nat 14) (List [nat 0; ifact n (nat 1)])
                 (push (ifact n (nat 1)) stack)
                 (List
                    [List [sym "M1" "ICONST"; nat 1];
                     List [sym "M1" "ISTORE"; nat 1];
                     List [sym "M1" "ILOAD"; nat 0];
                     List [sym "M1" "IFLE"; nat 10];
                     List [sym "M1" "ILOAD"; nat 0];
                     List [sym "M1" "ILOAD"; nat 1]; List [sym "M1" "IMUL"];
                     List [sym "M1" "ISTORE"; nat 1];
                     List [sym "M1" "ILOAD"; nat 0];
                     List [sym "M1" "ICONST"; nat 1];
                     List [sym "M1" "ISUB"];
                     List [sym "M1" "ISTORE"; nat 0];
                     List [sym "M1" "GOTO"; int (-10)];
                     List [sym "M1" "ILOAD"; nat 1];
                     List [sym "M1" "HALT"]])) : thm
  val ifact_is_factorial =
    |- ∀a n.
         (|= natp n) ∧ (|= natp a) ⇒
         |= equal (ifact n a) (mult (exclaim n) a) : thm
  val ifact_correct =
    |- ∀stack a n.
         (|= natp n) ⇒
         |= equal
              (run (ifact_sched n)
                 (make_state (nat 0) (List [n; a]) stack
                    (List
                       [List [sym "M1" "ICONST"; nat 1];
                        List [sym "M1" "ISTORE"; nat 1];
                        List [sym "M1" "ILOAD"; nat 0];
                        List [sym "M1" "IFLE"; nat 10];
                        List [sym "M1" "ILOAD"; nat 0];
                        List [sym "M1" "ILOAD"; nat 1];
                        List [sym "M1" "IMUL"];
                        List [sym "M1" "ISTORE"; nat 1];
                        List [sym "M1" "ILOAD"; nat 0];
                        List [sym "M1" "ICONST"; nat 1];
                        List [sym "M1" "ISUB"];
                        List [sym "M1" "ISTORE"; nat 0];
                        List [sym "M1" "GOTO"; int (-10)];
                        List [sym "M1" "ILOAD"; nat 1];
                        List [sym "M1" "HALT"]])))
              (make_state (nat 14) (List [nat 0; exclaim n])
                 (push (exclaim n) stack)
                 (List
                    [List [sym "M1" "ICONST"; nat 1];
                     List [sym "M1" "ISTORE"; nat 1];
                     List [sym "M1" "ILOAD"; nat 0];
                     List [sym "M1" "IFLE"; nat 10];
                     List [sym "M1" "ILOAD"; nat 0];
                     List [sym "M1" "ILOAD"; nat 1]; List [sym "M1" "IMUL"];
                     List [sym "M1" "ISTORE"; nat 1];
                     List [sym "M1" "ILOAD"; nat 0];
                     List [sym "M1" "ICONST"; nat 1];
                     List [sym "M1" "ISUB"];
                     List [sym "M1" "ISTORE"; nat 0];
                     List [sym "M1" "GOTO"; int (-10)];
                     List [sym "M1" "ILOAD"; nat 1];
                     List [sym "M1" "HALT"]])) : thm
  val ifact_def =
    |- ∀n a.
         ifact n a = itel [(zp n,a)] (ifact (add (int (-1)) n) (mult n a)) :
  thm
  val repeat_def =
    |- ∀th n.
         repeat th n =
         itel [(zp n,List [])] (cons th (repeat th (add (int (-1)) n))) : thm
  val exclaim_def =
    |- ∀n.
         exclaim n =
         itel [(zp n,nat 1)] (mult n (exclaim (add (int (-1)) n))) : thm
  val ifact_sched_def =
    |- ∀n. ifact_sched n = app (repeat (nat 0) (nat 2)) (ifact_loop_sched n)
     : thm
- load "load_book";
> val it = () : unit
-  val M1_thms = map (I ## load_book.load_simp_fn) (theorems "imported_acl2");
> val M1_thms =
    [("push_defun", |- ∀x y. push x y = cons x y),
     ("top_defun", |- ∀stack. top stack = car stack),
     ("pop_defun", |- ∀stack. pop stack = cdr stack),
     ("nth_defun",
      |- ∀n list.
           nth n list =
           itel [(zp n,car list)] (nth (add (int (-1)) n) (cdr list))),
     ("make_state_defun",
      |- ∀pc locals stack program.
           make_state pc locals stack program =
           List [pc; locals; stack; program]),
     ("pc_defun", |- ∀s. pc s = nth (nat 0) s),
     ("locals_defun", |- ∀s. locals s = nth (nat 1) s),
     ("stack_defun", |- ∀s. stack s = nth (nat 2) s),
     ("program_defun", |- ∀s. program s = nth (nat 3) s),
     ("op_code_defun", |- ∀inst. op_code inst = car inst),
     ("arg1_defun", |- ∀inst. arg1 inst = nth (nat 1) inst),
     ("arg2_defun", |- ∀inst. arg2 inst = nth (nat 2) inst),
     ("arg3_defun", |- ∀inst. arg3 inst = nth (nat 3) inst),
     ("m1_len_defun",
      |- ∀x. m1_len x = itel [(endp x,nat 0)] (add (nat 1) (m1_len (cdr x)))),
     ("app_defun",
      |- ∀x y. app x y = itel [(endp x,y)] (cons (car x) (app (cdr x) y))),
     ("rev_defun",
      |- ∀x.
           rev x = itel [(endp x,List [])] (app (rev (cdr x)) (List [car x]))),
     ("rev1_defun",
      |- ∀x a. rev1 x a = itel [(endp x,a)] (rev1 (cdr x) (cons (car x) a))),
     ("frev_defun", |- ∀x. frev x = rev1 x (List [])),
     ("repeat_defun",
      |- ∀th n.
           repeat th n =
           itel [(zp n,List [])] (cons th (repeat th (add (int (-1)) n)))),
     ("popn_defun",
      |- ∀n stk.
           popn n stk = itel [(zp n,stk)] (popn (add (int (-1)) n) (pop stk))),
     ("update_nth_defun",
      |- ∀n v list.
           update_nth n v list =
           itel [(zp n,cons v (cdr list))]
             (cons (car list) (update_nth (add (int (-1)) n) v (cdr list)))),
     ("m1_member_defun",
      |- ∀e list.
           m1_member e list =
           itel [(endp list,List []); (equal e (car list),t)]
             (m1_member e (cdr list))),
     ("index_defun",
      |- ∀e lst.
           index e lst =
           itel [(endp lst,nat 0); (equal e (car lst),nat 0)]
             (add (nat 1) (index e (cdr lst)))),
     ("suppliedp_defun",
      |- ∀key args.
           suppliedp key args =
           itel [(endp args,List []); (equal key (car args),t)]
             (suppliedp key (cdr (cdr args)))),
     ("actual_defun",
      |- ∀key args.
           actual key args =
           itel [(endp args,List []); (equal key (car args),car (cdr args))]
             (actual key (cdr (cdr args)))),
     ("boundp_defun",
      |- ∀var alist.
           boundp var alist =
           itel [(endp alist,List []); (equal var (car (car alist)),t)]
             (boundp var (cdr alist))),
     ("binding_defun",
      |- ∀var alist.
           binding var alist =
           itel
             [(endp alist,List []);
              (equal var (car (car alist)),car (cdr (car alist)))]
             (binding var (cdr alist))),
     ("bind_defun",
      |- ∀var val alist.
           bind var val alist =
           itel
             [(endp alist,List [List [var; val]]);
              (equal var (car (car alist)),
               cons (List [var; val]) (cdr alist))]
             (cons (car alist) (bind var val (cdr alist)))),
     ("u_fix_defun", |- ∀x n. u_fix x n = mod x (expt (nat 2) n)),
     ("s_fix_defun",
      |- ∀x n.
           s_fix x n =
           itel
             [(less (mod x (expt (nat 2) n))
                 (expt (nat 2) (add (int (-1)) n)),mod x (expt (nat 2) n))]
             (add (mod x (expt (nat 2) n)) (unary_minus (expt (nat 2) n)))),
     ("u_big1_defun",
      |- ∀lst acc.
           u_big1 lst acc =
           itel [(endp lst,acc)]
             (u_big1 (cdr lst)
                (add (u_fix (car lst) (nat 8))
                   (mult (expt (nat 2) (nat 8)) acc)))),
     ("u_big_defun", |- ∀lst. u_big lst = u_big1 lst (nat 0)),
     ("s_big_defun",
      |- ∀lst. s_big lst = s_fix (u_big lst) (mult (nat 8) (m1_len lst))),
     ("nextn_defun",
      |- ∀n lst.
           nextn n lst =
           itel [(zp n,List [])]
             (cons (car lst) (nextn (add (int (-1)) n) (cdr lst)))),
     ("skipn_defun",
      |- ∀n lst.
           skipn n lst =
           itel [(zp n,lst)] (skipn (add (int (-1)) n) (cdr lst))),
     ("next_inst_defun", |- ∀s. next_inst s = nth (pc s) (program s)),
     ("execute_iconst_defun",
      |- ∀inst s.
           execute_iconst inst s =
           make_state (add (nat 1) (pc s)) (locals s)
             (push (arg1 inst) (stack s)) (program s)),
     ("execute_iload_defun",
      |- ∀inst s.
           execute_iload inst s =
           make_state (add (nat 1) (pc s)) (locals s)
             (push (nth (arg1 inst) (locals s)) (stack s)) (program s)),
     ("execute_iadd_defun",
      |- ∀inst s.
           execute_iadd inst s =
           make_state (add (nat 1) (pc s)) (locals s)
             (push (add (top (pop (stack s))) (top (stack s)))
                (pop (pop (stack s)))) (program s)),
     ("execute_istore_defun",
      |- ∀inst s.
           execute_istore inst s =
           make_state (add (nat 1) (pc s))
             (update_nth (arg1 inst) (top (stack s)) (locals s))
             (pop (stack s)) (program s)),
     ("execute_isub_defun",
      |- ∀inst s.
           execute_isub inst s =
           make_state (add (nat 1) (pc s)) (locals s)
             (push (add (top (pop (stack s))) (unary_minus (top (stack s))))
                (pop (pop (stack s)))) (program s)),
     ("execute_imul_defun",
      |- ∀inst s.
           execute_imul inst s =
           make_state (add (nat 1) (pc s)) (locals s)
             (push (mult (top (pop (stack s))) (top (stack s)))
                (pop (pop (stack s)))) (program s)),
     ("execute_goto_defun",
      |- ∀inst s.
           execute_goto inst s =
           make_state (add (arg1 inst) (pc s)) (locals s) (stack s)
             (program s)),
     ("execute_ifle_defun",
      |- ∀inst s.
           execute_ifle inst s =
           make_state
             (itel
                [(not (less (nat 0) (top (stack s))),add (arg1 inst) (pc s))]
                (add (nat 1) (pc s))) (locals s) (pop (stack s)) (program s)),
     ("do_inst_defun",
      |- ∀inst s.
           do_inst inst s =
           itel
             [(equal (op_code inst) (sym "M1" "ICONST"),
               execute_iconst inst s);
              (equal (op_code inst) (sym "M1" "ILOAD"),execute_iload inst s);
              (equal (op_code inst) (sym "M1" "ISTORE"),
               execute_istore inst s);
              (equal (op_code inst) (sym "M1" "IADD"),execute_iadd inst s);
              (equal (op_code inst) (sym "M1" "ISUB"),execute_isub inst s);
              (equal (op_code inst) (sym "M1" "IMUL"),execute_imul inst s);
              (equal (op_code inst) (sym "M1" "GOTO"),execute_goto inst s);
              (equal (op_code inst) (sym "M1" "IFLE"),execute_ifle inst s)] s),
     ("step_defun", |- ∀s. step s = do_inst (next_inst s) s),
     ("run_defun",
      |- ∀sched s.
           run sched s = itel [(endp sched,s)] (run (cdr sched) (step s))),
     ("factorial_example_0_thm",
      |- |= equal
              (run
                 (List
                    [nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0;
                     nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0;
                     nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0;
                     nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0;
                     nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0;
                     nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0;
                     nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0;
                     nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0;
                     nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0;
                     nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0;
                     nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0;
                     nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0; nat 0;
                     nat 0; nat 0; nat 0; nat 0])
                 (make_state (nat 0) (List [nat 5; nat 0]) (List [])
                    (List
                       [List [sym "M1" "ICONST"; nat 1];
                        List [sym "M1" "ISTORE"; nat 1];
                        List [sym "M1" "ILOAD"; nat 0];
                        List [sym "M1" "IFLE"; nat 10];
                        List [sym "M1" "ILOAD"; nat 0];
                        List [sym "M1" "ILOAD"; nat 1];
                        List [sym "M1" "IMUL"];
                        List [sym "M1" "ISTORE"; nat 1];
                        List [sym "M1" "ILOAD"; nat 0];
                        List [sym "M1" "ICONST"; nat 1];
                        List [sym "M1" "ISUB"];
                        List [sym "M1" "ISTORE"; nat 0];
                        List [sym "M1" "GOTO"; int (-10)];
                        List [sym "M1" "ILOAD"; nat 1];
                        List [sym "M1" "HALT"]])))
              (List
                 [nat 14; List [nat 0; nat 120]; List [nat 120];
                  List
                    [List [sym "M1" "ICONST"; nat 1];
                     List [sym "M1" "ISTORE"; nat 1];
                     List [sym "M1" "ILOAD"; nat 0];
                     List [sym "M1" "IFLE"; nat 10];
                     List [sym "M1" "ILOAD"; nat 0];
                     List [sym "M1" "ILOAD"; nat 1]; List [sym "M1" "IMUL"];
                     List [sym "M1" "ISTORE"; nat 1];
                     List [sym "M1" "ILOAD"; nat 0];
                     List [sym "M1" "ICONST"; nat 1]; List [sym "M1" "ISUB"];
                     List [sym "M1" "ISTORE"; nat 0];
                     List [sym "M1" "GOTO"; int (-10)];
                     List [sym "M1" "ILOAD"; nat 1]; List [sym "M1" "HALT"]]])),
     ("ifact_loop_sched_defun",
      |- ∀n.
           ifact_loop_sched n =
           itel [(zp n,repeat (nat 0) (nat 4))]
             (app (repeat (nat 0) (nat 11))
                (ifact_loop_sched (add (int (-1)) n)))),
     ("ifact_sched_defun",
      |- ∀n. ifact_sched n = app (repeat (nat 0) (nat 2)) (ifact_loop_sched n)),
     ("exclaim_defun",
      |- ∀n.
           exclaim n =
           itel [(zp n,nat 1)] (mult n (exclaim (add (int (-1)) n)))),
     ("test_ifact_defun",
      |- ∀n.
           test_ifact n =
           top
             (stack
                (run (ifact_sched n)
                   (make_state (nat 0) (List [n; nat 0]) (List [])
                      (List
                         [List [sym "M1" "ICONST"; nat 1];
                          List [sym "M1" "ISTORE"; nat 1];
                          List [sym "M1" "ILOAD"; nat 0];
                          List [sym "M1" "IFLE"; nat 10];
                          List [sym "M1" "ILOAD"; nat 0];
                          List [sym "M1" "ILOAD"; nat 1];
                          List [sym "M1" "IMUL"];
                          List [sym "M1" "ISTORE"; nat 1];
                          List [sym "M1" "ILOAD"; nat 0];
                          List [sym "M1" "ICONST"; nat 1];
                          List [sym "M1" "ISUB"];
                          List [sym "M1" "ISTORE"; nat 0];
                          List [sym "M1" "GOTO"; int (-10)];
                          List [sym "M1" "ILOAD"; nat 1];
                          List [sym "M1" "HALT"]]))))),
     ("factorial_example_1_thm",
      |- |= equal (test_ifact (nat 5)) (exclaim (nat 5))),
     ("factorial_example_2_thm",
      |- |= equal (test_ifact (nat 1000)) (exclaim (nat 1000))),
     ("even_sched_defun",
      |- ∀i.
           even_sched i =
           itel
             [(zp i,repeat (nat 0) (nat 4));
              (equal i (nat 1),repeat (nat 0) (nat 8))]
             (app (repeat (nat 0) (nat 11)) (even_sched (add (int (-2)) i)))),
     ("test_even_defun",
      |- ∀i.
           test_even i =
           top
             (stack
                (run (even_sched i)
                   (make_state (nat 0) (List [i]) (List [])
                      (List
                         [List [sym "M1" "ILOAD"; nat 0];
                          List [sym "M1" "IFLE"; nat 12];
                          List [sym "M1" "ILOAD"; nat 0];
                          List [sym "M1" "ICONST"; nat 1];
                          List [sym "M1" "ISUB"];
                          List [sym "M1" "IFLE"; nat 6];
                          List [sym "M1" "ILOAD"; nat 0];
                          List [sym "M1" "ICONST"; nat 2];
                          List [sym "M1" "ISUB"];
                          List [sym "M1" "ISTORE"; nat 0];
                          List [sym "M1" "GOTO"; int (-10)];
                          List [sym "M1" "ICONST"; nat 0];
                          List [sym "M1" "HALT"];
                          List [sym "M1" "ICONST"; nat 1];
                          List [sym "M1" "HALT"]]))))),
     ("test_even_theorem_thm",
      |- (|= equal (test_even (nat 18)) (nat 1)) ∧
         (|= equal (test_even (nat 19)) (nat 0)) ∧
         (|= equal (test_even (nat 235)) (nat 0)) ∧
         |= equal (test_even (nat 234)) (nat 1)),
     ("collect_at_end_defun",
      |- ∀list e.
           collect_at_end list e =
           itel [(m1_member e list,list)] (app list (List [e]))),
     ("nth_nil_thm", |- ∀n. |= equal (nth n (List [])) (List [])),
     ("acl2_count_nth_thm",
      |- ∀n acl2_count list.
           (|= consp list) ⇒
           |= less (acl2_count (nth n list)) (acl2_count list)),
     ("collect_vars_in_expr_defun",
      |- ∀vars expr.
           collect_vars_in_expr vars expr =
           itel
             [(atom expr,itel [(symbolp expr,collect_at_end vars expr)] vars)]
             (collect_vars_in_expr
                (collect_vars_in_expr vars (nth (nat 0) expr))
                (nth (nat 2) expr))),
     ("collect_vars_in_stmt_star_space_m1_colon_colon_collect_vars_in_stmt_mutual",
      |- (∀stmt_list vars.
            collect_vars_in_stmt_star vars stmt_list =
            itel [(endp stmt_list,vars)]
              (collect_vars_in_stmt_star
                 (collect_vars_in_stmt vars (car stmt_list))
                 (cdr stmt_list))) ∧
         ∀stmt vars.
           collect_vars_in_stmt vars stmt =
           itel
             [(equal (nth (nat 1) stmt) (sym "M1" "="),
               collect_vars_in_expr (collect_at_end vars (nth (nat 0) stmt))
                 (nth (nat 2) stmt));
              (equal (nth (nat 0) stmt) (sym "M1" "WHILE"),
               collect_vars_in_stmt_star
                 (collect_vars_in_expr vars (nth (nat 1) stmt))
                 (cdr (cdr stmt)));
              (equal (nth (nat 0) stmt) (sym "M1" "RETURN"),
               collect_vars_in_expr vars (nth (nat 1) stmt))] vars),
     ("op_exclaim_defun",
      |- ∀op.
           op_exclaim op =
           itel
             [(equal op (csym "+"),List [List [sym "M1" "IADD"]]);
              (equal op (csym "-"),List [List [sym "M1" "ISUB"]]);
              (equal op (csym "*"),List [List [sym "M1" "IMUL"]])]
             (List [List [sym "M1" "ILLEGAL"]])),
     ("iload_exclaim_defun",
      |- ∀vars var.
           iload_exclaim vars var =
           List [List [sym "M1" "ILOAD"; index var vars]]),
     ("iconst_exclaim_defun",
      |- ∀n. iconst_exclaim n = List [List [sym "M1" "ICONST"; n]]),
     ("expr_exclaim_defun",
      |- ∀vars expr.
           expr_exclaim vars expr =
           itel
             [(atom expr,
               itel [(symbolp expr,iload_exclaim vars expr)]
                 (iconst_exclaim expr))]
             (app (expr_exclaim vars (nth (nat 0) expr))
                (app (expr_exclaim vars (nth (nat 2) expr))
                   (op_exclaim (nth (nat 1) expr))))),
     ("ifle_exclaim_defun",
      |- ∀offset. ifle_exclaim offset = List [List [sym "M1" "IFLE"; offset]]),
     ("goto_exclaim_defun",
      |- ∀offset. goto_exclaim offset = List [List [sym "M1" "GOTO"; offset]]),
     ("while_exclaim_defun",
      |- ∀test_code body_code.
           while_exclaim test_code body_code =
           app test_code
             (app (ifle_exclaim (add (nat 2) (m1_len body_code)))
                (app body_code
                   (goto_exclaim
                      (unary_minus
                         (add (m1_len test_code)
                            (add (nat 1) (m1_len body_code)))))))),
     ("test_exclaim_defun",
      |- ∀vars test.
           test_exclaim vars test =
           itel
             [(equal (nth (nat 1) test) (csym ">"),
               itel
                 [(equal (nth (nat 2) test) (nat 0),
                   expr_exclaim vars (nth (nat 0) test))]
                 (app (expr_exclaim vars (nth (nat 0) test))
                    (app (expr_exclaim vars (nth (nat 2) test))
                       (List [List [sym "M1" "ISUB"]]))))]
             (List [List [sym "M1" "ILLEGAL"]])),
     ("istore_exclaim_defun",
      |- ∀vars var.
           istore_exclaim vars var =
           List [List [sym "M1" "ISTORE"; index var vars]]),
     ("stmt_star_exclaim_space_m1_colon_colon_stmt_exclaim_mutual",
      |- (∀stmt_list vars.
            stmt_star_exclaim vars stmt_list =
            itel [(endp stmt_list,List [])]
              (app (stmt_exclaim vars (car stmt_list))
                 (stmt_star_exclaim vars (cdr stmt_list)))) ∧
         ∀stmt vars.
           stmt_exclaim vars stmt =
           itel
             [(equal (nth (nat 1) stmt) (sym "M1" "="),
               app (expr_exclaim vars (nth (nat 2) stmt))
                 (istore_exclaim vars (nth (nat 0) stmt)));
              (equal (nth (nat 0) stmt) (sym "M1" "WHILE"),
               while_exclaim (test_exclaim vars (nth (nat 1) stmt))
                 (stmt_star_exclaim vars (cdr (cdr stmt))));
              (equal (nth (nat 0) stmt) (sym "M1" "RETURN"),
               app (expr_exclaim vars (nth (nat 1) stmt))
                 (List [List [sym "M1" "HALT"]]))]
             (List [List [sym "M1" "ILLEGAL"]])),
     ("compile_defun",
      |- ∀formals stmt_list.
           compile formals stmt_list =
           stmt_star_exclaim (collect_vars_in_stmt_star formals stmt_list)
             stmt_list),
     ("example_compilation_1_thm",
      |- |= equal
              (compile (List [sym "M1" "N"])
                 (List
                    [List [sym "M1" "A"; sym "M1" "="; nat 1];
                     List
                       [sym "M1" "WHILE";
                        List [sym "M1" "N"; csym ">"; nat 0];
                        List
                          [sym "M1" "A"; sym "M1" "=";
                           List [sym "M1" "N"; csym "*"; sym "M1" "A"]];
                        List
                          [sym "M1" "N"; sym "M1" "=";
                           List [sym "M1" "N"; csym "-"; nat 1]]];
                     List [sym "M1" "RETURN"; sym "M1" "A"]]))
              (List
                 [List [sym "M1" "ICONST"; nat 1];
                  List [sym "M1" "ISTORE"; nat 1];
                  List [sym "M1" "ILOAD"; nat 0];
                  List [sym "M1" "IFLE"; nat 10];
                  List [sym "M1" "ILOAD"; nat 0];
                  List [sym "M1" "ILOAD"; nat 1]; List [sym "M1" "IMUL"];
                  List [sym "M1" "ISTORE"; nat 1];
                  List [sym "M1" "ILOAD"; nat 0];
                  List [sym "M1" "ICONST"; nat 1]; List [sym "M1" "ISUB"];
                  List [sym "M1" "ISTORE"; nat 0];
                  List [sym "M1" "GOTO"; int (-10)];
                  List [sym "M1" "ILOAD"; nat 1]; List [sym "M1" "HALT"]])),
     ("example_compilation_2_thm",
      |- |= equal
              (compile (List [sym "M1" "N"; sym "M1" "K"])
                 (List
                    [List [sym "M1" "A"; sym "M1" "="; nat 0];
                     List
                       [sym "M1" "WHILE";
                        List [sym "M1" "N"; csym ">"; sym "M1" "K"];
                        List
                          [sym "M1" "A"; sym "M1" "=";
                           List [sym "M1" "A"; csym "+"; nat 1]];
                        List
                          [sym "M1" "N"; sym "M1" "=";
                           List [sym "M1" "N"; csym "-"; nat 1]]];
                     List [sym "M1" "RETURN"; sym "M1" "A"]]))
              (List
                 [List [sym "M1" "ICONST"; nat 0];
                  List [sym "M1" "ISTORE"; nat 2];
                  List [sym "M1" "ILOAD"; nat 0];
                  List [sym "M1" "ILOAD"; nat 1]; List [sym "M1" "ISUB"];
                  List [sym "M1" "IFLE"; nat 10];
                  List [sym "M1" "ILOAD"; nat 2];
                  List [sym "M1" "ICONST"; nat 1]; List [sym "M1" "IADD"];
                  List [sym "M1" "ISTORE"; nat 2];
                  List [sym "M1" "ILOAD"; nat 0];
                  List [sym "M1" "ICONST"; nat 1]; List [sym "M1" "ISUB"];
                  List [sym "M1" "ISTORE"; nat 0];
                  List [sym "M1" "GOTO"; int (-12)];
                  List [sym "M1" "ILOAD"; nat 2]; List [sym "M1" "HALT"]])),
     ("example_execution_1_thm",
      |- |= equal
              (top
                 (stack
                    (run (repeat (nat 0) (nat 1000))
                       (make_state (nat 0) (List [nat 5; nat 0]) (List [])
                          (compile (List [sym "M1" "N"])
                             (List
                                [List [sym "M1" "A"; sym "M1" "="; nat 1];
                                 List
                                   [sym "M1" "WHILE";
                                    List [sym "M1" "N"; csym ">"; nat 0];
                                    List
                                      [sym "M1" "A"; sym "M1" "=";
                                       List
                                         [sym "M1" "N"; csym "*";
                                          sym "M1" "A"]];
                                    List
                                      [sym "M1" "N"; sym "M1" "=";
                                       List [sym "M1" "N"; csym "-"; nat 1]]];
                                 List [sym "M1" "RETURN"; sym "M1" "A"]]))))))
              (nat 120)),
     ("example_execution_2_thm",
      |- |= equal
              (top
                 (stack
                    (run (repeat (nat 0) (nat 1000))
                       (make_state (nat 0) (List [nat 10; nat 4; nat 0])
                          (List [])
                          (compile (List [sym "M1" "N"; sym "M1" "K"])
                             (List
                                [List [sym "M1" "A"; sym "M1" "="; nat 0];
                                 List
                                   [sym "M1" "WHILE";
                                    List
                                      [sym "M1" "N"; csym ">"; sym "M1" "K"];
                                    List
                                      [sym "M1" "A"; sym "M1" "=";
                                       List [sym "M1" "A"; csym "+"; nat 1]];
                                    List
                                      [sym "M1" "N"; sym "M1" "=";
                                       List [sym "M1" "N"; csym "-"; nat 1]]];
                                 List [sym "M1" "RETURN"; sym "M1" "A"]]))))))
              (nat 6)),
     ("stacks_thm",
      |- ∀s x.
           (|= equal (top (push x s)) x) ∧ (|= equal (pop (push x s)) s) ∧
           (|= equal (top (cons x s)) x) ∧ |= equal (pop (cons x s)) s),
     ("states_thm",
      |- ∀x program stack locals pc.
           (|= equal (pc (make_state pc locals stack program)) pc) ∧
           (|= equal (locals (make_state pc locals stack program)) locals) ∧
           (|= equal (stack (make_state pc locals stack program)) stack) ∧
           (|= equal (program (make_state pc locals stack program)) program) ∧
           (|= equal (pc (cons pc x)) pc) ∧
           (|= equal (locals (cons pc (cons locals x))) locals) ∧
           (|= equal (stack (cons pc (cons locals (cons stack x)))) stack) ∧
           |= equal
                (program
                   (cons pc (cons locals (cons stack (cons program x)))))
                program),
     ("step_opener_thm",
      |- ∀s.
           (|= consp (next_inst s)) ⇒
           |= equal (step s) (do_inst (next_inst s) s)),
     ("run_app_thm",
      |- ∀s b a. |= equal (run (app a b) s) (run b (run a s))),
     ("run_opener_thm",
      |- ∀sched th s.
           (|= equal (run (List []) s) s) ∧
           |= equal (run (cons th sched) s) (run sched (step s))),
     ("nth_add1_exclaim_thm",
      |- ∀list n.
           (|= natp n) ⇒
           |= equal (nth (add (nat 1) n) list) (nth n (cdr list))),
     ("nth_update_nth_thm",
      |- ∀list v j i.
           (|= natp i) ∧ (|= natp j) ⇒
           |= equal (nth i (update_nth j v list))
                (itel [(equal i j,v)] (nth i list))),
     ("update_nth_update_nth_1_thm",
      |- ∀list w v j i.
           (|= natp i) ∧ (|= natp j) ∧ ¬(|= equal i j) ⇒
           |= equal (update_nth i v (update_nth j w list))
                (update_nth j w (update_nth i v list))),
     ("update_nth_update_nth_2_thm",
      |- ∀list w v i.
           |= equal (update_nth i v (update_nth i w list))
                (update_nth i v list)),
     ("ifact_defun",
      |- ∀n a.
           ifact n a = itel [(zp n,a)] (ifact (add (int (-1)) n) (mult n a))),
     ("test_ifact_examples_thm",
      |- (|= equal (test_ifact (nat 5)) (exclaim (nat 5))) ∧
         (|= equal (test_ifact (nat 10)) (exclaim (nat 10))) ∧
         |= equal (test_ifact (nat 100)) (exclaim (nat 100))),
     ("ifact_loop_lemma_thm",
      |- ∀stack a n.
           (|= natp n) ∧ (|= natp a) ⇒
           |= equal
                (run (ifact_loop_sched n)
                   (make_state (nat 2) (List [n; a]) stack
                      (List
                         [List [sym "M1" "ICONST"; nat 1];
                          List [sym "M1" "ISTORE"; nat 1];
                          List [sym "M1" "ILOAD"; nat 0];
                          List [sym "M1" "IFLE"; nat 10];
                          List [sym "M1" "ILOAD"; nat 0];
                          List [sym "M1" "ILOAD"; nat 1];
                          List [sym "M1" "IMUL"];
                          List [sym "M1" "ISTORE"; nat 1];
                          List [sym "M1" "ILOAD"; nat 0];
                          List [sym "M1" "ICONST"; nat 1];
                          List [sym "M1" "ISUB"];
                          List [sym "M1" "ISTORE"; nat 0];
                          List [sym "M1" "GOTO"; int (-10)];
                          List [sym "M1" "ILOAD"; nat 1];
                          List [sym "M1" "HALT"]])))
                (make_state (nat 14) (List [nat 0; ifact n a])
                   (push (ifact n a) stack)
                   (List
                      [List [sym "M1" "ICONST"; nat 1];
                       List [sym "M1" "ISTORE"; nat 1];
                       List [sym "M1" "ILOAD"; nat 0];
                       List [sym "M1" "IFLE"; nat 10];
                       List [sym "M1" "ILOAD"; nat 0];
                       List [sym "M1" "ILOAD"; nat 1]; List [sym "M1" "IMUL"];
                       List [sym "M1" "ISTORE"; nat 1];
                       List [sym "M1" "ILOAD"; nat 0];
                       List [sym "M1" "ICONST"; nat 1];
                       List [sym "M1" "ISUB"];
                       List [sym "M1" "ISTORE"; nat 0];
                       List [sym "M1" "GOTO"; int (-10)];
                       List [sym "M1" "ILOAD"; nat 1];
                       List [sym "M1" "HALT"]]))),
     ("ifact_lemma_thm",
      |- ∀stack a n.
           (|= natp n) ⇒
           |= equal
                (run (ifact_sched n)
                   (make_state (nat 0) (List [n; a]) stack
                      (List
                         [List [sym "M1" "ICONST"; nat 1];
                          List [sym "M1" "ISTORE"; nat 1];
                          List [sym "M1" "ILOAD"; nat 0];
                          List [sym "M1" "IFLE"; nat 10];
                          List [sym "M1" "ILOAD"; nat 0];
                          List [sym "M1" "ILOAD"; nat 1];
                          List [sym "M1" "IMUL"];
                          List [sym "M1" "ISTORE"; nat 1];
                          List [sym "M1" "ILOAD"; nat 0];
                          List [sym "M1" "ICONST"; nat 1];
                          List [sym "M1" "ISUB"];
                          List [sym "M1" "ISTORE"; nat 0];
                          List [sym "M1" "GOTO"; int (-10)];
                          List [sym "M1" "ILOAD"; nat 1];
                          List [sym "M1" "HALT"]])))
                (make_state (nat 14) (List [nat 0; ifact n (nat 1)])
                   (push (ifact n (nat 1)) stack)
                   (List
                      [List [sym "M1" "ICONST"; nat 1];
                       List [sym "M1" "ISTORE"; nat 1];
                       List [sym "M1" "ILOAD"; nat 0];
                       List [sym "M1" "IFLE"; nat 10];
                       List [sym "M1" "ILOAD"; nat 0];
                       List [sym "M1" "ILOAD"; nat 1]; List [sym "M1" "IMUL"];
                       List [sym "M1" "ISTORE"; nat 1];
                       List [sym "M1" "ILOAD"; nat 0];
                       List [sym "M1" "ICONST"; nat 1];
                       List [sym "M1" "ISUB"];
                       List [sym "M1" "ISTORE"; nat 0];
                       List [sym "M1" "GOTO"; int (-10)];
                       List [sym "M1" "ILOAD"; nat 1];
                       List [sym "M1" "HALT"]]))),
     ("ifact_is_factorial_thm",
      |- ∀a n.
           (|= natp n) ∧ (|= natp a) ⇒
           |= equal (ifact n a) (mult (exclaim n) a)),
     ("ifact_correct_thm",
      |- ∀stack a n.
           (|= natp n) ⇒
           |= equal
                (run (ifact_sched n)
                   (make_state (nat 0) (List [n; a]) stack
                      (List
                         [List [sym "M1" "ICONST"; nat 1];
                          List [sym "M1" "ISTORE"; nat 1];
                          List [sym "M1" "ILOAD"; nat 0];
                          List [sym "M1" "IFLE"; nat 10];
                          List [sym "M1" "ILOAD"; nat 0];
                          List [sym "M1" "ILOAD"; nat 1];
                          List [sym "M1" "IMUL"];
                          List [sym "M1" "ISTORE"; nat 1];
                          List [sym "M1" "ILOAD"; nat 0];
                          List [sym "M1" "ICONST"; nat 1];
                          List [sym "M1" "ISUB"];
                          List [sym "M1" "ISTORE"; nat 0];
                          List [sym "M1" "GOTO"; int (-10)];
                          List [sym "M1" "ILOAD"; nat 1];
                          List [sym "M1" "HALT"]])))
                (make_state (nat 14) (List [nat 0; exclaim n])
                   (push (exclaim n) stack)
                   (List
                      [List [sym "M1" "ICONST"; nat 1];
                       List [sym "M1" "ISTORE"; nat 1];
                       List [sym "M1" "ILOAD"; nat 0];
                       List [sym "M1" "IFLE"; nat 10];
                       List [sym "M1" "ILOAD"; nat 0];
                       List [sym "M1" "ILOAD"; nat 1]; List [sym "M1" "IMUL"];
                       List [sym "M1" "ISTORE"; nat 1];
                       List [sym "M1" "ILOAD"; nat 0];
                       List [sym "M1" "ICONST"; nat 1];
                       List [sym "M1" "ISUB"];
                       List [sym "M1" "ISTORE"; nat 0];
                       List [sym "M1" "GOTO"; int (-10)];
                       List [sym "M1" "ILOAD"; nat 1];
                       List [sym "M1" "HALT"]]))),
     ("ifact_correct_corollary_1_thm",
      |- ∀stack a n.
           (|= natp n) ⇒
           |= equal
                (top
                   (stack
                      (run (ifact_sched n)
                         (make_state (nat 0) (List [n; a]) stack
                            (List
                               [List [sym "M1" "ICONST"; nat 1];
                                List [sym "M1" "ISTORE"; nat 1];
                                List [sym "M1" "ILOAD"; nat 0];
                                List [sym "M1" "IFLE"; nat 10];
                                List [sym "M1" "ILOAD"; nat 0];
                                List [sym "M1" "ILOAD"; nat 1];
                                List [sym "M1" "IMUL"];
                                List [sym "M1" "ISTORE"; nat 1];
                                List [sym "M1" "ILOAD"; nat 0];
                                List [sym "M1" "ICONST"; nat 1];
                                List [sym "M1" "ISUB"];
                                List [sym "M1" "ISTORE"; nat 0];
                                List [sym "M1" "GOTO"; int (-10)];
                                List [sym "M1" "ILOAD"; nat 1];
                                List [sym "M1" "HALT"]]))))) (exclaim n)),
     ("ifact_correct_corollary_2_thm",
      |- ∀stack a n.
           (|= natp n) ⇒
           |= equal
                (top
                   (stack
                      (run (ifact_sched n)
                         (make_state (nat 0) (List [n; a]) stack
                            (compile (List [sym "M1" "N"])
                               (List
                                  [List [sym "M1" "A"; sym "M1" "="; nat 1];
                                   List
                                     [sym "M1" "WHILE";
                                      List [sym "M1" "N"; csym ">"; nat 0];
                                      List
                                        [sym "M1" "A"; sym "M1" "=";
                                         List
                                           [sym "M1" "N"; csym "*";
                                            sym "M1" "A"]];
                                      List
                                        [sym "M1" "N"; sym "M1" "=";
                                         List
                                           [sym "M1" "N"; csym "-"; nat 1]]];
                                   List
                                     [sym "M1" "RETURN"; sym "M1" "A"]]))))))
                (exclaim n)),
     ("example_modify_1_thm",
      |- ∀inst s.
           |= equal
                (make_state (add (nat 1) (pc s)) (locals s)
                   (push (arg1 inst) (stack s)) (program s))
                (make_state (add (nat 1) (pc s)) (locals s)
                   (push (arg1 inst) (stack s)) (program s))),
     ("example_modify_2_thm",
      |- ∀inst s.
           |= equal
                (make_state (add (nat 1) (pc s))
                   (update_nth (arg1 inst) (top (stack s)) (locals s))
                   (pop (stack s)) (program s))
                (make_state (add (nat 1) (pc s))
                   (update_nth (arg1 inst) (top (stack s)) (locals s))
                   (pop (stack s)) (program s))),
     ("example_modify_3_thm",
      |- ∀s inst.
           |= equal
                (make_state (add (arg1 inst) (pc s)) (locals s) (stack s)
                   (program s))
                (make_state (add (arg1 inst) (pc s)) (locals s) (stack s)
                   (program s))),
     ("pattern_bindings_defun",
      |- ∀vars arg_expressions.
           pattern_bindings vars arg_expressions =
           itel [(endp vars,List [])]
             (cons (List [car vars; car arg_expressions])
                (pattern_bindings (cdr vars) (cdr arg_expressions)))),
     ("example_semantics_1_thm",
      |- ∀s inst.
           |= equal
                (make_state (add (nat 1) (pc s)) (locals s)
                   (push (arg1 inst) (stack s)) (program s))
                (make_state (add (nat 1) (pc s)) (locals s)
                   (push (arg1 inst) (stack s)) (program s))),
     ("concat_symbols_defun",
      |- ∀part1 part2.
           concat_symbols part1 part2 =
           intern_in_package_of_symbol
             (coerce
                (app (coerce (symbol_name part1) (csym "LIST"))
                   (coerce (symbol_name part2) (csym "LIST")))
                (csym "STRING")) (sym "M1" "RUN")),
     ("make_defun_defun",
      |- ∀name args dcl body.
           make_defun name args dcl body =
           itel [(dcl,List [csym "DEFUN"; name; args; dcl; body])]
             (List [csym "DEFUN"; name; args; body]))] : (string * thm) list
- 
