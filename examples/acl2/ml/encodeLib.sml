(*****************************************************************************)
(* File: encodeLib.sml                                                       *)
(* Author: James Reynolds                                                    *)
(*                                                                           *)
(* Provides the functions to encode HOL into ACL2                            *)
(*****************************************************************************)

(******************** To do *******************)

(* 1) Reduce_judgements is done very very badly, might want to consider re-doing it *)

(********** Useful stuff to remember **********)

(* Its not possible to have a 'P m ==> P (car m)' as a typing judgement, unless it is list, in the cases where pairs are present, they must both occur in the same form on *)
(* both sides, eg. (natp (car m) = t) ... ==> (natp (car m) = t) /\ (natp (car n) = t) and hence will be removed (stage 4.4) before the decision procedure *)


(**************** BUGS LIST **************)

(* encode_arg  [``a::l:num list``,``a::b::l:num list``] *)
(* encode_arg  [``[]:num list``] *)
(* really need to test reduce judgements with overlapping predicates: (natp n = t) /\ (natp m = t) ==> (natp n = t) /\ (natp m = t) /\ (natp (add n (unary_minus (nat 1)))) *)
(* There is a possibility that initialising P, where an extra hypothesis is required (eg. tails), might introduce more hypothesis *)
(* It lets you do 't' as a variable name *)
(* There is going to be a problem with: |- f (h::hs) a = f hs h::a --- probably requires a bit to lump together sexp_EVERY P parts, and perhaps to improve HO_PART_MATCH *)
(* list_predicate seems to be re-doing some predicates *) 

(* ChangeLog (brief) *)

(* 16/05 	- Completed & Changed MATCH_MP (DISCH h t) * to PROVE_HYP * t - seems to be working *)
(* 17/05 	- Added placement of P into result of stage5 (testing lines only), ensures non-recursive functions get arguments prefixed
		- Stage 5 now uses a 'convert_acl2' function, instead of one long line in testing
		- Add default value now returns a theorem relating the default value and the type
		- Definition proofs now determines function type by the function, not the default value (which was dumb)
		- Judgement procedure now uses thm from 'add_default_value' to adjust definition to fit proof scheme
		- Judgement procedure now uses CONJ_MATCH_MP to match the typing judgement to the decode/encode proof
		- Appeared to be creating possible P with args the wrong way round!
		- encode_arg [``[]``,``(x,y)::tl``] would fail because it was trying to keep the pairs together, added an encode_to_pair function to the list bit to solve
		- Changed THENCU to allow instantiation of free variables in the theorem generated by the left hand conv
			====> [.] |- nat (FST (sexp_to_pair nat int X)) = car (pair nat g (sexp_to_pair int X)),
                              [.] |- pair nat int (sexp_to_pair int X) = X
			----> [.] |- nat (FST (sexp_to_pair nat int X)) = car X   (g is instantiated to int)
		- As an aside to above, translateScript has two new pair theorems
		- Fixed (ish) correct_thm for solving taup(encode x) style things, quite a hack for the conjunctions stuff though *)
(* 19/05	- Created a CONJ_PART_MATCH, which acts like PART_MATCH but copes with associativity / commutivity of /\ (see CONJ_... tools)
		- Changed CONJ_MATCH_MP to use CONJ_PART_MATCH
		- Fixed generation of the correct_thm to use CONJ_PART_MATCH, no longer a massive hack! 
		- Appeared to be creating the final P with args the wrong way around aswell (should've seen that one, duh!)
		- Changed reduced_judgement so it will instantiate free variables in decoding functions 
		- As an aside to above, translateScript had the list theorems changed from (consp a = t) to ~(sexp_to_list f a = []) *)
(* 22/05	- Modified curry_single_function (stage1) so it can cope with functions with 0 arguments (used to raise UNCHANGED)
		- Modified convert_acl2 to filter on 'is_P_term', as functions without foralls (eg. no arguments) fail (*** this may crop up again ***)
		- Create_possible_P had this problem, as well as not being able to find a Pterm if there are no type judgements
		- current_hypothesis_set and collect_hypothesis_set modified to use is_P_term and is_definition
		- rewrite_P modified to cope with no P term, indicates that it /was/ T
		- rewrite_P also modified to remove acl2_if t (and hopefully redundantely acl2_if nil)
		- modified judgment_thm and correct_thm to cope with functions with no predicate
		- and modified rewrite_definition in the same way
		- Changed definition_proofs to output a theorem that may be used for rewriting
		- Put an ETA_CONV into judgement for things like (sexp_to_list (\a. sexp_to_nat a) ... )
		- More concise version of is_P_term
		- Modified reduce_judgement to keep lists of conjunctions to save time *)
(* 23/05	- Added functions to create list predicates (Stage 10) *)


(* Interactive stuff ... 
val _ = loadPath := "../ml/" :: !loadPath;

app load ["translateTheory","listLib"];

*)
open HolKernel boolLib bossLib Q Parse combinTheory computeLib
     Conv Thm Tactical BasicProvers Tactic Drule Definition translateTheory listTheory numLib listLib pairLib pairTheory sexpTheory;

(* These files are only required for my testing purposes... *)

open arithmeticTheory;

(*****************************************************************************)
(* Error handling and tracing                                                *)
(*****************************************************************************)

val stage_trace = ref 0;

fun remove_stage n = stage_trace := let val en = funpow n (curry op* 2) 1 in ((!stage_trace) div (2 * en)) * (2 * en) + (!stage_trace) mod en end;

fun add_stage n = (remove_stage n ; stage_trace := !stage_trace + funpow n (curry op* 2) 1);

fun print_trace stage message = if (!stage_trace) div (funpow stage (curry op* 2) 1) mod 2 = 1 then print message else ();

fun raise_error stage function error = 
	let val func = if stage > 0 then "Stage " ^ int_to_string stage ^ ": " ^ function else function
	in
		(if stage > 0 then print_trace stage ("Exception in " ^ func ^ ": " ^ error ^ "\n") else () ; raise (mk_HOL_ERR "encodeLib" func error))
	end;

(*****************************************************************************)
(* CONJ_... tools: Provides version of matching tools that tackle            *)
(*                 associativity / commutivity of /\                         *)
(*                                                                           *)
(* CONJ_MATCH_MP: thm -> thm -> thm                                          *)
(* CONJ_PART_MATCH: (term -> term) -> thm -> term -> thm                     *)
(*                                                                           *)
(*****************************************************************************)

(* Bugs / problems in this section: *)
(* --- fixed: conjunctions split into set --- 1) Not really sure what is happening when I try and match A /\ A with A etc... *)
(* 2) Doesn't produce a set of possible matches *)
(* 3) There is no (easy) way to work out what opr is doing to the thm, so it replaces all occurrences with the modified conjunctions *)
(* 4) Should really produce the equality thms directly from possible_matches, and use a lazy list or something at that *)

(* Find all the permutations of a list *)
fun perm [] = [[]]
  | perm l = foldl (fn (x,L) => map (cons x) (perm (subtract l [x])) @ L) [] l;

(* All pairings of two lists *)
fun comb_lists t1s t2s = map (zip t1s) (perm t2s);

(* Given two lists of redex / residue pairs *)
fun is_conflict ((t1s,h1s):{redex : term, residue : term} list * {redex : hol_type, residue : hol_type} list)
		((t2s,h2s):{redex : term, residue : term} list * {redex : hol_type, residue : hol_type} list) =
let 	fun test l1 l2 = exists (fn x => exists (fn y => (#redex x = #redex y) andalso not (#residue x = #residue y)) l1) l2
in
	(test t1s t2s) orelse (test h1s h2s)
end;

(* Given two lists of redex / residue pairs, combine them, throwing an exception if they can't be combined *)
fun combine_matches 	((t1s,h1s):{redex : term, residue : term} list * {redex : hol_type, residue : hol_type} list)
			((t2s,h2s):{redex : term, residue : term} list * {redex : hol_type, residue : hol_type} list) =
let	fun comb l1 l2 = foldl (fn (x,L) => if exists (fn y => (#redex x = #redex y) andalso not (#residue x = #residue y)) l2
						then raise_error 0 "combine_matches" "Matchings cannot be combined"
						else x::L) l2 l1
in
	(comb t1s t2s,comb h1s h2s)
end;

(* Given a list of possible matchings, return a list of possible matches throwing out those where #residues clash *)
fun append_matches [] = []
  | append_matches [x] = x
  | append_matches (l1::ls) = (fn L => foldl (fn (m1,ms) => mapfilter (combine_matches m1) L @ ms) [] l1) (append_matches ls);
		
(* Given two bound variables, t1v t2v, delete any matches with t1v |-> X where X is not t2v, in the case of t2v, delete that from the match *)
fun remove_redex t1v t2v L =
	let fun delete []:{redex : term, residue : term} list = []
              | delete (z::zs) = if (#redex z = t1v) then (if (#residue z = t2v) then zs else raise_error 0 "remove_redex" "Abstracted variable used in match") else delete zs
	in
		mapfilter (delete ## I) L
	end;


(* Return all possible matches for two terms, allowing for associativity / commutivity of /\ *)
fun possible_matches term1 term2 =
	if free_in ``$/\`` term1 andalso free_in ``$/\`` term2 then
	(if is_conj term1 andalso is_conj term2 then
		let val (t1s,t2s) = (mk_set o strip_conj ## mk_set o strip_conj) (term1,term2) in 
			flatten (map (append_matches o map (uncurry possible_matches)) (comb_lists t1s t2s)) end
	 else if is_comb term1 andalso is_comb term2 then
		let val ((t1l,t1r),(t2l,t2r)) = (dest_comb ## dest_comb) (term1,term2) in append_matches [possible_matches t1l t2l,possible_matches t1r t2r] end
	 else 
		let val (t1v,t1b) = dest_abs term1 in if free_in t1v term2 then [] else possible_matches t1b (body (rename_bvar (fst (dest_var t1v)) term2)) end)
	else [match_term term1 term2] handle _ => [];

(* As PART_MATCH but handles associativity / commutivity of /\ *)
fun CONJ_PART_MATCH opr thm term2 =
let	val thm' = SPEC_ALL thm
	val term1 = (opr o concl) thm'
	fun tactic x = REPEAT (CHANGED_TAC (
				FIRST [REFL_TAC,AP_TERM_TAC,AP_THM_TAC,HO_MATCH_MP_TAC (DISCH_ALL (MK_ABS (ASSUME ``!a. (P:'a -> 'b) a = Q a``))) THEN GEN_TAC,
					EQ_TAC THEN REPEAT STRIP_TAC, FIRST_ASSUM ACCEPT_TAC])) x
	fun prove_eq term1 term2 (tmatch,hmatch) = prove(mk_eq(subst tmatch (inst hmatch term1),term2),tactic)
in
	tryfind (fn match => PURE_ONCE_REWRITE_RULE [prove_eq term1 term2 match] (INST_TY_TERM match thm')) 
		(sort (fn a => fn b => length (fst a) < length (fst b)) (possible_matches term1 term2))
end;

(* As MATCH_MP but handles associativity / commutivity of /\ *)
fun CONJ_MATCH_MP thm1 thm2 = 
	MATCH_MP (CONJ_PART_MATCH (fst o dest_imp) thm1 (concl thm2)) thm2;



(*****************************************************************************)
(* Theorems required in the conversion process                               *)
(*****************************************************************************)

val IF_THMS = prove(``(acl2_if t a b = a) /\ (acl2_if nil a b = b)``,RW_TAC std_ss [cond_def,t_def,nil_def]);
	

(*****************************************************************************)
(* Stage 1: Replace function clauses with if statements                      *)
(*                                                                           *)
(* num:       |- (f 0 = A) /\ (f (SUC n) = B)                                *)
(*      --->  |- f n = if n = 0 then A else B [n - 1 / n]                    *)
(*                                                                           *)
(* list:      |- (f [] = A) /\ (f (hd::tl) = B)                              *)
(*      --->  |- f l = if l = [] then A else B [HD l / hd, TL l / tl]        *)
(*                                                                           *)
(* bool:      |- (f T = A) /\ (f F = B)                                      *)
(*      --->  |- f b = if b then A else B                                    *)
(*                                                                           *)
(* Pairs are not encoded to single variables                                 *)
(*                                                                           *)
(*****************************************************************************)

val num_thm = DECIDE ``x = if x = 0 then 0 else SUC (x - 1)``;
val list_thm = prove(``x = if x = [] then [] else (HD x) :: (TL x)``,Cases_on `x` THEN RW_TAC std_ss [HD,TL]);
val bool_thm = DECIDE ``x = if x then T else F``

(* Splits the head off a list, eg: a::b -> (a,b) and [e1;e2...] -> (e1,[e2;...]) *)
fun split_head term = 
	if is_cons term then (dest_cons term) else (fn ((a,b),c) => (hd a, mk_list (b,c))) ((split_after 1 ## I) (dest_list term));

(** Idea **)
(* Could this function be made general, just using theorems based on either conditionals or case statements and fed theorems? *)
(* ... could then made the encoding / decoding / typing functions general (somehow ... polytypism) and have an entire general infrastructure *)

(* General rule for function: *)
(*	1) separate terms into constructor classes (eg. [] , a :: b) *)
(*	2) recursively encode these constructors *)
(*	3) apply the each constructors destructor *)
(*	4) reconstruct the theorems with constructors *)
(*	5) apply the conditional, or case syntax, constructor *)

(*
Hol_datatype `num_tree = Leaf of num | Branch of num_tree => num => num_tree`;
val add_tree_def = Define `(add_tree (Leaf n) = n) /\ (add_tree (Branch left n right) = n + add_tree left + add_tree right);
argument_list add_tree_def;
*)

(* Store as a theorem: |- (NULL x) \/ (x = (HD x :: TL x)) (this is the theorem CONS) *)

(* IAP_TERM: same as AP_TERM except tries to instantiate the left type domain to match *)
fun IAP_TERM term thm = 
	AP_TERM (inst (match_type (repeat (fst o dom_rng) (type_of term)) ((type_of o lhs o concl) thm)) term) thm;

(* IMK_COMB: same as MK_COMB except tries to instantiate the left type domain to match *)
fun IMK_COMB (thm1,thm2) = 
	MK_COMB (INST_TYPE (match_type (repeat (fst o dom_rng) ((type_of o lhs o concl) thm1)) ((type_of o lhs o concl) thm2)) thm1,thm2);

(* imk_comb: same as mk_comb but tries to instantiate the left type domain to match *)
fun imk_comb (term1,term2) = 
	mk_comb (inst (match_type (repeat (fst o dom_rng) (type_of term1)) (type_of term2)) term1,term2);

(* MK_CONS: |- hd = hd', |- tl = tl' --> |- hd::tl = hd'::tl' *)
fun MK_CONS (h_thm,t_thm) = MK_COMB (IAP_TERM cons_tm h_thm,t_thm);

(* LIST_MK_PAIR: [|- x0 = y0, |- x1 = y1, ....] --> |- (x0,x1,...) = (y0,y1,...) *)
fun LIST_MK_PAIR [] = Raise Empty
  | LIST_MK_PAIR [x] = if (is_eq o concl) x then x else raise_error 0 "LIST_MK_PAIR" "Not an equation"
  | LIST_MK_PAIR (x::y) = IMK_COMB(IAP_TERM comma_tm x,LIST_MK_PAIR y);

(* transpose *)
fun transpose L = (map hd L) :: transpose (map tl L) handle e => [];

(* Term equal, ignoring variable naming *)
fun term_eq_nvar term1 term2 = 
	(let val ((l1,r1),(l2,r2)) = (dest_comb term1,dest_comb term2) in (term_eq_nvar l1 l2 andalso term_eq_nvar r1 r2) end) handle _ =>
	(let val ((l1,r1),(l2,r2)) = (dest_abs  term1,dest_abs  term2) in (term_eq_nvar l1 l2 andalso term_eq_nvar r1 r2) end) handle _ =>
	(is_var term1 andalso is_var term2) orelse (term1 = term2);

(* Forces an argument encoding into a pair |- (x,x') = A --> x = A [FST x / x,SND x / x'] *)
fun encode_to_pair thm = 
let	val var = mk_var("x",(type_of o lhs o concl) thm)
	val lhsp = fst o dest_pair
	val rhsp = snd o dest_pair
in
	CONV_RULE (LAND_CONV (REWR_CONV PAIR)) (INST [(lhsp o lhs o concl) thm |-> imk_comb (fst_tm,var),(rhsp o rhs o concl) thm |-> imk_comb (snd_tm,var)] thm)
end;







(* Encodes argument constructors into conditionals, eg. [``0n``,``SUC n``] --> |- x = (if x = 0 then 0 else SUC (x - 1)) *)
fun encode_arg [] = Raise Empty
  | encode_arg L = 
	if (is_pair o hd) L then 
		(LIST_MK_PAIR o snd)
			(foldr 
				(fn (x,(vl,tl)) => 
					let val nx = variant vl (mk_var ("x",(type_of o lhs o concl) x)) in 
						(nx::vl,(INST [mk_var ("x",(type_of o lhs o concl) x) |-> nx] x) :: tl) end)
				([],[]) (map encode_arg (transpose (map strip_pair L))))
	else if (is_list_type o type_of o hd) L andalso (exists is_cons L orelse exists is_nil L) then 
			let	val list_type = eltype (hd L)
				val head = mk_var ("x",list_type)
				val tail = mk_var ("x",mk_list_type list_type)
				val cons = MK_CONS ((INST [head |-> mk_hd tail] o repeat encode_to_pair o encode_arg ## INST [tail |-> mk_tl tail] o encode_arg) 
					(unzip (map split_head (filter (not o is_nil) L))))
			in
				ONCE_REWRITE_RULE [cons] (INST_TYPE [(hd o type_vars_in_term o concl) list_thm |-> list_type] list_thm)
			end
	else if length (op_mk_set term_eq_nvar L) = 1 then REFL (mk_var ("x",type_of (hd L)))
	else if (type_of o hd) L = ``:num`` then 
		(ONCE_REWRITE_RULE [AP_TERM ``SUC`` (INST [``x:num`` |-> ``x - 1n``] (encode_arg (map dest_suc (filter is_suc L))))] num_thm)
	else if ((fst o dest_type o type_of o hd) L) = "bool" then bool_thm		
	else raise_error 1 "encode_arg" ("Unsupported type constructor: " ^ ((fst o dest_type o type_of o hd) L));

(* argument_list - Returns sets of each curried argument from all function clauses, along with the function itself *)
fun argument_list thm = ((hd ## transpose) o unzip o map (strip_comb o fst o dest_eq o snd o strip_forall) o strip_conj o concl) thm;

(* Orders variables in terms of strings *)
fun sortx L = sort (fn a => fn b => fst (dest_var a) > fst (dest_var b)) L;

(* Pushes any constructors in *)
fun ONCE_PULL_IF_CONV term = 
	if can (REWR_CONV COND_RAND) term andalso (not (can (match_term ``COND :bool -> 'a -> 'a -> 'a``) (repeat rator term))) then REWR_CONV COND_RAND term
	else if can (REWR_CONV COND_RATOR) term then REWR_CONV COND_RATOR term
	else SUB_CONV ONCE_PULL_IF_CONV term;

(* Final function *)
fun raw_convert_tc arg_list replace_list =
	RIGHT_CONV_RULE (REPEATC ONCE_PULL_IF_CONV)
		(foldl (fn (a,b) => MK_COMB (b,a)) (REFL (fst arg_list)) 
			((rev o snd) (foldl (fn (x,(RL,L)) => 
				let val vars = (sortx o free_vars o concl) x in (List.drop(RL,length vars),(INST (map2 (curry op|->) vars
					(List.take (RL,length vars))) x)::L) end) 
			(replace_list,[]) 
			(map (encode_arg) (snd arg_list)))));

		
(* Makes a safe new variable, a -> zzz... avoiding those in the list *)
fun addc [] = [#"a"]
  | addc (x::xs) = if x >= #"z" then #"1" :: addc xs else (if x >= #"9" andalso x < #"a" then #"a" :: xs else Char.succ x :: xs);

fun next_var s = (implode o rev o addc o rev o explode) s;

fun new_var L t = mk_var(let val S = map (fst o dest_var) L in repeat (fn x => if mem x S then next_var x else raise Empty) "a" end,t);

fun acl2_variant L v = mk_var(let val S = map (fst o dest_var) L in repeat (fn x => if mem x S then next_var x else raise Empty) (fst (dest_var v)) end,type_of v);


(* Take the first variable in the constructor we find, if we don't find one, just use variants of x *)
fun make_var_list [] L = []
  | make_var_list (args::clauses) L = 
	let val x = (let val vr = all_varsl args in if vr = [] then new_var L (type_of (hd args)) else mk_var(fst (dest_var (hd vr)),type_of (hd args)) end) in 
		x :: make_var_list clauses (x :: L) end;


fun convert_tc arg_list function = RIGHT_CONV_RULE (PURE_ONCE_REWRITE_CONV [function]) 
					(raw_convert_tc arg_list (make_var_list (flatten (map (transpose o map strip_pair) (snd arg_list))) []));

(*****************************************************************************)
(* Stage 2: Curry all pairs                                                  *)
(*                                                                           *)
(* |- f (a,b) = A  --->  |- (\a b.f (a,b)) a b = A                           *)
(* |- f p = A      --->  |- (\a b.f (a,b)) a b = A [a / FST p, b / SND p]    *)
(*                                                                           *)
(*****************************************************************************)

(* Returns the argument list of the converted function *)
fun argument_list_single thm = (strip_comb o fst o dest_eq o snd o strip_forall o concl) thm;

(* Creates new variable names for a product variable: ``p:'a # 'b`` --> [``p1:'a``,``p2:'b``] *) 
fun make_pair_vars list p = 
	foldr (fn (a,L) => acl2_variant L a :: L) 
		(set_diff list [p])
		(map (mk_var o ((fn a => (fst (dest_var p)) ^ (Int.toString a)) ## I)) (enumerate 1 (strip_prod (type_of p))));

(* Only convert a term if it is a product term not explicitly paired and a use of FST or SND occurs for it *)
fun needs_conversion thm term = 
	(not o is_pair) term andalso can (dest_prod o type_of) term andalso 
		(free_in (imk_comb (fst_tm,term)) ((rhs o concl) thm) orelse free_in (imk_comb (snd_tm,term)) ((rhs o concl) thm));

(* Must partition for elements in which FST or SND are used, and which are not pairs themselves *)
(* Replace pair types: [(pl,pr) / p,pl / FST p,pr / SND p] *)
fun replace_products thm = RIGHT_CONV_RULE (DEPTH_CONV (FIRST_CONV (map REWR_CONV [FST,SND]))) 
	(INST ((fn (a,b) => map (fn c => c |-> (list_mk_pair o make_pair_vars b) c) a) (partition (needs_conversion thm) (snd (argument_list_single thm)))) thm);

(* Final function *)
fun curry_single_function thm = 
	let 	val rpt  = replace_products thm
		val cthms = [(SYM (DEPTH_CONV BETA_CONV (
			let val list = flatten (map strip_pair (snd (argument_list_single rpt)))
			in 
				foldl (fn (a,b) => mk_comb (b,a)) (list_mk_abs (list,(lhs o concl) rpt)) list end)))] handle UNCHANGED => []
	in
		ONCE_REWRITE_RULE cthms rpt
	end;

(*****************************************************************************)
(* Stage 3: Create an encoded / decoded version of the theorem               *)
(*                                                                           *)
(* |- f a = A   ---> |- encode (f (decode a')) = encode (A [decode a' / a])  *)
(*                                                                           *)
(*****************************************************************************)

(* Mechanism to support a case list *)
fun case_list x L default = (fn (SOME (_,x)) => x() | NONE => default ()) (assoc1 x L);

(* DISCHarges all the assumptions, but as a conjunction, eg: [P,Q,R...] |- A --> |- P /\ Q /\ R .. ==> A *)
fun DISCH_AND_CONJ thm = 
	if hyp thm = [] then thm else
	DISCH_AND_CONJ ((CONV_RULE (TRY_CONV (REWR_CONV AND_IMP_INTRO))) (DISCH (hd (hyp thm)) thm));

(* Returns the encoded variable of a type judgement *)
fun get_encoded_var term = (repeat (fn x => let val (a,b) = dest_comb x in if type_of b = ``:sexp`` then b else raise Empty end) 
				o (fn x => lhs x handle _ => (last o snd o strip_comb) x) o hd o strip_conj) term;

(* Converts a type judgement, |- P (f x) = t /\ Q (f x) = t ... , to |- (\x. P x = t /\ Q x = t) (f x) *)
fun BETA_TYPE thm = 
	GEN_ALL (CONV_RULE (UNBETA_CONV ((get_encoded_var o concl o SPEC_ALL) thm) THENC 
		RATOR_CONV (RENAME_VARS_CONV ((map (fst o dest_var) o fst o strip_forall o concl) thm))) (SPEC_ALL thm));

(* Encodes a type to give an encode function, encode - decode proof and a decode function *)

type encoded_type = {encoder : term, decoder : term, enc_dec_thm : thm, dec_enc_thm : thm, taup_thm : thm};

local
val pair_thm1 = prove(``(consp a = t) ==> (cons (car a) (cdr a) = a)``,
				Cases_on `a` THEN RW_TAC std_ss [consp_def,car_def,cdr_def,nil_def,t_def])
val pair_thm2 = prove(``(!a. P (f (a:'a)))  /\ (!b. Q (g (b:'b))) ==> (!a. P (car (pair f g a)) /\ Q (cdr (pair f g a)) /\ (consp (pair f g a) = t))``,
				RW_TAC std_ss [pair_def,car_def,cdr_def,consp_def,t_def])
fun ET (a,b,c,d,e) = {encoder = a, decoder = b, enc_dec_thm = c, dec_enc_thm = d, taup_thm = e}
fun DT {encoder = a, decoder = b, enc_dec_thm = c, dec_enc_thm = d, taup_thm = e} = (a,b,c,d,e)
in
fun encode_type encode_type_caller ttype =
  let 	fun inst_list term l = inst (map op|-> (zip (type_vars (type_of term)) l)) term
	val (tau,comps) = dest_type ttype
	val etf = encode_type encode_type_caller
  in
	case_list tau
		[
		("num",			fn () => ET (``nat:num -> sexp``,``sexp_to_nat``,SEXP_TO_NAT_OF_NAT,NAT_OF_SEXP_TO_NAT,NATP_NAT)),
		("int",			fn () => ET (``int:int -> sexp``,``sexp_to_int``,SEXP_TO_INT_OF_INT,INT_OF_SEXP_TO_INT,INTEGERP_INT)),
		("rat",			fn () => ET (``rat:rat -> sexp``,``sexp_to_rat``,SEXP_TO_RAT_OF_RAT,RAT_OF_SEXP_TO_RAT,RATIONALP_RAT)),
		("complex_rational",	fn () => ET (``num:complex_rational -> sexp``,``sexp_to_com``,SEXP_TO_COM_OF_COM,NUM_OF_SEXP_TO_COM,ACL2_NUMBERP_NUM)),
		("bool",		fn () => ET (``bool:bool -> sexp``,``sexp_to_bool``,SEXP_TO_BOOL_OF_BOOL,BOOL_OF_SEXP_TO_BOOL,BOOLEANP_BOOL)),
		("prod",		fn () =>
			case (map (DT o etf) comps)
			of [(ea,da,eda,dea,taupa),(eb,db,edb,deb,taupb)] =>
			(let 	val subs = map (fn x => x |-> variant (free_vars ea @ free_vars da) x) (free_vars eb @ free_vars db)
			in
			ET (	mk_comb(mk_comb(inst_list ``pair:('a -> sexp) -> ('b -> sexp) -> 'a # 'b -> sexp`` comps,ea),subst subs eb),
				mk_comb(mk_comb(inst_list ``sexp_to_pair:(sexp -> 'a) -> (sexp -> 'b) -> sexp -> 'a # 'b`` comps,da),subst subs db),
				MATCH_MP SEXP_TO_PAIR_OF_PAIR (CONJ eda (INST subs edb)),
				GEN_ALL (DISCH_AND_CONJ (UNDISCH (REWRITE_RULE [UNDISCH (SPEC ``car a`` dea),UNDISCH (SPEC ``cdr a`` deb),UNDISCH pair_thm1]
					(INST_TY_TERM (	[	mk_var("f",hd comps --> ``:sexp``) |-> ea,mk_var("f'",``:sexp`` --> hd comps) |-> da,
								mk_var("g",hd (tl comps) --> ``:sexp``) |-> eb,mk_var("g'",``:sexp`` --> hd (tl comps)) |-> db],
							[``:'a`` |-> hd comps,``:'b`` |-> hd (tl comps)]) PAIR_OF_SEXP_TO_PAIR)))),
				CONV_RULE (DEPTH_CONV BETA_CONV) (MATCH_MP pair_thm2 (CONJ (BETA_TYPE taupa) (BETA_TYPE taupb))))
			end)
			| _ => raise_error encode_type_caller "encode_type" "Incorrectly split product type!!"),
		("list",		fn () =>
			let	val (enc,dec,enc_dec,dec_enc,taup) = DT (etf (hd comps))
			in
			ET (	mk_comb(inst_list ``list:('a -> sexp) -> 'a list -> sexp`` comps,enc),
				mk_comb(inst_list ``sexp_to_list:(sexp -> 'a) -> sexp -> 'a list`` comps,dec),
				MATCH_MP SEXP_TO_LIST_OF_LIST enc_dec,
				GEN_ALL (REWRITE_RULE [dec_enc] (HO_PART_MATCH (snd o dest_conj o fst o dest_imp) LIST_OF_SEXP_TO_LIST (concl dec_enc))),
				GEN_ALL (MATCH_MP LISTP_LIST (BETA_TYPE taup)))
			end)]
	(fn () => raise_error encode_type_caller "encode_type" ("Type " ^ tau ^ " not supported"))
end handle e => (if is_vartype ttype then raise_error encode_type_caller "encode_type" "Type variables not supported" else raise e)
end;



(* Create a variable of the same name, but with type sexp *)
fun sexp_var var = mk_var (fst (dest_var var),``:sexp``);

(* Final functions *)
fun encode_decode_function thm = 
	INST (map (fn v => v |-> mk_comb ((#decoder o encode_type 3 o type_of) v,sexp_var v)) (snd (argument_list_single thm))) 
		(AP_TERM ((#encoder o encode_type 3) ((type_of o lhs o concl) thm)) thm);

(*****************************************************************************)
(* Stage 4: Create a possible rewrite and prove it can be used as such       *)
(*                                                                           *)
(* acl2_exp a b = acl2_if P (nat (sexp_to_nat a ** sexp_to_nat b)) (nat 0),  *)
(*	          P |- (nat (sexp_to_nat a ** sexp_to_nat b) = acl2_exp a b) *)
(*                                                                           *)
(*****************************************************************************)

(* Create and destruct acl2_cond *)
val acl2_if_tm = ``acl2_if``;

fun mk_acl2_cond (p,a,b) = 
	if not (type_of a = ``:sexp`` andalso type_of b = ``:sexp`` andalso type_of p = ``:sexp``) then raise_error 0 "mk_acl2_cond" "Arguments not of type :sexp"
	else mk_comb(mk_comb(mk_comb(acl2_if_tm,p),a),b);

fun dest_acl2_cond term = 
    case strip_comb term
     of (acl2_if,[p,a,b]) =>
         if same_const acl2_if acl2_if_tm
         then (p,a,b)
         else raise_error 0 "dest_acl2_cond" "not an application of \"acl2_if\""
      | _ => raise_error 0 "dest_acl2_cond" "not an application of \"acl2_if\""

fun is_acl2_cond term = 
     case strip_comb term
     of (acl2_if,[p,a,b]) => same_const acl2_if acl2_if_tm | _ => false;


(* Create and destruct acl2_cons *)
val acl2_cons_tm = ``cons``;

fun mk_acl2_cons (a,b) = 
	if not (type_of a = ``:sexp`` andalso type_of b = ``:sexp``) then raise_error 0 "mk_acl2_cons" "Arguments not of type :sexp"
	else mk_comb(mk_comb(acl2_cons_tm,a),b);

fun dest_acl2_cons term = 
    case strip_comb term
     of (acl2_cons,[a,b]) => if same_const acl2_cons acl2_cons_tm then (a,b) else raise_error 0 "dest_acl2_cons" "not an application of \"cons\""
     | _                  => raise_error 0  "dest_acl2_cons" "not an application of \"cons\"";

	

(* Takes an encoder function and creates a default value, eg: ``nat`` -> ``nat 0``, ``bool`` -> ``nil`` *)
local
fun default ttype =
let 	val (tau,comps) = dest_type ttype
in
	case_list tau 
		[("num" , fn () =>  ``0n``),("int" , fn () =>  ``0i``),("rat" , fn () =>  ``0:rat``),("complex_rational", fn () =>  ``num (com rat_0 rat_0)``),
		 ("bool" , fn () =>  ``F``),("prod" , fn () =>  list_mk_pair (map default comps)),("list" , fn () =>  mk_nil(hd comps))]
	(fn () => raise_error 7 "add_default_value" ("Type " ^ tau ^ " not supported"))
end handle e => (if is_vartype ttype then raise_error 4 "add_default_type" "Type variables not supported" else raise e)
in
fun add_default_value_hol term = mk_comb(term,(default o fst o dom_rng o type_of) term)
fun add_default_value term = (fn term => REWRITE_CONV [pair_def,list_def,bool_def] term handle _ => REFL term) (add_default_value_hol term)
end;


(* Define the function, then prove the rewrite *)
fun acl2_define_function name stage3 = 
let	val mp_thm = prove(``(X = acl2_if (bool P) a b) ==> (P ==> (a = X))``,Cases_on `P` THEN RW_TAC std_ss [cond_def,nil_def,t_def,bool_def])
	val function_clause = (lhs o concl) stage3;
	val args = (map (repeat rand) o snd o strip_comb o rand) function_clause
	val body = 
		mk_acl2_cond(
			mk_comb(``bool:bool -> sexp``,foldl (fn (a,b) => mk_comb (b,a)) (mk_var("P",foldl op--> ``:bool`` (map type_of args))) args),
			function_clause,
			(rhs o concl) (add_default_value(rator function_clause)))
in
	(UNDISCH o MATCH_MP mp_thm o SPEC_ALL o ASSUME)
		(foldl mk_forall (mk_eq(foldl (fn (a,b) => mk_comb (b,a)) (mk_var(name,foldl op--> ``:sexp`` (map type_of args))) args,body)) args)
end;


(* Is the term I'm looking at a P term? - term has a result type of bool (may just be a bool) and is a variable *)
(* Note: this can never occur anywhere else - if its a function then we can't have HO functions, if its a variable, we don't have any arguments, hence no other variables *)
fun is_P_term term =
	(fn (a,b) => is_var a andalso repeat (snd o dom_rng) (type_of a) = ``:bool``) (strip_comb term);

(* Is the term I'm looking at the definition? - All quantified variables occur as arguments to the lhs *)
fun is_definition term = 
	(uncurry set_eq) ((I ## snd o strip_comb o lhs) (strip_forall term)) handle _ => false;

(* Helper function to locate the P term in the hypothesis *)
fun findP thm = first is_P_term (hyp thm);
	


(*****************************************************************************)
(* Stage 5: Push the encodings in (ACL2_DEPTH_CONV)                          *)
(*                                                                           *)
(* |- nat (a + b) = add (nat a) (nat b) etc...                               *)
(*                                                                           *)
(*****************************************************************************)

(* Maps a conversion over the hypothesis of a theorem *)
fun CONV_HYP c thm =
let 	fun UNDISCHi thm = CONV_RULE (REWR_CONV (CONJUNCT1 (SPEC_ALL IMP_CLAUSES))) thm handle _ => UNDISCH thm
	fun conv (thm,[]) = thm
      	  | conv (thm,h::hs) = conv (UNDISCHi (CONV_RULE (LAND_CONV c) (DISCH h thm)),hs)
in
     conv (thm, hyp thm)
end;

(* LIST_DISCH : Discharges a term over the conclusion, and a list of hypothesis *)
local
	val imp_distrib = PROVE [] ``(A ==> B ==> C) = (A ==> B) ==> (A ==> C)``;
	fun IMP_DISTRIB_CONV term = (TRY_CONV ((PART_MATCH lhs imp_distrib) THENC (RAND_CONV IMP_DISTRIB_CONV))) term;
in
	fun LIST_DISCH term list thm = (DISCH term o UNDISCH_ALL o (CONV_RULE IMP_DISTRIB_CONV) o DISCH term) (foldl (uncurry DISCH) thm list)
end;

(* FULL_DISCH : Same as LIST_DISCH but does so for all the hypothesis *)
fun FULL_DISCH term thm = LIST_DISCH term (hyp thm) thm;


(* ACL2_IF_CONV:                                                             *) 
(*      encodes an if statement, prefixing any generated hypothesis with P   *)
(* [.] |- encode (if P then a else b) = acl2_if P' a' b' .. where            *)
(*       |- bool P = P', |- P ==> (encode a = a'), |- ~P ==> (encode b = b') *)

local
	val acl2_if_thm = prove(``(bool p = P) /\ (p ==> (f (a:'a) = A)) /\ (~p ==> (f b = B)) ==> (f (if p then a else b) = acl2_if P A B)``,
		RW_TAC std_ss [bool_def,cond_def,nil_def,t_def])
	fun DISCH_BUT term thm hs = LIST_DISCH term (set_diff (hyp thm) hs) thm
in
fun ACL2_IF_CONV conv rewrite term = 
let 	val (encode,(p,a,b)) = (I ## dest_cond) (dest_comb term) handle e => raise_error 5 "ACL2_IF_CONV" "Not of the form ``encode (if P then a else b)``"
	fun conv' term = UNDISCH (DISCH_BUT (findP rewrite) (conv term) (filter is_forall (hyp rewrite)))
	val P = conv' (mk_comb(``bool:bool -> sexp``,p))
	val A = DISCH_BUT p (conv' (mk_comb(encode,a))) (filter is_forall (hyp rewrite))
	val B = DISCH_BUT (mk_neg p) (conv' (mk_comb(encode,b))) (filter is_forall (hyp rewrite))
in	
	MATCH_MP acl2_if_thm (LIST_CONJ [P,A,B])
end
end;

(* ACL2_EQUAL_CONV: bool (a = b) = equal (encode a) (encode b) *)
local
	val proof = prove(``ONE_ONE f ==> (bool (a = b) = equal (f a) (f b))``,
		Cases_on `a = b` THEN RW_TAC std_ss [ONE_ONE_THM,equal_def,bool_def,nil_def,t_def] THEN METIS_TAC []);
in
fun ACL2_EQUAL_CONV term = 
let 	val thm = (PART_MATCH (lhs o snd o strip_imp) proof term)
		val t = (type_of o rand o fst o dest_imp o concl) thm
		val thm' = INST [mk_var("f",t) |-> (#encoder o encode_type 5 o fst o dom_rng) t] thm
in
	MATCH_MP thm' (prove((fst o dest_imp o concl) thm',REPEAT (
		(MAP_FIRST ACCEPT_TAC (filter (not o is_imp o concl) (CONJUNCTS ENCODE_ONE_ONE))) ORELSE 
		(MAP_FIRST MATCH_MP_TAC (filter (is_imp o concl) (CONJUNCTS ENCODE_ONE_ONE))) THEN TRY CONJ_TAC)))
end
end;


(* Rewrites the current term with the rewrite defined in stage4 *)

(* Function to detect whether we have the right term *)
fun can_recurse_conv thm term =
let	val (enc1,(function1,args1)) = (I ## strip_comb) ((dest_comb o lhs o concl) thm)
	val (enc2,(function2,args2)) = (I ## strip_comb) (dest_comb term)
in
	(enc1 = enc2) andalso (can (match_term function1) function2) andalso (map type_of args1 = map type_of args2)
end;

(* Terms will be of the form: encode (f (g (decode a)) (h (decode b)) ...)               *)
(* and will be encoded to be: acl2_f (encode (g (decode a))) (encode (h (decode b))) ... *)
(* the arguments will then be encoded                                                    *)
fun RECURSE_CONV conv rewrite term =
let	val args = (snd o strip_comb o rand) term
	val encodes = map (encode_type 5 o type_of) args
	val wrapped = map2 (fn x => (fn y => (RIGHT_CONV_RULE (RAND_CONV conv) o GSYM o SPEC x o #enc_dec_thm) y)) args encodes
in
	RIGHT_CONV_RULE (fn term => UNDISCH_ALL (PART_MATCH (lhs o snd o strip_imp) (DISCH_ALL rewrite) term)) (ONCE_REWRITE_CONV wrapped term)
end;

(* Returns true if term is of the form: ``nat X`` *)
fun is_encoded_term term = not (hd (map #residue (snd (match_term ``(encode:'a -> sexp) a`` term))) = ``:sexp``) handle _ => false

(* acl2_constant, returns true when the term is a constant of ACL2 *)
fun acl2_constant constants term = 
let 	fun is_number term = exists (fn x => is_numeral (#residue (first (fn x => #redex x = ``n:num``) (fst (match_term x term)))) handle _ => false)
		[``nat n``,``rat (& n):sexp``,``int (& n)``,``num (com (rat (& a) (& b)) (rat (& c) (& d)))``]
in
	is_encoded_term term andalso (is_number term orelse (is_var o rand) term) orelse mem term constants
end;

(* SUB_CONST_CONV - ignore top level acl2 constants and recurse on encoded sub-expressions *)
(*		  - terms should always be of the form: f (encode a) (encode b) ... or (encode a) *)
fun SUB_CONST_CONV constants conv term = 
	if acl2_constant constants term then REFL term else
	if is_encoded_term term then conv term else
	if is_comb term then COMB_CONV (SUB_CONST_CONV constants conv) term else
	if is_var term andalso type_of term = ``:sexp`` then REFL term
	else raise UNCHANGED;

(* THENCU - a version of THENC which passes through UNCHANGED, and allows instantiation of free variables in the left hand theorem *)
infix THENCU

fun (conv1 THENCU conv2) t =
let 	val th1 = conv1 t
	val th2 = conv2 ((rhs o concl) th1)
in
	TRANS (PART_MATCH rhs th1 ((lhs o concl) th2)) th2
end;

(* In the case of a list predicate: (sexp_EVERY P l /\ !a. P a ==> (encode (decode a) = a)), we should instantiate P *)
fun instantiate_list_predicates thm = 
let	val (proofs,hyps) = unzip (mapfilter (fn x => ((#dec_enc_thm o encode_type 5 o type_of o rand o lhs o snd o strip_imp o snd o strip_forall o #residue) 
				(first (fn y => #redex y = ``Q:bool``) 
				(fst (match_term ``sexp_EVERY P a /\ Q`` x))),x)) (hyp thm))
	val converted = CONV_HYP (DEPTH_CONV BETA_CONV) (foldl (uncurry INST_TY_TERM) thm 
		((map2 (fn x => fn y => ho_match_term [] empty_varset (snd (dest_conj x)) (concl y)) hyps proofs)))
in
	foldl (fn (a,t) => UNDISCH (tryfind (fn x => MATCH_MP (DECIDE ``B /\ (A /\ B ==> C) ==> (A ==> C)``) (CONJ x (DISCH a t))) proofs)) converted 
		(filter (can (match_term ``sexp_EVERY P a /\ Q``)) (hyp converted))
end;


(* ACL2_DEPTH_CONV *)
local
	fun print_if s f r = (let val result = f r in (print_trace 4 s ; print "\n" ; result) end)
	fun ACL2_DEPTH_CONVp n thms recurse_rewrite constants term =
	(print_trace 4 ("ACL2_DEPTH_CONV: " ^ implode (funpow n (curry op:: #" ") []) ^ (term_to_string term) ^ " ---> ") ; 
	let 	val RECURSE = ACL2_DEPTH_CONVp (n + 1) thms recurse_rewrite constants
	in
		if can_recurse_conv recurse_rewrite term then
			(print_trace 4 "RECURSE_CONV\n" ; RECURSE_CONV RECURSE recurse_rewrite term)
		else if is_comb term andalso (is_cond o rand) term then 
			(print_trace 4 "ACL2_IF_CONV\n" ; ACL2_IF_CONV RECURSE recurse_rewrite term)
		else if is_comb term andalso (is_eq o rand) term then
			(print_trace 4 "ACL2_EQUAL_CONV\n" ; (ACL2_EQUAL_CONV THENCU SUB_CONST_CONV constants RECURSE) term)
		else
			((fn term => (tryfind (fn thm => print_if (thm_to_string thm) 
					(instantiate_list_predicates o UNDISCH_ALL o PART_MATCH (lhs o snd o strip_imp) thm) term) thms)
				handle _ => raise UNCHANGED) THENCU
			(SUB_CONST_CONV constants RECURSE)) term
		handle UNCHANGED => 
			if acl2_constant constants term then 
				(print_trace 4 "constant\n" ; REFL term) else 
				(print_trace 4 "\n" ; raise_error 5 "ACL2_DEPTH_CONV" ("Unencodable term: " ^ term_to_string term))
	end)
in
	fun ACL2_DEPTH_CONV thms terminate constants term = ACL2_DEPTH_CONVp 0 thms terminate constants term
end;


(* Final function *)
fun convert_acl2 stage3 stage4 thms constants = 
	(fn thm => if can (first is_forall) (hyp thm) then thm else 
		UNDISCH_ALL (DISCH (first is_definition (hyp stage4)) (foldl (uncurry FULL_DISCH) thm (filter is_P_term (hyp stage4)))))
	(RIGHT_CONV_RULE (ACL2_DEPTH_CONV thms stage4 constants) stage3);


(*****************************************************************************)
(* Stage 6: Clean the set of hypotheses then make them into a conjunction    *)
(*                                                                           *)
(*	1) Move all type judgements to top level (move_top)                  *)
(*	2) Remove all terms which have Q ==> P m n ... as (P m n) must be    *)
(*	   in the hypothesis set (remove_all_antecedent ``P m n``)           *)
(*	3) Create a possible P based on top level typing judgements          *)
(*	   (create_possible_P hypothesis_set)                                *)
(*	4) Clean up based on this (remove_all_simple)                        *)
(*	       P ==> Q --> P \ (P inter Q) ==> Q \ (P inter Q)               *)
(*	5) Reduce any judgements created by recursive calls, eg:             *)
(*            |- (natp n = t) /\ (natp m = t) ==> (natp (add m n) = t)       *)
(*         (reduce_judgements_full)                                          *)
(*	6) Calculate a full version of P, initialise it, and clean up (as 4) *)
(*	7) Rewrite the hypothesis to use sexpressions (rewrite_P)            *)
(*                                                                           *)
(*****************************************************************************)

(* Is the hypothesis I'm looking at a typing judgement? *)
fun is_type_judgement term = 
	exists (fn x => can (match_term x) term) 
		[	``sexp_EVERY P l``,``natp a = t``,``integerp a = t``,``rationalp a = t``,``booleanp a = t``,``acl2_numberp a = t``,
			``characterp a = t``,``stringp a = t``];

(* Replacement dest_imp/strip_imp that doesn't treat ~X as X ==> F *)
fun dest_impA term = 
    case strip_comb term
        of (imp,[l,r]) => if same_const implication imp then (l,r) else raise_error 0 "dest_impA" "not an implication"
        | _ => raise_error 0 "dest_impA" "not an implication";

local
fun strip_impA1 term = (op:: o (I ## strip_impA1)) (dest_impA term) handle _ => [term]
in
fun strip_impA term = let val x = strip_impA1 term in (butlast x,last x) end
end;


(* Convert hypothesis: A ==> B ==> C --> A /\ B ==> C ... *)
local 
fun ch term =
	prove(mk_eq(term,mk_imp ((list_mk_conj o mk_set ## I) (strip_impA term))),EQ_TAC THEN REPEAT STRIP_TAC THEN RES_TAC) handle _ => REFL term
in
val conjunct_hypothesis = CONV_HYP ch
end;

(* Partition a list on equality of terms *)
local
fun op_partition' opr [] A = A
  | op_partition' opr (x::L) A = 
let	val (inx,outx) = partition (curry op= (opr x) o opr) L
in
	op_partition' opr (outx) ((x::inx)::A)
end
in
fun op_partition opr L = op_partition' opr L []
end;
	
(* Takes a set of hypothesis [A /\ B /\ P ==> C, ...] and replaces them with one P ==> C *)
local
val match_thm = DECIDE ``(A ==> B ==> C) /\ (B ==> A) ==> (B ==> C)``
in
fun move_top hyps thm = 
let	val new_hyp = mk_imp (((first is_P_term o strip_conj ## I) o dest_imp o hd) hyps)
	fun try_decide term = DECIDE term handle _ => raise_error 6 "move_top" ("Couldn't decide implication: " ^ (term_to_string term))
in
	UNDISCH (foldl (fn (h,t) => MATCH_MP match_thm (CONJ (DISCH h t) (try_decide (mk_imp(new_hyp,h)))))
		(DISCH new_hyp thm) hyps)
end
end;

(* If h1 is the conclusion of h2 remove h2 from the hypothesis set *)
fun remove_antecedant thm h1 h2 = 
	UNDISCH (MATCH_MP (DECIDE ``A /\ ((B ==> A) ==> C) ==> (A ==> C)``) (CONJ (ASSUME h1) (DISCH h2 thm)));

(* Remove all hypothesis that have h as conclusion *)
fun remove_all_antecedant h thm = foldl (fn (x,t) => remove_antecedant t h x handle _ => t) thm (hyp thm);

(* Create a P term out of the type judgements we have so far *)
fun create_possible_P hyp_set thm =
let 	val type_judgements = map (snd o dest_imp o hd) hyp_set
	val Pterm = findP thm
	fun CONV_HYP' conv thm = UNDISCH (CONV_HYP conv (
		((CONV_RULE o LAND_CONV o STRIP_QUANT_CONV o RAND_CONV o RATOR_CONV o RATOR_CONV) (DEPTH_CONV BETA_CONV)) (DISCH (first is_definition (hyp thm)) thm)))
in
	CONV_HYP' (DEPTH_CONV BETA_CONV) (
		INST [repeat rator Pterm |-> foldl mk_abs (list_mk_conj (Pterm :: type_judgements)) (rev (snd (strip_comb Pterm)))] thm)
end;

(* Remove anything unnecessary in the hypothesis set, generated from this new P, using: (A ==> B) ==> (C /\ A ==> C /\ B) *)
fun remove_extraneous thm h =
let	val removes = (uncurry intersect) ((strip_conj ## strip_conj) (dest_imp h))
	val l = set_diff (strip_conj (fst (dest_imp h))) removes
	val r = set_diff (strip_conj (snd (dest_imp h))) removes
in
	if l = [] then (* A ==> A /\ B ---> A ==> B *)
		PROVE_HYP (UNDISCH (DECIDE (mk_imp(mk_imp (list_mk_conj removes,list_mk_conj r),h)))) thm
	else if r = [] then (* A /\ B ==> A ---> T *)
		PROVE_HYP (DECIDE h) thm
	else (* A /\ B ==> A /\ C ---> B ==> C *)
		PROVE_HYP (UNDISCH (DECIDE (mk_imp(mk_imp (list_mk_conj l,list_mk_conj r),h)))) thm
end;

(* Try remove_simple for all hypothesis *)
local
fun rs thm [] = thm
  | rs thm (h::hs) = rs (remove_extraneous thm h) hs handle _ => rs thm hs
in
fun remove_all_simple thm = rs thm (hyp thm)
end;

fun is_decoder term = 
let 	val (arg,res) = (dom_rng o type_of o rator) term 
in 	arg = ``:sexp`` andalso not (res = ``:sexp``)  end handle _ => false;

(* Return all decoded sexpressions in a term *)
fun decoders A term = 
	if is_decoder term then term::A
	else if is_comb term then decoders (decoders A (rand term)) (rator term)
	else if is_abs term then decoders A (body term) else A;

    

(* Old version - pre 22/05 *)
(* If h has any type judgements in it, attempt to reduce them *)
fun reduce_judgement_old thm thms h =
let	val (left,right) = (I ## strip_conj) (dest_imp h)
 	val thm_list = mapfilter (fn h => BETA_RULE (tryfind (fn jt => HO_PART_MATCH (snd o strip_imp) jt h) thms)) (filter (not o is_P_term) right)
	fun add_in t1 t2 t = PROVE_HYP (UNDISCH (MATCH_MP (DECIDE (list_mk_imp ([concl t1,t2],h))) t1)) t
	fun remove_truth truth t = 
		let val right' = filter (not o curry op= (concl truth)) right in
			if right' = [] then PROVE_HYP truth t else add_in truth (mk_imp(left,list_mk_conj right')) t end
	(* If the theorem adds any free variables, then find the terms they occur in (_must_ contain decoder functions) *)
	(* and try to match these terms with terms in left, then instantiate the variables accordingly                  *)
	fun remove_mp mp t = 
	let	val right' = filter (not o curry op= ((snd o dest_imp o concl) mp)) right
		val new_vars = (fn x => set_diff (free_vars (fst x)) (free_vars (snd x))) ((dest_imp o concl) mp)
		val new_var_terms = map (fn var => first (free_in var) ((strip_conj o fst o dest_imp o concl) mp)) new_vars;
		val subs = (flatten ## flatten) (unzip (foldl (fn (x,L) => tryfind (match_term x) (decoders [] left) :: L) [] (flatten (map (decoders []) new_var_terms))));
		val implication = subst (fst subs) (inst (snd subs) (mk_imp(left,list_mk_conj ((fst o dest_imp o concl) mp :: right'))))
	in		
		add_in (INST_TY_TERM subs mp) implication t
	end handle _ => t
in
	(print_term h ; print "\n" ; foldl (fn (x,t) => if is_imp (concl x) then remove_mp x t else remove_truth x t) thm thm_list)
end;

(* Repeatedly reduce judgements until we have none left *)
fun reduce_judgements_full_old thms thm =
let 	val old_h = hyp thm
	val new_t = remove_all_simple (foldl (fn (h,t) => if is_imp h then reduce_judgement_old t thms h else t) thm (hyp thm))
in	
	if set_eq old_h (hyp new_t) then new_t else reduce_judgements_full_old thms new_t
end;


(* If h has any type judgements in it, attempt to reduce them *)
fun reduce_judgement (left,right,h,thm) thms =
let	val thm_list = mapfilter (fn h => BETA_RULE (tryfind (fn jt => HO_PART_MATCH (snd o strip_imp) jt h) thms)) (filter (not o is_P_term) right)
	fun add_in t1 t2 h t = PROVE_HYP (UNDISCH (MATCH_MP (DECIDE (list_mk_imp ([concl t1,t2],h))) t1)) t

	fun remove_truth truth (l,r,h,t) = 
		let val right' = filter (not o curry op= (concl truth)) r in
			if right' = [] then (l,[],h,PROVE_HYP truth t) else 
				let val new_h = mk_imp(l,list_mk_conj right') in
					(l,right',new_h,add_in truth new_h h t)
				end end

	(* If the theorem adds any free variables, then find the terms they occur in (_must_ contain decoder functions) *)
	(* and try to match these terms with terms in left, then instantiate the variables accordingly                  *)
	fun remove_mp mp (l,r,h,t) = 
	let	val right' = filter (not o curry op= ((snd o dest_imp o concl) mp)) r
		val new_vars = (fn x => set_diff (free_vars (fst x)) (free_vars (snd x))) ((dest_imp o concl) mp)
		val new_var_terms = map (fn var => first (free_in var) ((strip_conj o fst o dest_imp o concl) mp)) new_vars;
		val subs = (flatten ## flatten) (unzip (foldl (fn (x,L) => tryfind (match_term x) (decoders [] l) :: L) [] (flatten (map (decoders []) new_var_terms))));
		val left'' = subst (fst subs) (inst (snd subs) l)
		val right'' = map (subst (fst subs) o inst (snd subs)) (((fst o dest_imp o concl) mp):: right')
	in		
		(left'',right'',(mk_imp (left'',list_mk_conj right'')),add_in (INST_TY_TERM subs mp) (mk_imp (left'',list_mk_conj right'')) h t)
	end handle _ => (l,r,h,t)
in
	(foldl (fn (x,t) => if is_imp (concl x) then remove_mp x t else remove_truth x t) (left,right,h,thm) thm_list)
end;

(* Repeatedly reduce a single judgement until it doesn't change *)
fun reduce_judgement_full thms thm h =
let	val (left,right) = (I ## strip_conj) (dest_imp h)
	fun repeat (l,r,h,t) = 
		let val (l',r',h',t') = reduce_judgement (l,r,h,t) thms
		in
			(if not (r' = []) andalso (not (l = l') orelse (not (set_eq r r'))) then repeat (l',r',h',t') else t')
		end
in
	repeat (left,right,h,thm)
end;

(* Repeatedly reduce judgements until we have none left *)
fun reduce_judgements_full thms thm =
let 	val old_h = hyp thm
	val new_t = remove_all_simple (foldl (fn (h,t) => if is_imp h then reduce_judgement_full thms t h else t) thm (hyp thm))
in	
	if set_eq old_h (hyp new_t) then new_t else reduce_judgements_full thms new_t
end;





(* Get all the implications together: Conjunctions go straight in, implications are checked against these and P terms discarded *)
fun collect_hypothesis_set thm = 
let 	val ((Ls,Rs),Ps) = ((map strip_conj ## map strip_conj) o unzip o map dest_imp ## flatten o map strip_conj) 
				(partition is_imp (filter (not o is_definition) (hyp thm)))
	val dropP = filter (fn x => not (fst (dest_var (repeat rator x)) = "P") handle _ => true)
in
	(dropP Ps) @ (foldl (fn ((a,b),l) => if b = [] then l else (if a = [] then list_mk_conj b :: l else mk_imp(list_mk_conj a,list_mk_conj b) :: l)) []
		(zip (map (fn x => set_diff x Ps) Ls) (map dropP (map (fn x => set_diff x Ps) Rs))))
end;

(* Get the current hypothesis set *)
fun current_hypothesis_set thm = 
	filter (not o is_P_term)
		((strip_conj o rand o (fn (a,b,c) => a) o dest_acl2_cond o rhs o snd o strip_forall) (first is_definition (hyp thm)));

(* Initialise the new P *)
fun initialise_P thm = 
let	val new_set = set_diff (collect_hypothesis_set thm) (current_hypothesis_set thm)
	val Pterm = first is_P_term (flatten (map strip_conj (hyp thm)))
in
	CONV_HYP (REWRITE_CONV []) (INST [repeat rator Pterm |-> (fn term => foldl mk_abs term (rev (snd (strip_comb Pterm)))) 
		(if (new_set = []) then T else list_mk_conj new_set)] thm)
end;

(* Rewrite the P term *)
local 
val bool_nil_thm = prove(``!X. X = ~(bool X = nil)``,Cases THEN RW_TAC std_ss [bool_def,nil_def,t_def])
in
fun rewrite_P_hyp thm = 
let	val (definition,P_term) = (hd ## (fn [] => ``T`` | x::xs => x)) (partition is_definition (hyp thm))
	val P_term' = ((fn (a,b,c) => a) o dest_acl2_cond o rhs o snd o strip_forall) definition
	val P_term'' = mk_comb(``bool:bool -> sexp``,P_term)
in
	if not (P_term' = P_term'') then 
		raise_error 6 "rewrite_P_hyp" 
			("Predicate in definition does not match predicate in hypothesis: " ^ (term_to_string P_term'') ^ " != " ^ (term_to_string P_term') ^ "\n")
	else
		let 	val r1 = REDEPTH_CONV (FIRST_CONV (map REWR_CONV (filter (is_eq o snd o strip_forall o concl) (CONJUNCTS BOOL_THMS @ CONJUNCTS BOOLP_THMS)))) P_term'
					handle UNCHANGED => REFL P_term'
			val r2 = SPEC P_term bool_nil_thm
		in
			CONV_HYP (TRY_CONV (REWR_CONV r2) THENC PURE_ONCE_REWRITE_CONV [r1] THENC PURE_REWRITE_CONV [IF_THMS]) thm
		end
end
end;


(* Final function *)
fun resolve_hypothesis stage5 jthms = 
let	val concise_thm = (remove_all_simple o conjunct_hypothesis) stage5
	val hyp_set = op_partition rand (filter (is_type_judgement o snd o strip_imp) (hyp concise_thm))
	fun print_do s f thm = (print_trace 6 (s ^ "\n") ; f thm)
in
	(	print_do "7: Rewriting the predicate to an s-expression ..." 		rewrite_P_hyp o
		print_do "6: Initialising the predicate ..." 				initialise_P o 
		print_do "5: Reducing typing judgements ..." 				(reduce_judgements_full jthms) o 
		print_do "4: Cleaning the hypothesis set ..." 				remove_all_simple o 
		print_do "3: Creating a possible predicate based on argument types ..." (create_possible_P hyp_set) o
		print_do "2: Removing terms with predicate as conclusion ..." 		(remove_all_antecedant (first is_P_term (hyp concise_thm))) o
		print_do "1: Moving type judgements to top level ..." 			(fn thm => foldl (uncurry move_top) thm hyp_set)) concise_thm
end;


(*****************************************************************************)
(* Stage 7: Define a function based on the rewrite in stage4 and remove      *)
(*          the corresponding hypothesis                                     *)
(*                                                                           *)
(*          acl2_exp m n = nat (...) |- acl2_exp m n = acl2_if ...           *)
(*      --> |- acl2_exp m n = nat (...) , |- acl2_exp m n = acl2_if ...      *)
(*                                                                           *)
(*****************************************************************************)

(* Like MATCH_MP, but if the two terms are quantified, it attempts to make that quantification *)
fun FMATCH_MP thm1 thm2 =
	MATCH_MP thm1 (foldl (uncurry GEN) (SPEC_ALL thm2) ((rev o fst o strip_forall o fst o dest_imp o concl) thm1));

(* Final function *)
fun define_and_resolve stage6 =
let 	val defn = first is_definition (hyp stage6)
	val defn_stripped = (snd o strip_forall) defn
	val func = (repeat rator o lhs) defn_stripped
	val definition = (print_trace 7 "Creating definition... \n" ; new_definition((fst o dest_var) func,defn_stripped))
	val undisch = DISCH defn (DISCH (first (not o is_definition) (hyp stage6)) stage6 handle _ => stage6)
in
	(print_trace 7 "Resolving ... \n" ; 
	(definition, FMATCH_MP (INST [func |-> (repeat rator o lhs o snd o strip_forall o concl) definition] undisch) definition))
end;




(*****************************************************************************)
(* Stage 8: Prove the correctness theorem and the type theorem               *)
(*                                                                           *)
(* (i)  |- exp a b = sexp_to_nat (acl2_exp (nat a) (nat b))                  *)
(* (ii) |- natp (acl2_exp a b) = t                                           *)
(*                                                                           *)
(*****************************************************************************)

(* Get the encodings of all the arguments *)
fun arg_encodings stage4 = 
let 	val x = (snd o strip_comb o rand o lhs o concl) stage4 handle _ => 
		raise_error 8 "arg_encodings" "Output of Stage 4 is not of form \"|- enc (f (dec a) (dec b) ...) = A\"\n"
in
	map (fn x => ((fst o dest_var o rand) x,(encode_type 8 o type_of) x)) x
end;

(* Substitute encoded types into the definition: |- acl2_exp a b = A --> |- acl2_exp (nat a) (nat b) = A *)
fun subst_args (encodings:(string * encoded_type) list) stage7d =
	(GEN_ALL o INST	(map (fn (x,y) => mk_var(x,``:sexp``) |-> mk_comb(#encoder y,mk_var(x,(fst o dom_rng o type_of o #encoder) y))) encodings) o SPEC_ALL) stage7d;



(* Finish off, reduce the hypothesis, wrap in the function encoder and simplify *)
local
	fun rewrite_to_bool thms term = 
		if term = ``nil`` orelse term = ``t`` then REFL term
		else if is_acl2_cond term then 
			let 	val (p,a,b) = dest_acl2_cond term
			in 
				RIGHT_CONV_RULE (REWRITE_CONV [IF_THMS]) 
					(MK_COMB (MK_COMB (AP_TERM acl2_if_tm (rewrite_to_bool thms p),rewrite_to_bool thms a),rewrite_to_bool thms b))
			end
		else if can (match_term ``bool a``) term then (REWRITE_RULE [bool_def] o AP_TERM ``bool``)
			(EQT_INTRO (tryfind (fn thm => CONJ_PART_MATCH I thm (rand term)) thms))
		else tryfind (fn thm => CONJ_PART_MATCH lhs thm term) thms
		handle _ => raise_error 8 "rewrite_to_bool" ("Could not prove predicate on instantiated terms: " ^ (term_to_string term))
in		
fun correct_thm (encodings:(string * encoded_type) list) (func_encode:encoded_type) stage7d =
let 	val stage7d' = subst_args encodings stage7d
	val rewritten = if null encodings then stage7d' else 
		(SPEC_ALL (REWRITE_RULE (map (#enc_dec_thm o snd) encodings) 
			(REWRITE_RULE [IF_THMS] (CONV_RULE ((STRIP_QUANT_CONV o RAND_CONV o RATOR_CONV o RATOR_CONV o RAND_CONV) 
				(rewrite_to_bool (map (#taup_thm o snd) encodings))) stage7d'))))
in
	(GEN_ALL o GSYM o RIGHT_CONV_RULE (REWR_CONV (#enc_dec_thm func_encode)) o AP_TERM (#decoder func_encode)) rewritten
end
end;


	
(* Create the type judgement *)
local
val acl2_if_thm = prove(``(X = acl2_if P (f a) (f b)) /\ (!a. Q (f a)) ==> (!a. Q X)``,RW_TAC std_ss [cond_def,nil_def,t_def])
fun do_judgement (func_encode:encoded_type) stage7d = 
let	val stage7d' = CONV_RULE ((STRIP_QUANT_CONV o RAND_CONV o RAND_CONV) (REWR_CONV (GSYM (add_default_value (#encoder func_encode))))) stage7d
in	
	(SPEC_ALL o CONV_RULE (DEPTH_CONV BETA_CONV) o MATCH_MP acl2_if_thm) (CONJ (SPEC_ALL stage7d') ((BETA_TYPE o #taup_thm) func_encode))
end
in
fun judgement func_encode stage7d = 
let val result = if (is_acl2_cond o rhs o snd o strip_forall o concl) stage7d then do_judgement func_encode stage7d else
		 CONV_RULE (RAND_CONV (REWR_CONV (SYM stage7d)) THENC DEPTH_CONV BETA_CONV)
			(PART_MATCH rand ((BETA_TYPE o #taup_thm) func_encode) ((rhs o concl) stage7d))
in
	(LIST_CONJ (map GEN_ALL (CONJUNCTS result)),CONV_RULE (DEPTH_CONV ETA_CONV) (CONJ_MATCH_MP (#dec_enc_thm func_encode) result))
end;
end;
	

(* Final function *)
fun definition_proofs stage4 stage7d =
let 	val stage7d' = (rhs o concl o SPEC_ALL) stage7d
	val func_encode = (encode_type 8 o type_of o rand) (if is_acl2_cond stage7d' then ((fn (a,b,c) => b) o dest_acl2_cond) stage7d' else stage7d')
	val cthm = (print_trace 8 "Proving correctness theorem ...\n" ; BETA_RULE (correct_thm (arg_encodings stage4) func_encode stage7d))
	val (tjthm,rjthm) = (print_trace 8 "Proving judgement theorems ... \n" ; judgement func_encode stage7d)
	val rthm = (print_trace 8 "Proving rewrite theorem ... \n" ; RIGHT_CONV_RULE (REWR_CONV rjthm) (AP_TERM (#encoder func_encode) (SPEC_ALL cthm)))
in
	(cthm, tjthm, rjthm, rthm)
end;

(*****************************************************************************)
(* Stage 9: Rewrite the definition with the recursive s-expression           *)
(*                                                                           *)
(*        |- acl2_exp a b = acl2_if (...) (nat ((\m n. m ** n) ...)) (nat 0) *)
(*    --> |- acl2_exp a b = acl2_if (...) (acl2_if (equal n (nat 0)....      *) 
(*                                                                           *)
(*****************************************************************************)

local 
val rewr1 = prove(``(A = acl2_if P B C) = ((P = nil) ==> (A = C)) /\ (~(P = nil) ==> (A = B))``,RW_TAC std_ss [cond_def,nil_def,t_def])
fun rewrite_definition_if stage7r stage7d = 
let 	val (L,R) = CONJ_PAIR (CONV_RULE (REWR_CONV rewr1) (SPEC_ALL stage7d))
in
	CONV_RULE (REWR_CONV (GSYM rewr1)) (CONJ L (DISCH_ALL (CONV_RULE (LAND_CONV (REWR_CONV (GSYM (UNDISCH R)))) (UNDISCH stage7r))))
end
in
fun rewrite_definition stage7r stage7d = 
	if (is_acl2_cond o rhs o snd o strip_forall o concl) stage7d then rewrite_definition_if stage7r stage7d else
	TRANS (SPEC_ALL stage7d) stage7r
end;

(*****************************************************************************)
(* Stage 10: Try to find a list predicate, or create one if none exist       *)
(*                                                                           *)
(*****************************************************************************)

val list_predicates = ref ([]:(thm * thm) list);

val every_acl2_thm = prove(``bool (sexp_EVERY P a) = acl2_if (consp a) (acl2_if (bool (P (car a))) (bool (sexp_EVERY P (cdr a))) nil) (equal a nil)``,
	Induct_on `a` THEN 
	RW_TAC std_ss [sexp_EVERY_def,cond_def,equal_def,bool_def,consp_def,car_def,cdr_def,prove(``~(t = nil)``,RW_TAC std_ss [nil_def,t_def])] THEN
	Cases_on `P a` THEN FULL_SIMP_TAC std_ss [bool_def,prove(``~(t = nil)``,RW_TAC std_ss [nil_def,t_def]),equal_def,cond_def]);

(* BOOL_CONV: converts a bool () into an sexpression *)
fun BOOL_CONV term = 
	if not (rator term = ``bool :bool -> sexp``) then NO_CONV term
	else REDEPTH_CONV (FIRST_CONV (map REWR_CONV (filter (is_eq o snd o strip_forall o concl) (CONJUNCTS BOOL_THMS @ CONJUNCTS BOOLP_THMS)))) term;

(* Create a list predicate function from the ``bool (sexpEVERY P v)`` term given *)
fun create_list_predicate term = 
let 	val var = (rand o rand) term
	val name = (fst (dest_var var)) ^ "_listp"
	val definition = new_definition(name,mk_eq(mk_comb(mk_var(name,``:sexp -> sexp``),var),term))
in
	(definition,CONV_RULE (DEPTH_CONV BOOL_CONV) (BETA_RULE (REWRITE_RULE [GSYM definition] (PART_MATCH lhs every_acl2_thm term))))
end;

(* Find out whether there is a term that matches, and return that, or create a new one *)
fun list_predicate predicates term = 
	tryfind (fn x => SPEC_ALL (CONJ_PART_MATCH ((fn (a,b,c) => b) o dest_acl2_cond o (fn (a,b,c) => b) o dest_acl2_cond o rhs) (snd x) term)) (!predicates) handle _ =>
	let val result = create_list_predicate term in (predicates := result :: !predicates ; SPEC_ALL (fst result)) end;

(* Replace all list predicates in a theorem *)
fun replace_list_predicates predicates thm = 
let	fun REPLACE_CONV term = 
		if can (match_term ``bool (sexp_EVERY P a)``) term then
			let val rterm = RAND_CONV (DEPTH_CONV REPLACE_CONV) term handle UNCHANGED => REFL term in 
				TRANS rterm (GSYM (list_predicate predicates ((rhs o concl) rterm))) end
		else	NO_CONV term
in
	(print "Replacing list predicates ... \n" ; RIGHT_CONV_RULE (DEPTH_CONV REPLACE_CONV) thm)
end;

(*****************************************************************************)
(* Pre-processing: Remove let expressions and beta reduce                    *)
(*****************************************************************************)

val PRE_PROCESS = LIST_CONJ o (map (CONV_RULE (STRIP_QUANT_CONV (RAND_CONV (REDEPTH_CONV (BETA_CONV ORELSEC PairedLambda.let_CONV)))))) o CONJUNCTS;

(*****************************************************************************)
(* Finishing up:  add the typing theorems and correctness proofs to the rule *)
(*                set used for encoding                                      *)
(*****************************************************************************)

val rewrite_thms = ref (flatten (map CONJUNCTS [RAT_THMS,BOOL_THMS,NAT_THMS,INT_THMS,COM_THMS,LIST_THMS,PAIR_THMS]));
val acl2_constants = ref [``add``,``bool``,``equal``,``nil``,``t``];
val judgement_thms = ref (CONJUNCTS JUDGEMENT_THMS);

type encoded_function = {correctness : thm, typing : thm, rewrite_enc_dec : thm, rewrite_encode : thm, acl2_definition : thm};

fun update_lists (encoded:encoded_function) = 
	(	rewrite_thms := (#rewrite_encode encoded) :: (#rewrite_enc_dec encoded) :: !rewrite_thms ;
		judgement_thms := (CONJUNCTS (#typing encoded)) @ !judgement_thms ;
		acl2_constants := ((fst o strip_comb o lhs o snd o strip_forall o concl o #acl2_definition) encoded) :: !acl2_constants);

fun convert_definition name function = 
let 	val _ = print ("Encoding function: " ^ name ^ "\n")
	val function' = PRE_PROCESS function
	val stage3 = encode_decode_function (curry_single_function (convert_tc (argument_list function') function'))
	val stage4 = acl2_define_function name stage3
	val stage5 = convert_acl2 stage3 stage4  (!rewrite_thms) (!acl2_constants)
	val (stage7d,stage7r) = define_and_resolve (resolve_hypothesis stage5 (!judgement_thms))
	val (correctness,typing,rewrite_enc_dec,rewrite_encode) = definition_proofs stage4 stage7d
	val acl2_definition = replace_list_predicates list_predicates (rewrite_definition stage7r stage7d)
	val result = {correctness = correctness, typing = typing, rewrite_enc_dec = rewrite_enc_dec, rewrite_encode = rewrite_encode, acl2_definition = acl2_definition}
in
	(print "Updating lists ... \n" ; update_lists result ; result)
end;
