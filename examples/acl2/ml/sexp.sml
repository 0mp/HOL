(*****************************************************************************)
(* Various ML tools to support ACL2 in HOL including:                        *)
(*                                                                           *)
(*  1. A printer from HOL to ACL2.                                           *)
(*                                                                           *)
(*  2. A converter from the ML representation of ACL2 defuns,                *)
(*     defaxioms and defthms generated by Matt's tool a2ml.csh               *)
(*     to HOL term.                                                          *)
(*****************************************************************************)

(*****************************************************************************)
(* Ignore everything up to "END BOILERPLATE"                                 *)
(*****************************************************************************)

(*****************************************************************************)
(* START BOILERPLATE NEEDED FOR COMPILATION                                  *)
(*****************************************************************************)

(******************************************************************************
* Load theories
******************************************************************************)
(* The commented out stuff below should be loaded in interactive sessions
quietdec := true;
map 
 load  
 ["intSyntax","stringLib","stringSimps", "rich_listTheory","pred_setLib"];
open stringLib numLib stringSimps rich_listTheory pred_setLib;
printDepth := 1000;
printLength := 1000;
Globals.checking_const_names := false;
quietdec := false;
*)

(******************************************************************************
* Boilerplate needed for compilation: open HOL4 systems modules
******************************************************************************)
open HolKernel Parse boolLib bossLib;

(******************************************************************************
* Open theories
******************************************************************************)
open intSyntax stringLib numLib;

(*****************************************************************************)
(* END BOILERPLATE                                                           *)
(*****************************************************************************)

(*****************************************************************************)
(* Swich off warning messages when defining types and constants with         *)
(* non-standard names (e.g. names originating from ACL2).                    *)
(*****************************************************************************)
val _ = (Globals.checking_const_names := false);

(*****************************************************************************)
(* Error reporting function (uses some HOL boilerplate I don't understand)   *)
(*****************************************************************************)
fun err fn_name msg = raise(mk_HOL_ERR "sexp" fn_name msg);

(*****************************************************************************)
(* Global variable holding current package name. Initially "ACL2"             *)
(*****************************************************************************)
val current_package = ref "ACL2";

(*****************************************************************************)
(* Set value of current package                                              *)
(*****************************************************************************)
fun set_current_package pname =
 (current_package := pname);

(*****************************************************************************)
(* Global updateable  list of ACL2 simplification theorems                   *)
(*****************************************************************************)
val acl2_simps = ref([]:thm list);

(*****************************************************************************)
(* Function to add a list of theorems to acl2_simps                          *)
(*****************************************************************************)
fun add_acl2_simps thl = (acl2_simps := (!acl2_simps) @ thl);

(*****************************************************************************)
(* |- ("T" = "NIL") = F  -- shouldn't need to have to prove this explicitly! *)
(*****************************************************************************)
val T_NIL = EVAL ``"T" = "NIL"``;

val _ = add_acl2_simps[T_NIL];

(*****************************************************************************)
(* Tactic that simplifies with acl2_simps and other theorems supplied        *)
(* explicitly by the user                                                    *)
(*****************************************************************************)
fun ACL2_SIMP_TAC thl = RW_TAC list_ss ((!acl2_simps) @ thl);

(*****************************************************************************)
(* Global association list of pairs (hol-name, acl2-name).                   *)
(*****************************************************************************)
val acl2_name_list = 
 ref([("ACL2_PAIR", "COMMON-LISP::CONS")]:(string*string)list);

(*****************************************************************************)
(* Function to add an entry to acl2_name_list                                *)
(*****************************************************************************)
fun add_acl2_names names = 
 (acl2_name_list := union (!acl2_name_list) names);

(*****************************************************************************)
(* Print !acl2_name_list to a string (used in adjoin_to_theory).             *)
(* There may be a better way of doing this!                                  *)
(*****************************************************************************)
local
fun string_pair_list_to_string_aux [] = ""
 |  string_pair_list_to_string_aux [(hol,acl2)] = 
    ("(\"" ^ hol ^ "\",\"" ^ acl2 ^"\")")
 |  string_pair_list_to_string_aux ((hol,acl2)::pl) = 
    ("(\"" ^ hol ^ "\",\"" ^ acl2 ^"\")," ^ 
    string_pair_list_to_string_aux pl)
in
fun string_pair_list_to_string pl =
 ("[" ^ string_pair_list_to_string_aux pl ^ "]")
end;

(*****************************************************************************)
(* declare_names("acl2-name","hol-name")                                     *)
(*                                                                           *)
(*  1. Checks "acl2-name" is the name of exactly one constant.               *)
(*                                                                           *)
(*  2. Checks "hol-name" isn't an existing abbreviation.                     *)
(*                                                                           *)
(*  3. Uses the HOL overloading mechanism to introduce "hol-name"            *)
(*     as an alternative name for "acl2-name" ("hol-name" should be          *)
(*     a valid HOL identifier name).                                         *)
(*****************************************************************************)
fun declare_names (acl2_name,hol_name) =
 let val hol_tml = Term.decls hol_name
     val acl2_tml = Term.decls acl2_name
 in
  if null acl2_tml
   then (print "no constant named: ";
         print acl2_name;
         err "declare_names" "no term with acl2 name") else
  if not(length acl2_tml = 1)
   then (print "Warning -- there is more than one constant named: ";
         print acl2_name;
         print "\n") else
  if not(length hol_tml = 0)
   then (print "Warning -- there is already a constant named: ";
         print hol_name;
         print "\n") 
   else (add_acl2_names[(hol_name,acl2_name)];
         overload_on(hol_name,hd acl2_tml))
 end;

(*****************************************************************************)
(* Three functions from KXS (modified by MJCG) to support non-standard names *)
(*****************************************************************************)
fun dest_hd_eqn eqs =
   let val hd_eqn = if is_conj eqs then fst(dest_conj eqs) else eqs
       val (lhs,rhs) = dest_eq (snd(strip_forall hd_eqn))
   in (strip_comb lhs, rhs)
   end;

fun non_standard_name_defn name q =
  let val absyn0 = Parse.Absyn q
      val (qtm,_) = Defn.parse_defn absyn0
      val ((f,args),rhs) = dest_hd_eqn qtm
      val (fname,fty) = dest_var f
      val qtm' = subst [f |-> mk_var(name,fty)] qtm
  in
   (fname, Defn.mk_defn fname qtm')
  end;

fun non_standard_nameDefine name q =
 let val (hol_name,def) = non_standard_name_defn name q
 in
  ((hol_name, #1(TotalDefn.primDefine def))
   handle e => raise wrap_exn "ACL2 support" "xxDefine" e)
 end;

(*****************************************************************************)
(* acl2Define "acl2_name" `(foo ... = ...) /\ ... ` does the following:      *)
(*                                                                           *)
(*  1. non_standard_nameDefine "acl2_name" `(foo ... = ...) /\ ... `         *)
(*                                                                           *)
(*  2. adds the theorem resulting from the definition to acl2_simps          *)
(*                                                                           *)
(*  3. declare_names("acl2_name","hol_name") ("hol_name" is name of hol)     *)
(*                                                                           *)
(*  4. the definition theorem is returned                                    *)
(*                                                                           *)
(* Example:                                                                  *)
(*                                                                           *)
(* val stringp_def =                                                         *)
(*  acl2Define "COMMON-LISP::STRINGP"                                        *)
(*   `(stringp(str x) = t) /\ (stringp _ = nil)`;                            *)
(*                                                                           *)
(*****************************************************************************)
fun acl2Define acl2_name q =
 let val (hol_name,th) = non_standard_nameDefine acl2_name q
 in
  acl2_simps := (!acl2_simps) @ [th];
  declare_names(acl2_name,hol_name);
  (print"\""; 
   print acl2_name; 
   print "\" defined with HOL name \""; 
   print hol_name; print "\"\n");
  th
 end;

(*****************************************************************************)
(* Generate date and time for making file timestamps                         *)
(*****************************************************************************)
fun date() = Date.fmt "%c" (Date.fromTimeLocal (Time.now ()));

(*****************************************************************************)
(* Create a output stream to a file called file_name.lisp, apply a printer   *)
(* to it and then flush and close the stream.                                *)
(*****************************************************************************)
fun print_lisp_file file_name printer =
 let val outstr = TextIO.openOut(file_name ^ ".lisp")
     fun out s = TextIO.output(outstr,s)
 in
 (out("; File created from HOL using print_lisp_file on " ^ date() ^ "\n\n");  
   (* Add time stamp                                                         *)  
  out("(IN-PACKAGE \"ACL2\")\n\n");
   (* ACL2 initialisation                                                    *)
  printer out;
  TextIO.flushOut outstr;
  TextIO.closeOut outstr)
 end;

(*****************************************************************************)
(* Representation of s-expressions in ML                                     *)
(*                                                                           *)
(* Complex rational a/b + (p/q)i is constructed by mlnum("a","b","p","q").   *)
(* Must use strings, as ML numerals are 32-bit!                              *)
(*                                                                           *)
(*   con mlchr  = fn : char -> mlsexp                                        *)
(*   con mlnum  = fn : string * string * string * string -> mlsexp           *)
(*   con mlpair = fn : mlsexp * mlsexp -> mlsexp                             *)
(*   con mlstr  = fn : string -> mlsexp                                      *)
(*   con mlsym  = fn : string * string -> mlsexp                             *)
(*                                                                           *)
(* Negative numbers are represented by prefixing the numerator with "-",     *)
(* so denominators b and q should be natural number numerals (0,1,2,...),    *)
(* and numerators a and p should be natural number numerals, possibly with   *)
(* a "-" prefix. Thus mlnum("1","-1","0","1") is invalid.                    *)
(*****************************************************************************)
datatype mlsexp =
   mlsym  of string * string
 | mlstr  of string
 | mlchr  of char
 | mlnum  of string * string * string * string
 | mlpair of mlsexp * mlsexp;

val mksym  = curry mlsym
and mkstr  = mlstr
and mkchr  = mlchr o chr
and mknum  = fn numerator_x => 
              fn denominator_x => 
               fn numerator_y => 
                fn denominator_y => 
                 mlnum(numerator_x,denominator_x,numerator_y,denominator_y)
and mkpair = fn x => 
              fn y => 
               mlpair(x,y);
 
(*****************************************************************************)
(* Test and destructor for mlsym                                             *)
(*****************************************************************************)
fun is_mlsym (mlsym(_,_)) = true
 |  is_mlsym _ = false;

(* No longer used
fun dest_mlsym(mlsym(pkg,nam)) = (pkg,nam)
 | dest_mlsym _ = err "dest_mlsym" "not an mlsym";
*)

(*****************************************************************************)
(* Alternative name for mlstr used to indicate string originates from a      *)
(* list of characters sent from ACL2.                                        *)
(*****************************************************************************)
val mk_chars_str = mlstr;

(*****************************************************************************)
(* Abbreviation for some symbols.                                            *)
(*****************************************************************************)
val mlnil      = mksym "COMMON-LISP" "NIL"
val mlt        = mksym "COMMON-LISP" "T"
and mlquote    = mksym "COMMON-LISP" "QUOTE"
and mlcons     = mksym "COMMON-LISP" "CONS"
and mllambda   = mksym "COMMON-LISP" "LAMBDA"
and mldefun    = mksym "COMMON-LISP" "DEFUN"
and mlmutual   = mksym "ACL2"        "MUTUAL-RECURSION"
and mldefaxiom = mksym "ACL2"        "DEFAXIOM"
and mldefthm   = mksym "ACL2"        "DEFTHM";


(*****************************************************************************)
(* "pkg::nam" |--> ("pkg","nam")                                             *)
(*****************************************************************************) 
val split_acl2_name =
 let 
  fun split_acl2_name_chars acc [] = ([],rev acc)
   |  split_acl2_name_chars acc (#":" :: #":" :: l) = (rev acc,l)
   |  split_acl2_name_chars acc (c :: l) = split_acl2_name_chars (c :: acc) l
 in
  (implode ## implode) o split_acl2_name_chars [] o explode
end;

(*****************************************************************************)
(* "pkg::nam" |--> mlsym("pkg","nam")                                        *)
(* "nam"      |--> mlsym((!current_package),"nam") (when no "::" in "nam")   *)
(*****************************************************************************) 
fun string_to_mlsym s =
 if s = "ACL2_PAIR"
  then mlcons
  else let val (pkg,nam) = split_acl2_name s
       in
        mlsym(if pkg = "" then (!current_package) else pkg, nam)
       end;

(*****************************************************************************)
(* Test for a proper list: (x1 . (x2 . ... . (xn . nil) ...))                *)
(*****************************************************************************)
fun is_mlsexp_proper_list (sym as mlsym(_,_)) =
     (sym = mlnil)
 |  is_mlsexp_proper_list (mlpair(_,p)) =
     is_mlsexp_proper_list p
 |  is_mlsexp_proper_list _ = false;

(*****************************************************************************)
(* Test for a proper list or an atom                                         *)
(*****************************************************************************)
fun is_mlsexp_list (p as mlpair(_,_)) = is_mlsexp_proper_list p
 |  is_mlsexp_list _                  = true;

(*****************************************************************************)
(* Destruct an ML s-expression list:                                         *)
(*  (x1 . (x2 . ... (xn . nil) ...))  |--> [x1,x2,...,xn]                    *)
(*****************************************************************************)
fun dest_mlsexp_list (sym as mlsym(_,_)) = 
     if (sym = mlnil) then [] else [sym]
 |  dest_mlsexp_list (mlpair(p1,p2)) =
     p1 :: dest_mlsexp_list p2
 |  dest_mlsexp_list p = [p];

(*****************************************************************************)
(* [x1,...,xn] --> (mkpair x1 ... (mkpair xn mlnil) ... ))                   *)
(*****************************************************************************)
fun mk_mlsexp_list [] = mlnil
 |  mk_mlsexp_list (x::xl) = mlpair(x, mk_mlsexp_list xl);

(*****************************************************************************)
(* Test for a quote: (QUOTE x)                                               *)
(*****************************************************************************)
fun is_mlquote (mlpair(x,mlpair(_,n))) = (x = mlquote) andalso (n = mlnil)
 |  is_mlquote _                       = false;

(*****************************************************************************)
(* Extract body of a quote: (QUOTE x) |--> x                                 *)
(*****************************************************************************)
fun dest_mlquote (mlpair(_,mlpair(x,_))) = x
 |  dest_mlquote _                       = err "dest_mlquote" "bad argument";

(*****************************************************************************)
(* Make an ML quote x |--> (QUOTE x)                                         *)
(*****************************************************************************)
fun mk_mlquote x = mk_mlsexp_list[mlquote,x];

(*****************************************************************************)
(* Test for a lambda: ((LAMBDA (x1 ... xm) bdy) (a1 ... an))                 *)
(*****************************************************************************)
fun is_mllambda (mlpair(mlpair(x,mlpair(params,mlpair(bdy,n))),args)) = 
     (x = mllambda)        andalso 
     is_mlsexp_list params andalso 
     is_mlsexp_list args   andalso 
     is_mlsexp_list bdy    andalso
     (n = mlnil)
 |  is_mllambda _ = false;

(*****************************************************************************)
(* Lambda destructor:                                                        *)
(*   ((LAMBDA (x1 ... xm) bdy) (a1 ... an))                                  *)
(*   |-->                                                                    *)
(*   ([x1, ..., xm], bdy, [a1, ..., an])                                     *)
(*                                                                           *)
(*****************************************************************************)
fun dest_mllambda (mlpair(mlpair(_,mlpair(params,mlpair(bdy,_))),args)) = 
     (dest_mlsexp_list params, bdy, dest_mlsexp_list args)
 |  dest_mllambda _ = 
     err "dest_mllambda" "bad argument";

(*****************************************************************************)
(* Test for a defun: (DEFUN nam (x1 ... xn) bdy)                             *)
(*****************************************************************************)
fun is_mldefun 
     (mlpair(x,mlpair(mlsym(_,_),mlpair(params,mlpair(bdy,n))))) = 
      (x = mldefun)         andalso
      is_mlsexp_list params andalso
      is_mlsexp_list bdy    andalso
      (n = mlnil)
 |  is_mldefun _  = false;

(*****************************************************************************)
(* Defun destructor: (DEFUN nam (x1 ... xn) bdy) |-->(nam,[x1,...,xn],bdy)   *)
(*****************************************************************************)
fun dest_mldefun d =
     if is_mldefun d 
      then case dest_mlsexp_list d
           of [_,nam,params,bdy] 
              => (nam, dest_mlsexp_list params, bdy)
           |  _                  
              => err "dest_mldefun" "bad case match"
      else err "dest_mldefun" "not a defun";

(*****************************************************************************)
(* Defun Constructor: (nam,[x1,...,xn],bdy) |--> (DEFUN nam (x1 ... xn) bdy) *)
(*****************************************************************************)
fun mk_mldefun (nam, params, bdy) =
 mk_mlsexp_list [mldefun, nam, mk_mlsexp_list params, bdy];

(*****************************************************************************)
(* Test for a defaxiom: (DEFAXIOM nam bdy)                                   *)
(*****************************************************************************)
fun is_mldefaxiom 
     (mlpair(x,mlpair(mlsym(_,_),mlpair(bdy,n)))) = 
      (x = mldefaxiom)   andalso
      is_mlsexp_list bdy andalso
      (n = mlnil)
 |  is_mldefaxiom _  = false;

(*****************************************************************************)
(* Defaxiom destructor: (DEFAXIOM nam bdy) |--> (nam,bdy)                    *) 
(*****************************************************************************)
fun dest_mldefaxiom
     (mlpair(_,mlpair(nam,mlpair(bdy,_)))) = (nam, bdy)
 |  dest_mldefaxiom _ = err "dest_mldefaxiom" "bad argument";

(*****************************************************************************)
(* Defaxiom constructor:  (nam,bdy) |--> (DEFAXIOM nam bdy)                  *)
(*****************************************************************************)
fun mk_mldefaxiom(nam,bdy) = 
 mk_mlsexp_list [mldefaxiom, nam, bdy];

(*****************************************************************************)
(* Test for a defthm: (DEFTHM nam bdy)                                        *)
(*****************************************************************************)
fun is_mldefthm 
     (mlpair(x,mlpair(mlsym(_,_),mlpair(bdy,n)))) = 
      (x = mldefthm)     andalso
      is_mlsexp_list bdy andalso
      (n = mlnil)
 |  is_mldefthm _  = false;

(*****************************************************************************)
(* Defthm destructor: (DEFTHM nam bdy) |--> (nam,bdy)                        *) 
(*****************************************************************************)
fun dest_mldefthm
     (mlpair(_,mlpair(nam,mlpair(bdy,_)))) = (nam, bdy)
 |  dest_mldefthm _ = err "dest_mldefthm" "bad argument";

(*****************************************************************************)
(* Defthm constructor:  (nam,bdy) |--> (DEFTHM nam bdy)                      *)
(*****************************************************************************)
fun mk_mldefthm(nam,bdy) = 
 mk_mlsexp_list [mldefthm, nam, bdy];

(*****************************************************************************)
(* Test for a mutual: (MUTUAL-RECURSION d1 ... dn)                           *)
(*****************************************************************************)
fun is_mlmutual (mlpair(x, defs)) =
      (x = mlmutual) andalso is_mlsexp_list defs
 |  is_mlmutual _  = false;

(*****************************************************************************)
(* Mutual destructor: (MUTUAL-RECURSION d1 ... dn) |--> [d1, ..., dn]        *) 
(*****************************************************************************)
fun dest_mlmutual (mlpair(_, defs)) = dest_mlsexp_list defs
 |  dest_mlmutual _ = err "dest_mlmutual" "bad argument";

(*****************************************************************************)
(* Test for ``nat n`` where n is a numeral                                   *)
(*****************************************************************************)
fun is_nat tm =
 is_comb tm           andalso
 (rator tm = ``nat``) andalso
 is_numeral(rand tm);

(*****************************************************************************)
(* Convert ``nat n`` to "n"                                                  *)
(*****************************************************************************)
fun dest_nat tm = Arbnum.toString(dest_numeral(rand tm));

(*****************************************************************************)
(* Test for ``n`` where n is an integer numeral                              *)
(*****************************************************************************)
fun is_integer tm =
 is_comb tm andalso
 (if rator tm = ``int_of_num:num->int``       (* $& overloaded on int_of_num *)
   then is_numeral(rand tm) else
  if rator tm = ``int_neg:int->int``          (* $~ overloaded on int_neg    *)
   then is_integer(rand tm) else
  false);

(*****************************************************************************)
(* Test for ``int n`` where n is an integer numeral                          *)
(*****************************************************************************)
fun is_int tm =
 is_comb tm           andalso
 (rator tm = ``int``) andalso
 is_integer(rand tm);

(*****************************************************************************)
(* Convert an integer term numeral to a string:                              *)
(*                                                                           *)
(*  ``&d1d2...dn``   |-->  "d1d2...dn"                                       *)
(*  ``~& d1d2...dn`` |-->  "-d1d2...dn"                                      *)
(*****************************************************************************)
fun dest_integer tm =
 let val (opr,args) = strip_comb tm
 in
  if opr = ``int_of_num:num->int`` andalso (tl args = [])
   then (if is_numeral(hd args)
          then Arbnum.toString(dest_numeral(hd args))
          else (print_term tm;
                print " is not a non-negative integer numeral\n";
                err "dest_integer" "not a non-negative integer numeral")) 
   else (if opr = ``int_neg:int->int`` andalso (tl args = [])
          then ("-" ^ dest_integer(hd args))
          else (print_term tm;
                print " is not an integer numeral\n";
                err "dest_integer" "not an integer numeral"))
 end;

(*****************************************************************************)
(* Convert ``int n`` to dest_integer ``n``                                   *)
(*****************************************************************************)
fun dest_int tm = dest_integer(rand tm);

(*****************************************************************************)
(* Replace initial "-" by "~" in a string (converts ACL2 representation of   *)
(* a negative integer to HOL representation).                                *)
(*****************************************************************************)
fun acl2_int_to_hol_int s =
 let val chars = explode s
  in
   if not(null chars) andalso hd chars = #"-" 
    then implode(#"~" :: tl chars) 
    else s
  end;

(*****************************************************************************)
(* Test whether a string is a natural number numeral                         *)
(*****************************************************************************)
fun is_num_string s = all Char.isDigit (explode s);


(*****************************************************************************)
(* Test whether a string is an integer numeral                               *)
(*****************************************************************************)
fun is_int_string s = 
 let val sl = explode s 
 in
  null sl 
   orelse ((hd sl = #"-") andalso all Char.isDigit (tl sl))
   orelse all Char.isDigit sl
 end;

(*****************************************************************************)
(* Test for ``cpx a b c d``                                                  *)
(*****************************************************************************)
fun is_cpx tm =
 let val (opr,args) = strip_comb tm
 in
  (opr = ``cpx``) 
    andalso (length args = 4)
    andalso is_int_string(dest_integer(el 1 args))
    andalso is_num_string(dest_integer(el 2 args))
    andalso is_int_string(dest_integer(el 3 args))
    andalso is_num_string(dest_integer(el 4 args))
 end;

(*****************************************************************************)
(* ``cpx an ad bn bd`` |--> ("an", "ad", "bn", "bd")                         *)
(*                                                                           *)
(* Negative numbers are represented with a prefixed "-" (e.g. "-3").         *)
(*****************************************************************************)
fun dest_cpx tm =
 if is_cpx tm          (* Probably redundant extra check included for safety *)
  then
  let val (_,args) = strip_comb tm
  in
   (dest_integer(el 1 args), 
    dest_integer(el 2 args), 
    dest_integer(el 3 args), 
    dest_integer(el 4 args))
  end
 else (print_term tm;
       print " is not a complex numeral\n";
       err "dest_cpx" "not a complex numeral");

(*****************************************************************************)
(* mlsym(pkg,nam) |--> "pkg::nam"                                            *)
(*****************************************************************************)
fun mlsym_to_string (sym as mlsym(pkg,nam)) = (pkg^"::"^nam)
 |  mlsym_to_string _ = err "mlsym_to_string" "non sym argument";

(*****************************************************************************)
(* Get the HOL name from ACL2 name.                                          *)
(* If there is no HOL name (e.g. an ACL2 variable) the ACL2 name is          *)
(* returned.                                                                 *)
(*****************************************************************************)
local
fun get_hol_name_from_acl2_name_aux [] sym = 
     mlsym_to_string sym
 |  get_hol_name_from_acl2_name_aux ((hol,acl2) :: nl) sym = 
     if acl2 = mlsym_to_string sym
      then hol
      else get_hol_name_from_acl2_name_aux nl sym
in
fun get_hol_name_from_acl2_name sym = 
     get_hol_name_from_acl2_name_aux (!acl2_name_list) sym
end;

(*****************************************************************************)
(* Translate a term of type ``:sexp`` to an s-expression represented in ML   *)
(*****************************************************************************)
fun term_to_mlsexp tm =
 if is_var tm
  then string_to_mlsym(fst(dest_var tm)) else
 if is_const tm
  then string_to_mlsym(fst(dest_const tm)) else
 if is_nat tm
  then mlnum(dest_nat tm, "1", "0", "1") else
 if is_int tm
  then mlnum(dest_int tm, "1", "0", "1") else
 if is_cpx tm
  then mlnum(dest_cpx tm) else
 if is_numeral tm
  then (print "Bad occurence of numeral ";
        print_term tm; print ". Use \"nat\", \"int\" or \"cpx\".\n";
        err "term_to_mlsexp" "bad occurrence of a numeral") else
 if is_integer tm
  then (print "Bad occurence of integer numeral ";
        print_term tm; print ". Use \"nat\", \"int\" or \"cpx\".\n";
        err "term_to_mlsexp" "bad occurrence of an integer numeral") else
 if is_let tm
  then term_to_mlsexp(mk_comb(dest_let tm)) else
 if is_comb tm
  then 
   let val (opr,args) = strip_comb tm
   in 
    if is_const opr
     then (case fst(dest_const opr)
           of "ACL2_SYMBOL"    => mk_mlquote
                                   (mlsym(fromHOLstring(hd args), 
                                          fromHOLstring(hd(tl args))))
           |  "ACL2_STRING"    => mlstr(fromHOLstring(hd args))
           |  "ACL2_CHARACTER" => mlchr(fromHOLchar(hd args))
           |  "ACL2_NUMBER"    => (print_term tm; print "\n";
                                   print "term built with num not supported";
                                   print " -- use nat, int or cpx\n";
                                   err "term_to_mlsexp" "ACL2_NUMBER case unsupported")
           |  "cpx"            => (print_term tm; print "\n";
                                   print "bad use of cpx\n";
                                   err "term_to_mlsexp" "badly formed application of cpx")
           |  _                => mk_mlsexp_list(map term_to_mlsexp (opr::args))

          ) else
    if is_var opr
     then mk_mlsexp_list (map term_to_mlsexp (opr::args)) else
    if is_abs opr
     then 
      let val (params,bdy) = strip_abs opr
      in 
       if not(length params = length args)
        then (print_term tm; print "\n";
              print "different numbers of formal and actual parameters\n";
              err "term_to_mlsexp" "formal/actual mismatch")
        else mk_mlsexp_list
             (mk_mlsexp_list
               [mllambda, 
                mk_mlsexp_list(map term_to_mlsexp params), 
                term_to_mlsexp bdy]
              :: map term_to_mlsexp args)
      end else
    (print_term opr; 
     print " is not allowed as a function\n";
     err "term_to_mlsexp" "bad function")
   end else
 (print_term tm; print "\n";
  print "bad argument to term_to_mlsexp\n";
  err "term_to_mlsexp" "bad argument");

(*****************************************************************************)
(* Print an ML s-expression s on an output stream out                        *)
(*****************************************************************************)
fun print_mlsexp (out:string->unit) (sym as mlsym(_,_))  =
     out(mlsym_to_string sym)
 | print_mlsexp (out:string->unit) (mlstr s) =
     (out "\""; out s; out "\"")
 | print_mlsexp (out:string->unit) (mlchr c) =
     (out "(code-char "; out(int_to_string(ord c)); out ")")
 | print_mlsexp (out:string->unit) (mlnum(an,ad,bn,bd)) =
    if (bn = "0") andalso (bd = "1")
     then (out an; out "/"; out ad)
     else (out "(COMMON-LISP::COMPLEX ";
           out an; out "/"; out ad; 
           out " ";
           out bn; out "/"; out bd; 
           out ")")
 | print_mlsexp (out:string->unit) (mlpair(p1,p2)) =
     (out "(";
      (if is_mlsexp_list p2
        then let val sl = dest_mlsexp_list p2
             in
              if null sl
               then print_mlsexp out p1 
               else (print_mlsexp out p1;
                     map (fn p => (out " "; print_mlsexp out p)) sl;
                     ())
             end
        else (print_mlsexp out p1; out " . "; print_mlsexp out p2)); 
      out ")");

(*****************************************************************************)
(* Print an ML s-expression to the interactive session                       *)
(*****************************************************************************)
fun pr_mlsexp s = (print_mlsexp print s; print "\n");      

(*****************************************************************************)
(* Print an s-expression term to the interactive session                     *)
(*****************************************************************************)
fun pr_sexp t = pr_mlsexp(term_to_mlsexp t);

(*****************************************************************************)
(* Translate a hol-acl2 definition                                           *)
(*                                                                           *)
(*   |- f x1 ... xn = e                                                      *)
(*                                                                           *)
(* to an ML s-expression representing                                        *)
(*                                                                           *)
(*  (defun f (x1 ... xn) ^(term_to_mlsexp e))                                *)
(*****************************************************************************)
fun mk_mlsexp_defun th =
 let val (_,concl) = dest_thm(SPEC_ALL th)
     val (l,r) = dest_eq concl
     val (opr, args) = strip_comb l
 in
  mk_mlsexp_list
   [mksym "COMMON-LISP" "DEFUN",
    string_to_mlsym(fst((if is_var opr then dest_var else dest_const) opr)),
    mk_mlsexp_list(map term_to_mlsexp args),
    term_to_mlsexp r]
 end;    

(*****************************************************************************)
(* Print a hol-acl2 definition                                               *)
(*                                                                           *)
(*   |- f x1 ... xn = e                                                      *)
(*                                                                           *)
(* as                                                                        *)
(*                                                                           *)
(*  (defun f (x1 ... xn) ^(term_to_mlsexp e))                                *)
(*****************************************************************************)
fun pr_mlsexp_defun th = pr_mlsexp(mk_mlsexp_defun th);

(*****************************************************************************)
(* Code for processing ACL2 defuns slurped into HOL via Matt's a2ml tool     *)
(*****************************************************************************)

(*****************************************************************************)
(* Convert a string to integer numeral                                       *)
(*                                                                           *)
(*  string_to_int_term "37"  = ``37``                                        *)
(*  string_to_int_term "~37" = ``~37``                                       *)
(*  string_to_int_term "-37" = ``~37``                                       *)
(*****************************************************************************)
fun string_to_int_term s = intSyntax.term_of_int(Arbint.fromString s);

(*****************************************************************************)
(* There are two obvious ways to convert an mlsexp to a term:                *)
(*                                                                           *)
(*  1. recursively descend through it build up a term;                       *)
(*                                                                           *)
(*  2. convert it to a string s than then use Term[QUOTE s].                 *)
(*                                                                           *)
(* Method 1 allows more detailed checking and gives finer control over       *)
(* error messages.  Method 2 is a bit easier to implement, but may be        *)
(* less robust.                                                              *)
(*                                                                           *)
(* Initially we started to implement Method 2 as it was simpler, but then    *)
(* it became clear that it would not handle ACL2's non standard              *)
(* identifier names, so we switched to Method 1.                             *)
(*                                                                           *)
(* However, the unfinished partial implementation of Method 2                *)
(* (mlsexp_to_string) is useful for debugging, as it enables one to print    *)
(* compact representations of imported mlsexps.                              *)
(*                                                                           *)
(*****************************************************************************)

(*****************************************************************************)
(* Convert an ML s-expression (mlsexp) to a string that will parse to the    *)
(* corresponding HOL s-expression (sexp).                                    *)
(*****************************************************************************)
fun mlquote_to_string (mlsym(pkg,nam)) = 
     ("(sym \"" ^ pkg ^ "\" \"" ^ nam ^"\")")
 |  mlquote_to_string (mlstr s) = 
     ("(str " ^ "\"" ^ s ^ "\")")
 |  mlquote_to_string (mlchr c) = 
     ("(chr " ^ "(CHR " ^ int_to_string(ord c) ^ "))")
 |  mlquote_to_string (mlnum(an,ad,bn,bd)) = 
     ("(cpx " ^ 
         acl2_int_to_hol_int an ^ " " ^ 
         acl2_int_to_hol_int ad ^ " " ^ 
         acl2_int_to_hol_int bn ^ " " ^ 
         acl2_int_to_hol_int bd ^")")
 |  mlquote_to_string (mlpair(x,y)) =
     ("(cons " ^ mlquote_to_string x ^ " " ^ mlquote_to_string y ^ ")");

(*****************************************************************************)
(* Convert an ML s-expression (mlsexp) to a string that will parse to the    *)
(* corresponding HOL s-expression (sexp).                                    *)
(*****************************************************************************)
fun mlquote_to_string (mlsym(pkg,nam)) = 
     ("(sym \"" ^ pkg ^ "\" \"" ^ nam ^"\")")
 |  mlquote_to_string (mlstr s) = 
     ("(str " ^ "\"" ^ s ^ "\")")
 |  mlquote_to_string (mlchr c) = 
     ("(chr " ^ "(CHR " ^ int_to_string(ord c) ^ "))")
 |  mlquote_to_string (mlnum(an,ad,bn,bd)) = 
     ("(cpx " ^ 
         acl2_int_to_hol_int an ^ " " ^ 
         acl2_int_to_hol_int ad ^ " " ^ 
         acl2_int_to_hol_int bn ^ " " ^ 
         acl2_int_to_hol_int bd ^")")
 |  mlquote_to_string (mlpair(x,y)) =
     ("(cons " ^ mlquote_to_string x ^ " " ^ mlquote_to_string y ^ ")");

(*****************************************************************************)
(* Convert an ML s-expression (mlsexp) to the coresponding HOL               *)
(* s-expression (i.e. term of type sexp).                                    *)
(*****************************************************************************)
fun mlquote_to_term (sym as mlsym(pkg,nam)) = 
     if sym = mlnil then ``nil`` else
     if sym = mlt   then ``t``   else
     ``sym ^(fromMLstring pkg) ^(fromMLstring nam)``
 |  mlquote_to_term (mlstr s) = 
     ``str ^(fromMLstring s)``
 |  mlquote_to_term (mlchr c) = 
     ``chr ^(fromMLchar c)``
 |  mlquote_to_term (mlnum(an,ad,bn,bd)) = 
     ``cpx ^(string_to_int_term an) 
           ^(string_to_int_term ad) 
           ^(string_to_int_term bn) 
           ^(string_to_int_term bd)``
 |  mlquote_to_term (mlpair(x,y)) =
     ``cons ^(mlquote_to_term x) ^(mlquote_to_term y)``;

(*****************************************************************************)
(* Convert an mlsexp representing a term to a string.                        *)
(*                                                                           *)
(* From: http://www.dina.kvl.dk/~sestoft/mosmllib/List.html                  *)
(*                                                                           *)
(*    [foldl op% e xs] evaluates xn % (x(n-1) % ( ... % (x2 % (x1 % e))))    *)
(*    where xs = [x1, x2, ..., x(n-1), xn], and % is taken to be infixed.    *)
(*                                                                           *)
(*****************************************************************************)
fun mlsexp_to_string (sym as mlsym(_,_)) =
     mlsym_to_string sym
 |  mlsexp_to_string (mlstr s) = ("(str " ^ "\"" ^ s ^ "\")")
 |  mlsexp_to_string (mlchr c) = 
      ("(chr " ^ "(CHR " ^ int_to_string(ord c) ^ "))")
 |  mlsexp_to_string (mlnum(an,ad,bn,bd)) = 
     ("(cpx " ^ 
         acl2_int_to_hol_int an ^ " " ^ 
         acl2_int_to_hol_int ad ^ " " ^ 
         acl2_int_to_hol_int bn ^ " " ^ 
         acl2_int_to_hol_int bd ^")")
 |  mlsexp_to_string (p as mlpair(x,y)) =
     if is_mlquote p
      then mlquote_to_string(dest_mlquote p)
      else ("(" ^
            (if is_mlsexp_list y
              then foldl 
                    (fn (z,zs) => zs ^ " " ^ mlsexp_to_string z) 
                    (mlsexp_to_string x) 
                    (dest_mlsexp_list y)
              else (print "attempt to translate a non-list to a term\n";
                    err "mlsexp_to_string" "non-list")) ^
            ")");

(*****************************************************************************)
(* mlsym(pkg,nam) |--> mk_var("pkg::nam",``:sexp``)                          *)
(*****************************************************************************)
fun param_to_var (sym as mlsym(_,_)) = 
      mk_var(mlsym_to_string sym,``:sexp``)
 |  param_to_var _ = 
      (print "Not a mlsym\n";
       err "param_to_var" "not an mlsym");

(*****************************************************************************)
(* Look up the HOL name of an ACL2 name and return the corresponding         *)
(* term.  Return a variable with a supplied type if there is no HOL name.    *)
(*****************************************************************************)
fun acl2_name_to_term sym ty = 
 if sym = mlt
  then ``t`` else
 if sym = mlnil
  then ``nil`` else
 if sym = mlcons
  then ``ACL2_PAIR`` else
 mk_const(mlsym_to_string sym,ty)
  handle HOL_ERR _ => mk_var(mlsym_to_string sym,ty);

(*****************************************************************************)
(* n |--> ``:sexp -> ... -> sexp`` (n arguments)                             *)
(*****************************************************************************)
fun mk_sexp_fun_ty n =
 if n = 0 then ``:sexp`` else ``:sexp -> ^(mk_sexp_fun_ty(n-1))``;

(*****************************************************************************)
(* list_mk_abs doesn't create an abstraction when the arg list is empty      *)
(*****************************************************************************)
val list_mk_fun = list_mk_abs;

(*****************************************************************************)
(* Convert an mlsexp representing a term to the term.                        *)
(*****************************************************************************)
fun mlsexp_to_term (sym as mlsym(_,_)) =
    acl2_name_to_term sym ``:sexp``
 |  mlsexp_to_term (mlstr s) = ``str ^(fromMLstring s)``
 |  mlsexp_to_term (mlchr c) = ``chr ^(fromMLchar c)``
 |  mlsexp_to_term (mlnum(an,ad,bn,bd)) = 
     ``cpx ^(string_to_int_term an) 
           ^(string_to_int_term ad) 
           ^(string_to_int_term bn) 
           ^(string_to_int_term bd)``
 |  mlsexp_to_term (p as mlpair(x,y)) =
     if is_mlquote p
      then mlquote_to_term(dest_mlquote p) else
     if is_mllambda p
      then let val (params,bdy,args) = dest_mllambda p
           in
            list_mk_comb
             (list_mk_fun(map param_to_var params, mlsexp_to_term bdy),
              map mlsexp_to_term args)
           end else
     if is_mlsexp_list y 
      then let val args = map mlsexp_to_term (dest_mlsexp_list y)
               val opr = if is_mlsym x
                          then acl2_name_to_term 
                                x
                                (mk_sexp_fun_ty(length args))
                          else mlsexp_to_term x
           in
            (list_mk_comb(opr,args)
             handle HOL_ERR _ => 
              (print "Can't make term\n";
               err "mlsexp_to_term" "bad mlsexp")) 
            end else
     (print "attempt to translate a non-list to a term\n";
      err "mlsexp_to_term" "non-list");

(*****************************************************************************)
(* (defun d (x1 ... xm) b) |--> "d x1 ... xm = b"                            *)
(*****************************************************************************)
fun defun_to_string d =
 if is_mldefun d
  then let val (sym, params, bdy) = dest_mldefun d
       in
        foldl 
         (fn (z,zs) => zs ^ " " ^ z) 
         ("ACL2_" ^ mlsym_to_string sym)
         (map mlsym_to_string params)
        ^ " = " ^ mlsexp_to_string bdy
      end
  else (print "defun badly formed\n";
        err "defun_to_string" "bad defun");

(*****************************************************************************)
(* (defun nam (x1 ... xm) bdy) |--> ("DEFUN",    "nam", ``\x1 ... xm. bdy``) *)
(* (defthm nam bdy)            |--> ("DEFTHM",   "nam", ``bdy``)             *)
(* (defaxiom nam bdy)          |--> ("DEFAXIOM", "nam", ``bdy``)             *)
(*****************************************************************************)
fun def_to_term d =
 if is_mldefun d
  then let val (nam,params,bdy) = dest_mldefun d
       in
        ("DEFUN", nam, list_mk_fun(map param_to_var params, mlsexp_to_term bdy))
       end else
 if is_mldefaxiom d
  then let val (nam,bdy) = dest_mldefaxiom d
       in
        ("DEFAXIOM", nam, mlsexp_to_term bdy)
       end else
 if is_mldefthm d
  then let val (nam,bdy) = dest_mldefthm d
       in
        ("DEFTHM", nam, mlsexp_to_term bdy)
       end 
  else err "def_to_term" "not a def";

(*****************************************************************************)
(* |- f = \x1 ... xn. bdy                                                    *)
(* ----------------------                                                    *)
(*  |- f x1 ... xn = bdy                                                     *)
(*****************************************************************************)
fun MK_DEF_EQ th =
 if is_eq(concl(SPEC_ALL th))
  then foldl 
        (fn (v,th) => RIGHT_CONV_RULE BETA_CONV (AP_THM th v)) 
        th 
        (fst(strip_abs(rhs(concl(SPEC_ALL th)))))
  else th;

(*****************************************************************************)
(* ML datatype to represent defs sent from ACL2                              *)
(*****************************************************************************)
datatype acl2def =
   defun    of string * thm
 | defaxiom of string * term
 | defthm   of string * term;

(*****************************************************************************)
(* ``ACL2::FOO`` |--> ``foo``                                                *)
(*****************************************************************************)
fun clean_acl2_var tm =
 if is_var tm
  then let val (s,ty) = dest_var tm
           val (pkg,nam) = split_acl2_name s
       in
        if pkg = !current_package
         then mk_var(implode(map Char.toLower (explode nam)), ty)
         else tm
       end
  else tm;

(*****************************************************************************)
(* Clean all the free variables in a term                                    *)
(*****************************************************************************)
fun clean_acl2_term tm =
 subst (map (fn v => v |-> clean_acl2_var v) (free_vars tm)) tm;

(*****************************************************************************)
(* Clean all the free variables in a theorem                                 *)
(*****************************************************************************)
fun CLEAN_ACL2_THM th =
 INST (map (fn v => v |-> clean_acl2_var v) (thm_frees th)) th;

(*****************************************************************************)
(* Apply def_to_term and then create an acl2def                              *)
(*                                                                           *)
(* ("DEFUN", "nam", ``\x1 ... xm. bdy``)                                     *)
(* |-->                                                                      *)
(* defun(nam_def_axiom, [axioms: nam_def_axiom] |- nam = \x1 ..., xm. bdy)   *)
(*                                                                           *)
(* ("DEFAXIOM", "nam", tm)                                                   *)
(* |-->                                                                      *)
(* defaxiom(nam, tm)                                                         *)
(*                                                                           *)
(* ("DEFTHM", "nam", tm)                                                     *)
(* |-->                                                                      *)
(* defthm(nam, tm)                                                           *)
(*                                                                           *)
(*****************************************************************************)
fun mk_def d =
 let val (def_kind,sym,tm) = def_to_term d
 in
  if def_kind = "DEFUN" 
   then let val ty = type_of tm
            val sym_name = mlsym_to_string sym
            val _ = new_constant(sym_name,ty)
            val newcon = mk_const(sym_name,ty)
            val newvar = mk_var(sym_name,ty)
            val newtm = subst[newvar |-> newcon]tm
            val defun_name = sym_name ^ "_acl2_defun"
            val deftm = mk_eq(newcon,newtm)
            val defun_thm = 
                 save_thm
                  (defun_name,
                   CLEAN_ACL2_THM
                    (MK_DEF_EQ(mk_oracle_thm(Tag.read "ACL2_DEFUN")([],deftm))))
        in
         defun(defun_name, defun_thm)
        end else
  if def_kind = "DEFAXIOM" 
   then defaxiom(mlsym_to_string sym, tm) else
  if def_kind = "DEFTHM" 
   then defthm(mlsym_to_string sym, tm) else
  err "mk_def" "bad argument"
 end;

(*****************************************************************************)
(* Expand a mutual recursion to a list of definitions                        *)
(*****************************************************************************)
fun mk_defs d =
     if is_mlmutual d then map mk_def (dest_mlmutual d) else [mk_def d];

(*****************************************************************************)
(* Convert a list of character code to a string.                             *)
(* Used in ML generated from ACL2 by a2ml.                                   *)
(*****************************************************************************)
val chars_to_string = implode o (map chr);

(*****************************************************************************)
(* Print an acl2def                                                          *)
(*****************************************************************************)
fun print_acl2def out (defun(nam,th)) =
     (out "; Defun:    "; out nam; out "\n";
      print_mlsexp out (mk_mlsexp_defun th); out "\n\n")
 |  print_acl2def out (defaxiom(nam,tm)) =
     (out "; Defaxiom: "; out nam; out "\n";
      print_mlsexp out
       (mk_mlsexp_list
         [mldefaxiom, string_to_mlsym nam, term_to_mlsexp tm]); 
      out "\n\n")
 |  print_acl2def out (defthm(nam,tm)) =
     (out "; Defthm:   "; out nam; out "\n";
      print_mlsexp out
       (mk_mlsexp_list
         [mldefthm, string_to_mlsym nam, term_to_mlsexp tm]); 
      out "\n\n");

(*****************************************************************************)
(* Convert a preterm to a string (used for inputting ACL2)                   *)
(*****************************************************************************)
local 
fun drop_until_close [] = []              (* drop chars until comment closes *)
 |  drop_until_close (#"*" :: #")" :: l) = l
 |  drop_until_close (c :: l) =  drop_until_close l 
fun strip_comments [] = []                               (* remove comments *)
 |  strip_comments (#"(" :: #"*" :: l) = strip_comments(drop_until_close l)
 |  strip_comments (c :: l) =  c :: strip_comments l 
fun strip_loc s = implode(strip_comments(explode s))
fun unQUOTE(QUOTE s) = s                                   (* QUOTE s |--> s *)
 |  unQUOTE _ = err "unQUOTE" "not applied to a QUOTE"
in
val preterm_to_string = 
 foldr (fn(q,sl) => strip_loc(unQUOTE (q:term frag)) ^ "\n" ^ sl) ""
end;

(*****************************************************************************)
(* Absolute path of acl2 directory                                           *)
(*****************************************************************************)
val acl2_path = ref(Globals.HOLDIR ^ "/examples/acl2");

(*****************************************************************************)
(* Location of a2ml.csh tool for converting ACL2 files to ML files           *)
(*****************************************************************************)
val a2ml = ((!acl2_path) ^ "/lisp/a2ml.csh");

(*****************************************************************************)
(* Location of  pprint-file.csh. tool for pretty-printing ACL2 files         *)
(*****************************************************************************)
val pp = ((!acl2_path) ^ "/lisp/pprint-file.csh");

(*****************************************************************************)
(* Reference into which mlsexp generated by a2ml is put                      *)
(*****************************************************************************)
val acl2_list_ref = ref([] : mlsexp list);

(*****************************************************************************)
(* Convert a status to s string                                              *)
(*****************************************************************************)
fun status_to_string s =
 if s = Process.success then "success" else
 if s = Process.failure then "failure" else "not \"success\" or \"failure\"!";

(*****************************************************************************)
(* Print a list of ACL2 DEFUNs to a file defun-tmp.lisp,                     *)
(* then run a2ml to create defun-tmp.ml.                                     *)
(*****************************************************************************)
fun print_defuns_to_mlsexps ql =
 let val sl = map preterm_to_string ql
     val _ = print_lisp_file "defun-tmp" (fn pr => map pr sl)
     val a2ml_res =
          Process.system
           (a2ml ^ " defun-tmp.lisp defun-tmp.ml >& defun-tmp.log")
 in
  if not(a2ml_res = Process.success)
   then (print "a2ml defun-tmp.lisp defun-tmp.ml: ";
         print(status_to_string a2ml_res);
         print "\n";
         err "print_defuns_to_mlsexs" "a2ml failed") else
   ()
 end;

(*****************************************************************************)
(* Create a script file for a theory named thy that contains ACL2 DEFUNs ql  *)
(* and hol names specified in an alist name_alist                            *)
(*****************************************************************************)
fun print_acl2_defun_script thy ql name_alist =
 let val outstr = TextIO.openOut("header-tmp.ml")
     fun out s = TextIO.output(outstr,s)
 in
  out("(* File created from HOL using print_acl2_defun_script on " 
      ^ date() ^ " *)\n\n");    
  out "open HolKernel Parse boolLib bossLib;\n";
  out "open stringLib complex_rationalTheory gcdTheory sexp sexpTheory;\n";
(*out "val _ = (acl2_simps := (!acl2_simps)@(CONJUNCTS ACL2_SIMPS));\n";*)
  out ("val _ = new_theory \"" ^ thy ^ "\";");
  out "\n\n";
  out "val name_alist = \n";
  out(string_pair_list_to_string name_alist);
  out ";\n\n";
  TextIO.flushOut outstr;
  TextIO.closeOut outstr;
  print_defuns_to_mlsexps ql;
  Process.system
   ("cat header-tmp.ml defun-tmp.ml end-boilerplate.ml > " 
     ^ thy ^ "Script.sml")
 end;

(*****************************************************************************)
(* Apply mk_def and then overload a hol name on the defined constant,        *)
(* if it is found in a supplied alist                                        *)
(*****************************************************************************)
fun define_and_overload name_alist mlsexp =
 let val th =
      case mk_def mlsexp
       of defun(_,defth) => defth
       |   _             => err "new_defuns" "not a defun"
     val (opr,_) = strip_comb(lhs(concl(SPEC_ALL th)))
     val opr_name = fst(dest_const opr handle HOL_ERR _ => dest_var opr)
     val _ = case assoc2 opr_name name_alist
              of SOME(nam,_) => overload_on(nam,opr)
              |  _           => ()
 in
  th
 end;


(*****************************************************************************)
(* Add theory load time code to restore binding of acl2_simps in theory      *)
(*****************************************************************************)
fun save_acl2_simps () =  
 adjoin_to_theory
 {sig_ps = NONE,
  struct_ps =
    SOME(fn ppstrm => 
          PP.add_string ppstrm
           ("val _ = (sexp.acl2_simps :="
            ^"  (!sexp.acl2_simps)@(Drule.CONJUNCTS ACL2_SIMPS));"))
 };


(*****************************************************************************)
(* Add theory load time code to restore binding of current_package in theory *)
(*****************************************************************************)
fun save_current_package() = 
 adjoin_to_theory
 {sig_ps = NONE,
  struct_ps =
    SOME(fn ppstrm => 
          PP.add_string ppstrm
           ("val _ = sexp.set_current_package \"" 
            ^ (!current_package) ^ "\";"))
 };


(*****************************************************************************)
(* Add theory load time code to restore binding of acl2_name_list in theory  *)
(*****************************************************************************)
fun save_acl2_name_list () =
 adjoin_to_theory
 {sig_ps = NONE,
  struct_ps =
    SOME(fn ppstrm => 
          PP.add_string ppstrm
           ("val _ = sexp.add_acl2_names " ^ 
            string_pair_list_to_string(!acl2_name_list) ^
            ";"))
 };

(*****************************************************************************)
(* Save the acl2_simps, current_package, acl2_name_list then export theory   *)
(*****************************************************************************)
fun export_acl2_theory () =
 (save_thm("ACL2_SIMPS", LIST_CONJ(!acl2_simps));
  save_acl2_simps();
  save_current_package();
  save_acl2_name_list();
  export_theory());
  
(* Various snippets for testing

use "load_sexp.ml";
use "../lisp/defaxioms.lisp.trans.ml";

val defaxioms_list =
let fun wrap_mk_defs d = ([], [mk_defs d]) handle _ => ([d],[]);
    val _ = (printLength := 1000)
in
 time
 List.tabulate
  (length (!acl2_list_ref), 
   fn i => (print(Int.toString(i+1));
            print "\n";
            (i+1, time wrap_mk_defs (el (i+1) (!acl2_list_ref)))))
end;

print_lisp_file 
 "TestAll" 
 (fn out => mapfilter 
             (print_acl2def out)
             (rev(flatten (map (flatten o snd o snd) defaxioms_list))));  

print_lisp_file 
 "TestFn" 
 (fn out => (print_mlsexp out (mk_mlsexp_defun th); out "\n\n"));

val defaxioms_list = map mk_defs (!acl2_list_ref);

*)
