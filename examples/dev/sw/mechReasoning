
app load ["relationTheory", "pred_setSimps","pred_setTheory","whileTheory","finite_mapTheory","rich_listTheory", "listSyntax", 
          "annotatedIL", "rulesTheory"];

open HolKernel Parse boolLib bossLib numLib pairLib relationTheory pairTheory arithmeticTheory listSyntax preARMTheory
     pred_setSimps pred_setTheory listTheory rich_listTheory whileTheory finite_mapTheory annotatedIL rulesTheory;

(*---------------------------------------------------------------------------------*)
(*      Simplifier on finite maps                                                  *) 
(*---------------------------------------------------------------------------------*)

val fupdate_normalizer =
 let val thm = SPEC_ALL FUPDATE_LT_COMMUTES
     val pat = lhs(snd(dest_imp(concl thm)))
 in
   {name = "Finite map normalization",
    trace = 2,
    key = SOME([],pat),
    conv = let fun reducer tm =
                 let val (theta,ty_theta) = match_term pat tm
                     val thm' = INST theta (INST_TYPE ty_theta thm)
                     val constraint = fst(dest_imp(concl thm'))
                     val cthm = EQT_ELIM(reduceLib.REDUCE_CONV constraint)
                 in MP thm' cthm
                 end
           in
               K (K reducer)
           end}
 end;

val finmap_conv_frag =
 simpLib.SSFRAG
     {convs = [fupdate_normalizer],
      rewrs = [], ac=[],filter=NONE,dprocs=[],congs=[]};

val finmap_ss = bossLib.std_ss ++ finmap_conv_frag ++ rewrites [FUPDATE_EQ, FAPPLY_FUPDATE_THM];

val set_ss = std_ss ++ SET_SPEC_ss ++ PRED_SET_ss;

(*---------------------------------------------------------------------------------*)
(*      Symbolic Simulation of Basic Blocks                                        *) 
(*---------------------------------------------------------------------------------*)

(* make variable tuple, e.g. ((v0,v1),v2,...) *)
fun mk_vars exp =
  let
    val i = ref (~1);
    fun set_vars (annotatedIL.PAIR (e1,e2)) =
          mk_pair(set_vars e1, set_vars e2)
     |  set_vars exp =
          mk_var ("v" ^ (i := !i + 1; Int.toString (!i)) , Type `:DATA`)
  in
    set_vars exp 
  end

(* make mread tuple, e.g. ((st<v0>,st<v1>),st<v2>,...) *)
fun mk_mreads st (annotatedIL.PAIR (e1,e2)) =
        mk_pair(mk_mreads st e1, mk_mreads st e2)
 |  mk_mreads st exp =
        mk_comb ( mk_comb (Term`mread`, st), convert_exp exp)
  handle e => (print "mk_mreads: invalid incoming expression"; Raise e);


(* make a list of rules [exp0 <- v0, exp1 <- v1, ...] *)
fun mk_subst_rules expL =
  let
    val i = ref (~1);
  in 
    List.map (fn exp => (i := !i + 1; {redex = exp, residue = mk_var ("v" ^ (Int.toString (!i)), Type `:DATA`)})) expL
  end
  
(* eliminate all "decode"s and get the new state *) 
fun elim_decode th = 
  if is_pair (rhs (concl th)) then
     th
  else
     let val th' = (CONV_RULE (DEPTH_CONV (
		         REWRITE_CONV [Once mdecode_def] THENC 
			 SIMP_CONV finmap_ss [write_thm, read_thm, toMEM_def, toEXP_def, toREG_def, index_of_reg_def]))) th
     in  elim_decode th'
     end
  handle e => (print "get_blk_spec: errors occur while symbolically simulating a block"; Raise e);

      
(* Given an basic block, the charateristic function on inputs and outputs are derived by symbolic simulation *)
(* and the context about unchanged variables is maintained                                                   *) 
(* Finally well_formed information is given                                                                  *)

fun mk_blk_spec ir = 
  let 
      fun break_ir (BLK (instL,{ins = ins1, outs = outs1, context = context1, spec = blk_spec})) = 
                               (instL,ins1,outs1,context1)
       |  break_ir _ = raise invalidILExp;
     
      val (instL,ins,outs,context) = break_ir ir;

      val ir_t = mk_comb (``BLK``, mk_list (List.map convert_stm instL, Type`:DOPER`));
      val st = mk_pair (mk_var ("regs", Type `:num |-> DATA`), mk_var ("mem", Type `:num |-> DATA`));
      val instance = list_mk_comb (``run_ir:CTL_STRUCTURE -> DSTATE -> DSTATE``, [ir_t, st]);
      val th0 =  REWRITE_CONV [IR_SEMANTICS_BLK] instance;            

      val th1 = elim_decode th0;              (* symbolically simulate the block *)
      val new_st = rhs (concl th1);

      fun read_one_var s exp = 
          let val v0 = list_mk_comb (Term`mread`, [s, convert_exp exp]);
              val v1 = rhs (concl (SIMP_CONV finmap_ss [mread_def, toMEM_def, toREG_def, index_of_reg_def, read_thm] v0))
	  in v1
	  end

      fun calculate_outs (PAIR (a,b)) = 
              mk_pair (calculate_outs a, calculate_outs b)
       |  calculate_outs exp =
              read_one_var new_st exp

      val rules = mk_subst_rules (List.map (read_one_var st) (pair2list ins));

      val (initV,out_vars) = (mk_vars ins, mk_vars outs);      
      val f_c = mk_pabs (initV, subst rules (calculate_outs outs));  (* the charateristic function *)
      val st' = mk_var ("st", Type `:DSTATE`);

      (* the characteristic function *)
      val (in_f,out_f) = (mk_pabs (st', mk_mreads st' ins), mk_pabs (st', mk_mreads st' outs));
      val f_spec = list_mk_comb (inst [{redex = alpha, residue = type_of initV}, {redex = beta, residue = type_of out_vars}] ``PSPEC``, 
                                [ir_t, list_mk_pair[in_f,f_c,out_f]]);

      (* context function *)
      val context_spec = list_mk_comb (Term`UNCHANGED`, [ir_t, mk_list (List.map convert_exp context, Type `:MEXP`)]);
      
      (* well_formedness *)
      val wf_spec = mk_comb (Term`WELL_FORMED`, ir_t);

      val spec = list_mk_conj [f_spec, context_spec, wf_spec]

   in
      prove (spec,   (* set_goal ([],spec) *)
             SIMP_TAC std_ss [PSPEC_def, HSPEC_def, UNCHANGED_def, FORALL_DSTATE, BLOCK_IS_WELL_FORMED] THEN
                 REWRITE_TAC [th1] THEN
                 SIMP_TAC list_ss [mread_def, toMEM_def, toREG_def, index_of_reg_def, read_thm] THEN
                 SIMP_TAC finmap_ss []
            )
   end;


(*---------------------------------------------------------------------------------*)
(*      Specification for Tail Recursion                                           *) 
(*---------------------------------------------------------------------------------*)

(* Given a TR, the charateristic function on inputs and outputs are derived by the TR_RULE *)
(* and the context about unchanged variables is maintained                                 *) 

(* get the charateristic function from a specification *)
fun get_spec_info (f_spec, context_spec) = 
    let val (_, [ir, fs]) = strip_comb f_spec;
        val list0 = strip_pair fs;
        val (ins, f_c, outs) = (#2 (dest_abs (hd list0)), List.nth(list0,1), #2 (dest_abs (List.nth(list0,2))));
        val contextL = List.nth(#2 (strip_comb context_spec),1)
    in
       (ir, (ins, f_c, outs),contextL)
    end
     handle e => (print "get_spec_info: the input is not valid PSPEC and UNCHANGED"; Raise e);

fun convert_cond (exp1, rop, exp2) =
  let
    val cond_t0 = list_mk_pair [mk_comb (``toEXP``, convert_exp exp1), 
				convert_rop rop, 
				mk_comb (``toEXP``, convert_exp exp2)];
    val cond_t1 = rhs (concl (SIMP_CONV std_ss [toEXP_def, toMEM_def, toREG_def, index_of_reg_def] cond_t0))
  in
    cond_t1
  end
  handle e => (print "mk_cond: errors occur while converting the condition"; Raise e);

fun strip_pair2 t =
  if is_pair t then List.foldl (fn (t0,L0) => L0 @ (strip_pair2 t0)) [] (strip_pair t)
  else [t];

fun mk_cj_cond cond_t ins =
  let 
    val st = mk_var ("st", Type `:DSTATE`);
    val instance = list_mk_comb (``eval_cond``, [cond_t, st]);

    val read_const_th = prove (``!st v. read st (WCONST v) = v``, SIMP_TAC std_ss [FORALL_DSTATE, read_thm]); 

    val th0 = REWRITE_CONV [ARMCompositionTheory.eval_cond_def] instance;
    val th1 = REWRITE_RULE [read_const_th] th0;
    val instance1 = rhs (concl th1);

    val rules = mk_subst_rules (List.map (fn t0 => rhs (concl (REWRITE_CONV [mread_def, toMEM_def, toREG_def, index_of_reg_def] t0))) (strip_pair2 ins));
    val cj_cond = subst rules instance1  (* the condition function *)
  in
     cj_cond
  end

fun mk_cond_f cond_t ins =                  (* the condition function *)
    let 
        val rules = mk_subst_rules (strip_pair2 ins)
    in 
        mk_pabs (subst rules ins, mk_cj_cond cond_t ins)
    end

fun guessR2 tp = 
    let val tp1 = List.nth(#2 (dest_type tp),1)
    in
        inst [alpha |-> tp1] ``measure (w2n o FST )``
    end

fun cheat_tac (asl,g) = ACCEPT_TAC(ASSUME g) (asl,g);


fun mk_tr_spec cond body_spec = 
  let 
      val specL = strip_conj (concl body_spec);
      val (body_ir,(ins,f,outs),contextL) = get_spec_info (hd specL, hd (tl specL));

      val t_cond = convert_cond cond;
      val tr_ir = list_mk_comb (``TR``, [t_cond, body_ir]);
      val st = mk_var ("st", Type `:DSTATE`);
      val instance = list_mk_comb (``run_ir:CTL_STRUCTURE -> DSTATE -> DSTATE``, [tr_ir, st]);
      
      val initV = #1 (dest_pabs f);

      val cond_f_0 = mk_cond_f t_cond ins;
      val cond_f = list_mk_comb (inst [alpha |-> bool, beta |-> bool, gamma |-> type_of initV] ``$o``, [``$~:bool->bool``,cond_f_0]);

      val tr_f = list_mk_comb (inst [alpha |-> type_of initV] ``WHILE``, [cond_f, f]);
      val prj_f = mk_pabs (st,ins);
       
      (* well_founded relation: WF (\st1 st0. ~eval_cond cond st0 /\ (st1 = run_ir ir st0)) *)
      
      val (st0,st1) = (mk_var ("st0", Type `:DSTATE`), mk_var ("st1", Type `:DSTATE`));
      val wf_t0 = mk_neg (list_mk_comb (``eval_cond``, [t_cond, st0]));
      val wf_t1 = mk_eq (st1, list_mk_comb (``run_ir``, [body_ir, st0]));
      val wf_t2 = list_mk_abs ([st1,st0],mk_conj(wf_t0,wf_t1));
      val wf_t3 = mk_comb (inst [alpha |-> Type `:DSTATE`] ``WF``, wf_t2);
      val wf_th = prove (wf_t3, (* set_goal ([],wf_t3) *)
                         MATCH_MP_TAC (INST_TYPE [alpha |-> type_of initV] WF_TR_LEM_2) THEN
                         EXISTS_TAC prj_f THEN
                         EXISTS_TAC f THEN
                         EXISTS_TAC cond_f_0 THEN
                         SIMP_TAC std_ss [SIMP_RULE std_ss [PSPEC_def, HSPEC_def] body_spec] THEN
                         SIMP_TAC std_ss [ARMCompositionTheory.eval_cond_def, FORALL_DSTATE, mread_def, 
                                         index_of_reg_def,toREG_def, toMEM_def, read_thm] THEN
                         MATCH_MP_TAC (INST_TYPE [alpha |-> type_of initV] WF_TR_LEM_3) THEN
                         (let val r = guessR2 (type_of initV) in 
                              WF_REL_TAC `^r`
                          end
                          handle e => (print "fail to prove totalness, add statement into assumption list"; cheat_tac)
                         )
                         );

      (* the characteristic function *)
      val f_spec = list_mk_comb (inst [alpha |-> type_of initV, beta |-> type_of initV] ``PSPEC``, 
                                [tr_ir, list_mk_pair[prj_f,tr_f,prj_f]]);

      val f_th =  prove (f_spec,   (* set_goal ([],f_spec) *)
                        ASSUME_TAC wf_th THEN
                        MATCH_MP_TAC PROJ_TR_RULE THEN
                        SIMP_TAC std_ss [body_spec] THEN
                        STRIP_TAC THENL [
                            RW_TAC std_ss [],
                            SIMP_TAC std_ss [ARMCompositionTheory.eval_cond_def, FORALL_DSTATE, mread_def, 
                                         index_of_reg_def, toREG_def, toMEM_def, read_thm]
                            ]
		        )

      (* context function *)
      val context_spec = list_mk_comb (Term`UNCHANGED`, [tr_ir, contextL]);
      val context_th = prove (context_spec,   (* set_goal ([],context_spec) *)
                      ASSUME_TAC wf_th THEN
                      MATCH_MP_TAC CONTEXT_TR_RULE THEN
                      SIMP_TAC std_ss [body_spec] THEN
                      RW_TAC std_ss []
	        )

      val well_formed_spec = mk_comb (``WELL_FORMED``, tr_ir);
      val well_formed_th = prove (well_formed_spec,   (* set_goal ([],well_formed_spec) *)
                      ASSUME_TAC wf_th THEN
                      MATCH_MP_TAC WELL_FORMED_TR_RULE THEN
                      SIMP_TAC std_ss [body_spec] THEN
                      RW_TAC std_ss []
	        );

      val spec = list_mk_conj [f_spec, context_spec, well_formed_spec];

      val th =  prove (spec,   (* set_goal ([],spec) *)
			SIMP_TAC std_ss [f_th, context_th, well_formed_th]
		      )
   in
        th
   end;



(*---------------------------------------------------------------------------------*)
(*      Specification for Sequential Composition                                   *) 
(*---------------------------------------------------------------------------------*)

fun mk_sc_spec ir1_spec ir2_spec = 
  let 

      val (specL1,specL2) = (strip_conj (concl ir1_spec), strip_conj (concl ir2_spec));
      val (ir1,(ins1,f1,outs1),contextL1) = get_spec_info (hd specL1, hd (tl specL1));
      val (ir2,(ins2,f2,outs2),contextL2) = get_spec_info (hd specL2, hd (tl specL2));

      val sc_ir = list_mk_comb (``SC``, [ir1, ir2]);
      val st = mk_var ("st", Type `:DSTATE`);
      val instance = list_mk_comb (``run_ir:CTL_STRUCTURE -> DSTATE -> DSTATE``, [sc_ir, st]);
      
      val sc_f = list_mk_comb (inst [alpha |-> type_of ins2, beta |-> type_of outs2, gamma |-> type_of ins1] ``$o``, [f2,f1]);
      val (in_f,out_f) = (mk_pabs (st,ins1), mk_abs (st,outs2));
      val out_f1 = mk_pabs (st, outs1);       

      (* the characteristic function *)
      val f_spec = list_mk_comb (inst [alpha |-> type_of ins1, beta |-> type_of outs2] ``PSPEC``, 
                                [sc_ir, list_mk_pair[in_f,sc_f,out_f]]);

      val f_th =  prove (f_spec,   (* set_goal ([],f_spec) *)
                        MATCH_MP_TAC PROJ_SC_RULE THEN
                        EXISTS_TAC out_f1 THEN
                        SIMP_TAC std_ss [ir1_spec, ir2_spec]
		        )

      (* context function *)
      val context_spec = list_mk_comb (Term`UNCHANGED`, [sc_ir, contextL2]);
      val context_th = prove (context_spec,   (* set_goal ([],context_spec) *)
                      MATCH_MP_TAC CONTEXT_SC_RULE THEN
                      SIMP_TAC std_ss [ir1_spec, ir2_spec]
	        )

      val well_formed_spec = mk_comb (``WELL_FORMED``, sc_ir);
      val well_formed_th = prove (well_formed_spec,   (* set_goal ([],well_formed_spec) *)
                      MATCH_MP_TAC IR_SC_IS_WELL_FORMED THEN
                      SIMP_TAC std_ss [ir1_spec, ir2_spec]
	        );

      val spec = list_mk_conj [f_spec, context_spec, well_formed_spec];

      val th =  prove (spec,   (* set_goal ([],spec) *)
			SIMP_TAC std_ss [f_th, context_th, well_formed_th]
		      )
   in
        th
   end;

(*---------------------------------------------------------------------------------*)
(*      Specification for Conditional Jumps                                        *) 
(*---------------------------------------------------------------------------------*)
 
fun mk_cj_spec cond ir1_spec ir2_spec = 
  let 
      val (specL1,specL2) = (strip_conj (concl ir1_spec), strip_conj (concl ir2_spec));
      val (ir1,(ins1,f1,outs1),contextL1) = get_spec_info (hd specL1, hd (tl specL1));
      val (ir2,(ins2,f2,outs2),contextL2) = get_spec_info (hd specL2, hd (tl specL2));

      val t_cond = convert_cond cond;
      val cj_ir = list_mk_comb (``CJ``, [t_cond, ir1, ir2]);
      val st = mk_var ("st", Type `:DSTATE`);
      val instance = list_mk_comb (``run_ir:CTL_STRUCTURE -> DSTATE -> DSTATE``, [cj_ir, st]);
      
      val initV = #1 (dest_pabs f1);
      val cj_cond = mk_pabs(initV, mk_cj_cond t_cond ins1);
      val cj_f = mk_pabs(initV, list_mk_comb (inst [alpha |-> type_of outs1] ``COND``, [mk_comb(cj_cond,initV), mk_comb(f1,initV), mk_comb(f2,initV)]));

      val (in_f,out_f) = (mk_pabs (st,ins1), mk_abs (st,outs2));

      (* the characteristic function *)
      val f_spec = list_mk_comb (inst [alpha |-> type_of ins1, beta |-> type_of outs2] ``PSPEC``, 
                                [cj_ir, list_mk_pair[in_f,cj_f,out_f]]);

      val f_th =  prove (f_spec,   (* set_goal ([],f_spec) *)
                        MATCH_MP_TAC (SIMP_RULE std_ss [LAMBDA_PROD] (INST_TYPE [alpha |-> type_of initV] PROJ_CJ_RULE)) THEN
                        SIMP_TAC std_ss [ir1_spec, ir2_spec] THEN
                        SIMP_TAC std_ss [ARMCompositionTheory.eval_cond_def, FORALL_DSTATE, mread_def, 
                                         index_of_reg_def, toREG_def, toMEM_def, read_thm, GSYM PFORALL_THM]
		        )

      (* context function *)
      val context_spec = list_mk_comb (Term`UNCHANGED`, [cj_ir, contextL2]);
      val context_th = prove (context_spec,   (* set_goal ([],context_spec) *)
                      MATCH_MP_TAC CONTEXT_CJ_RULE THEN
                      SIMP_TAC std_ss [ir1_spec, ir2_spec]
	        )

      val well_formed_spec = mk_comb (``WELL_FORMED``, cj_ir);
      val well_formed_th = prove (well_formed_spec,   (* set_goal ([],well_formed_spec) *)
                      MATCH_MP_TAC IR_CJ_IS_WELL_FORMED THEN
                      SIMP_TAC std_ss [ir1_spec, ir2_spec]
	        );

      val spec = list_mk_conj [f_spec, context_spec, well_formed_spec];

      val th =  prove (spec,   (* set_goal ([],spec) *)
			SIMP_TAC std_ss [f_th, context_th, well_formed_th]
		      )
   in
        th
   end;


(*---------------------------------------------------------------------------------*)
(*      Forward Reasoning                                                          *) 
(*---------------------------------------------------------------------------------*)

fun fwd_reason (TR (cond, body, {spec = spec1, ins = ins1, outs = outs1, context = contextL})) = 
      let val body_spec = fwd_reason body;
      in
          mk_tr_spec cond body_spec
      end

 |  fwd_reason (SC (ir1, ir2, {spec = spec1, ins = ins1, outs = outs1, context = contextL})) =
      mk_sc_spec (fwd_reason ir1) (fwd_reason ir2)

 |  fwd_reason (CJ (cond, ir1, ir2, {spec = spec1, ins = ins1, outs = outs1, context = contextL})) =
      mk_cj_spec cond (fwd_reason ir1) (fwd_reason ir2)

 |  fwd_reason (BLK blk_ir) =
      mk_blk_spec (BLK blk_ir)
 ;


(*---------------------------------------------------------------------------------*)
(*      Display the theorem at the level of ARM flat code                          *) 
(*---------------------------------------------------------------------------------*)

fun f_correct spec =
  let
      val th0 = CONJUNCT1 spec;
      val th1 = SIMP_RULE std_ss [PSPEC_def, HSPEC_def, run_ir_def] th0;
      val th2 = SIMP_RULE std_ss [translate_def, translate_assignment_def, toEXP_def, toREG_def, toMEM_def, index_of_reg_def] th1;
      val th3 = SIMP_RULE list_ss [ARMCompositionTheory.mk_SC_def, ARMCompositionTheory.mk_CJ_def, ARMCompositionTheory.mk_TR_def] th2
  in
      th3
  end
     

(*---------------------------------------------------------------------------------*)
(*      Examples                                                         *) 
(*---------------------------------------------------------------------------------*)

(*---------------------------------------------------------------------------------*)

val fact_def = Define `
   fact (x:DATA,a) = if x=0w then a else fact(x-1w,x*a)`;

val fact_thm = Q.store_thm (
   "fact_thm",
   `fact = (\(x,a).a) o (WHILE ($~ o (\(x,a).x = 0w)) (\(x,a).(x-1w,x*a)))`,
   SIMP_TAC std_ss [FUN_EQ_THM, FORALL_PROD] THEN
   HO_MATCH_MP_TAC (fetch "-" "fact_ind") THEN
   REPEAT STRIP_TAC THEN
   ONCE_REWRITE_TAC [fact_def, WHILE] THEN
   RW_TAC std_ss []
  );

(*
val (fact_ins,fact_ir,fact_outs) = sfl2ir fact_def;
val fact_spec = fwd_reason fact_ir;
val stat1 = f_correct fact_spec;
val stat2 = SIMP_RULE std_ss [GSYM (SIMP_RULE std_ss [FORALL_PROD, FUN_EQ_THM] fact_thm)] stat1;
*)

(*---------------------------------------------------------------------------------*)

val f1_def = Define `
    f1 (a,b) = if a = 1w then b else a + b`;

(*
val (f1_ins,f1_ir,f1_outs) = sfl2ir f1_def;
val f1_spec = fwd_reason f1_ir;
val stat1 = f_correct f1_spec;
*)

(*---------------------------------------------------------------------------------*)

val ShiftXor_def =
 Define
   `ShiftXor (x,s,k0,k1) = ((x << 4) + k0) # (x + s) # ((x >> 5) + k1)`;

(*
val (ShiftXor_ins,ShiftXor_ir,ShiftXor_outs) = sfl2ir ShiftXor_def;
val ShiftXor_spec = fwd_reason ShiftXor_ir;
val stat1 = f_correct ShiftXor_spec;
*)

