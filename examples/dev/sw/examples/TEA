(*---------------------------------------------------------------------------*)
(* A version of TEA, taken from examples/Crypto/TEA                          *)
(*---------------------------------------------------------------------------*)

(*---------------------------------------------------------------------------*)
(* Cipher types                                                              *)
(*---------------------------------------------------------------------------*)

val _ = type_abbrev("block", ``:word32 # word32``);
val _ = type_abbrev("key",   ``:word32 # word32 # word32 # word32``);
val _ = type_abbrev("state", ``:block # key # word32``);

(* --------------------------------------------------------------------------*)
(* Definitions used in Round computations                                    *)
(* --------------------------------------------------------------------------*)

val FORALL_TEA_BLOCK = Q.store_thm
  ("FORALL_TEA_STATE",
    `(!s:block. P s) =
        !v0 v1. P (v0,v1)`,
    SIMP_TAC std_ss [FORALL_PROD]);

val FORALL_TEA_KEY = Q.store_thm
  ("FORALL_TEA_STATE",
    `(!s:key. P s) =
        !k0 k1 k2 k3. P (k0,k1,k2,k3)`,
    SIMP_TAC std_ss [FORALL_PROD]);

val FORALL_TEA_STATE = Q.store_thm
  ("FORALL_TEA_STATE",
    `(!s:state. P s) = 
        !y z k0 k1 k2 k3 sum. P ((y,z),(k0,k1,k2,k3),sum)`,
    SIMP_TAC std_ss [FORALL_PROD]);


val env0 = [];

val DELTA_def = Define `DELTA = 0x9e3779b9w`;

(* Fails ... what to do about constants? *)
(*toANF [] DELTA_def;*)   

val ShiftXor_def = 
 Define 
   `ShiftXor (x,s,k0,k1) = ((x << 4) + k0) # (x + s) # ((x >> 5) + k1)`;

val env1 = toANF [] ShiftXor_def;
val arm1 = compileEnv env1;

val ShiftXor_CORRECT = prove (
   simT (mk_ARM arm1),
   SEQ_TAC [ShiftXor_def]
  ); 

(******************************************************************
  Name              : ShiftXor
  Arguments         : r0 r1 r2 r3
  Modified Registers: r0 r1 r2 r4
  Returns           : r0
  Body:
    0:          mov     ip, sp
    1:          stmfd   sp!, {fp,ip,lr,pc}
    2:          sub     fp, ip, #1i
    3:          lsl     r4, r0, #4i
    4:          add     r2, r4, r2
    5:          add     r1, r0, r1
    6:          eor     r1, r2, r1
    7:          asr     r0, r0, #5i
    8:          add     r0, r0, r3
    9:          eor     r0, r1, r0
   10:          sub     sp, fp, #3i
   11:          ldmfd   sp, {fp,sp,pc}
*)

(* --------------------------------------------------------------------------*)
(*	One round forward computation    				     *)
(* --------------------------------------------------------------------------*)

val Round_def = 
 Define
   `Round ((y,z),(k0,k1,k2,k3),sum):state  = 
      ((y + ShiftXor(z, sum+DELTA, k0, k1),
        z + ShiftXor(y + ShiftXor(z, sum+DELTA, k0, k1), sum+DELTA, k2, k3)),
       (k0,k1,k2,k3), 
       sum+DELTA)`;

   val env2 = toANF env1 (REWRITE_RULE [DELTA_def] Round_def);	
   val arm2 = compileEnv env2;

val Round_CORRECT = prove (
   simT (mk_ARM arm2),
   SEQ_TAC [Round_def, ShiftXor_def, DELTA_def]
  );


(******************************************************************
  Name              : Round
  Arguments         : r0 r1 r2 r3 r4 r5 r6 
  Modified Registers: r0 r1 r7 r8 
  Returns           : r8 r1 r2 r3 r4 r5 r0 
  Body: 
    0:          mov     ip, sp
    1:          stmfd   sp!, {fp,ip,lr,pc}
    2:          sub     fp, ip, #1i
    3:          add     r7, r6, #2654435769iw
    4:          sub     sp, sp, #1i
    5:          stmfd   sp!, {r1,r7,r2,r3}
    6:          bl      + (24)
    7:          add     sp, sp, #4i
    8:          ldr     r7, [sp, #1]
    9:          add     sp, sp, #1i
   10:          add     r8, r0, r7
   11:          add     r7, r6, #2654435769iw
   12:          sub     sp, sp, #1i
   13:          stmfd   sp!, {r1,r7,r2,r3}
   14:          bl      + (16)
   15:          add     sp, sp, #4i
   16:          ldr     r7, [sp, #1]
   17:          add     sp, sp, #1i
   18:          add     r7, r0, r7
   19:          add     r0, r6, #2654435769iw
   20:          sub     sp, sp, #1i
   21:          stmfd   sp!, {r7,r0,r4,r5}
   22:          bl      + (8)
   23:          add     sp, sp, #4i
   24:          ldr     r0, [sp, #1]
   25:          add     sp, sp, #1i
   26:          add     r1, r1, r0
   27:          add     r0, r6, #2654435769iw
   28:          sub     sp, fp, #3i
   29:          ldmfd   sp, {fp,sp,pc}
  *****************************************************************
  Name              : ShiftXor
  Arguments         : r0 r1 r2 r3 
  Modified Registers: r0 r1 r2 r4 
  Returns           : r0 
  Body: 
   30:          mov     ip, sp
   31:          stmfd   sp!, {r0,r1,r2,r3,r4,ip,fp,ip,lr,pc}
   32:          sub     fp, ip, #1i
   33:          ldmfd   ip, {r0,r1,r2,r3}
   34:          add     ip, ip, #4i
   35:          lsl     r4, r0, #4i
   36:          add     r2, r4, r2
   37:          add     r1, r0, r1
   38:          eor     r1, r2, r1
   39:          asr     r0, r0, #5i
   40:          add     r0, r0, r3
   41:          eor     r0, r1, r0
   42:          add     sp, fp, #6i
   43:          str     r0, [sp]
   44:          sub     sp, sp, #1i
   45:          sub     sp, fp, #9i
   46:          ldmfd   sp, {r0,r1,r2,r3,r4,ip,fp,sp,pc}
*)

(*---------------------------------------------------------------------------*)
(* Arbitrary number of cipher rounds                                         *)
(*---------------------------------------------------------------------------*)

(* In the following, we work on a simpler Round function while proceeding the Rounds *)

val Round_def =
 Define
   `Round ((y,z),(k0,k1,k2,k3),sum):state  =
      ((y,z),
       (k0,k1,k2,k3),
       sum+1w)`;

val env2 = toANF [] Round_def;
val arm2 = compileEnv env2;

(*****************************************************************
  Name              : Round
  Arguments         : r0 r1 r2 r3 r4 r5 r6 
  Modified Registers: r6 
  Returns           : r0 r1 r2 r3 r4 r5 r6 
  Body: 
    0:          mov     ip, sp
    1:          stmfd   sp!, {fp,ip,lr,pc}
    2:          sub     fp, ip, #1i
    3:          add     r6, r6, #1iw
    4:          sub     sp, fp, #3i
    5:          ldmfd   sp, {fp,sp,pc}
*)

val (Rounds_def, Rounds_ind) = Defn.tprove
 (Hol_defn
   "Rounds"
   `Rounds (n,s:state) = if n=0w then s else Rounds (n-1w, Round s)`,
  WF_REL_TAC `measure (w2n o FST)` THEN
  METIS_TAC [WORD_PRED_THM]);

val env3 = toANF env2 (SIMP_RULE std_ss [FORALL_TEA_STATE, Round_def, DELTA_def] (GEN_ALL Rounds_def));
val arm3 = compileEnv env3;

(******************************************************************
  Name              : Rounds
  Arguments         : r0 r8 r5 r4 r3 r2 r6 r7 
  Modified Registers: r0 r1 r2 r3 r4 r5 r8 r9 
  Returns           : r8 r5 r4 r3 r2 r1 r0 
  Body: 
    0:          mov     ip, sp
    1:          stmfd   sp!, {fp,ip,lr,pc}
    2:          sub     fp, ip, #1i
    3:          cmp     r0, #0iw
    4:          beq     + (7)
    5:          sub     r9, r0, #1iw
    6:          add     r1, r7, #1iw
    7:          stmfd   sp!, {r9,r8,r5,r4,r3,r2,r6,r1}
    8:          ldmfd   sp, {r0,r8,r5,r4,r3,r2,r6,r7}
    9:          add     sp, sp, #8i
   10:          bal     - (7)
   11:          mov     r1, r6
   12:          mov     r0, r7
   13:          sub     sp, fp, #13i
   14:          ldmfd   sp, {fp,sp,pc}
*)

(*
  set_goal ([], simT (mk_ARM arm3))

  REPEAT GEN_TAC THEN
  STRIP_TAC THEN POP_ASSUM MP_TAC THEN
  ASM_REWRITE_TAC [] THEN

        (*  Process the first three instructions :
    		0:          mov     ip, sp
    		1:          stmfd   sp!, {fp,ip,lr,pc}
    		2:          sub     fp, ip, #1i
        *)

  NTAC 3 (ONE_STEP_TAC) THEN

  	(*  Process the recursive body			*)

	REPEAT (POP_ASSUM (K ALL_TAC)) THEN
             
        `!cpsr regs mems. ?k. (((pc',cpsr',regs',mems') = run k (instB,15) (3,cpsr,regs,mems)) /\ 
			(regs ' 13 = 96w)) ==>
		((pc' = 13) /\  (((regs' ' 8,regs' ' 5),(regs' ' 4,regs' ' 3,regs' ' 2,regs' ' 1),regs' ' 0) =
       			Rounds (regs ' 0,(regs ' 8,regs ' 5), (regs ' 4,regs ' 3,regs ' 2,regs ' 6),regs ' 7)))` 
				by ALL_TAC THENL [
	    Induct_on `w2n (regs ' 0)` THEN REPEAT STRIP_TAC THENL [

		(* Basic case					*)

		`regs ' 0 = n2w 0` by METIS_TAC [w2n_ELIM] THEN
		Q.PAT_ASSUM  `0 = i` (K ALL_TAC) THEN
		Q.EXISTS_TAC `4` THEN 
		NTAC 4 ONE_STEP_TAC THEN REWRITE_TAC [Once Rounds_def, RUN_LEM_1] THEN
		RW_TAC list_ss [ABS_PAIR_THM,NOT_EQ_FAPPLY,FUPDATE_EQ,FAPPLY_FUPDATE],

                (* Inductive case                                   *)

		FULL_SIMP_TAC list_ss [GSYM RIGHT_FORALL_IMP_THM] THEN
		`?pc1 cpsr1 regs1 mems1. run 8 (instB,15) (3,cpsr,regs,mems) = (pc1,cpsr1,regs1,mems1)`
                        by METIS_TAC [ABS_PAIR_THM] THEN
		PAT_ASSUM ``!regs1 cpsr mems.x`` (ASSUME_TAC o Q.SPECL [`regs1`,`cpsr1`,`mems1`]) THEN 
		FULL_SIMP_TAC list_ss [GSYM RIGHT_EXISTS_IMP_THM] THEN
 
		Q.EXISTS_TAC `8 + k` THEN REWRITE_TAC [RUN_THM_1] THEN 
		Q.ABBREV_TAC `runf = run k (instB,15)` THEN ASM_REWRITE_TAC [] THEN 
		STRIP_TAC THEN

		IMP_RES_TAC WORD_IND_LEM THEN
		Q.PAT_ASSUM `run 8 (instB,15) x = y` (MP_TAC) THEN
		NTAC 8 ONE_STEP_TAC THEN
		STRIP_TAC THEN

		PAT_ASSUM (Term `v = w2n (regs0 ' 0 - 1w)`) (ASSUME_TAC o WORD_RULE) THEN
		`v = w2n (regs1 ' 0)` by RW_TAC list_ss [NOT_EQ_FAPPLY,FUPDATE_EQ,FAPPLY_FUPDATE] THEN 

		REWRITE_TAC [Once Rounds_def, Round_def] THEN
		WORD_TAC THEN

		`(regs ' 0 +  4294967295w = regs1 ' 0) /\ 
		(regs ' 7 + 1w =  regs1 ' 7)` by RW_TAC arith_ss [NOT_EQ_FAPPLY,FUPDATE_EQ,FAPPLY_FUPDATE] THEN
		`(regs1 ' 8 = regs ' 8) /\ (regs1 ' 5 = regs ' 5) /\ (regs1 ' 4 = regs ' 4) /\ (regs1 ' 3 = regs ' 3) /\
		 (regs1 ' 2 = regs ' 2) /\ (regs1 ' 2 = regs ' 2) /\ 
		 (regs1 ' 13 = 96w)` by METIS_TAC [FAPPLY_FUPDATE, NOT_EQ_FAPPLY] THEN

		FULL_SIMP_TAC list_ss [ABS_PAIR_THM, FUPDATE_COMMUTES,NOT_EQ_FAPPLY,FUPDATE_EQ,FAPPLY_FUPDATE,LET_THM]
			]
		],
	
	(*  Process the last two instructions :
		  14:          sub     sp, fp, #2
   		  15:          ldmfd   sp, {fp,sp,pc}
	*)


    ] 		

*)

(*---------------------------------------------------------------------------*)
(* Encrypt  (32 rounds)                                                      *)
(*---------------------------------------------------------------------------*)

val TEAEncrypt_def = 
 Define 
   `TEAEncrypt (keys,txt) = 
      let (cipheredtxt,keys,sum) = Rounds(32w,(txt,keys,0w)) in
      cipheredtxt`;


val env4 = toANF env3 (SIMP_RULE std_ss [FORALL_TEA_BLOCK, FORALL_TEA_KEY] (GEN_ALL TEAEncrypt_def));
val arm4 = compileEnv env4;

(******************************************************************
  Name              : TEAEncrypt
  Arguments         : r0 r1 r2 r3 r4 r5 
  Modified Registers: r0 r1 r2 r3 r4 r5 r6 
  Returns           : r6 r5 
  Body: 
    0:          mov     ip, sp
    1:          stmfd   sp!, {fp,ip,lr,pc}
    2:          sub     fp, ip, #1i
    3:          sub     sp, sp, #7i
    4:          mov     r10, #0iw
    5:          str     r10, [sp]
    6:          sub     sp, sp, #1i
    7:          stmfd   sp!, {r4,r5,r0,r1,r2,r3}
    8:          mov     r10, #32iw
    9:          str     r10, [sp]
   10:          sub     sp, sp, #1i
   11:          bl      + (6)
   12:          add     sp, sp, #8i
   13:          ldmfd   sp, {r6,r5,r4,r3,r2,r1,r0}
   14:          add     sp, sp, #7i
   15:          sub     sp, fp, #3i
   16:          ldmfd   sp, {fp,sp,pc}
*****************************************************************
  Name              : Rounds
  ...

*)


(* --------------------------------------------------------------------------*) 
(* --------------------------------------------------------------------------*) 
(*      Decryption                                                           *)
(*      Analogous to the encryption case                                     *)
(* --------------------------------------------------------------------------*)
(* --------------------------------------------------------------------------*) 




(* --------------------------------------------------------------------------*)
(*      One round backward computation                                        *)
(* --------------------------------------------------------------------------*)

val InvRound_def =
 Define
   `InvRound((y,z),(k0,k1,k2,k3),sum)  =
        ((y - ShiftXor(z - ShiftXor(y, sum, k2, k3), sum, k0, k1),
          z - ShiftXor(y, sum, k2, k3)),
         (k0,k1,k2,k3),
         sum-DELTA)`;
   
val env5 = toANF env1 InvRound_def;

(*---------------------------------------------------------------------------*)
(* Arbitrary number of decipher rounds                                       *)
(*---------------------------------------------------------------------------*)

val (InvRounds_def, InvRounds_ind) = Defn.tprove
 (Hol_defn
   "InvRounds"
   `InvRounds (n,s:state) = if n=0w then s else InvRounds (n-1w, InvRound s)`,
  WF_REL_TAC `measure (w2n o FST)` THEN
  METIS_TAC [WORD_PRED_THM]);

val env6 = toANF env5 InvRounds_def;

(*---------------------------------------------------------------------------*)
(* Decrypt (32 rounds)                                                       *)
(*---------------------------------------------------------------------------*)

val TEADecrypt_def =
 Define
   `TEADecrypt (keys,txt) =
      let (plaintxt,keys,sum) = InvRounds(32w,(txt,keys,DELTA << 5)) in
      plaintxt`;

val env7 = toANF env6 TEADecrypt_def;
