(*---------------------------------------------------------------------------*)
(* A version of TEA, taken from examples/Crypto/TEA                          *)
(*---------------------------------------------------------------------------*)

loadPath := ".." :: !loadPath;

use "compiler";

open Assem BasicProvers;

(*---------------------------------------------------------------------------*)
(* Cipher types                                                              *)
(*---------------------------------------------------------------------------*)

val _ = type_abbrev("block", ``:word32 # word32``);
val _ = type_abbrev("key",   ``:word32 # word32 # word32 # word32``);
val _ = type_abbrev("state", ``:block # key # word32``);

(* --------------------------------------------------------------------------*)
(* Definitions used in Round computations                                    *)
(* --------------------------------------------------------------------------*)

val env0 = [];

val DELTA_def = Define `DELTA = 0x9e3779b9w`;

val ShiftXor_def = 
 Define 
   `ShiftXor (x,s,k0,k1) = ((x << 4) + k0) # (x + s) # ((x >> 5) + k1)`;

val env1 = toANF env0 ShiftXor_def;
val arm1 = compileEnv env1;
printarm arm1;
(*****************************************************************
  Name              : ShiftXor
  Arguments         : r0 r1 r2 r3 
  Modified Registers: r0 r1 r2 r4 
  Returns           : r0 
  Body: 
    0:          mov     ip, sp
    1:          stmfd   sp!, {fp,ip,lr,pc}
    2:          sub     fp, ip, #1i
    3:          lsl     r4, r0, #4i
    4:          add     r2, r4, r2
    5:          add     r1, r0, r1
    6:          eor     r1, r2, r1
    7:          asr     r0, r0, #5i
    8:          add     r0, r0, r3
    9:          eor     r0, r1, r0
   10:          sub     sp, fp, #3i
   11:          ldmfd   sp, {fp,sp,pc}

  simT (mk_ARM arm1);

  SEQ_TAC [ShiftXor_def];

*)

(*---------------------------------------------------------------------------*)
(*  One round forward computation and one round backward computation         *)
(*---------------------------------------------------------------------------*)

val Round_def = 
 Define
   `Round ((y,z),(k0,k1,k2,k3),sum):state  = 
      ((y + ShiftXor(z, sum+DELTA, k0, k1),
        z + ShiftXor(y + ShiftXor(z, sum+DELTA, k0, k1), sum+DELTA, k2, k3)),
       (k0,k1,k2,k3), 
       sum+DELTA)`;

   val env2 = toANF env1 (REWRITE_RULE [DELTA_def] Round_def);	
   val arm2 = compileEnv env2;
   printarm arm2;
(*****************************************************************
  Name              : Round
  Arguments         : r0 r1 r2 r3 r4 r5 r6 
  Modified Registers: r0 r1 r7 r8 
  Returns           : r8 r1 r2 r3 r4 r5 r0 
  Body: 
    0:          mov     ip, sp
    1:          stmfd   sp!, {fp,ip,lr,pc}
    2:          sub     fp, ip, #1i
    3:          add     r7, r6, #2654435769iw
    4:          sub     sp, sp, #1i
    5:          stmfd   sp!, {r1,r7,r2,r3}
    6:          bl      + (24)
    7:          add     sp, sp, #4i
    8:          ldr     r7, [sp, #1]
    9:          add     sp, sp, #1i
   10:          add     r8, r0, r7
   11:          add     r7, r6, #2654435769iw
   12:          sub     sp, sp, #1i
   13:          stmfd   sp!, {r1,r7,r2,r3}
   14:          bl      + (16)
   15:          add     sp, sp, #4i
   16:          ldr     r7, [sp, #1]
   17:          add     sp, sp, #1i
   18:          add     r7, r0, r7
   19:          add     r0, r6, #2654435769iw
   20:          sub     sp, sp, #1i
   21:          stmfd   sp!, {r7,r0,r4,r5}
   22:          bl      + (8)
   23:          add     sp, sp, #4i
   24:          ldr     r0, [sp, #1]
   25:          add     sp, sp, #1i
   26:          add     r1, r1, r0
   27:          add     r0, r6, #2654435769iw
   28:          sub     sp, fp, #3i
   29:          ldmfd   sp, {fp,sp,pc}
*****************************************************************
  Name              : ShiftXor
  Arguments         : r0 r1 r2 r3 
  Modified Registers: r0 r1 r2 r4 
  Returns           : r0 
  Body: 
   30:          mov     ip, sp
   31:          stmfd   sp!, {r0,r1,r2,r4,fp,ip,lr,pc}
   32:          sub     fp, ip, #1i
   33:          ldmfd   ip, {r0,r1,r2,r3}
   34:          lsl     r4, r0, #4i
   35:          add     r2, r4, r2
   36:          add     r1, r0, r1
   37:          eor     r1, r2, r1
   38:          asr     r0, r0, #5i
   39:          add     r0, r0, r3
   40:          eor     r0, r1, r0
   41:          add     sp, fp, #6i
   42:          str     r0, [sp]
   43:          sub     sp, fp, #7i
   44:          ldmfd   sp, {r0,r1,r2,r4,fp,sp,pc}

   simT (mk_ARM arm2);
   
*)

(* With lets *)
val Round_def = 
 Define
   `Round (((y,z),(k0,k1,k2,k3),s):state)  = 
      let s' = s + DELTA in
      let y' = ShiftXor(z, s', k0, k1) 
      in
       ((y', z + ShiftXor(y', s', k2, k3)), (k0,k1,k2,k3), s')`;

val Round_def' = REWRITE_RULE [DELTA_def] Round_def;

val env2 = toANF env1 Round_def';
val arm2 = compileEnv env2;
printarm arm2;

val InvRound_def = 
 Define
   `InvRound((y,z),(k0,k1,k2,k3),sum)  =
        ((y - ShiftXor(z - ShiftXor(y, sum, k2, k3), sum, k0, k1),
          z - ShiftXor(y, sum, k2, k3)), 
	 (k0,k1,k2,k3), 
         sum-DELTA)`;

val env3 = toANF env2 InvRound_def;

(*---------------------------------------------------------------------------*)
(* Arbitrary number of cipher rounds                                         *)
(*---------------------------------------------------------------------------*)

val Rounds_def = 
 Define
   `Rounds (n,s:state) = if n=0 then s else Rounds (n-1, Round s)`;

val env4 = toANF env3 Rounds_def;

val InvRounds_def =
 Define
   `InvRounds (n,s:state) = if n=0 then s else InvRounds (n-1,InvRound s)`;

val env5 = toANF env4 InvRounds_def;


(*---------------------------------------------------------------------------*)
(* Encrypt and Decrypt (32 rounds)                                           *)
(*---------------------------------------------------------------------------*)

val TEAEncrypt_def = 
 Define 
   `TEAEncrypt (keys,txt) = FST (Rounds(32,(txt,keys,0w)))`;

val env6 = toANF env5 TEAEncrypt_def;

val TEADecrypt_def = 
 Define 
   `TEADecrypt (keys,txt) = FST (InvRounds(32,(txt,keys,DELTA << 5)))`;

val env7 = toANF env6 TEADecrypt_def;

