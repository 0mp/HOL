(*---------------------------------------------------------------------------*)
(* Factorial (on word32)                                                     *)
(*---------------------------------------------------------------------------*)

use "compiler";

val _ = set_fixity "word_suc" Prefix;   (* correct parse directive *)

(*---------------------------------------------------------------------------*)
(* Define factorial.                                                         *)
(*                                                                           *)
(* fact_def = |- fact (x,a) = if x = 0w then a else fact (x - 1w, x * a))    *)
(*                                                                           *)
(*---------------------------------------------------------------------------*)

val (fact_def, fact_ind) = Defn.tprove
 (Hol_defn
   "fact"
   `fact (x,a) = if x=0w then a else fact(x-1w,x*a)`,
  WF_REL_TAC `measure (w2n o FST)` THEN 
  METIS_TAC [WORD_PRED_THM]);

(*---------------------------------------------------------------------------*)
(* The first two passes of processing converts the recursion equations into  *)
(* a combinator expression (fact_ast), then into a rough approximation of    *)
(* A-Normal form (fact_anf).                                                 *)
(*                                                                           *)
(* fact_ast =                                                                *)
(*  |- fact =                                                                *)
(*        Ite (Seq (Par (\(x,a). x) (\(x,a). 0w)) (UNCURRY $=)) (\(x,a). a)  *)
(*            (Seq (Par (Seq (Par (\(x,a). x) (\(x,a). 1w)) (UNCURRY $-))    *)
(*            (Seq (Par (\(x,a). x) (\(x,a). a)) (UNCURRY $* ))) fact)       *)
(*                                                                           *)
(*   fact_anf =                                                              *)
(*    |- !v1 v2.                                                             *)
(*         fact (v1,v2) =                                                    *)
(*           let v3 = 0w in                                                  *)
(*           let v4 = UNCURRY $= (v1,v3) in                                  *)
(*             if v4 then                                                    *)
(*                v2                                                         *)
(*             else                                                          *)
(*               let v5 = 1w in                                              *)
(*               let v6 = UNCURRY $- (v1,v5) in                              *)
(*               let v7 = UNCURRY $* (v1,v2) in                              *)
(*               let v8 = fact (v6,v7)                                       *)
(*               in v8                                                       *)
(*                                                                           *)
(*---------------------------------------------------------------------------*)

val factoids as [(fact_const,(_,_, fact_anf, fact_ast))] = toANF [] fact_def;

(*---------------------------------------------------------------------------*)
(* The next step of processing makes quite a big jump, going directly        *)
(* to the instructions for the machine. Things like conversion to the        *)
(* control flow graph, register allocation, etc. are all hidden.             *)
(*                                                                           *)
(*  fact_arm =                                                               *)
(*  ("fact",                                                                 *)
(*   ``:word32 # word32 -> word32``,                                         *)
(*   PAIR(REG 0, REG 1),                                                     *)
(*     [MOVE{dst = REG 12, src = REG 13},                                    *)
(*      OPER{dst = [WREG 13], jump = NONE, oper = (STMFD, NONE, false),      *)
(*           src = [REG 0, REG 2, REG 3, REG 11, REG 12, REG 14, REG 15]},   *)
(*      OPER{dst = [REG 11], jump = NONE, oper = (SUB, NONE, false),         *)
(*           src = [REG 12, NCONST 1]}, MOVE{dst = REG 2, src = WCONST 0},   *)
(*      OPER{dst = [REG 2], jump = NONE, oper = (CMP, NONE, false),          *)
(*           src = [REG 0, REG 2]},                                          *)
(*      OPER{dst = [], jump = SOME [<symbol>], oper = (B, SOME EQ, false),   *)
(*           src = [REG 2]}, MOVE{dst = REG 2, src = WCONST 1},              *)
(*      OPER{dst = [REG 3], jump = NONE, oper = (SUB, NONE, false),          *)
(*           src = [REG 0, REG 2]},                                          *)
(*      OPER{dst = [REG 2], jump = NONE, oper = (MUL, NONE, false),          *)
(*           src = [REG 0, REG 1]},                                          *)
(*      OPER{dst = [WREG 13], jump = NONE, oper = (STMFD, NONE, false),      *)
(*           src = [REG 3, REG 2]},                                          *)
(*      OPER{dst = [REG 0, REG 1], jump = NONE, oper = (LDMFD, NONE, false), *)
(*           src = [REG 13]},                                                *)
(*      OPER{dst = [REG 13], jump = NONE, oper = (ADD, NONE, false),         *)
(*           src = [REG 13, NCONST 2]},                                      *)
(*      OPER{dst = [], jump = SOME [<symbol>], oper = (B, SOME AL, false),   *)
(*           src = []}, MOVE{dst = REG 0, src = REG 1},                      *)
(*      OPER{dst = [REG 13], jump = NONE, oper = (SUB, NONE, false),         *)
(*           src = [REG 11, NCONST 5]},                                      *)
(*      OPER{dst = [REG 0, REG 2, REG 3, REG 11, REG 13, REG 15], jump=NONE, *)
(*           oper = (LDMFD, NONE, false), src = [REG 13]}],                  *)
(*   REG 0)                                                                  *)
(*                                                                           *)
(* Here's a more readable rendering:                                         *)
(*                                                                           *)
(* printarm fact_arm;                                                        *)
(*                                                                           *)
(*    Name: fact                                                             *)
(*    Arguments:                                                             *)
(*        r0 r1                                                              *)
(*    Body:                                                                  *)
(*        0:          mov     ip, sp                                         *)
(*        1:          stmfd   sp!, {fp,ip,lr,pc}                    *)
(*        2:          sub     fp, ip, #1                                     *)
(*        3:          mov     r2, #0w                                        *)
(*        4:          cmp     r0, r2                                         *)
(*        5:          beq     + (8)                                          *)
(*        6:          mov     r2, #1w                                        *)
(*        7:          sub     r3, r0, r2                                     *)
(*        8:          mul     r2, r0, r1                                     *)
(*        9:          stmfd   sp!, {r3,r2}                                   *)
(*       10:          ldmfd   sp, {r0,r1}                                    *)
(*       11:          add     sp, sp, #2                                     *)
(*       12:          bal     - (9)                                          *)
(*       13:          mov     r0, r1                                         *)
(*       14:          sub     sp, fp, #5                                     *)
(*       15:          ldmfd   sp, {fp,sp,pc}                        *)
(*    Return:                                                                *)
(*        r0                                                                 *)
(*                                                                           *)
(*---------------------------------------------------------------------------*)

val fact_arm = compileEnv factoids;
val _ = printarm fact_arm;

(*---------------------------------------------------------------------------*)
(* Then the machine program (an ML data value) is converted to a HOL term    *)
(* and the correctness goal is set-up via simT.                              *)
(*                                                                           *)
(* The goal states that, provided the program terminates and satisfies some  *)
(* conditions on the registers, executing the program (via terRun) leaves    *)
(* machine memory in such a state that reading the result from register 0 is *)
(* equal to the mathematical function applied to the inputs, which are       *)
(* initially in registers 0 and 1.                                           *)
(*                                                                           *)
(* The initial state of the program is held in                               *)
(*                                                                           *)
(*          pc0     -- program counter                                       *)
(*          cpsr0   -- status register                                       *)
(*          regs0   -- registers                                             *)
(*          mems0   -- memory                                                *)
(*                                                                           *)
(* The final state is computed by terRun and put in (pc1,cpsr1,regs1,mems1)  *)
(*                                                                           *)
(*   !pc0 cpsr0 regs0 mems0.                                                 *)
(*        (w2n (regs0 14) = 16) /\                                           *)
(*        (regs0 13 = 100w) /\                                               *)
(*        (pc0 = 0) /\                                                       *)
(*        terminated (instB,16) (pc0,cpsr0,regs0,mems0)                      *)
(*       ==>                                                                 *)
(*        let (pc1,cpsr1,regs1,mems1) =                                      *)
(*            terRun (instB,16) (pc0,cpsr0,regs0,mems0)                      *)
(*        in                                                                 *)
(*           (pc1 = 16) /\                                                   *)
(*           (read (regs1,mems1) (REG 0)                                     *)
(*              =                                                            *)
(*            fact (read (regs0,mems0) (REG 0),                              *)
(*                  read (regs0,mems0) (REG 1)))                             *)
(*                                                                           *)
(*---------------------------------------------------------------------------*)

val fact_arm_term = mk_ARM fact_arm;

simT fact_arm_term;  (* create goal and put it into the goalstack *)

(*---------------------------------------------------------------------------*)
(* Setting up instruction buffer rewrites                                    *)
(*---------------------------------------------------------------------------*)

val thm = fetch "-" "instB_def";

val instB_thm = Q.prove
(`(instB 0 = ((MOV,NONE,F),SOME (REG 12),[REG 13],NONE)) /\
  (instB 1 = ((STMFD,NONE,F),SOME (WREG 13), [REG 0; REG 2; REG 3; REG 11; REG 12; REG 14; REG 15],NONE)) /\
  (instB 2 = ((SUB,NONE,F),SOME (REG 11),[REG 12; NCONST 1], NONE)) /\
  (instB 3 = ((MOV,NONE,F),SOME (REG 2),[WCONST 0w],NONE)) /\
  (instB 4 = ((CMP,NONE,F),NONE,[REG 0; REG 2],NONE)) /\
  (instB 5 = ((B,SOME EQ,F),NONE,[REG 2],SOME (POS 8))) /\
  (instB 6 = ((MOV,NONE,F),SOME (REG 2),[WCONST 1w],NONE)) /\
  (instB 7 = ((SUB,NONE,F),SOME (REG 3), [REG 0; REG 2],NONE)) /\
  (instB 8 = ((MUL,NONE,F),SOME (REG 2), [REG 0; REG 1],NONE)) /\
  (instB 9 = ((STMFD,NONE,F),SOME (WREG 13), [REG 3; REG 2],NONE)) /\
  (instB 10 = ((LDMFD,NONE,F),SOME (REG 13),[REG 0; REG 1],NONE)) /\
  (instB 11 = ((ADD,NONE,F),SOME (REG 13),[REG 13; NCONST 2],NONE)) /\
  (instB 12 = ((B,SOME AL,F),NONE,[],SOME (NEG 9))) /\
  (instB 13 = ((MOV,NONE,F),SOME (REG 0),[REG 1],NONE)) /\
  (instB 14 = ((SUB,NONE,F),SOME (REG 13),[REG 11; NCONST 5],NONE)) /\
  (instB 15 = ((LDMFD,NONE,F),SOME (REG 13), [REG 0; REG 2; REG 3; REG 11; REG 13; REG 15],SOME INR))`
 ,
 REPEAT CONJ_TAC THEN EVAL_TAC); 

val ss = srw_ss() ++ 
         rewrites [read_def, write_def, set_pc_def, STORE_def, instB_thm,decode1_thm,decode2_thm];

val lem1 = Q.prove
(`(w2n x = 0) = (x = 0w)`,
 RW_TAC ss [EQ_IMP_THM] THENL
 [IMP_RES_TAC w2n_n2w THEN RW_TAC ss [], ALL_TAC] THEN EVAL_TAC);

val lem2 = Q.prove(`(0 = w2n x) = (x = 0w)`,METIS_TAC[lem1]);

val lem3 = Q.prove
(`(w2n x = 16) = (x = 16w)`,
 RW_TAC ss [EQ_IMP_THM] THENL
 [IMP_RES_TAC w2n_n2w THEN RW_TAC ss [], ALL_TAC] THEN EVAL_TAC);


(* Start proof *)

e (RW_TAC ss []); r 1;
e (Induct_on `w2n(regs0 0)`);

(* Base case *)
e (RW_TAC ss [lem2,lem3,Once fact_def]);
e (`terRun (instB,16) 
        (run 15 (instB,16) (0,cpsr0,regs0,mems0)) 
    = (pc1,cpsr1,regs1,mems1)`  by METIS_TAC [TERRUN_THM]);
e (POP_ASSUM MP_TAC THEN POP_ASSUM (K ALL_TAC));
e (SIMP_TAC std_ss [Once run_def]);
e (SIMP_TAC ss []);

val LDM_TAC = 
  CONV_TAC (DEPTH_CONV ((REWR_CONV FOLDL_CONS ORELSEC REWR_CONV FOLDL_NIL)
    THENC RATOR_CONV (RAND_CONV (DEPTH_CONV GEN_BETA_CONV
                    THENC REWRITE_CONV ([read_def,pair_case_def]@ type_rws"EXP")
                    THENC SIMP_CONV ss []
                    THENC WORD_CONV
                    THENC reduceLib.REDUCE_CONV
                    THENC REWRITE_CONV ([write_def, STORE_def,pair_case_def]@type_rws"EXP")
                    THENC SIMP_CONV ss []))));
	THEN ASM_REWRITE_TAC [] THEN

(* Step case *)

