(*---------------------------------------------------------------------------*)
(* Factorial (on word32)                                                     *)
(*---------------------------------------------------------------------------*)

loadPath := ".." :: !loadPath;

use "compiler";

open Assem BasicProvers;

val _ = set_fixity "word_suc" Prefix;   (* correct parse directive *)

(*---------------------------------------------------------------------------*)
(* Define factorial.                                                         *)
(*                                                                           *)
(* fact_def = |- fact (x,a) = if x = 0w then a else fact (x - 1w, x * a))    *)
(*                                                                           *)
(*---------------------------------------------------------------------------*)

val (fact_def, fact_ind) = Defn.tprove
 (Hol_defn
   "fact"
   `fact (x,a) = if x=0w then a else fact(x-1w,x*a)`,
  WF_REL_TAC `measure (w2n o FST)` THEN 
  METIS_TAC [WORD_PRED_THM]);

(*---------------------------------------------------------------------------*)
(* The first two passes of processing converts the recursion equations into  *)
(* a combinator expression (fact_ast), then into a rough approximation of    *)
(* A-Normal form (fact_anf).                                                 *)
(*                                                                           *)
(* fact_ast =                                                                *)
(*  |- fact =                                                                *)
(*        Ite (Seq (Par (\(x,a). x) (\(x,a). 0w)) (UNCURRY $=)) (\(x,a). a)  *)
(*            (Seq (Par (Seq (Par (\(x,a). x) (\(x,a). 1w)) (UNCURRY $-))    *)
(*            (Seq (Par (\(x,a). x) (\(x,a). a)) (UNCURRY $* ))) fact)       *)
(*                                                                           *)
(* fact_anf =                                                                *)
(*  |- !v1 v2.                                                               *)
(*         fact (v1,v2) =                                                    *)
(*           let v3 = UNCURRY $= (v1,0w)                                     *)
(*           in if v3 then v2                                                *)
(*              else let v4 = UNCURRY $- (v1,1w) in                          *)
(*                   let v5 = UNCURRY $* (v1,v2) in                          *)
(*                   let v6 = fact (v4,v5)                                   *)
(*                   in v6                                                   *)
(*                                                                           *)
(*---------------------------------------------------------------------------*)

val factoids as [(fact_const,(_,_, fact_anf, fact_ast))] = toANF [] fact_def;


(*------------------------------------------------------------------------------*)
(* The next step builds an intermediate representation tree for the A-Normal	*)
(* form, with the arguments and returns of the factorial function extracted.	*)
(* All variables are stored in the temporary table.				*) 
(* First phase of optimization is carried on this intermedate representation  	*)
(* Linearizing this tree would give us a sequence of statements          	*)
(*                                                                       	*)
(* val fact_args = PAIR(TEMP 1, TEMP 3) : exp	 	    	                *)
(*                                                                       	*)
(* val fact_stms =							  	*)
(*  [LABEL<symbol>, MOVE(TEMP 0, WCONST 0),	                                *)
(*   MOVE(TEMP 2, RELOP(EQ, TEMP 1, TEMP 0)),	                                *)
(*   CJUMP(TEMP 2, <symbol>), MOVE(TEMP 5, WCONST 1),	                        *)
(*   MOVE(TEMP 6, BINOP(MINUS, TEMP 1, TEMP 5)),	                        *)
(*   MOVE(TEMP 7, BINOP(MUL, TEMP 1, TEMP 3)),	                                *)
(*   MOVE(TEMP 8, CALL(NAME<symbol>, [TEMP 6, TEMP 7])),	                *)
(*   MOVE(TEMP 4, TEMP 8), JUMP<symbol>,			                *)
(*   LABEL<symbol>, MOVE(TEMP 4, TEMP 3),			                *)
(*   LABEL<symbol>] : stm list						        *)
(*                                                                       	*)
(* val fact_outs = TEMP 4							*)
(*------------------------------------------------------------------------------*)


(*------------------------------------------------------------------------------*)
(* Then a control flow graph is built from the intermediate representation tree *)
(* Since the linerization determines the control flow of statements, this CFG   *)
(* is unique. Instructions in the CFG are puesdo-ARM instructions operating on  *)
(* temporaries rather than registers and memory. 				*)
(* Use and defition information is added for each instruction        		*)
(* Linearizing this tree would give us a sequence of instructions               *)
(*                                                                              *)
(* val fact_args = PAIR(TEMP 1, TEMP 3) : exp                    		*)
(*                                                                              *)
(* val fact_stms =								*)
(* [LABEL{lab = <symbol>}, MOVE{dst = TEMP 0, src = WCONST 0},		        *)
(*   OPER{dst = [TEMP 2], jump = NONE, oper = (CMP, NONE, false),		*)
(*        src = [TEMP 1, TEMP 0]},						*)
(*   OPER{dst = [], jump = SOME [<symbol>],					*)
(*        oper = (B, SOME EQ, false), src = [TEMP 2]},		                *)
(*   MOVE{dst = TEMP 5, src = WCONST 1},					*)
(*   OPER{dst = [TEMP 6], jump = NONE, oper = (SUB, NONE, false),		*)
(*        src = [TEMP 1, TEMP 5]},						*)
(*   OPER{dst = [TEMP 7], jump = NONE, oper = (MUL, NONE, false),		*)
(*        src = [TEMP 1, TEMP 3]},						*)
(*   OPER{dst = [TEMP 8], jump = SOME [<symbol>],				*)
(*        oper = (BL, NONE, false), src = [TEMP 6, TEMP 7]},		        *)
(*   MOVE{dst = TEMP 4, src = TEMP 8},						*)
(*   OPER{dst = [], jump = SOME [<symbol>],					*)
(*        oper = (B, SOME AL, false), src = []},			        *)
(*   LABEL{lab = <symbol>}, MOVE{dst = TEMP 4, src = TEMP 3},			*)
(*   LABEL{lab = <symbol>}] 							*)
(*                                                                              *)
(* val fact_outs = TEMP 4                                                  	*)
(* 	                                                                  	*)
(* Here's a more readable rendering:                             		*)
(*                                                         			*)
(* fact:									*)
(*      mov     t0, #0w								*)
(*      cmp     t1, t0								*)
(*      beq     l4 (5)								*)
(*      mov     t5, #1w								*)
(*      sub     t6, t1, t5							*)
(*      mul     t7, t1, t3							*)
(*      bl      (t8), (t6,t7) fact (0)						*)
(*      mov     t4, t8								*)
(*      bal     l5 (6)								*)
(* L4:										*)
(*      mov     t4, t3								*)
(* L5:										*)
(*                                                         			*)
(*------------------------------------------------------------------------------*)


(*------------------------------------------------------------------------------*)
(* The next step of processing goes to the instructions for the machine. 	*)
(* Temporaries are allocated into registers r0-r9 (r10 - r15 are reserved for	*)
(* particular purpose. Specifically, r11, r12, r13, r14 and r15 store the values*)
(* of fp, ip, sp, lr and pc respectively; r10 is used to transfer memory values.*)
(* When there are no sufficient available registers, some temporaries are 	*)
(* into the memory 								*)  
(*                                                                           	*)
(* val args = PAIR(REG 0, REG 1) : exp			                        *)
(*                                                                           	*)
(* val stms =									*)
(*    [LABEL{lab = <symbol>}, MOVE{dst = REG 2, src = WCONST 0},	        *)
(*     OPER{dst = [REG 2], jump = NONE, oper = (CMP, NONE, false),	        *)
(*          src = [REG 0, REG 2]},					        *)
(*     OPER{dst = [], jump = SOME [<symbol>],					*)
(*          oper = (B, SOME EQ, false), src = [REG 2]},	                        *)
(*     MOVE{dst = REG 2, src = WCONST 1},				        *)
(*     OPER{dst = [REG 3], jump = NONE, oper = (SUB, NONE, false),	        *)
(*          src = [REG 0, REG 2]},					        *)
(*     OPER{dst = [REG 2], jump = NONE, oper = (MUL, NONE, false),	        *)
(*          src = [REG 0, REG 1]},					        *)
(*     OPER{dst = [REG 0], jump = SOME [<symbol>],			        *)
(*          oper = (BL, NONE, false), src = [REG 3, REG 2]},	                *)
(*     MOVE{dst = REG 0, src = REG 0},				                *)
(*     OPER{dst = [], jump = SOME [<symbol>],					*)
(*          oper = (B, SOME AL, false), src = []},			        *)
(*     LABEL{lab = <symbol>}, MOVE{dst = REG 0, src = REG 1},	                *)
(*     LABEL{lab = <symbol>}] : instr list					*)
(*                                                                           	*)
(*  val outs = REG 0 : exp						        *)
(*                                                                           	*)
(* Here's a more readable rendering:                                         	*)
(*                                                                           	*)
(*  Name              : fact							*)
(*  Arguments         : r0 r1							*)
(*  Modified Registers: r0 r2 r3						*)
(*  Returns           : r0							*)
(*  Body:									*)
(*    0:  fact:									*)
(*    1:          mov     r2, #0w						*)
(*    2:          cmp     r0, r2						*)
(*    3:          beq     l4 (5)						*)
(*    4:          mov     r2, #1w						*)
(*    5:          sub     r3, r0, r2						*)
(*    6:          mul     r2, r0, r1						*)
(*    7:          bl      (r0), (r3,r2) fact (0)				*)
(*    8:          mov     r0, r0						*)
(*    9:          bal     l5 (6)						*)
(*   10:  L4:									*)
(*   11:          mov     r0, r1						*)
(*   12:  L5:									*)
(*										*)
(*------------------------------------------------------------------------------*)
(* The correctness of the register allocation is easily verified		*)
(* Note that in the following v4 is a bool variable that will be discarded  	*)
(* by the control flow processor						*)    
(*										*)
(* - regAllocation.check_allocation (fact_anf) 					*)
(*										*)
(* |- fact (r0,r1) =								*)
(*     (let r2 = 0w in								*)
(*      let v4 = UNCURRY $= (r0,r2) in						*)
(*        v4 => r1								*)
(*        | (let r2 = 1w in							*)
(*           let r3 = UNCURRY $- (r0,r2) in					*)
(*           let r2 = UNCURRY $* (r0,r1) in					*)
(*           let r0 = fact (r3,r2) in						*)
(*             r0))								*)
(*										*)
(*------------------------------------------------------------------------------*)


(*------------------------------------------------------------------------------*)
(* Then all modules are linked together. We try to conform to the APCS 		*) 
(* (ARM Procedure Call Standard) but make some optimization when linking modules*)
(* When a subroutine is called, the arguments are passed into r0-r9 in order,   *)
(* and if there are too many arguments, the extra arguments are passed by the   *)
(* stack. Refer to the APCS for more information.				*)
(* Tail recursive functions bring a lot of convenience in linking		*)
(* Note that memory addresses are based on words instead of bytes here		*) 
(*                                                                              *)
(* val arm_fact =								*) 
(*  [("fact", ``:word32 # word32 -> word32``,					*)
(*     PAIR(REG 0, REG 1),					                *)
(*     [LABEL{lab = <symbol>}, MOVE{dst = REG 12, src = REG 13},	        *)
(*      OPER{dst = [WREG 13], jump = NONE,				        *)
(*           oper = (STMFD, NONE, false),					*)
(*           src = [REG 11, REG 12, REG 14, REG 15]},	                        *)
(*      OPER{dst = [REG 11], jump = NONE, oper = (SUB, NONE, false),            *)
(*           src = [REG 12, NCONST 1]}, LABEL{lab = <symbol>},	                *)
(*      MOVE{dst = REG 2, src = WCONST 0},				        *)
(*      OPER{dst = [REG 2], jump = NONE, oper = (CMP, NONE, false),	        *)
(*           src = [REG 0, REG 2]},					        *)
(*      OPER{dst = [], jump = SOME [<symbol>],					*)
(*           oper = (B, SOME EQ, false), src = [REG 2]},                        *)
(*      MOVE{dst = REG 2, src = WCONST 1},				        *)
(*      OPER{dst = [REG 3], jump = NONE, oper = (SUB, NONE, false),	        *)
(*           src = [REG 0, REG 2]},					        *)
(*      OPER{dst = [REG 2], jump = NONE, oper = (MUL, NONE, false),	        *)
(*           src = [REG 0, REG 1]},					        *)
(*      OPER{dst = [WREG 13], jump = NONE,				        *)
(*           oper = (STMFD, NONE, false),					*)
(*           src = [REG 3, REG 2]},				        	*)
(*      OPER{dst = [REG 0, REG 1], jump = NONE,			                *)
(*           oper = (LDMFD, NONE, false), src = [REG 13]},		        *)
(*      OPER{dst = [REG 13], jump = NONE, oper = (ADD, NONE, false),            *)
(*           src = [REG 13, NCONST 2]},				                *)
(*      OPER{dst = [], jump = SOME [<symbol>],					*)
(*           oper = (B, SOME AL, false), src = []},			        *)
(*      LABEL{lab = <symbol>}, MOVE{dst = REG 0, src = REG 1},	                *)
(*      LABEL{lab = <symbol>},							*)
(*      OPER{dst = [REG 13], jump = NONE, oper = (SUB, NONE, false),            *)
(*           src = [REG 11, NCONST 3]},				                *)
(*      OPER{dst = [REG 11, REG 13, REG 15], jump = NONE,	                *)
(*           oper = (LDMFD, NONE, false), src = [REG 13]}],		        *)
(*      REG 0, <set>)]							        *)
(*										*)
(* Here's a more readable rendering:                                            *)
(*                                                                              *)
(* - printarm arm_fact;								*)
(* *****************************************************************		*)
(*  Name              : fact							*)
(*  Arguments         : r0 r1							*)
(*  Modified Registers: r0 r2 r3						*)
(*  Returns           : r0							*)
(*  Body:									*)
(*    0:  fact:									*)
(*    1:          mov     ip, sp						*)
(*    2:          stmfd   sp!, {fp,ip,lr,pc}					*)
(*    3:          sub     fp, ip, #1						*)
(*    4:  fact_0:								*)
(*    5:          mov     r2, #0w						*)
(*    6:          cmp     r0, r2						*)
(*    7:          beq     l4 (5)						*)
(*    8:          mov     r2, #1w						*)
(*    9:          sub     r3, r0, r2						*)
(*   10:          mul     r2, r0, r1						*)
(*   11:          stmfd   sp!, {r3,r2}						*)
(*   12:          ldmfd   sp, {r0,r1}						*)
(*   13:          add     sp, sp, #2						*)
(*   14:          bal     fact_0 (7)						*)
(*   15:  L4:									*)
(*   16:          mov     r0, r1						*)
(*   17:  L5:									*)
(*   18:          sub     sp, fp, #3						*)
(*   19:          ldmfd   sp, {fp,sp,pc}					*)
(*                                                                              *)
(*------------------------------------------------------------------------------*)

(*------------------------------------------------------------------------------*)
(* The next step is to eliminate labels: all conditional and unconditional jumps*)
(* are altered so that the tarjets are relative to the pc.           		*)
(* Again, note that memory addresses are based on words instead of bytes. 	*)
(*										*)
(* Here is the result after label elimination					*)
(*										*)
(* *****************************************************************		*)
(*  Name              : fact							*)
(*  Arguments         : r0 r1							*)
(*  Modified Registers: r0 r2 r3						*)
(*  Returns           : r0							*)
(*  Body:									*)
(*    0:          mov     ip, sp                                                *)
(*    1:          stmfd   sp!, {fp,ip,lr,pc}                                    *)
(*    2:          sub     fp, ip, #1i                                           *)
(*    3:          cmp     r0, #0iw                                              *)
(*    4:          beq     + (7)                                                 *)
(*    5:          sub     r3, r0, #1iw                                          *)
(*    6:          mul     r2, r0, r1                                            *)
(*    7:          stmfd   sp!, {r3,r2}                                          *)
(*    8:          ldmfd   sp, {r0,r1}                                           *)
(*    9:          add     sp, sp, #2i                                           *)
(*   10:          bal     - (7)                                                 *)
(*   11:          mov     r0, r1                                                *)
(*   12:          sub     sp, fp, #3i                                           *)
(*   13:          ldmfd   sp, {fp,sp,pc}                                        *)
(*										*)
(*------------------------------------------------------------------------------*)
(*										*)
(* If print in capital letters and without register alias                       *)
(*										*)
(* - use_alias := false;							*)
(* - use_capital := true;							*)
(* *****************************************************************		*)
(*  Name              : fact							*)
(*  Arguments         : R0 R1							*)
(*  Modified Registers: R0 R2 R3						*)
(*  Returns           : R0							*)
(*  Body:									*)
(*    0:          MOV     R12, R13						*)
(*    1:          STMFD   R13!, {R11,R12,R14,R15}				*)
(*    2:          SUB     R11, R12, #1						*)
(*    3:          MOV     R2, #0w						*)
(*    4:          CMP     R0, R2						*)
(*    5:          BEQ     + (8)							*)
(*    6:          MOV     R2, #1w						*)
(*    7:          SUB     R3, R0, R2						*)
(*    8:          MUL     R2, R0, R1						*)
(*    9:          STMFD   R13!, {R3,R2}						*)
(*   10:          LDMFD   R13, {R0,R1}						*)
(*   11:          ADD     R13, R13, #2						*)
(*   12:          BAL     - (9)							*)
(*   13:          MOV     R0, R1						*)
(*   14:          SUB     R13, R11, #3						*)
(*   15:          LDMFD   R13, {R11,R13,R15}					*)
(*										*)
(*------------------------------------------------------------------------------*)

val fact_arm = compileEnv factoids;
val _ = printarm fact_arm;

(*---------------------------------------------------------------------------*)
(* Then the machine program (an ML data value) is converted to a HOL term    *)
(* and the correctness goal is set-up via simT.                              *)
(*                                                                           *)
(* The goal states that, provided the program terminates and satisfies some  *)
(* conditions on the registers, executing the program (via terRun) leaves    *)
(* machine memory in such a state that reading the result from register 0 is *)
(* equal to the mathematical function applied to the inputs, which are       *)
(* initially in registers 0 and 1.                                           *)
(*                                                                           *)
(* The initial state of the program is held in                               *)
(*                                                                           *)
(*          pc0     -- program counter                                       *)
(*          cpsr0   -- status register                                       *)
(*          regs0   -- registers                                             *)
(*          mems0   -- memory                                                *)
(*                                                                           *)
(* The final state is computed by terRun and put in (pc1,cpsr1,regs1,mems1)  *)
(*                                                                           *)
(*    (w2n (regs0 14) = 16) /\                                               *)
(*    (regs0 13 = 100w) /\                                                   *)
(*    (pc0 = 0) /\                                                           *)
(*    terminated (instB,16) (pc0,cpsr0,regs0,mems0) /\                       *)
(*    ((pc1,cpsr1,regs1,mems1) = terRun (instB,16) (pc0,cpsr0,regs0,mems0)   *)
(*   ==>                                                                     *)
(*     (pc1 = 16) /\                                                         *)
(*     (read (regs1,mems1) (REG 0)                                           *)
(*        =                                                                  *)
(*      fact (read (regs0,mems0) (REG 0),                                    *)
(*            read (regs0,mems0) (REG 1)))                                   *)
(*                                                                           *)
(*---------------------------------------------------------------------------*)

val fact_arm_term = mk_ARM fact_arm;

(* create goal and put it into the goalstack *)
set_goal([],simT fact_arm_term); 

(*---------------------------------------------------------------------------*)
(* Setting up instruction buffer rewrites                                    *)
(*---------------------------------------------------------------------------*)

*---------------------------------------------------------------------------*)
(* Setting up instruction buffer rewrites                                    *)
(*---------------------------------------------------------------------------*)

val instB_thm = !Verify.INSTB_LEM;

(*---------------------------------------------------------------------------*)
(* The proof by simulation                                                   *)
(* It goes by inducting on the first argument whose value is stored in r0    *)
(*---------------------------------------------------------------------------*)

fun get_pc c =
let val set_pc_app = rand(last(snd(strip_comb(rhs(fst(dest_imp c))))))
    val (_,[decode1_app,_]) = strip_comb set_pc_app
    val (_,[st,i]) = strip_comb decode1_app
    val (pc,_) = dest_pair st
in numSyntax.int_of_term pc
end
handle HOL_ERR _ => raise ERR "get_pc" "";

fun INSTR_TAC (asl,g) =
let val i = get_pc g
in
  select_tac (List.nth(!cur_insts, i)) (asl,g)
   handle HOL_ERR _ => raise ERR "INSTR_TAC"
       ("Unable to select tactic for "^Int.toString i^"-th instruction")
end;

fun ONE_STEP_TAC x =
 (REWRITE_TAC [Once run_def, instB_thm] THEN
  reduceLib.REDUCE_TAC THEN
  REWRITE_TAC [decode2_thm] THEN
  INSTR_TAC THEN
  REWRITE_TAC [set_pc_def, write_thm, read_thm] THEN
  WORD_TAC THEN
  SIMP_TAC bool_ss []) x;

val run_compset = word32Lib.word_compset();

val base_run_ss = 
 let open computeLib pairTheory sumTheory oneTheory optionTheory listTheory
    val thms' = map lazyfy_thm
                     [CLOSED_PAIR_EQ, FST, SND,pair_case_thm,
                     CURRY_DEF,UNCURRY_DEF,PAIR_MAP_THM] 
                 @
                map lazyfy_thm
                     [ISL,ISR,OUTL,OUTR,INR_INL_11,
                      sum_distinct,sum_distinct1,sum_case_def,one_case_def]
                 @
                map lazyfy_thm
                     [NOT_NONE_SOME,NOT_SOME_NONE,SOME_11,
                      option_case_compute,OPTION_MAP_DEF,
                      IS_SOME_DEF,IS_NONE_DEF,THE_DEF,
                      OPTION_JOIN_DEF]
                 @
                [APPEND,APPEND_NIL, FLAT, HD, TL,
                 LENGTH, MAP, MAP2, NULL_DEF, MEM, EXISTS_DEF,
                 EVERY_DEF, ZIP, UNZIP, FILTER, FOLDL, FOLDR,
                 FOLDL, REVERSE_DEF, EL_compute, ALL_DISTINCT,
                 computeLib.lazyfy_thm list_case_compute,
                 list_size_def,FRONT_DEF,LAST_DEF]
                 @
                [run_def,decode2_thm, decode1_thm, read_thm, write_thm, 
                 setS_thm,getS_thm,goto_thm,read_pc_def, set_pc_def]
 in 
   add_thms thms' run_compset;
   std_ss ++ rewrites thms'   
 end;

fun GEN_RUN_CONV instB_thm =
  let open computeLib
      val _ = add_thms [instB_thm] run_compset
  in CBV_CONV run_compset
  end;

val RUN_CONV = GEN_RUN_CONV instB_thm;

val run_ss = base_run_ss ++ rewrites [instB_thm];


val ZERO_LEM = Q.prove
(`!x. (w2n x = 0) = (x = 0w)`,
 GEN_TAC THEN EQ_TAC THEN RW_TAC std_ss [] THENL 
 [METIS_TAC [w2n_ELIM], WORD_TAC]);

val SUC_LEM = Q.prove
(`!x m. (w2n x = SUC m) ==> ~(x = 0w) /\ ~(x <. 0w)`,
 RW_TAC std_ss [WORD_LO_THM] THENL 
  [METIS_TAC [ZERO_LEM,numTheory.NOT_SUC],WORD_TAC]);

val TERRUN_LEM = Q.prove
(`!m s s' x.
    terminated x s /\ (run m x s = s') 
   ==> 
    terminated x s' /\ !k. terRun x s' = terRun x (run k x s')`,
 METIS_TAC [TERRUN_THM,TERMINATED_THM,ABS_PAIR_THM]);

val TERRUN_LEM_1 = Q.prove
(`!m s s' x.
    terminated x s /\ (run m x s = s') ==> terminated x s' `,
 METIS_TAC [TERRUN_LEM]);

val TERRUN_LEM_2 = Q.prove
(`!k m s s' x.
    terminated x s /\ (run m x s = s') ==> (terRun x s' = terRun x (run k x s'))`,
 METIS_TAC [TERRUN_LEM]);


(* The following is clumsy, will get cleaned up. *)
e (RW_TAC list_ss [read_thm]);
r 1;
e (POP_ASSUM MP_TAC THEN IMP_RES_THEN SUBST1_TAC (Q.SPEC `3` TERRUN_THM));
(* slow
e (ASM_SIMP_TAC run_ss [] THEN WORD_TAC); 
*)
(* fast *)
val tm = rand(rhs(fst(dest_imp(snd(top_goal())))));
e (MP_TAC (RUN_CONV tm));
e (ASM_REWRITE_TAC [] THEN WORD_TAC THEN SIMP_TAC bool_ss [] THEN STRIP_TAC);

e (Induct_on `w2n (regs0 0)` THEN REPEAT STRIP_TAC);
(* Base case *)
e (POP_ASSUM MP_TAC);
e (POP_ASSUM (fn runthm =>
   POP_ASSUM (fn terminatedthm => 
      SUBST1_TAC (MATCH_MP (Q.SPEC `4` TERRUN_LEM_2) (CONJ terminatedthm runthm))
   THEN ASSUME_TAC (MATCH_MP TERRUN_LEM_1 (CONJ terminatedthm runthm)))));

e (`regs0 0 = n2w 0` by METIS_TAC [w2n_ELIM] THEN Q.PAT_ASSUM  `0 = i` (K ALL_TAC));
e (ASM_REWRITE_TAC []);
(*
e (ASM_SIMP_TAC run_ss [] THEN WORD_TAC);
e (ASM_SIMP_TAC run_ss [] THEN WORD_TAC);
*)
val tm1 = rand(rhs(fst(dest_imp(snd(top_goal())))));
val th1 = SIMP_RULE std_ss []
             ((RUN_CONV THENC REWRITE_CONV (map ASSUME (fst(top_goal())))
               THENC RUN_CONV) tm1);
expandf (ASSUME_TAC th1);

(* Last two steps *)
e (POP_ASSUM (fn runthm =>
   POP_ASSUM (fn regthm => 
   POP_ASSUM (fn terminatedthm => 
      SUBST1_TAC (MATCH_MP (Q.SPEC `2` TERRUN_LEM_2) (CONJ terminatedthm runthm))
   THEN ASSUME_TAC regthm
   THEN ASSUME_TAC (MATCH_MP TERRUN_LEM_1 (CONJ terminatedthm runthm))))));
val tm2 = rand(rhs(fst(dest_imp(snd(top_goal())))));
e (PURE_REWRITE_TAC [RUN_CONV tm2]);
e (RW_TAC list_ss [TERRUN_STOP,Once fact_def]);
 THEN STRIP_TAC);

(*Step Case*)

e (POP_ASSUM MP_TAC);
e (POP_ASSUM (fn runthm =>
   POP_ASSUM (fn terminatedthm => 
      SUBST1_TAC (MATCH_MP (Q.SPEC `10` TERRUN_LEM_2) (CONJ terminatedthm runthm))
   THEN ASSUME_TAC (MATCH_MP TERRUN_LEM_1 (CONJ terminatedthm runthm)))));

e (`~(regs0 0 = 0w) /\ ~(regs0 0 <. 0w)` by METIS_TAC [SUC_LEM]);

val tm1a = rand(rhs(fst(dest_imp(snd(top_goal())))));
val th1a = SIMP_RULE std_ss []
             ((RUN_CONV THENC REWRITE_CONV (map ASSUME (fst(top_goal())))
               THENC RUN_CONV) tm1a);
e (NTAC 2 (POP_ASSUM (K ALL_TAC)));
expandf (PURE_REWRITE_TAC [th1a]);




 SIMP_TAC list_ss [read_thm] THEN REPEAT STRIP_TAC 
 THEN  (*  Process the first three instructions :
            0:   mov     ip, sp
            1:   stmfd   sp!, {fp,ip,lr,pc}
            2:   sub     fp, ip, #1           *)
 `?pc' cpsr' regs' mems'. 
     run 3 (instB,16) (0,cpsr0,regs0,mems0) = (pc',cpsr',regs',mems')`
   by METIS_TAC [ABS_PAIR_THM] THEN
 `terRun (instB,16) (0,cpsr0,regs0,mems0) = 
  terRun (instB,16) (pc',cpsr',regs',mems')` 
     by METIS_TAC [TERMINATED_THM,TERRUN_THM]
 THEN POP_ASSUM SUBST_ALL_TAC
 THEN POP_ASSUM MP_TAC
 THEN NTAC 3 ONE_STEP_TAC
 

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


 REWRITE_TAC [read_thm] THEN REPEAT STRIP_TAC 
 THEN

 (*  Process the first three instructions :
          0:          mov     ip, sp
          1:          stmfd   sp!, {fp,ip,lr,pc}
          2:          sub     fp, ip, #1
 *)

 `?pc' cpsr' regs' mems'. 
       run 3 (instB,16) (pc0,cpsr0,regs0,mems0) = (pc',cpsr',regs',mems')`
     by METIS_TAC [ABS_PAIR_THM] THEN
  `terminated (instB,16) (pc',cpsr',regs',mems')` 
     by METIS_TAC [TERMINATED_THM] THEN
  `terRun (instB,16) (0,cpsr0,regs0,mems0) = 
   terRun (instB,16) (pc',cpsr',regs',mems')` 
     by METIS_TAC [TERRUN_THM] THEN
  ASM_REWRITE_TAC []	 THEN

  Q.PAT_ASSUM `run 3 (instB,16) x = y` MP_TAC THEN
  NTAC 3 ONE_STEP_TAC THEN
  REWRITE_TAC [run_def] THEN STRIP_TAC THEN

  POP_ASSUM (ASSUME_TAC o SYM) THEN
  FULL_SIMP_TAC std_ss [] THEN
  NTAC 5 (POP_ASSUM (K ALL_TAC)) THEN

 (*  Now process the recursive body *)

  `!cpsr mems. 
   ?k. let (pc',cpsr',regs',mems') = 
           run k (instB,16) (3,cpsr,
                            (\k. k = 15 => 3w | 
                                 k = 11 => 99w | 
                                 k = 13 => 96w | 
                                 k = 12 => 100w | regs0 k), mems) 
       in
          (pc' = 14) /\  
          (regs' 0 = fact(regs0 0,regs0 1)) /\
          (regs' 11 = 99w) /\ 
          (regs' 12 = 100w) /\ 
          (regs' 13 = 96w)` by ALL_TAC THENL [

        NTAC 5 (POP_ASSUM (K ALL_TAC)) THEN
        Induct_on `w2n (regs0 0)` THEN REPEAT STRIP_TAC THENL [

                (* Base case *)

                `regs0 0 = n2w 0` by METIS_TAC [w2n_ELIM] THEN
                Q.PAT_ASSUM  `0 = i` (K ALL_TAC) THEN
                Q.EXISTS_TAC `4` THEN
                NTAC 4 ONE_STEP_TAC THEN REWRITE_TAC [Once fact_def, run_def] THEN
                RW_TAC list_ss [ABS_PAIR_THM],

                (* Inductive case  *)

                FULL_SIMP_TAC list_ss [GSYM RIGHT_FORALL_IMP_THM] THEN
                `?pc1 cpsr1 regs1 mems1. 
                    run 10 (instB,16) 
                           (3,cpsr,
                           (\k. k = 15 => 3w | 
                                k = 11 => 99w | 
                                k = 13 => 96w |
                                k = 12 => 100w | regs0 k),mems) 
                     = (pc1,cpsr1,regs1,mems1)`
                        by METIS_TAC [ABS_PAIR_THM] THEN
                PAT_ASSUM ``!regs01 cpsr mems.x`` 
                            (ASSUME_TAC o Q.SPECL [`regs1`,`cpsr1`,`mems1`]) THEN
                FULL_SIMP_TAC list_ss [GSYM RIGHT_EXISTS_IMP_THM] THEN

                Q.EXISTS_TAC `10 + k` THEN REWRITE_TAC [RUN_THM_1] THEN
                Q.ABBREV_TAC `runf = run k (instB,16)` THEN ASM_REWRITE_TAC [] THEN

                IMP_RES_TAC WORD_IND_LEM THEN
                Q.PAT_ASSUM `run 10 (instB,16) x = y` (MP_TAC) THEN
                NTAC 10 ONE_STEP_TAC THEN
                REWRITE_TAC [Once run_def] THEN STRIP_TAC THEN

                PAT_ASSUM (Term `v = w2n (regs0 0 - 1w)`) (ASSUME_TAC o WORD_RULE) THEN
                `v = w2n (regs1 0)` by RW_TAC list_ss [] THEN reduceLib.REDUCE_TAC THEN
                FULL_SIMP_TAC list_ss [ABS_PAIR_THM] THEN

                `(\k1. k1 = 15 => n2w pc1 | 
                       k1 = 11 => 99w | 
                       k1 = 13 => 96w | 
                       k1 = 12 => 100w | regs1 k1) 
                  = regs1` by
                        RW_TAC arith_ss [FUN_EQ_THM] THENL [
                                NTAC 6 (POP_ASSUM (K ALL_TAC)) THEN RW_TAC arith_ss [] THEN
                                FULL_SIMP_TAC arith_ss [],

                        REWRITE_TAC [Once fact_def] THEN WORD_TAC THEN
                        `(regs1 0 = regs0 0 + 4294967295w) /\ 
                         (regs1 1 = regs0 0 * regs0 1)` by RW_TAC arith_ss [] THEN
                        FULL_SIMP_TAC list_ss [ABS_PAIR_THM, LET_THM]
                        ]
                ],

        (*  Process the last two instructions :
                  14:          sub     sp, fp, #2
                  15:          ldmfd   sp, {fp,sp,pc}
        *)

        POP_ASSUM (STRIP_ASSUME_TAC o REWRITE_RULE [LET_THM] o 
                   (Q.SPECL [`cpsr0`, `(\addr. addr = 97 => regs0 11
                                        | addr = 98 => 100w
                                        | addr = 99 => 16w | 
                                        addr = 100 => 1w | mems0 addr)`])) THEN
        Q.PAT_ASSUM `terminated (instB,16) (pc0,cpsr0,regs0,mems0)` (K ALL_TAC) THEN
        IMP_RES_TAC (Q.SPEC `k` TERRUN_THM) THEN
        POP_ASSUM (ASSUME_TAC o Q.SPEC `k`) THEN
        ONCE_ASM_REWRITE_TAC [] THEN POP_ASSUM (K ALL_TAC) THEN

        `?pc1 cpsr1 regs1 mems1. 
           run k (instB,16)
               (3,cpsr0, (\k. k = 15 => 3w | k = 11 => 99w | 
                              k = 13 => 96w | k = 12 => 100w | regs0 k),
                (\addr. addr = 97 => regs0 11 | addr = 98 => 100w | 
                        addr = 99 => 16w | addr = 100 => 1w | mems0 addr)) 
           = (pc1,cpsr1,regs1,mems1)` by METIS_TAC [ABS_PAIR_THM] THEN
        `terminated (instB,16) (pc1,cpsr1,regs1,mems1)` by METIS_TAC [TERMINATED_THM] THEN
        FULL_SIMP_TAC list_ss [] THEN
        `terRun (instB,16) (14,cpsr1,regs1,mems1) 
           =
         terRun (instB,16) (run 2 (instB,16) (pc1,cpsr1,regs1,mems1))` 
          by METIS_TAC [TERRUN_THM] THEN
        ONCE_ASM_REWRITE_TAC [] THEN
        POP_ASSUM (K ALL_TAC) THEN
        NTAC 2 ONE_STEP_TAC THEN
        RW_TAC std_ss [run_def, TERRUN_STOP]
    ]

