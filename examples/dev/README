
===============================================================================
== This directory contains Juliano's HOL files modified by MJCG & KXS        ==
== [see end of this file for version history]                                ==
===============================================================================

composeScript.sml ......... definition of devices and their composition
devScript.sml.............. definition and theorems on liveness
compileScript.sml ......... definitions and theorems to support compiler
compile.sml ............... convert to combinators and compile to circuits
vsynth.sml ................ convert a circuit made with MAKE_CIRCUIT to Verilog
FactScript.sml ............ an example
dff ....................... Melham's temporal abstraction theory
Holmakefile ............... instructions for Holmake

*******************************************************************************
There are six levels of abstraction:

 S: Source       (subset of TFL)
 I: Intermediate (source combinators Atm, Seq, Par, Ite, Rec)
 D: Devices      (handshake hardware combinators: ATM, SEQ, PAR, ITE, REC)
 N: Netlist      (abstract device predicates: unclocked DEL and DFF)
 C: Circuit      (clocked synchronous device predicates: Dtype, Dff)
 V: Verilog      (netlist pretty-printed into Verilog)

The main user-level functions are hwDefine, REFINE and MAKE_NETLIST
for creating hardware, refining it and then creating a netlist
representation, and MAKE_CIRCUIT and MAKE_VERILOG for creating
Verilog HDL output.
*******************************************************************************

To make generated hardware devices a bit more readable, the following
(experimental) infixes are now defined in composeScript.sml

   set_fixity ";;" (Infixl 750); overload_on (";;", ``SEQ``)
   set_fixity "||" (Infixl 650); overload_on ("||", ``PAR``)

The bus concatenation operator <> is defined by:

   |- !f g. f <> g = (\t. (f t,g t))

Abstract device netlists are generated by MAKE_NETLIST and contain the
following components combinational components:

  |- COMB f (inp,out)      = !t. out t = f (inp t)
  |- CONSTANT c out        = !t. out t = c
  |- MUX (sel,in1,in2,out) = !t. out t = (if sel t then in1 t else in2 t
  |- AND (in1,in2,out)     = !t. out t = in1 t /\ in2 t
  |- OR (in1,in2,out)      = !t. out t = in1 t \/ in2 t
  |- NOT (inp,out)         = !t. out t = ~inp t

and two kinds of sequential components (registers):

  |- DEL (inp,out)         = (out 0 = inp 0) /\ !t. out(t+1) = inp t
  |- DFF (d,clk,q)         = !t. q(t+1) =
                                 if POSEDGE clk (t+1) then d(t+1) else q t

where:

  |- POSEDGE s t = if t=0 then F else ~s(t-1) /\ s t

The components DEL and DFF do not correspond to standard components,
so they are implemented in terms of simpler ones:

  |- REG (inp,out) = !t. out (t + 1) = inp t
  |- REGF(inp,out) = (out 0 = F) /\ REG (inp,out)

These are then implemented in terms of standard clocked reqisters:

  |- Dtype (ck,d,q) = !t. q (t+1) = (if Rise ck t then d t else q t)
  |- Dff   (ck,d,q) = (q 0 = F) /\ Dtype(ck,d,q)

where:

 |- Rise s t = ~(s t) /\ s(t+1)

The implementation of REG and REGF in terms of Dtype and Dff involves
a temporal abstraction, since Dtype and Dff are edge-triggered on a
clock, but REG and REGF are not.  The refinement from the unclocked
level of abstraction to the clocked circuit level is implemented
formally using infrastructure from Melham's theory of temporal
abstraction in the directory dff:

Using Melham's dff theories it is proved in compileScript.sml that:

 |- InfRise clk ==> !d q. Dtype (clk,d,q) ==> REG (d at clk,q at clk)
 |- InfRise clk ==> !d q. Dff (clk,d,q) ==> REGF (d at clk,q at clk)

Where

 |- Inf sig = !t. ?t'. t < t' /\ sig t'        (* sig true infinitely often) *)
 |- InfRise clk = Inf(Rise clk)      (* clk has infinitely many rising edges *)
 |- s at clk = s when (Rise clk)         (* s sampled at rising edges of clk *)

The term ``(s when P) n`` gives the value of s at the time when P is
true on the n-th occasion (``when`` is defined using the choice
operator in dff/tempabsScript.sml). Thus ``s at clk`` is ``s`` sampled
at rising edges of ``clk`` (the sampling being just before the clock rises).
Note that ``s at clk`` is similar to ``s@clk`` in PSL.

Clocked synchronous circuits using combinational logic and the
registers Dtype and Dff are synthesised using MAKE_CIRCUIT.

*******************************************************************************


hwDefine : term frag list -> thm * thm * thm
--------------------------------------------

Single entrypoint for definitions where proof of termination will
succeed. Allows measure function to be indicated in same quotation as
definition, or not.
                                                                         
    hwDefine lib `(eqns) measuring f`                                    
                                                                         
will use f as the measure function and attempt automatic termination
proof. If successful, returns (|- eqns, |- ind, |- dev) 

NB. the recursion equations must be parenthesized; otherwise, strange
    parse errors result. Also, the name of the defined function must be
    alphanumeric.
                                                                         
One can also not mention the measure function, as in Define:             
                                                                         
    hwDefine `eqns`                                                  
                                                                         
which will accept either non-recursive or recursive specifications. It
returns a triple (|- eqns, |- ind, |- dev) where the ind theorem
should be ignored (it will be numTheory.INDUCTION.

See FactScript.sml for examples.


REFINE: (term -> thm) -> thm -> thm
-----------------------------------
 
The first argument of REFINE is a "refine function", refine say,
which maps a term representing a circuit, <circuit> say, to a theorem

   |- <circuit'> ===> <circuit>

where ``===>`` is defined by:

   |- P ===> Q  =  !x. P x ==> Q x.

and <circuit'> is a term representing the result of refining <circuit>
with the function refine.

Evaluating

   REFINE refine (|- <circuit> ===> Dev f)

applies refine to <circuit> to get

   |- <circuit'> ===> <circuit>

and then uses transitivity of ===> (DEV_IMP_TRANS) to deduce:

   |- <circuit'> ===> Dev f

See FactScript.sml for examples.


Two useful refine functions are ATM_REFINE and LIB_REFINE.


ATM_REFINE : term -> thm
------------------------

This maps ``DEV f`` to |- ATM f ===> DEV f


LIB_REFINE : thm list -> term -> thm
------------------------------------

Evaluating

   LIB_REFINE
    [|- <circuit> ===> DEV f1,
     |- <circuit> ===> DEV f2
     ...
     |- <circuit> ===> DEV fn]
    ``DEV fi``

returns the first theorem |- <circuit> ===> DEV fi that it finds in the
supplied list (i.e. the supplied library).

Refinement functions (analogously to conversions and tactics) can be combined using
combinators THENR, ORELSER, DEPTHR. See FactScript.sml for examples.


THENR : (term -> thm) * (term -> thm) -> (term -> thm)
------------------------------------------------------

Combines refinements sequentially.


ORELSER : (term -> thm) * (term -> thm) -> (term -> thm)
--------------------------------------------------------

Tries first refinement and if that fails tries the second one.


DEPTHR : (term -> thm) -> (term -> thm)
---------------------------------------------

Scans through a term representing a circuit applying the supplied
refinement function to each subterm of the form ``DEV f`` and 
either generating

 |- DEV g ===> DEV f

if the refinement function returns this, or, if the refinement
function fails:

 |- DEV f ===> DEV f

A refined circuit is then build up using the "monotonicity" theorems:

  SEQ_DEV_IMP =
   |- !P1 P2 Q1 Q2.
       P1 ===> Q1 /\ P2 ===> Q2
       ==>
       (SEQ P1 P2 ===> SEQ Q1 Q2)

  PAR_DEV_IMP =
   |- !P1 P2 Q1 Q2.
       P1 ===> Q1 /\ P2 ===> Q2
       ==>
       (PAR P1 P2 ===> PAR Q1 Q2)

  ITE_DEV_IMP =
   |- !P1 P2 P3 Q1 Q2 Q3.
       P1 ===> Q1 /\ P2 ===> Q2 /\ P3 ===> Q3
       ==>
       (ITE P1 P2 P3 ===> ITE Q1 Q2 Q3)

  REC_DEV_IMP =
   |- !P1 P2 P3 Q1 Q2 Q3.
       P1 ===> Q1 /\ P2 ===> Q2 /\ P3 ===> Q3
       ==>
       (REC P1 P2 P3 ===> REC Q1 Q2 Q3)

  PRECEDE_DEV_IMP
  |- !f P Q. P ===> Q ==> PRECEDE f P ===> PRECEDE f Q 

Note that "DEPTHR refine" should never fail.


add_combinational : string list -> unit
---------------------------------------

Add a list of constant names to the constants that are implemented as
combinational by the compiler. The definition is:

 fun add_combinational l = 
  (combinational_constants := union l (!combinational_constants)); 

The initial list of combinational constant names (i.e. the initial
value of the reference combinational_constants) is:

  ["T","F","/\\","\\/","~",",","o","CURRY","UNCURRY","COND",
   "FST","SND","=","Seq","Par","Ite","0","NUMERAL","BIT1","BIT2","ZERO",
   "+","-"];


is_combinational : term -> bool
-------------------------------

Test whether a terms is a combinational function of its free variables
(i.e. is built up using only combinational constants).


MAKE_NETLIST : thm -> thm
-------------------------

Evaluating

 MAKE_NETLIST (|- <device> ===> DEV f)

unfolds <device> using the definitions of ATM, SEQ, PAR, ITE and REC
and normalises the resulting term into a form, <netlist> say,
corresponding to a netlist, and returns

 |- (\(load,inp,done,out). <netlist> ===> DEV f

See FactScript.sml for examples (e.g. FACT_net).


MAKE_CIRCUIT : thm -> thm
-------------------------

Evaluating

 MAKE_CIRCUIT (|- <device> ===> DEV f)

unfolds <device> into a netlist, then replaces DEL and DFF by
implementations using REG and REGF and then, uing Melham's temporal
abstraction theory in dff, refines the unclocked REG and REGF to
clocked Dtype and Dff, and returns:

 |- InfClock clk
    ==>
    <circuit> 
    ==> 
    DEV f (load at clk,inp at clk,done at clk,out at clk)

See FactScript.sml for examples (e.g. FACT_cir).


MAKE_VERILOG : string 
                -> int 
                -> int 
                -> thm
                -> (int * int * (string * string) list * int) list
                -> unit
------------------------------------------------------------------

Evaluating

 MAKE_VERILOG
  file
  maxtime 
  period
  (|- InRise clk 
      ==>
      (?v0 .... vn. (inp = inp1 <> ... <> inpu) /\
                    (out = out1 <> ... <> outv) /\
                    <circuit>)
      ==>
      DEV Spec (load at clk,inp at clk,done at clk,out at clk))
  stimulus 
 
creates a file "file.vl" containing the definitions of the modules
used in <circuit> and a module Main corresponding to the circuit
represented by the supplied theorem (assumed made with MAKE_CIRCUIT).

The module Main has a parameter maxtime giving the length of the
simulation.

The clock line clk and the handshake completion line done are declared
to be boolean wires. The internal variables v0, ... ,vn are declared
to be wires of appropriate widths (computed from their types).

The input load is declared to be a boolean register and the inputs
inp1, ... ,inpu are declared to be registers of the appropriate width.

A dumpfile called "file.vcd" is created and clk, load, and signals
inp1, ... ,inpu, done, out1, ... ,outv are declared to have their value
changes dumped to the VCD file.

The module Main also has an instance for each occurrence of a module
in <circuit> (with the sizes computed from the types).

An instance of Clock is created with time between edges as specified
by the parameter period.

The input variables are driven according to the parameter stimulus,
which is an ML list of tuples of the form:

 (start_delay, load_delay, [("inp1",val),...,("inpu",val)], end_delay)

Each such tuple specifies a transaction:

 1. delay of start_delay;
 2. "load" is set to 0;
 3. delay of load_delay (a positive integer);
 4. each input is driven with the supplied value
    (a string that prints to a valid Verilog expression);
 5. delay of end_delay;
 6. "load" is driven high.

Current code is extremely "alpha" having only been tested on one example!

I am using Icarus Verilog for simulation
(http://www.icarus.com/eda/verilog/) and GTKWave
(http://www.cs.man.ac.uk/apt/tools/gtkwave/) for viewing VCD files.
Both are public domain and seem to work.

*******************************************************************************

Auxiliary functions of interest include the following.

Convert : thm -> thm
--------------------

Convert (|- f x = e) returns a theorem |- f = p, where p is a
combinatory expression built from the combinators Seq, Par and Ite.


RecConvert: : thm -> thm -> thm
-------------------------------

RecConvert (|- f x = if f1 x then f2 x else f(f3 x)) (|- TOTAL(f1,f2,f3))
returns a theorem

 |- f = Rec(p1,p2,p3)

where p1, p2 and p3 are combinatory expressions built from the
combinators Seq, Par and Ite.

A term PRECEDE f d represents a device d preceded by combinational
logic and a term FOLLOW d f represents a device d followed by
combinational logic. 

  |- PRECEDE f d =
      (\(load,inp,done,out). ?v. COMB f (inp,v) /\ d(load,v,done,out))

  |- FOLLOW d f =
      (\(load,inp,done,out). ?v. d(load,inp,done,v) /\ COMB f (v,out))

The function f representing the combinational logic must only contain
constants declared combinational by having their names included in the
ML assignable list "combinational_constants".

Currently PRECEDE and FOLLOW are eliminated when generating netlists,
but they may appear in the output of the compiler (see the
CompileConvert example below).


CompileProg : thm list -> term -> thm
-------------------------------------

CompileProg takes a program and a constant defined in the program

 CompileProg : thm list -> term -> thm
               --------    ----
               program   constant

When the compiler encounters a function f that isn't an application of
Seq, Par or Ite, then DEV f is generated. It is assumed this
will subsequently be refined to hardware (see Refine).

Compile : thm -> thm
--------------------

Compile (|- c = e)  =  CompileProg [|- c = e] ``c``


CompileConvert : thm -> thm
---------------------------

Converts a non-recursive equation to combinators and then compiles to
a device implementation.

Example: 

 Fact;
 > val it = |- !n. Fact n = SND (FactIter (n,1)) : thm

 - CompileConvert Fact;
 > val it =
     |- FOLLOW (PRECEDE (Par (\n. n) (\n. 1)) (DEV FactIter)) SND 
        ===>
        DEV Fact : thm


RecCompileConvert : thm -> thm -> thm
-------------------------------------

Converts a recursive equation to combinators and then compiles to a
device implementation Needs a totality theorem (user-supplied as third
argument).

Example:

- val FactIter =
    |- FactIter (n,acc) =
       (if n = 0 then (n,acc) else FactIter (n - 1,n * acc))

- val FactIter_TOTAL =
    |- TOTAL
         ((\(n,acc). n = 0),(\(n,acc). (n,acc)),(\(n,acc). (n - 1,n * acc)))

 - RecCompileConvert FactIter FactIter_TOTAL;
 > val it =
     |- REC(FOLLOW (DEV (\(n,acc). n) || DEV (\(n,acc). 0)) (UNCURRY $=))
           (DEV (\x. x))
           (DEV (\x. FST x - 1) || PRECEDE (\x. x) (DEV (UNCURRY $*)))
        ===>
        DEV FactIter


COMB_SYNTH_CONV : term -> thm
-----------------------------

One step of conversion of

 ``COMB 
    (\(i1,...,im). (<term1>,...,<termn>) 
    (inp1 <> ... <> inpm, out1 <> .... outn)``

to a netlist.

Example:

- COMB_SYNTH_CONV 
   ``COMB (\(m,n,p). (m-p, SUC(m+n+(p-1)))) (in1<>in2<>in3,out1<>out2)``;
> val it =
    |- COMB (\(m,n,p). (m - p,SUC (m + n + (p - 1))))
         (in1 <> in2 <> in3,out1 <> out2) =
       COMB (\(m,n,p). m - p) (in1 <> in2 <> in3,out1) /\
       COMB (\(m,n,p). SUC (m + n + (p - 1))) (in1 <> in2 <> in3,out2) : thm

To completely convert to a netlist COMB_SYNTH_CONV needs to be
iterated. Example:

- REDEPTH_CONV COMB_SYNTH_CONV 
   ``COMB (\(m,n,p). (m-p, SUC(m+n+(p-1)))) (in1<>in2<>in3,out1<>out2)``;
> val it =
    |- COMB (\(m,n,p). (m - p,SUC (m + n + (p - 1))))
         (in1 <> in2 <> in3,out1 <> out2) =
       (?v709 v710.
          (v709 = in1) /\ (v710 = in3) /\
          COMB (UNCURRY $-) (v709 <> v710,out1)) /\
       ?v711.
         (?v712 v713.
            (?v714 v715.
               (v714 = in1) /\ (v715 = in2) /\
               COMB (UNCURRY $+)
                 (v714 <> v715,v712)) /\
            (?v716 v717.
               (v716 = in3) /\ CONSTANT 1 v717 /\
               COMB (UNCURRY $-)
                 (v716 <> v717,v713)) /\
            COMB (UNCURRY $+)
              (v712 <> v713,v711)) /\
         COMB SUC (v711,out2) : thm

Note that the redundant variables are pruned by MAKE_NETLIST and also,
for readability, the example above uses ``v709`` but COMB_SYNTH_CONV
actually generates ``%%genvar%%709`.

COMB_SYNTH_CONV may print out some diagnostic stuff if it fails to
prove certain subgoals (though it may nevertheless still produce
something reasonable).  This output can be switched off by setting the
ML reference "if_print_flag" to false.


=============================================================================== 


===============================================================================
== This directory contains Juliano's HOL files modified by MJCG & KXS        ==
== [Revised version incorporating Juliano's new treatment of recursion]      ==
== [Revised version incorporating liveness]                                  ==
== [04.01.05: improved proofs from KXS in composeScript.sml & devScript.sml] ==
== [09.01.05: MJCG added converter to combinators Seq, Par, Ite, Rec]        ==
== [13.01.05: major tidy and update by MJCG]                                 ==
== [17.01.05: MJCG installed hwDefine and improved examples from KXS]        ==
== [18.01.05: MJCG added Refine and revised FactScript.sml]                  ==
== [19.01.05: MJCG changed to use refinement combinators]                    ==
== [20.01.05: MJCG added netlist synthesis]                                  ==
== [21.01.05: MJCG minor changes and README update]                          ==
== [27.01.05: MJCG added hw synthesis improvements]                          ==
== [28.01.05: MJCG more optimisations and updated README]                    ==
== [29.01.05: MJCG added COMB_SYNTH_CONV removed SEL operators]              ==
== [30.01.05: MJCG added dff: Melham's temporal abstraction theory]          ==
== [01.02.05: MJCG minor tweaks to MAKE_NETLIST and COMB_SYNTH_CONV]         ==
== [06.02.05: MJCG added refinement to clocked dtype registers               ==
== [08.02.05: MJCG added ?-quantification of internal wires to MAKE_CIRCUIT  ==
== [10.02.05: MJCG split input and output busses                             ==
== [11.02.05: Holmakefile (thanks to MN) + code improvements (thanks to KXS) ==
== [14.02.05: MJCG added vsynth (defines MAKE_VERILOG)                       ==
===============================================================================
