
===============================================================================
== This directory contains Juliano's HOL files modified by MJCG & KXS        ==
== [Revised version incorporating Juliano's new treatment of recursion]      ==
== [Revised version incorporating liveness]                                  ==
== [04.01.05: improved proofs from KXS in composeScript.sml & devScript.sml] ==
== [09.01.05: MJCG added converter to combinators Seq, Par, Ite, Rec]        ==
== [13.01.05: major tidy and update by MJCG]                                 ==
== [17.01.05: MJCG installed hwDefine and improved examples from KXS]        ==
== [18.01.05: MJCG added Refine and revised FactScript.sml]                  ==
== [19.01.05: MJCG changed to use refinement combinators]                    ==
===============================================================================

composeScript.sml ......... definition of devices and their composition
devScript.sml.............. definition and theorems on liveness
compileScript.sml ......... definitions and theorems to support compiler
compile.sml ............... convert to combinators and compile to devices
FactScript.sml ............ an example

N.B. To make generated hardware a bit more readable, the following
     (experimental) infixes are now defined in composeScript.sml

        set_fixity ";;" (Infixl 750); overload_on (";;", ``SEQ``)
        set_fixity "||" (Infixl 650); overload_on ("||", ``PAR``)

The main user-level functions are hwDefine and REFINE,
for creating hardware and then refining it.

hwDefine : term frag list -> thm * thm * thm
--------------------------------------------

Single entrypoint for definitions where proof of termination will
succeed. Allows measure function to be indicated in same quotation as
definition, or not.
                                                                         
    hwDefine lib `(eqns) measuring f`                                    
                                                                         
will use f as the measure function and attempt automatic termination
proof. If successful, returns (|- eqns, |- ind, |- dev) 

NB. the recursion equations must be parenthesized; otherwise, strange
    parse errors result. Also, the name of the defined function must be
    alphanumeric.
                                                                         
One can also not mention the measure function, as in Define:             
                                                                         
    hwDefine `eqns`                                                  
                                                                         
which will accept either non-recursive or recursive specifications. It
returns a triple (|- eqns, |- ind, |- dev) where the ind theorem
should be ignored (it will be numTheory.INDUCTION.

See FactScript.sml for examples.


REFINE: (term -> thm) -> thm -> thm
-----------------------------------
 
The first argument of REFINE is a "refine function", refine say,
which maps a term representing a circuit, <circuit> say, to a theorem

   |- <circuit'> ===> <circuit>

where ``===>`` is defined by:

   |- P ===> Q  =  !x. P x ==> Q x.

and <circuit'> is a term representing the result of refining <circuit>
with the function refine.

Evaluating

   REFINE refine (|- <circuit> ===> Dev f)

applies refine to <circuit> to get

   |- <circuit'> ===> <circuit>

and then uses transitivity of ===> (DEV_IMP_TRANS) to deduce:

   |- <circuit'> ===> Dev f

See FactScript.sml for examples.


Two useful refine functions are ATM_REFINE and LIB_REFINE.


ATM_REFINE : term -> thm
------------------------

This maps ``DEV f`` to |- ATM f ===> DEV f


LIB_REFINE : thm list -> term -> thm
------------------------------------

Evaluating

   LIB_REFINE
    [|- <circuit> ===> DEV f1,
     |- <circuit> ===> DEV f2
     ...
     |- <circuit> ===> DEV fn]
    ``DEV fi``

returns the first theorem |- <circuit> ===> DEV fi that it finds in the
supplied list (i.e. the supplied library).

Refinement functions (analogously to conversions and tactics) can be combined using
combinators THENR, ORELSER, DEPTHR. See FactScript.sml for examples.


THENR : (term -> thm) * (term -> thm) -> (term -> thm)
------------------------------------------------------

Combines refinements sequentially.


ORELSER : (term -> thm) * (term -> thm) -> (term -> thm)
--------------------------------------------------------

Tries first refinement and if that fails tries the second one.


DEPTHR : (term -> thm) -> (term -> thm)
---------------------------------------------

Scans through a term representing a circuit applying the supplied
refinement function to each subterm of the form ``DEV f`` and 
either generating

 |- DEV g ===> DEVf

if the refinement function returns this, or, if the refinement
function fails:

 |- DEV f ===> DEV f

A refined circuit is then build up using the "monotonicity" theorems:

  SEQ_DEV_IMP =
   |- !P1 P2 Q1 Q2.
       P1 ===> Q1 /\ P2 ===> Q2
       ==>
       (SEQ P1 P2 ===> SEQ Q1 Q2)

  PAR_DEV_IMP =
   |- !P1 P2 Q1 Q2.
       P1 ===> Q1 /\ P2 ===> Q2
       ==>
       (PAR P1 P2 ===> PAR Q1 Q2)

  ITE_DEV_IMP =
   |- !P1 P2 P3 Q1 Q2 Q3.
       P1 ===> Q1 /\ P2 ===> Q2 /\ P3 ===> Q3
       ==>
       (ITE P1 P2 P3 ===> ITE Q1 Q2 Q3)

  REC_DEV_IMP =
   |- !P1 P2 P3 Q1 Q2 Q3.
       P1 ===> Q1 /\ P2 ===> Q2 /\ P3 ===> Q3
       ==>
       (REC P1 P2 P3 ===> REC Q1 Q2 Q3)

Note that "DEPTHR refine" should never fail.


*******************************************************************************

Auxiliary functions of interest include the following.

Convert : thm -> thm
--------------------

Convert (|- f x = e) returns a theorem |- f = p, where p is a
combinatory expression built from the combinators Seq, Par and Ite.


RecConvert: : thm -> thm -> thm
-------------------------------

RecConvert (|- f x = if f1 x then f2 x else f(f3 x)) (|- TOTAL(f1,f2,f3))
returns a theorem

 |- f = Rec(p1,p2,p3)

where p1, p2 and p3 are combinatory expressions built from the
combinators Seq, Par and Ite.


Compile : thm list -> term -> thm
---------------------------------------------

Compile takes a program and a constant defined in the program

 Compile : thm list -> term -> thm
           --------    ----
           program   constant

When the compiler encounters a function f that isn't an application of
Seq, Par or Ite, then DEV f is generated. It is assumed this
will subsequently be refined to hardware (see Refine).

N.B. Not sure that the program argument is really useful. 
     It may get eliminated.

ConvertCompile : thm -> thm
---------------------------

Converts a non-recursive equation to combinators and then compiles to
a device implementation.

Example: 

 Fact;
 > val it = |- !n. Fact n = SND (FactIter (n,1)) : thm

 - ConvertCompile Fact;
 > val it =
     |- SEQ (SEQ (PAR (ATM (\n. n)) (ATM (\n. 1))) (ATM FactIter)) (ATM SND) 
        ===> 
        DEV Fact : thm


RecConvertCompile : thm -> thm -> thm
-------------------------------------

Converts a recursive equation to combinators and then compiles to a
device implementation Needs a totality theorem (user-supplied as third
argument).

Example:

- val FactIter =
    |- FactIter (n,acc) =
       (if n = 0 then (n,acc) else FactIter (n - 1,n * acc))

- val FactIter_TOTAL =
    |- TOTAL
         ((\(n,acc). n = 0),(\(n,acc). (n,acc)),(\(n,acc). (n - 1,n * acc)))

 - RecConvertCompile FactIter FactIter_TOTAL;
 > val it =
    |- REC
         (SEQ (PAR (ATM (\(n,acc). n)) (ATM (\(n,acc). 0)))
              (ATM (UNCURRY $=)))
         (PAR (ATM (\(n,acc). n)) (ATM (\(n,acc). acc)))
         (PAR
            (SEQ (PAR (ATM (\(n,acc). n)) (ATM (\(n,acc). 1)))
                 (ATM (UNCURRY $-)))
            (SEQ (PAR (ATM (\(n,acc). n)) (ATM (\(n,acc). acc)))
                 (ATM (UNCURRY $*)))) 
       ===> 
       DEV FactIter


=============================================================================== 
