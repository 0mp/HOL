
===============================================================================
== This directory contains Juliano's HOL files modified by MJCG & KXS        ==
== [Revised version incorporating Juliano's new treatment of recursion]      ==
== [Revised version incorporating liveness]                                  ==
== [04.01.05: improved proofs from KXS in composeScript.sml & devScript.sml] ==
== [09.01.05: MJCG added converter to combinators Seq, Par, Ite, Rec]        ==
== [13.01.05: major tidy and update by MJCG]                                 ==
== [17.01.05: MJCG installed hwDefine and improved examples from KXS]        ==
== [18.01.05: MJCG added Refine and revised FactScript.sml]                  ==
== [19.01.05: MJCG changed to use refinement combinators]                    ==
== [20.01.05: MJCG added netlist synthesis]                                  ==
== [21.01.05: MJCG minor changes and README update]                          ==
== [26.01.05: MJCG added hw synthesis improvements]                          ==
===============================================================================

composeScript.sml ......... definition of devices and their composition
devScript.sml.............. definition and theorems on liveness
compileScript.sml ......... definitions and theorems to support compiler
compile.sml ............... convert to combinators and compile to devices
FactScript.sml ............ an example

*******************************************************************************
There are four levels of abstraction:

 S: Source       (subset of TFL)
 I: Intermediate (source combinators Atm, Seq, Par, Ite, Rec)
 C: Compiled     (hardware combinators ATM, SEQ, PAR, ITE, REC)
 N: Netlist      (existentially quantified conjunction of device predicates)
 V: Verilog      (netlist pretty-printed into Verilog)

The main user-level functions are hwDefine, REFINE and MAKE_NETLIST
for creating hardware, refining it and then creating a netlist
representation. Translation to Verilog is not yet implemented.
*******************************************************************************

To make generated hardware a bit more readable, the following
(experimental) infixes are now defined in composeScript.sml

   set_fixity ";;" (Infixl 750); overload_on (";;", ``SEQ``)
   set_fixity "||" (Infixl 650); overload_on ("||", ``PAR``)

The bus concatenation operator <> is defined by:

   |- !f g. f <> g = (\t. (f t,g t))

and some bus component selection operators are defined by:

   SEL_2_1_def = SEL_2_1 (inp,out) = (out = FST o inp)
   SEL_2_2_def = SEL_2_2 (inp,out) = (out = SND o inp)
   SEL_3_1_def = SEL_3_1 (inp,out) = (out = FST o inp)
   SEL_3_2_def = SEL_3_2 (inp,out) = (out = FST o SND o inp)
   SEL_3_3_def = SEL_3_3 (inp,out) = (out = SND o SND o inp)

These operators are introduced when creating netlists using
MAKE_NETLIST (see example below).

Other operators used in netlists are:

  |- CONSTANT c out = !t. out t = c
  |- BINOP f (in1,in2,out) = !t. out t = f(in1 t,in2 t)

*******************************************************************************


hwDefine : term frag list -> thm * thm * thm
--------------------------------------------

Single entrypoint for definitions where proof of termination will
succeed. Allows measure function to be indicated in same quotation as
definition, or not.
                                                                         
    hwDefine lib `(eqns) measuring f`                                    
                                                                         
will use f as the measure function and attempt automatic termination
proof. If successful, returns (|- eqns, |- ind, |- dev) 

NB. the recursion equations must be parenthesized; otherwise, strange
    parse errors result. Also, the name of the defined function must be
    alphanumeric.
                                                                         
One can also not mention the measure function, as in Define:             
                                                                         
    hwDefine `eqns`                                                  
                                                                         
which will accept either non-recursive or recursive specifications. It
returns a triple (|- eqns, |- ind, |- dev) where the ind theorem
should be ignored (it will be numTheory.INDUCTION.

See FactScript.sml for examples.


REFINE: (term -> thm) -> thm -> thm
-----------------------------------
 
The first argument of REFINE is a "refine function", refine say,
which maps a term representing a circuit, <circuit> say, to a theorem

   |- <circuit'> ===> <circuit>

where ``===>`` is defined by:

   |- P ===> Q  =  !x. P x ==> Q x.

and <circuit'> is a term representing the result of refining <circuit>
with the function refine.

Evaluating

   REFINE refine (|- <circuit> ===> Dev f)

applies refine to <circuit> to get

   |- <circuit'> ===> <circuit>

and then uses transitivity of ===> (DEV_IMP_TRANS) to deduce:

   |- <circuit'> ===> Dev f

See FactScript.sml for examples.


Two useful refine functions are ATM_REFINE and LIB_REFINE.


ATM_REFINE : term -> thm
------------------------

This maps ``DEV f`` to |- ATM f ===> DEV f


LIB_REFINE : thm list -> term -> thm
------------------------------------

Evaluating

   LIB_REFINE
    [|- <circuit> ===> DEV f1,
     |- <circuit> ===> DEV f2
     ...
     |- <circuit> ===> DEV fn]
    ``DEV fi``

returns the first theorem |- <circuit> ===> DEV fi that it finds in the
supplied list (i.e. the supplied library).

Refinement functions (analogously to conversions and tactics) can be combined using
combinators THENR, ORELSER, DEPTHR. See FactScript.sml for examples.


THENR : (term -> thm) * (term -> thm) -> (term -> thm)
------------------------------------------------------

Combines refinements sequentially.


ORELSER : (term -> thm) * (term -> thm) -> (term -> thm)
--------------------------------------------------------

Tries first refinement and if that fails tries the second one.


DEPTHR : (term -> thm) -> (term -> thm)
---------------------------------------------

Scans through a term representing a circuit applying the supplied
refinement function to each subterm of the form ``DEV f`` and 
either generating

 |- DEV g ===> DEV f

if the refinement function returns this, or, if the refinement
function fails:

 |- DEV f ===> DEV f

A refined circuit is then build up using the "monotonicity" theorems:

  SEQ_DEV_IMP =
   |- !P1 P2 Q1 Q2.
       P1 ===> Q1 /\ P2 ===> Q2
       ==>
       (SEQ P1 P2 ===> SEQ Q1 Q2)

  PAR_DEV_IMP =
   |- !P1 P2 Q1 Q2.
       P1 ===> Q1 /\ P2 ===> Q2
       ==>
       (PAR P1 P2 ===> PAR Q1 Q2)

  ITE_DEV_IMP =
   |- !P1 P2 P3 Q1 Q2 Q3.
       P1 ===> Q1 /\ P2 ===> Q2 /\ P3 ===> Q3
       ==>
       (ITE P1 P2 P3 ===> ITE Q1 Q2 Q3)

  REC_DEV_IMP =
   |- !P1 P2 P3 Q1 Q2 Q3.
       P1 ===> Q1 /\ P2 ===> Q2 /\ P3 ===> Q3
       ==>
       (REC P1 P2 P3 ===> REC Q1 Q2 Q3)

Note that "DEPTHR refine" should never fail.


MAKE_NETLIST : thm -> thm
-------------------------

Evaluating

 MAKE_NETLIST (|- <circuit> ===> DEV f)

unfolds the definition of <circuit> using the definitions of ATM, SEQ,
PAR, ITE and REC and normalises the resulting term into a form,
<netlist> say, corresponding to a netlist, and returns

 |- (\(load,inp,done,out). <netlist) ===> DEV f

The following example is from FactScript.sml

 val FACT_cir =
    |- (\(load,inp,done,out).
          ?v0 v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13 v14 v15 v16 v17 v18
             v19 v20 v21 v22 v23 v24 v25 v26 v27 v28 v29 v30 v31 v32 v33 v34
             v35 v36 v37 v38 v39 v40 v41 v42 v43 v44 v45 v46 v47 v48 v49 v50
             v51 v52 v54 v55 v56 v57 v58 v59 v60 v61 v62 v63 v64 v65 v66 v67
             v68 v69 v70 v71 v72 v73 v74 v75 v76 v77 v78 v79 v80 v81 v82 v83
             v84 v85 v86 v87 v88 v89 v90 v91 v92 v93 v94 v95 v96 v97 v98 v99
             v100 v101 v102 v103 v104 v105 v106 v107 v108 v109 v110 v111
             v112 v113 v114 v115 v116 v117 v118 v119 v120 v121 v122 v123
             v124 v125 v126 v127 v128 v129 v130 v131 v132 v133 v134 v135
             v136 v137 v138 v139 v140 v141 v142 v143 v144 v145 v146 v147
             v148 v149 v150 v151 v152 v153 v154 v155 v156 v157 v158 v159
             v160 v161 v162 v163 v164 v165 v166 v167 v168 v169 v170 v171
             v172 v173 v174 v175 v176 v177 v178 v179 v180 v181 v182 v183
             v184 v185 v186 v187 v188 v189 v190 v191 v192 v194 v195 v196
             v197 v198 v199 v200 v201 v202 v203 v204 v205 v206 v207.
            NOT (v1,v4) /\ OR (v4,load,v3) /\ DEL (v3,v19) /\
            NOT (v19,v18) /\ AND (v18,v3,v17) /\ DEL (v2,v16) /\
            AND (v17,v16,v15) /\ OR (v15,v14,v12) /\ DEL (v13,v21) /\
            NOT (v21,v20) /\ AND (v20,v13,v14) /\
            MUX (v14,v58 <> v57,((\x. x) <> (\x. 1)) o inp,v6) /\
            DFF (v6,v12,v11) /\ NOT (v22,v25) /\ OR (v25,v12,v24) /\
            DEL (v24,v36) /\ NOT (v36,v35) /\ AND (v35,v24,v34) /\
            DEL (v23,v33) /\ AND (v34,v33,v32) /\ DEL (v32,v40) /\
            NOT (v40,v39) /\ AND (v39,v32,v38) /\ NOT (v38,v31) /\
            SEL_2_1 (v6,v37) /\ DEL (v37,v29) /\ DEL (v32,v44) /\
            NOT (v44,v43) /\ AND (v43,v32,v42) /\ NOT (v42,v30) /\
            CONSTANT 0 v41 /\ DEL (v41,v28) /\ DFF (v29,v31,v27) /\
            DFF (v28,v30,v26) /\ AND (v31,v30,v23) /\ DEL (v23,v48) /\
            NOT (v48,v47) /\ AND (v47,v23,v46) /\ NOT (v46,v22) /\
            BINOP (UNCURRY $=) (v27,v26,v45) /\ DEL (v45,v9) /\
            AND (v23,v22,v10) /\ DEL (v10,v52) /\ NOT (v52,v51) /\
            AND (v51,v10,v50) /\ AND (v50,v9,v8) /\ NOT (v9,v49) /\
            AND (v49,v50,v7) /\ DEL (v8,v56) /\ NOT (v56,v55) /\
            AND (v55,v8,v54) /\ NOT (v54,v5) /\ DEL (v11,v0) /\
            DEL (v7,v67) /\ NOT (v67,v66) /\ AND (v66,v7,v65) /\
            DEL (v13,v64) /\ AND (v65,v64,v63) /\ DEL (v63,v71) /\
            NOT (v71,v70) /\ AND (v70,v63,v69) /\ NOT (v69,v62) /\
            COMB (\x. FST x - 1) (v11,v68) /\ DEL (v68,v60) /\
            NOT (v73,v76) /\ OR (v76,v63,v75) /\ NOT (v77,v80) /\
            OR (v80,v75,v79) /\ NOT (v81,v84) /\ OR (v84,v79,v83) /\
            DEL (v83,v94) /\ NOT (v94,v93) /\ AND (v93,v83,v92) /\
            DEL (v82,v91) /\ AND (v92,v91,v90) /\ DEL (v90,v98) /\
            NOT (v98,v97) /\ AND (v97,v90,v96) /\ NOT (v96,v89) /\
            SEL_2_1 (v11,v95) /\ DEL (v95,v87) /\ DEL (v90,v109) /\
            NOT (v109,v108) /\ AND (v108,v90,v107) /\ DEL (v88,v106) /\
            AND (v107,v106,v105) /\ DEL (v105,v113) /\ NOT (v113,v112) /\
            AND (v112,v105,v111) /\ NOT (v111,v104) /\ SEL_2_2 (v11,v110) /\
            DEL (v110,v102) /\ DEL (v105,v117) /\ NOT (v117,v116) /\
            AND (v116,v105,v115) /\ NOT (v115,v103) /\ CONSTANT 0 v114 /\
            DEL (v114,v101) /\ DFF (v102,v104,v100) /\
            DFF (v101,v103,v99) /\ AND (v104,v103,v88) /\
            DFF (v87,v89,v86) /\ DFF (v100 <> v99,v88,v85) /\
            AND (v89,v88,v82) /\ DEL (v82,v133) /\ NOT (v133,v132) /\
            AND (v132,v82,v131) /\ DEL (v81,v130) /\ AND (v131,v130,v129) /\
            OR (v129,v128,v125) /\ DEL (v127,v135) /\ NOT (v135,v134) /\
            AND (v134,v127,v128) /\ MUX (v128,v126,v86 <> v85,v119) /\
            DFF (v119,v125,v124) /\ NOT (v136,v139) /\
            OR (v139,v125,v138) /\ DEL (v138,v150) /\ NOT (v150,v149) /\
            AND (v149,v138,v148) /\ DEL (v137,v147) /\
            AND (v148,v147,v146) /\ DEL (v146,v154) /\ NOT (v154,v153) /\
            AND (v153,v146,v152) /\ NOT (v152,v145) /\
            SEL_3_1 (v119,v151) /\ DEL (v151,v143) /\ DEL (v146,v158) /\
            NOT (v158,v157) /\ AND (v157,v146,v156) /\ NOT (v156,v144) /\
            CONSTANT 0 v155 /\ DEL (v155,v142) /\ DFF (v143,v145,v141) /\
            DFF (v142,v144,v140) /\ AND (v145,v144,v137) /\
            DEL (v137,v162) /\ NOT (v162,v161) /\ AND (v161,v137,v160) /\
            NOT (v160,v136) /\ BINOP (UNCURRY $=) (v141,v140,v159) /\
            DEL (v159,v122) /\ AND (v137,v136,v123) /\ DEL (v123,v166) /\
            NOT (v166,v165) /\ AND (v165,v123,v164) /\
            AND (v164,v122,v121) /\ NOT (v122,v163) /\
            AND (v163,v164,v120) /\ DEL (v121,v177) /\ NOT (v177,v176) /\
            AND (v176,v121,v175) /\ DEL (v118,v174) /\
            AND (v175,v174,v173) /\ DEL (v173,v181) /\ NOT (v181,v180) /\
            AND (v180,v173,v179) /\ NOT (v179,v172) /\ CONSTANT 0 v178 /\
            DEL (v178,v170) /\ DEL (v173,v185) /\ NOT (v185,v184) /\
            AND (v184,v173,v183) /\ NOT (v183,v171) /\
            COMB (\x. SND x) (v124,v182) /\ DEL (v182,v169) /\
            DFF (v170,v172,v168) /\ DFF (v169,v171,v167) /\
            AND (v172,v171,v118) /\ DEL (v120,v189) /\ NOT (v189,v188) /\
            AND (v188,v120,v187) /\ NOT (v187,v127) /\
            COMB
              ((\x. FST x - 1) <>
               ((\x. FST (SND x)) <> (\x. FST (SND x) + SND (SND x))))
              (v124,v186) /\ DEL (v186,v126) /\ DEL (v127,v191) /\
            AND (v127,v191,v190) /\ AND (v118,v123,v192) /\
            AND (v192,v190,v81) /\ AND (v82,v81,v78) /\ DEL (v78,v196) /\
            NOT (v196,v195) /\ AND (v195,v78,v194) /\ NOT (v194,v77) /\
            DEL (v167,v72) /\ AND (v78,v77,v74) /\ DEL (v74,v200) /\
            NOT (v200,v199) /\ AND (v199,v74,v198) /\ NOT (v198,v73) /\
            COMB SND (v72,v197) /\ DEL (v197,v59) /\ AND (v74,v73,v61) /\
            DFF (v60,v62,v58) /\ DFF (v59,v61,v57) /\ AND (v62,v61,v13) /\
            DEL (v13,v202) /\ AND (v13,v202,v201) /\ AND (v5,v10,v203) /\
            AND (v203,v201,v2) /\ DEL (v2,v207) /\ NOT (v207,v206) /\
            AND (v206,v2,v205) /\ NOT (v205,v1) /\ COMB SND (v0,v204) /\
            DEL (v204,out) /\ AND (v2,v1,done)) ===> DEV FACT : thm

*******************************************************************************

Auxiliary functions of interest include the following.

Convert : thm -> thm
--------------------

Convert (|- f x = e) returns a theorem |- f = p, where p is a
combinatory expression built from the combinators Seq, Par and Ite.


RecConvert: : thm -> thm -> thm
-------------------------------

RecConvert (|- f x = if f1 x then f2 x else f(f3 x)) (|- TOTAL(f1,f2,f3))
returns a theorem

 |- f = Rec(p1,p2,p3)

where p1, p2 and p3 are combinatory expressions built from the
combinators Seq, Par and Ite.


CompileProg : thm list -> term -> thm
-------------------------------------

CompileProg takes a program and a constant defined in the program

 CompileProg : thm list -> term -> thm
               --------    ----
               program   constant

When the compiler encounters a function f that isn't an application of
Seq, Par or Ite, then DEV f is generated. It is assumed this
will subsequently be refined to hardware (see Refine).

Compile : thm -> thm
--------------------

Compile (|- c = e)  =  CompileProg [|- c = e] ``c``


CompileConvert : thm -> thm
---------------------------

Converts a non-recursive equation to combinators and then compiles to
a device implementation.

Example: 

 Fact;
 > val it = |- !n. Fact n = SND (FactIter (n,1)) : thm

 - CompileConvert Fact;
 > val it =
     |- SEQ (SEQ (PAR (ATM (\n. n)) (ATM (\n. 1))) (ATM FactIter)) (ATM SND) 
        ===> 
        DEV Fact : thm


RecCompileConvert : thm -> thm -> thm
-------------------------------------

Converts a recursive equation to combinators and then compiles to a
device implementation Needs a totality theorem (user-supplied as third
argument).

Example:

- val FactIter =
    |- FactIter (n,acc) =
       (if n = 0 then (n,acc) else FactIter (n - 1,n * acc))

- val FactIter_TOTAL =
    |- TOTAL
         ((\(n,acc). n = 0),(\(n,acc). (n,acc)),(\(n,acc). (n - 1,n * acc)))

 - RecCompileConvert FactIter FactIter_TOTAL;
 > val it =
    |- REC
         (SEQ (PAR (ATM (\(n,acc). n)) (ATM (\(n,acc). 0)))
              (ATM (UNCURRY $=)))
         (PAR (ATM (\(n,acc). n)) (ATM (\(n,acc). acc)))
         (PAR
            (SEQ (PAR (ATM (\(n,acc). n)) (ATM (\(n,acc). 1)))
                 (ATM (UNCURRY $-)))
            (SEQ (PAR (ATM (\(n,acc). n)) (ATM (\(n,acc). acc)))
                 (ATM (UNCURRY $*)))) 
       ===> 
       DEV FactIter


=============================================================================== 
