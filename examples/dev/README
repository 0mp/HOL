
===============================================================================
== This directory contains Juliano's HOL files modified by MJCG & KXS        ==
== [Revised version incorporating Juliano's new treatment of recursion]      ==
== [Revised version incorporating liveness]                                  ==
== [04.01.05: improved proofs from KXS in composeScript.sml & devScript.sml] ==
== [09.01.05: MJCG added converter to combinators Seq, Par, Ite, Rec]        ==
== [13.01.05: major tidy and update by MJCG]                                 ==
== [17.01.05: MJCG installed hwDefine and improved examples from KXS]        ==
== [18.01.05: MJCG added Refine and revised FactScript.sml]                  ==
===============================================================================

composeScript.sml ......... definition of devices and their composition
devScript.sml.............. definition and theorems on liveness
compileScript.sml ......... definitions and theorems to support compiler
compile.sml ............... convert to combinators and compile to devices
FactScript.sml ............ an example

N.B. To make generated hardware a bit more readable, the following
     (experimental) infixes are now defined in composeScript.sml

        set_fixity ";;" (Infixl 750); overload_on (";;", ``SEQ``)
        set_fixity "||" (Infixl 650); overload_on ("||", ``PAR``)

The main user-level functions are hwDefine and Refine,
for creating hardware and refinement.

hwDefine : term frag list -> thm * thm * thm
--------------------------------------------

Single entrypoint for definitions where proof of termination will
succeed. Allows measure function to be indicated in same quotation as
definition, or not.
                                                                         
    hwDefine lib `(eqns) measuring f`                                    
                                                                         
will use f as the measure function and attempt automatic termination
proof. If successful, returns (|- eqns, |- ind, |- dev) 

NB. the recursion equations must be parenthesized; otherwise, strange
    parse errors result. Also, the name of the defined function must be
    alphanumeric.
                                                                         
One can also not mention the measure function, as in Define:             
                                                                         
    hwDefine `eqns`                                                  
                                                                         
which will accept either non-recursive or recursive specifications. It
returns a triple (|- eqns, |- ind, |- dev) where the ind theorem
should be ignored (it will be numTheory.INDUCTION.

See FactScript.sml for examples.

Refine: (term -> thm) -> thm -> thm
-----------------------------------
 
The first argument of Refine is a "refine function", refinefn say,
which maps a term ``DEV g`` to a theorem |- DEV h ===> DEV g,
where |= P ===> Q = !x. P x ==> Q x. 

"Refine refinefn (|- <circuit> ===> Dev f)" recursively scans
<circuit> replacing ``DEV g`` by ``DEV h`` (where refinefn applied to
``DEV g`` yields |- DEV h ===> DEV h) and returns a theorem

   |- <circuit'> ===> Dev f

where <circuit'> is the result of the scan.

See FactScript.sml for examples.

Two useful refine functions are ATMfn and Lib

ATMfn : term -> thm
------------------

This maps ``DEV f`` to |- ATM f ===> DEV f

Lib : thm list -> term -> thm
-----------------------------

Lib                                                                       *)
 [|- <circuit> ===> DEV f1,
  |- <circuit> ===> DEV f2
  ...
  |- <circuit> ===> DEV fn]
 ``DEV fi``

returns the first theorem <circuit> ===> DEV fi that it finds in the
supplied list (i.e. library)

*******************************************************************************

Auxiliary functions of interest include the following.

Convert : thm -> thm
--------------------

Convert (|- f x = e) returns a theorem |- f = p, where p is a
combinatory expression built from the combinators Seq, Par and Ite.


RecConvert: : thm -> thm -> thm
-------------------------------

RecConvert (|- f x = if f1 x then f2 x else f(f3 x)) (|- TOTAL(f1,f2,f3))
returns a theorem

 |- f = Rec(p1,p2,p3)

where p1, p2 and p3 are combinatory expressions built from the
combinators Seq, Par and Ite.


Compile : thm list -> term -> thm
---------------------------------------------

Compile takes a program and a constant defined in the program

 Compile : thm list -> term -> thm
           --------    ----
           program   constant

When the compiler encounters a function f that isn't an application of
Seq, Par or Ite, then DEV f is generated. It is assumed this
will subsequently be refined to hardware (see Refine).

N.B. Not sure that the program argument is really useful. 
     It may get eliminated.

ConvertCompile : thm -> thm
---------------------------

Converts a non-recursive equation to combinators and then compiles to
a device implementation.

Example: 

 Fact;
 > val it = |- !n. Fact n = SND (FactIter (n,1)) : thm

 - ConvertCompile Fact;
 > val it =
     |- SEQ (SEQ (PAR (ATM (\n. n)) (ATM (\n. 1))) (ATM FactIter)) (ATM SND) 
        ===> 
        DEV Fact : thm


RecConvertCompile : thm -> thm -> thm
-------------------------------------

Converts a recursive equation to combinators and then compiles to a
device implementation Needs a totality theorem (user-supplied as third
argument).

Example:

- val FactIter =
    |- FactIter (n,acc) =
       (if n = 0 then (n,acc) else FactIter (n - 1,n * acc))

- val FactIter_TOTAL =
    |- TOTAL
         ((\(n,acc). n = 0),(\(n,acc). (n,acc)),(\(n,acc). (n - 1,n * acc)))

 - RecConvertCompile FactIter FactIter_TOTAL;
 > val it =
    |- REC
         (SEQ (PAR (ATM (\(n,acc). n)) (ATM (\(n,acc). 0)))
              (ATM (UNCURRY $=)))
         (PAR (ATM (\(n,acc). n)) (ATM (\(n,acc). acc)))
         (PAR
            (SEQ (PAR (ATM (\(n,acc). n)) (ATM (\(n,acc). 1)))
                 (ATM (UNCURRY $-)))
            (SEQ (PAR (ATM (\(n,acc). n)) (ATM (\(n,acc). acc)))
                 (ATM (UNCURRY $*)))) 
       ===> 
       DEV FactIter


=============================================================================== 
