
Our system is implemented in HOL4, but the ideas could be
realised in other programmable higher order logic proof systems like
Isabelle, PVS, NuPrl and Coq. In such systems, functions are defined
recursively and then proof scripts are executed to prove properties of
the functions.  Proof scripts are programs that perform sequences of
deductions to create theorems.

The key idea of our approach is to automatically prove theorems of the
form $\vdash {\it{Imp}}\Longrightarrow\DEF{Dev}~f$, where
{\it{Imp}} is a term describing a circuit, $\DEF{Dev}~f$ specifies
that function $f$ is computed by a four-phase handshake and the
operator $\Longrightarrow$ means that the implementation meets the
specification.  Several different representations of implementations
are created, with the lowest level corresponding to
synthesisable Verilog.

We illustrate the translation from higher order logic to hardware with a
simple toy example: the factorial function. This example is chosen for
clarity in illustrating our ideas and is not typical of the kind of
applications were are working on!  For a discussion of those
applications see Section~\ref{secRelatedWork}.
The factorial function \DEF{FACT} satisfies

\vspace*{-2mm}

{\baselineskip10pt\begin{alltt}
 \(\vdash (\DEF{FACT} 0 = 1) \wedge {\forall}n. \DEF{FACT}(\DEF{Suc} n) = \DEF{Suc} n \times \DEF{FACT} n\)
\end{alltt}}

\vspace*{-2mm}
We can only synthesise tail recursions, so the first
step is to define a tail-recursive function \DEF{FactIter} and show
that it can be used to compute \DEF{Fact}.

\vspace*{-2mm}

{\baselineskip14pt\begin{alltt}
\( \vdash \DEF{FactIter}(n,acc) = \texttt{if} n=0 \texttt{then} (n,acc) \texttt{else} \DEF{FactIter}(n-1,n{\times}acc)) \)
\( \vdash \DEF{FACT} n = \DEF{Snd}(\DEF{FactIter}(n,1)) \)
\end{alltt}}

\vspace*{-2mm}

\noindent In HOL, \DEF{FactIter} would be defined by executing:

\vspace*{-2mm}

{\baselineskip10pt\begin{alltt}
 Define
\(  `\DEF{FactIter}(n,acc) = \texttt{if} n=0 \texttt{then} (n,acc) \texttt{else} \DEF{FactIter}(n-1,n{\times}acc))`\)
\end{alltt}}

\vspace*{-2mm}

\noindent to synthesise a hardware implementation one simply uses
\texttt{hwDefine} instead.

\vspace*{-2mm}


{\baselineskip10pt\begin{alltt}
 hwDefine
\(  `\DEF{FactIter}(n,acc) = \texttt{if} n=0 \texttt{then} (n,acc) \texttt{else} \DEF{FactIter}(n-1,n{\times}acc))`\)
\end{alltt}}


\vspace*{-2mm}

\noindent This defines \DEF{FactIter} in the logic (i.e.~does an
implicit \texttt{Define}), but it also creates a theorem:

\vspace*{-2mm}

{\baselineskip10pt\begin{alltt}
\( \vdash \DEF{REC} (\DEF{Dev} ({\lambda}x. \DEF{Fst} x = 0))         \) 
\(        (\DEF{Dev} ({\lambda}x. x))                                 \)
\(        (\DEF{PAR} (\DEF{Dev} ({\lambda}x. \DEF{Fst} x - 1))        \)
\(             (\DEF{PRECEDE} ({\lambda}x. x) (\DEF{Dev}({\times})))) \)
\(    \Longrightarrow \DEF{Dev} \DEF{FactIter}                        \)
\end{alltt}}

\vspace*{-2mm}

\noindent The term to the left of $\Longrightarrow$ is a high level
representation of an implementation using `circuit constructors' which
are described in the appendix.  The term \DEF{Dev~FactIter} describes
a behaviour that applies the function \DEF{FactIter} under the control
of a four-phase handshake. The details of the handshake are specified
in the definition of the higher order function \DEF{Dev} in
Section~\ref{secSpecification}. The theorem proved automatically by
\texttt{hwDefine} verifies that the circuit is a correct
implementation (of \DEF{FactIter} in the example above). As it is the
factorial function \DEF{FACT} that we want to implement, we create an
implementation of it, called \DEF{Fact}, using \DEF{FactIter}:

\vspace*{-2mm}

{\baselineskip10pt\begin{alltt}
 hwDefine\( `\DEF{Fact} n = \DEF{Snd}(\DEF{FactIter} (n,1))  \)
\end{alltt}}

\vspace*{-2mm}

\noindent The implicit \texttt{Define} defines \DEF{Fact} satisfying this equation, hence:

\vspace*{-2mm}

{\baselineskip14pt\begin{alltt}
\( \vdash \DEF{Fact} n = \DEF{Snd}(\DEF{FactIter}(n,1)) \)
\( \vdash \DEF{Fact} = \DEF{FACT}                       \)
\end{alltt}}

\vspace*{-2mm}

\noindent \texttt{hwDefine} also gives us a verified implemention of
\DEF{Fact}:

\vspace*{-2mm}

{\baselineskip10pt\begin{alltt}
\( \vdash \DEF{FOLLOW} (\DEF{PRECEDE} ({\lambda}n. (n,1)) (\DEF{Dev} \DEF{FactIter})) \DEF{Snd} \Longrightarrow \DEF{Dev} \DEF{Fact} \)
\end{alltt}}

\vspace*{-2mm}

\noindent The circuit here contains \DEF{Dev~FactIter} preceded and
followed by some combinational logic. We can refine this
implementation by replacing the specification
\DEF{Dev~FactIter} by the previously constructed implementation
(our circuit constructors are compositional).

\vspace*{-2mm}

{\baselineskip10pt\begin{alltt}
\( \vdash \DEF{FOLLOW}                                                                   \)
\(     (\DEF{PRECEDE} ({\lambda}n. (n,1))                                                \)
\(        (\DEF{REC} (\DEF{Dev} ({\lambda}x. \DEF{Fst} x = 0))                           \)
\(             (\DEF{Dev} ({\lambda}x. x))                                               \)
\(             (\DEF{PAR} (\DEF{Dev} ({\lambda}x. \DEF{Fst} x - 1))                      \)
\(                  (\DEF{PRECEDE} ({\lambda}x. x) (\DEF{Dev}({\times})))))) \DEF{Snd}   \)
\(    \Longrightarrow \DEF{Dev} \DEF{Fact}                                               \)
\end{alltt}}

\vspace*{-2mm}

At this point, we need to decide whether multiplication ($\times$)
has a combinational or sequential implementation.

Components in a
circuit of the form $\DEF{Dev}~f$ are specifications to compute
$f$. They can either be refined to implementations (like we just
refined \DEF{Dev~FactIter}) or they can be converted to
combinational logic (assuming we have a combinational circuit to
compute $f$ in our library of components).

Suppose we wanted to use a sequential implimentation of multiplication,
then we would synthesise a theorem:

\vspace*{-2mm}

{\baselineskip10pt\begin{alltt}
\( \vdash \texttt{(...)} \Longrightarrow \DEF{Dev}({\times}) \)
\end{alltt}}

\vspace*{-2mm}

\noindent and then refine the occurrence of $\DEF{Dev}(\times)$
to \texttt{(...)}.  In this fashion we can incrementally develop a
circuit in a top-down fashion. To manage such developments we have
implemented operators for combining refinements analogous to rewriting
operators. This is a fairly standard ML programming
method and we don't give further details here.

For simplicity, let us continue the example using a combinational
implementation of multiplication. We add ${\times}$ to the list of
combinationally-implementable functions and then our system will
automatically prove a theorem of the form shown below (we have omitted
parts of the circuit to save space, but hope what remains is enough to
give an idea).

\vspace*{-2mm}

{\baselineskip10pt\begin{alltt}
\( \vdash ({\exists}v0 v1 v2 v3 v4 v5 v6 v7 v8 v9 ...                                             \)
\(      ... v51 v52 v53 v54 v55.                                                                       \)
\(     \DEF{CONSTANT} 1 v0 {\wedge} \DEF{DEL}(load,v20) {\wedge} \DEF{NOT}(v20,v19) {\wedge}       \)
\(     \DEF{NOT}(v50,v37) {\wedge} \DEF{COMB}({\times}) (v10<>v9,v49) {\wedge}                     \)
      \(\raisebox{3mm}{\vdots}\)
\(     \DEF{DEL}(v49,v35) {\wedge} \DEF{DFF}(v36,v38,v13) {\wedge} \DEF{DFF}(v35,v37,v12) {\wedge} \)
\(     \DEF{AND}(v2,v8,v55) {\wedge} \DEF{AND}(v55,v53,done))                                     \)
\(    \Rightarrow \DEF{Dev} \DEF{FACT} (load,inp,done,out)                                         \)
\end{alltt}}

\vspace*{-2mm}

The arguments $(load,inp,done,out)$ are control and data lines of the component
and are explained later. The circuit to the left of $\Rightarrow$ is a netlist represented in
the standard way in higher order logic \cite{Mel93} and built out of
two kinds of abstract registers: a unit delay \DEF{DEL} and
edge-triggered register \DEF{DFF}. The other components are
combinational and comprise boolean functions \DEF{NOT},
\DEF{AND}, \DEF{OR}, multiplexers \DEF{MUX}, constants
and functional blocks
$\DEF{COMB}~f$ that compute the function $f$. These components are
described in more detail in Section~\ref{secImplementation}. To
create a netlist that can be converted to hardware, the occurences of
\DEF{DEL} and \DEF{DFF} need to be implemented using standard
clocked registers. This invoves converting from an abstract `cycle
based' model to a clocked synchronous model. The particular theory of doing this that we use
was developed by Melham \cite{Mel93}. We have incorporated
his theory (and even some of his old HOL88 code) to
implement a synthesis script. Applied to our factorial implementation, this yields
a theorem of the form:

\vspace*{-1mm}

{\baselineskip10pt\begin{alltt}
\( \vdash \DEF{InfRise} clk                                                                        \)
\(   \Rightarrow                                                                                   \)
\(   ({\exists}v0 v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 ...                               \)
\(     ... v125 v126 v127 v128 v129.                                                                   \)
\(     \DEF{CONSTANT} 1 v0 {\wedge} \DEF{TRUE} v23 {\wedge} \DEF{Dff}(clk,v23,v22) {\wedge}        \)
\(     \DEF{COMB}({\times}) (v10<>v9,v100) {\wedge} \DEF{TRUE} v109 {\wedge}                       \)
       \(\raisebox{3mm}{\vdots}\)
\(     \DEF{Dtype}(clk,v12,v123) {\wedge} \DEF{AND}(v77,v76,v14) {\wedge} \DEF{TRUE} v129 {\wedge} \)
\(     \DEF{AND} (v2,v8,v126) {\wedge} \DEF{AND}(v126,v124,done))                                  \)
\(   \Rightarrow \DEF{Dev} \DEF{FACT} (load \DEF{at} clk, inp \DEF{at} clk, done \DEF{at} clk, out \DEF{at} clk) \)
\end{alltt}}

\vspace*{-2mm}

This theorem uses explicitly clocked registers \DEF{Dtype} and
\DEF{Dff} (defined in Section~\ref{secCompilingByProof}) and states
that, assuming a live clock ($\DEF{InfRise}~clk$ means $clk$
has infinitely many rising edges), then the behaviour of the
synthesised circuit implements a handshake computing
\DEF{FACT}. A signal of the form $s~\DEF{at}~clk$ is the temporal abstraction
of $s$ abstracted on rising edges of $clk$.

We have implemented a program in Standard ML that prints a netlist of
the sort generated above as Verilog. Although the HDL created is not
formally verified (it cannot be, as Verilog has no formal semantic
specification) visual inspection and other tools can yield a high
degree of confidence that it corresponds to the verified netlist
represented in higher order logic. The Verilog we create is intended
to be synthesisable, but we have not yet tried any actual synthesis
experiments.


