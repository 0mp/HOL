

We illustrate the translation from higher order logic to hardware with a
simple toy example: the factorial function. This example is chosen for
clarity and is not typical of the kind of
applications were are working on!  For a discussion of those
applications see Section~\ref{secRelatedWork}.
The factorial function \DEF{FACT} satisfies

\vspace*{-2mm}

{\baselineskip10pt\begin{alltt}
 \(\vdash (\DEF{FACT} 0 = 1) \wedge {\forall}n. \DEF{FACT}(\DEF{Suc} n) = \DEF{Suc} n \times \DEF{FACT} n\)
\end{alltt}}

\vspace*{-2mm}
We can only synthesise tail recursions, so the first
step is to define a tail-recursive function \DEF{FactIter} and show
that it can be used to compute \DEF{FACT}.

\vspace*{-2mm}

{\baselineskip14pt\begin{alltt}
\( \vdash \DEF{FactIter}(n,acc) = \texttt{if} n=0 \texttt{then} (n,acc) \texttt{else} \DEF{FactIter}(n-1,n{\times}acc)) \)
\( \vdash \DEF{FACT} n = \DEF{Snd}(\DEF{FactIter}(n,1)) \)
\end{alltt}}

\vspace*{-2mm}

\noindent In HOL, \DEF{FactIter} would be defined by executing:

\vspace*{-2mm}

{\baselineskip10pt\begin{alltt}
 Define
\(  `\DEF{FactIter}(n,acc) = \texttt{if} n=0 \texttt{then} (n,acc) \texttt{else} \DEF{FactIter}(n-1,n{\times}acc))`\)
\end{alltt}}

\vspace*{-2mm}

\noindent to synthesise a hardware implementation one simply uses
\texttt{hwDefine} instead.

\vspace*{-2mm}


{\baselineskip10pt\begin{alltt}
 hwDefine
\(  `\DEF{FactIter}(n,acc) = \texttt{if} n=0 \texttt{then} (n,acc) \texttt{else} \DEF{FactIter}(n-1,n{\times}acc))`\)
\end{alltt}}


\vspace*{-2mm}

\noindent This defines \DEF{FactIter} in the logic (i.e.~does an
implicit \texttt{Define}), but it also creates a theorem:

\vspace*{-2mm}

{\baselineskip10pt\begin{alltt}
\( \vdash \DEF{REC} (\DEF{Dev} ({\lambda}x. \DEF{Fst} x = 0))         \) 
\(        (\DEF{Dev} ({\lambda}x. x))                                 \)
\(        (\DEF{PAR} (\DEF{Dev} ({\lambda}x. \DEF{Fst} x - 1))        \)
\(             (\DEF{PRECEDE} ({\lambda}x. x) (\DEF{Dev}({\times})))) \)
\(    \Longrightarrow \DEF{Dev} \DEF{FactIter}                        \)
\end{alltt}}

\vspace*{-2mm}

\noindent The term to the left of $\Longrightarrow$ is a high level
representation of an implementation using `circuit constructors' which
are described in the appendix.  The term \DEF{Dev~FactIter} describes
a behaviour that applies the function \DEF{FactIter} under the control
of a four-phase handshake. The details of the handshake are specified
in the definition of the higher order function \DEF{Dev} in
Section~\ref{secSpecification}. The theorem that is proved automatically by
\texttt{hwDefine} verifies that the circuit is a correct
implementation (of \DEF{FactIter} in the example above). We want to implement \DEF{FACT}, so
we create an
implementation of it, called \DEF{Fact}, using \DEF{FactIter}:

\vspace*{-2mm}

{\baselineskip10pt\begin{alltt}
 hwDefine\( `\DEF{Fact} n = \DEF{Snd}(\DEF{FactIter} (n,1))`  \)
\end{alltt}}

\vspace*{-2mm}

\noindent The implicit \texttt{Define} defines \DEF{Fact} satisfying this equation, hence:

\vspace*{-2mm}

{\baselineskip14pt\begin{alltt}
\( \vdash \DEF{Fact} n = \DEF{Snd}(\DEF{FactIter}(n,1)) \)
\( \vdash \DEF{Fact} = \DEF{FACT}                       \)
\end{alltt}}

\vspace*{-2mm}

\noindent \texttt{hwDefine} also gives us a verified implemention of
\DEF{Fact}:

\vspace*{-2mm}

{\baselineskip10pt\begin{alltt}
\( \vdash \DEF{FOLLOW} (\DEF{PRECEDE} ({\lambda}n. (n,1)) (\DEF{Dev} \DEF{FactIter})) \DEF{Snd} \Longrightarrow \DEF{Dev} \DEF{Fact} \)
\end{alltt}}

\vspace*{-2mm}

\noindent The circuit here contains \DEF{Dev~FactIter} preceded and
followed by some combinational logic. We can refine this
implementation by replacing the specification
\DEF{Dev~FactIter} by the previously constructed implementation
(our circuit constructors are compositional).

\vspace*{-2mm}

{\baselineskip10pt\begin{alltt}
\( \vdash \DEF{FOLLOW}                                                                   \)
\(     (\DEF{PRECEDE} ({\lambda}n. (n,1))                                                \)
\(        (\DEF{REC} (\DEF{Dev} ({\lambda}x. \DEF{Fst} x = 0))                           \)
\(             (\DEF{Dev} ({\lambda}x. x))                                               \)
\(             (\DEF{PAR} (\DEF{Dev} ({\lambda}x. \DEF{Fst} x - 1))                      \)
\(                  (\DEF{PRECEDE} ({\lambda}x. x) (\DEF{Dev}({\times})))))) \DEF{Snd}   \)
\(    \Longrightarrow \DEF{Dev} \DEF{Fact}                                               \)
\end{alltt}}

\vspace*{-2mm}

At this point a design decision is needed: whether to give multiplication ($\times$)
a combinational or sequential implementation.
Components in a
circuit of the form $\DEF{Dev}~f$ are specifications to compute
$f$. They can either be refined to implementations (like we just
refined \DEF{Dev~FactIter}) or they can be converted to
combinational logic (assuming we can directly implement
$f$ in terms of logic gates).

Suppose we wanted to use a sequential implementation of multiplication,
then we would synthesise a theorem:

\vspace*{-2mm}

{\baselineskip10pt\begin{alltt}
\( \vdash \texttt{(...)} \Longrightarrow \DEF{Dev}({\times}) \)
\end{alltt}}

\vspace*{-2mm}

\noindent and then refine the occurrence of $\DEF{Dev}(\times)$
to \texttt{(...)}.  In this fashion we can incrementally develop a
circuit in a top-down fashion. To manage such developments we have
implemented operators for combining refinements analogous to rewriting
operators \cite{paulson83}.

For simplicity (though unrealistically), let us continue the example
using a combinational implementation of multiplication. We add
${\times}$ to the list of combinationally-implementable functions and
then our system will automatically prove a theorem of the form shown
below (we have omitted parts of the circuit to save space, but hope
what remains is enough to give an idea).

\vspace*{-2mm}

{\baselineskip10pt\begin{alltt}
\( \vdash ({\exists}v0 v1 v2 v3 v4 v5 v6 v7 v8 v9 ...                                             \)
\(      ... v51 v52 v53 v54 v55.                                                                       \)
\(     \DEF{CONSTANT} 1 v0 {\wedge} \DEF{DEL}(load,v20) {\wedge} \DEF{NOT}(v20,v19) {\wedge}       \)
\(     \DEF{NOT}(v50,v37) {\wedge} \DEF{COMB}({\times}) (v10\texttt{<>}v9,v49) {\wedge}                     \)
      \(\raisebox{3mm}{\vdots}\)
\(     \DEF{DEL}(v49,v35) {\wedge} \DEF{DFF}(v36,v38,v13) {\wedge} \DEF{DFF}(v35,v37,v12) {\wedge} \)
\(     \DEF{AND}(v2,v8,v55) {\wedge} \DEF{AND}(v55,v53,done))                                     \)
\(    \Rightarrow \DEF{Dev} \DEF{FACT} (load,inp,done,out)                                         \)
\end{alltt}}

\vspace*{-2mm}

The arguments $(load,inp,done,out)$ are control and data lines of the
component and are explained in Section~\ref{secSpecification}. The
circuit to the left of $\Rightarrow$ is a netlist represented in the
standard way in higher order logic \cite{Mel93} and built out of two
kinds of abstract registers: a unit delay \DEF{DEL} and edge-triggered
register \DEF{DFF}. The other components are combinational and
comprise boolean functions \DEF{NOT},
\DEF{AND}, \DEF{OR}, multiplexers \DEF{MUX}, constants $\DEF{CONSTANT}~n$
and functional blocks
$\DEF{COMB}~f$ that compute the function $f$. These components are
described in more detail in Section~\ref{secImplementation}. To
create a netlist that can be converted to hardware, the occurrences of
\DEF{DEL} and \DEF{DFF} need to be implemented using standard
clocked registers. This invoves converting from an abstract `cycle
based' model to a clocked synchronous model. The particular theory of
doing this that we use was developed by Melham \cite{Mel93}. We have
incorporated his theory (and even some of his old HOL88 code) to
implement a synthesis script. Applied to our factorial implementation,
this yields a theorem of the form:

\vspace*{-1mm}

{\baselineskip10pt\begin{alltt}
\( \vdash \DEF{InfRise} clk                                                                        \)
\(   \Rightarrow                                                                                   \)
\(   ({\exists}v0 v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 ...                               \)
\(     ... v125 v126 v127 v128 v129.                                                                   \)
\(     \DEF{CONSTANT} 1 v0 {\wedge} \DEF{TRUE} v23 {\wedge} \DEF{Dff}(clk,v23,v22) {\wedge}        \)
\(     \DEF{COMB}({\times}) (v10\texttt{<>}v9,v100) {\wedge} \DEF{TRUE} v109 {\wedge}                       \)
       \(\raisebox{3mm}{\vdots}\)
\(     \DEF{Dtype}(clk,v12,v123) {\wedge} \DEF{AND}(v77,v76,v14) {\wedge} \DEF{TRUE} v129 {\wedge} \)
\(     \DEF{AND} (v2,v8,v126) {\wedge} \DEF{AND}(v126,v124,done))                                  \)
\(   \Rightarrow \DEF{Dev} \DEF{FACT} (load \DEF{at} clk, inp \DEF{at} clk, done \DEF{at} clk, out \DEF{at} clk) \)
\end{alltt}}

\vspace*{-2mm}

This theorem uses explicitly clocked registers \DEF{Dtype} and
\DEF{Dff} (defined in Section~\ref{secImplementation}) and states
that, assuming a live clock ($\DEF{InfRise}~clk$ means $clk$
has infinitely many rising edges), then the behaviour of the
synthesised circuit implements a handshake computing
\DEF{FACT}. A signal of the form $s~\DEF{at}~clk$ is the temporal abstraction
of $s$ abstracted on rising edges of $clk$.

We have implemented a program in Standard ML that prints a netlist of
the sort generated above as Verilog. Although the HDL created is not
formally verified (it cannot be, as Verilog has no formal semantic
specification) visual inspection and other tools can yield a high
degree of confidence that it corresponds to the verified netlist
represented in higher order logic. The Verilog we create is intended
to be synthesisable, but we have not yet tried any actual synthesis
experiments. A tiny fragment of the Verilog for the \DEF{FACT}
implementation is:

\vspace*{-3mm}

{\baselineskip6pt\footnotesize\begin{verbatim}
module FACT (clk,load,inp,done,out);
 input clk,load; input [31:0] inp;
 output done; output [31:0] out;
 wire clk,done;
 wire [31:0] v0; wire [31:0] v1; ... wire [0:0] v225;

 CONSTANT   CONSTANT_0 (v0);          defparam CONSTANT_0.size  = 31;
                                      defparam CONSTANT_0.value = 1;
 TRUE       TRUE_0 (v23);
 Dff        Dff_0 (clk,v23,v22);
 Dtype      Dtype_0 (clk,load,v21);   defparam Dtype_0.size = 0;
 MUX        MUX_0 (v22,v21,load,v20); defparam MUX_0.size = 0;
 ...
endmodule
\end{verbatim}}

