\documentclass{llncs}
\usepackage{epic,eepic,subfigure,alltt}
\input{notation.tex}

%--------------------------------------------------------------------------
\title{Higher-Level Hardware Synthesis in HOL\\
{\it (do we need a new title?)}\\[-4mm]}

\author{}
\institute{}

\begin{document}
\maketitle

\vspace*{-8mm}

\begin{center}
\begin{tabular}{ccc}
{\bf Mike Gordon, Juliano Iyoda} &\hspace*{5mm}& {\bf Scott Owens, Konrad Slind}\\
University of Cambridge          &\hspace*{5mm}& University of Utah\\
Computer Laboratory              &\hspace*{5mm}& School of Computing\\
William Gates Building           &\hspace*{5mm}& 50 South Central Campus Drive\\
JJ Thomson Avenue                &\hspace*{5mm}& Salt Lake City\\
Cambridge CB3 0FD, UK            &\hspace*{5mm}& Utah UT84112, USA
\end{tabular}


\vspace*{2mm}

(authors listed in alphabetical order)
\end{center}

\vspace*{-5mm}

%--------------------------------------------------------------------------
\thispagestyle{empty}

\begin{abstract}
To be written last!
\end{abstract}

%--------------------------------------------------------------------------
\section{Introduction}
\label{secIntroduction}

We describe a correct-by-construction flow from function definitions
in higher order logic to hardware implementations.  Each synthesised
implementation of a function $f$ is created in the form of a theorem
$\vdash {\it{Imp}}\Rightarrow\texttt{DEV}~f$, where {\it{Imp}} is a
term describing a circuit that implements a four-phase handshake
computing $f$, and the handshake is specified in higher oder logic by
$\texttt{DEV}~f$. The synthesis process is implemented using proof
scripts and goes through several phases, each refining the
implementation to a more concrete form, until a representation that
can be output as Verilog is created. We intend that future synthesis
routes will provide the option of refining the intermediate
representations to other formats, for example to ARM
assembler.

We have in mind two uses of the work described here: (i) generating
implementations and (ii) generating testbench monitors.

(i): Our current system can generate synthesisable Verilog, so can be
used to make correct-by-construction implementations. However, the
synthesis is quite naive and so the resulting hardware is not likely
to have high performance. This may not matter for some applications,
and we anticipate that having guaranteed-correct implementations will
interest some clients. For example, a major case study at Utah aims to
produce implementations of components useful for building
cryptographic hardware.  This will result in a reference library of ``golden''
implementations. Although the synthesis is naive, it is transparent
and programmable. Users can tune the generated hardware by
pre-optimising the higher order logic definitions that are used. Thus
part of the flow from mathematical specification to hardware can
consist in deductive optimisation of the source functions prior to
input to the synthesis tool.

(ii): The second use of our work is to automatically generate testbench
infrastructure. The idea here is that one synthesises a
guaranteed-correct representation of behaviour that can be run as a checker in
parallel, say in a Verilog simulator, with a bespoke hard-crafted
implementation. There is an analogy with
Assertion Based Verification (ABV) in the dynamic verification of
hardware. There, one uses a tool like FoCs [add refs to FoCs and Charme paper] 
o turn specifications into checkers.  With ABV specifications
are typically in temporal logic (e.g.{} PSL), but if the specification
were in HOL than our compiler could be used to make
testbench monitors to test (rather than to be) real implementations.



%--------------------------------------------------------------------------
\section{Related Work}
\label{secRelatedWork}
%--------------------------------------------------------------------------
\input{relatedWork.tex}

%--------------------------------------------------------------------------
\section{The Source Language}
\label{secTheSourceLanguage}
%--------------------------------------------------------------------------


%--------------------------------------------------------------------------
\section{Specification}
\label{secSpecification}
%--------------------------------------------------------------------------
The circuits generated by our compiler satisfy
a specification defined in terms of a handshaking device.
This section describes how such device operates and 
presents its formal definition.

A handshaking device is a black box that 
computes a particular function, say~$f$. 
It works in a similar way of a function call.
In order to compute $f$, we have to trigger 
the device and wait its termination.
At the moment a call is made, valid data
must be provided as input. At the time of
termination, the device outputs the value
of $f$ applied to the (previously taken) input.

The device interface comprises
the control signals \VAR{load} and \VAR{done}.
In order to trigger the device, a positive
edge (a signal transition from low to high)
must be provided on \VAR{load}. The termination
is indicated by asserting \VAR{done}.

Figure~\ref{figDev} shows a sequence of events that illustrates a
transaction in which a handshaking device performs a single
computation starting at a time $t$ and ending at a later time $t'$
(where time counts cycles). 

\begin{figure}[htb]
   \centerline{
      \subfigure[The device is ready.]{
         \label{figDev1}\input{dev1.eepic}\hspace*{1.5cm}}
      \subfigure[There is a positive edge on \VAR{load}.]{
         \label{figDev2}\input{dev2.eepic}\hspace*{2.7cm}}}
   \hspace*{0.4cm}
   \centerline{
      \subfigure[The device is busy.]{
         \label{figDev3}\input{dev3.eepic}\hspace*{0.1cm}}
      \subfigure[The computation terminates.]{
         \label{figDev4}\input{dev4.eepic}}\hspace*{0cm}}
      \caption{\label{figDev}A handshake protocol.}
\end{figure}
% Suppose the device computes a function $f$.
At the start of a transaction (time~$t$) the device must be outputting \DEF{T} on $done$
(to indicate it is ready) and the environment must be asserting
\DEF{F} on $load$, i.e.~in a state such that a positive edge on $load$
can be generated (Figure~\ref{figDev1}). 
A~transaction is initiated by asserting (at time
$t{+}1$) the value \DEF{T} on $load$, i.e.~$load$ has a positive edge
at time $t{+}1$. This causes the device to read the value, $v$
say, being input on $inp$ (at time $t{+}1$) and to de-assert $done$
(Figure~\ref{figDev2}).
The device then becomes insensitive to inputs (Figure~\ref{figDev3})
until \DEF{T} is next asserted on $done$,
at which time (say time $t' > t{+}1$) the value
$f(v)$ computed will be output on $out$ (Figure~\ref{figDev4}).

Before specifying the behaviour of a handshaking device,
the auxiliary predicates \DEF{Posedge} and \DEF{HoldF} are defined.

A positive edge of a signal is defined as the transition of its
value from low to high or, in our case, from \DEF{F} to \DEF{T}. 
\DEF{Posedge} is specified by:
\[
\TURNST\ \DEF{Posedge}\ s\ t~ ~=~~ \IF{~t{=}0~}{~\DEF{F}~}{~(\NOT\hspace*{0.8mm} s(t{-}1)\ \AND\ s\ t~})
\]
Note that if the time is zero, it is assumed that no positive edge has
occurred.

The term \mE{\DEF{HoldF}\ (t_1,t_2)\ s} says that a
signal \VAR{s} holds a low value \DEF{F} during a half-open interval
starting at \sVAR{t}{1} to just before \sVAR{t}{2}.
\[
\TURNST\ \DEF{HoldF}\ (t_1,t_2)\ s = \forall t.\ t_1 \leq t < t_2\ \IMP\ \NOT(s\ t)
\]

The behaviour of the handshaking device computing a function $f$ is described by the term 
$\DEF{Dev}\ f\ \VAR{(load,inp,done,out)}$ where:
\[
\begin{array}{l}
\TURNST\ \DEF{Dev}\ f\ \VAR{(load,inp,done,out)} = \\
~~\quad     (\forall t.\ \VAR{done}\ t\ \AND\ \DEF{Posedge}\ \VAR{load}\ (t{+}1)\ \\
\phantom{~~\quad     (\forall t.~} \IMP \\
\phantom{~~\quad     (\forall t.\ ~ } \exists t'.\ t' > t{+}1\ \AND\ \DEF{HoldF}\ (t{+}1,t')\ \VAR{done}\ \AND \\
\phantom{~~\quad     (\forall t.\ ~ \exists t'.\ }  \VAR{done}\ t'\ \AND\ (\VAR{out}\ t' = f (\VAR{inp}\ (t{+}1))))\ \\
~~\quad  \AND \\
~~\quad (\forall t.\ \VAR{done}\ t\ \AND\ \NOT(\DEF{Posedge}\ \VAR{load}\ (t{+}1))\ \IMP  \VAR{done}\ (t{+}1))\\
~~\quad  \AND \\
~~\quad (\forall t.\ \NOT\VAR{done}\ t\ \IMP \exists t'.\ t' > t{+}1\ \AND \VAR{done}\ (t{+}1))\\
\end{array}
\]
The first conjunct in the right-hand side describes the context presented
in Figure~\ref{figDev}. If the device is available and a positive
edge occurs on \VAR{load}, there exists a time \VAR{t'} in future
when \VAR{done} signals its termination and the output is produced.
The value of the output at time \VAR{t'} is the result
of applying \VAR{f} to the value of the input at time $\VAR{t}{+}1$.
The signal \VAR{done} holds the value \DEF{F} during the computation.
The second conjunct specifies the situation where no call
is made on \VAR{load} and the device simply remains idle.
Finally, the last conjunct states that if the device
is busy, it will eventually finish its computation
and become idle.

%--------------------------------------------------------------------------
\section{Implementation}
\label{secImplementation}
%--------------------------------------------------------------------------
This section describes how the behaviour of
hardware components are specified in HOL
and shows the design of circuits for
synthesising the combinators \DEF{Atm},
\DEF{Seq}, \DEF{Par}, \DEF{Ite} and \DEF{Rec}.

Hardware behaviour is specified by defining
relations that restrict the observable values of the 
external wires. Our convention is to use fully 
capitalised names for primitive circuits and 
circuit constructors.

The behaviour of a combinational AND-gate
is specified by a relation that constrains the value of the output
to the conjunction of the inputs.
\[
\TURNST\ \DEF{AND}\ (\sVAR{in}{1},\sVAR{in}{2},\VAR{out}) = 
   \forall t.\ \VAR{out}\ t = (\sVAR{in}{1}\ t\ \AND\ \sVAR{in}{2}\ t)
\]
A combinational OR-gate with inputs \sVAR{in}{1} and \sVAR{in}{2}
and output \VAR{out} is defined in a similar way.
\[
\TURNST\ \DEF{OR}\ (\sVAR{in}{1},\sVAR{in}{2},\VAR{out}) = 
   \forall t.\ \VAR{out}\ t = (\sVAR{in}{1}\ t\ \OR\ \sVAR{in}{2}\ t)
\]
An inverter simply outputs the negation of the input.
\[
\TURNST\ \DEF{NOT}\ (\VAR{inp},\VAR{out}) = 
   \forall t.\ \VAR{out}\ t = \NOT(\VAR{inp}\ t)
\]
A multiplexer connects the input \sVAR{in}{1}
to the output \VAR{out} if the selector \VAR{sel} has the value~\DEF{T}.
Otherwise, it outputs the value of \sVAR{in}{2}.
\[
\TURNST\ \DEF{MUX}\ (\VAR{sel},\sVAR{in}{1},\sVAR{in}{2},\VAR{out}) = 
   \forall t.\ \VAR{out}\ t = \IF{\VAR{sel}\ t}{\sVAR{in}{1}\ t}{\sVAR{in}{2}\ t}
\]
In general, a combinational component computing a function \VAR{f}
is specified by:
\[
\TURNST\ \DEF{COMB}\ f\ \VAR{(inp,out)} = \forall t.\ \VAR{out}\ t = f (\VAR{inp}\ t)
\]
At any given time, this generic combinational device
outputs \VAR{f} applied to the current value
of the input. Notice that this is a parameterised
(or abstract) circuit. In order to have a concrete circuit
the argument \VAR{f} must be instantiated.
For example, $\DEF{COMB}\ (\lambda x.\ x{+}1)\ (\VAR{inp,out})$
specifies a concrete circuit.

A delay outputs the value of the input at the previous time.
\[
\TURNST\ \DEF{DEL}\ (\VAR{inp},\VAR{out}) = 
    (\VAR{out}\ 0 = \VAR{inp}\ 0)\ \AND\ 
    (\forall t.\ \VAR{out} (t{+}1) = \VAR{inp}\ t)
\]
At time zero, the delay behaves as a wire.
A D-type flip-flop \DEF{DFF} outputs the value of the input \VAR{d} on the
positive edge of the signal~\VAR{clk}.
If no positive edge occurs, the output \VAR{q} remains
unchanged.
\[
\TURNST\ \DEF{DFF} (\VAR{d,clk,q})~ =~
 \forall t.\ q (t{+}1) =  \IF{\DEF{Posedge}\ \VAR{clk}\ (t{+}1)}{d (t{+}1)}{q\ t}
\]

The connection between two components is modelled
by the conjunction of their specifications.
The physical connection is represented by
the identically-labelled wires of the subcomponents.
Moreover,  the existential quantifier hides the 
internal wires of the composite device.

For example, $\DEF{POSEDGE}(\VAR{inp},\VAR{out})$ specifies a composite
device that asserts \DEF{T} on its output $\VAR{out}$ if and only if a positive edge
has occurred on the input $\VAR{inp}$. Our implementation is:
\[
\TURNST\ \DEF{POSEDGE} (\VAR{inp},\VAR{out}) = 
    \exists c_0~ c_1.\ \DEF{DEL} (\VAR{inp},c_0)\ \AND\
                  \DEF{NOT} (c_0, c_1)\ \AND\ \DEF{AND} (c_1,\VAR{inp},\VAR{out})
\]
This component connects a \DEF{DEL}, \DEF{NOT} and \DEF{AND}
by the internal wires \sVAR{c}{0} and~\sVAR{c}{1} (Figure~\ref{figPosedge}).
The wire \sVAR{c}{0} has the value of the
input at the previous time. The circuit outputs \DEF{T} if
\sVAR{c}{0} has the value \DEF{F} and the current input is \DEF{T} ---
which is exactly what characterises a positive edge.
\begin{figure}[htb]
   \centerline{\input{posedge.eepic}}
   \caption{\label{figPosedge}The \DEF{POSEDGE} circuit.}
\end{figure}


% It is easy to show that \DEF{POSEDGE} has the 
% following property.
% \[
% \TURNST\ \DEF{POSEDGE} (\VAR{inp},\VAR{out})\ \IMP\
%          (\forall t.\ \VAR{out}\ t = \DEF{Posedge}\ \VAR{inp}\ t)
% \]

For each combinator \DEF{Atm}, \DEF{Seq}, \DEF{Par},
\DEF{Ite} and \DEF{Rec} we define corresponding
parameterised circuits to synthesise them.

The circuit \DEF{ATM} implements an atomic device.
\[
\begin{array}{l}
\TURNST\ \DEF{ATM}\ f\ (\VAR{load,inp,done,out}) =\\
\phantom{\TURNST\ ~~}    \exists c_0~ c_1.\ \DEF{POSEDGE} (\VAR{load}, c_0)\ \AND \ 
\DEF{NOT} (c_0, \VAR{done})\ \AND\\
\phantom{\TURNST\ ~~\exists c_0, c_1.\ }  \DEF{COMB}\ f\ (\VAR{inp},c_1)\ \AND\ \DEF{DEL} (c_1,\VAR{out})
\end{array}
\]
This device takes one time unit to compute (see Figure~\ref{figAtom}).
Although a combinational circuit is 
clearly more efficient than an atomic device,
this device is suitable for composing with other
handshaking devices.

The constructor \DEF{SEQ} specifies a circuit which combines
the devices $f$ and $g$ to compute in sequence.
\[
\begin{array}{l}
\TURNST\ \DEF{SEQ}\ f\ g\ (\VAR{load,inp,done,out}) = \\
\phantom{\TURNST\ ~~} \exists c_0~ c_1~ c_2~ c_3~ \VAR{data}.\\
\phantom{\TURNST\ ~~\exists~}                      \DEF{NOT} (c_2,c_3) \ \AND \ 
                      \DEF{OR} (c_3,\VAR{load},c_0) \ \AND \  f (c_0,\VAR{inp},c_1,\VAR{data}) \ \AND \\
\phantom{\TURNST\ ~~ \exists~} 
        g (c_1,\VAR{data},c_2,\VAR{out})\ \AND\ 
        \DEF{AND} (c_1,c_2,\VAR{done}) 
\end{array}
\]
The subcomponents \VAR{f} and \VAR{g} have the same interface of
a handshaking device. The output of the component \VAR{f} 
is the input of the component \VAR{g} (see the
variables \sVAR{c}{1} and \VAR{data} in Figure~\ref{figSeq}).
This composite device signals its completion when both \VAR{f} and 
\VAR{g} terminate.

\begin{figure}[htb]
   \centerline{
      \subfigure[$\DEF{ATM}\ f$]{
         \label{figAtom}\input{atm.eepic}\hspace*{0cm}}
      \subfigure[$\DEF{SEQ}\ f\ g$]{
         \label{figSeq}\input{seq.eepic}\hspace*{0cm}}
      \subfigure[$\DEF{PAR}\ f\ g$]{
         \label{figPar}\input{par.eepic}}}
      \caption{\label{figSeqPar}Implementation of composite devices.}
\end{figure}

The constructor \DEF{PAR} combines two devices in parallel.
\[
\begin{array}{l}
\TURNST\ \DEF{PAR}\ f\ g\ (\VAR{load,inp,done,out}) = \\
\phantom{\TURNST\ ~}     \exists c_0~c_1~\VAR{start}~\sVAR{done}{1}~\sVAR{done}{2}~
                                 \sVAR{data}{1}~\sVAR{data}{2}~\sVAR{out}{1}~\sVAR{out}{2}.\\
\phantom{\TURNST\ ~~ \exists~}
       \DEF{POSEDGE} (\VAR{load},c_0)\ \AND\  
       \DEF{DEL} (\VAR{done},c_1)\ \AND \ 
       \DEF{AND} (c_0,c_1,\VAR{start})\ \AND\\
\phantom{\TURNST\ ~~ \exists~}
       f (\VAR{start},\VAR{inp},\sVAR{done}{1},\sVAR{data}{1})\ \AND \ 
       g (\VAR{start},\VAR{inp},\sVAR{done}{2},\sVAR{data}{2})\ \AND\\
\phantom{\TURNST\ ~~ \exists~}
       \DEF{DFF} (\sVAR{data}{1},\sVAR{done}{1},\sVAR{out}{1})\ \AND \  
       \DEF{DFF} (\sVAR{data}{2},\sVAR{done}{2},\sVAR{out}{2})\ \AND\\
\phantom{\TURNST\ ~~ \exists~}
       \DEF{AND} (\sVAR{done}{1},\sVAR{done}{2},done)\ \AND \ 
       (\VAR{out} = \LAMBDA{t}{(\sVAR{out}{1}\ t,\sVAR{out}{2}\ t)})
\end{array}
\]
The devices \VAR{f} and \VAR{g} are triggered simultaneously
by \VAR{start}
and return \sVAR{data}{1} and \sVAR{data}{2}, respectively
(see Figure~\ref{figPar}). 
As \VAR{f} and \VAR{g} may terminate at different times,
their outputs are stored by DFFs and made available
by \sVAR{out}{1} and \sVAR{out}{2}.
The components \DEF{POSEDGE} and \DEF{DEL} prevent
calls to either \VAR{f} or \VAR{g} during their computation.

The conditional constructor \DEF{ITE} implements an if-then-else
circuit from three subcomponents.
\[
\begin{array}{l}
\TURNST\ \DEF{ITE}\ e\ f\ g\ (\VAR{load,inp,done,out}) =\\
\phantom{\TURNST\ ~}
   \exists c_0~c_1~c_2~\VAR{start}~\VAR{start'}~\VAR{done\_e}~\VAR{data\_e}~q~ 
                          \VAR{not\_e}~\VAR{data\_f}~\VAR{data\_g}~\VAR{sel}\\
\phantom{\TURNST\ ~\exists }
                  \VAR{done\_f}~\VAR{done\_g}~
                          \VAR{start\_f}~\VAR{start\_g}.\ \\
\phantom{\TURNST\ ~\exists ~}
           \DEF{POSEDGE} (\VAR{load},c_0)\ \AND\
           \DEF{DEL} (\VAR{done},c_1)\ \AND\ \DEF{AND} (c_0,c_1,\VAR{start})\ \AND \\
\phantom{\TURNST\ ~\exists ~}
           e (\VAR{start},\VAR{inp},\VAR{done\_e},\VAR{data\_e})\ \AND\
           \DEF{POSEDGE} (\VAR{done\_e},\VAR{start'})\ \AND \\
\phantom{\TURNST\ ~\exists ~}
           \DEF{DFF} (\VAR{data\_e},\VAR{done\_e},\VAR{sel})\ \AND\
           \DEF{DFF} (\VAR{inp},\VAR{start},q)\ \AND \\
\phantom{\TURNST\ ~\exists ~}
           \DEF{AND} (\VAR{start'},\VAR{data\_e},\VAR{start\_f})\ \AND\
           \DEF{NOT} (\VAR{data\_e},\VAR{not\_e})\ \AND \\
\phantom{\TURNST\ ~\exists ~}
           \DEF{AND} (\VAR{start'},\VAR{not\_e},\VAR{start\_g})\ \AND\
           f (\VAR{start\_f},q,\VAR{done\_f},\VAR{data\_f})\ \AND\\
\phantom{\TURNST\ ~\exists ~}
           g (\VAR{start\_g},q,\VAR{done\_g},\VAR{data\_g})\ \AND\
           \DEF{MUX} (\VAR{sel},\VAR{data\_f},\VAR{data\_g},out)\ \AND \\
\phantom{\TURNST\ ~\exists ~}
           \DEF{AND} (\VAR{done\_e},\VAR{done\_f},c_2)\ \AND\
           \DEF{AND} (c_2,\VAR{done\_g},\VAR{done}) 
\end{array}
\]
The device \VAR{e} implements a boolean test, while
\VAR{f} and \VAR{g} implement the conditional branches.
The output of \VAR{e} triggers either \VAR{f} or \VAR{g}
(see the variable \VAR{data\_e} in Figure~\ref{figIf}).
A multiplexer selects the right output based on the
(stored) value of \VAR{data\_e}.
The variable \VAR{done} is asserted if all subcomponents
have terminated.

\begin{figure}[htb]
   \centerline{\input{if.eepic}}
   \caption{\label{figIf}The conditional constructor: $\DEF{ITE}\ e\ f\ g$.}
\end{figure}

The language introduced in Section~\ref{secTheSourceLanguage} 
has an operator \DEF{Rec} for specifying tail-recursive functions ${\cal{F}}$
of the form
\[
\begin{array}{l}
\VAR{{\cal{F}}}\ \VAR{x} ~=~ \IF{\VAR{e}\ \VAR{x}}
                         {\VAR{f}\ \VAR{x}}
                         {\VAR{{\cal{F}}}(\VAR{g}\  \VAR{x})}
\end{array}
\]
Such a function ${\cal{F}}$ is specified by $\DEF{Rec}~\VAR{e}~\VAR{f}~\VAR{g}$ as defined
above. A handshaking circuit that implements ${\cal{F}}$ (if it is well-defined) is
constructed using the \DEF{REC} constructor, where:
\[
\begin{array}{l}
\TURNST\ \DEF{REC}\ e\ f\ g\ (\VAR{load,inp,done,out}) = \\
\phantom{\TURNST\ ~}
     \exists \VAR{done\_g}~ \VAR{data\_g}~ \VAR{start\_e}~ q~ \VAR{done\_e}~ 
             \VAR{data\_e}~ \VAR{start\_f}~ \VAR{start\_g}~ \VAR{inp\_e}~ 
             \VAR{done\_f}\\[-1mm]
\phantom{\TURNST\ ~\exists }
             \sVAR{c}{0}~ \sVAR{c}{1}~ 
             \sVAR{c}{2}~ \sVAR{c}{3}~\sVAR{c}{4}~
             \VAR{start}~ \VAR{sel}~ \VAR{start'}~ \VAR{not\_e}. \\[0.5mm]
\phantom{\TURNST\ ~\exists~ }
        \DEF{POSEDGE}(\VAR{load},\sVAR{c}{0})\ \AND\
        \DEF{DEL}(\VAR{done},\sVAR{c}{1})\ \AND\
        \DEF{AND}(\sVAR{c}{0},\sVAR{c}{1},\VAR{start})\ \AND \\
\phantom{\TURNST\ ~\exists~ }
        \DEF{OR}(\VAR{start,sel,start\_e})\ \AND\
        \DEF{POSEDGE}(\VAR{done\_g,sel})\ \AND \\
\phantom{\TURNST\ ~\exists~ }
        \DEF{MUX}(\VAR{sel,data\_g,inp,inp\_e})\ \AND\
           \DEF{DFF}(\VAR{inp\_e},\VAR{start\_e},q)\ \AND \\
\phantom{\TURNST\ ~\exists~ }
           e (\VAR{start\_e},\VAR{inp\_e},\VAR{done\_e},\VAR{data\_e}) \AND\
        \DEF{POSEDGE}(\VAR{done\_e,start'})\ \AND \\
\phantom{\TURNST\ ~\exists~ }
        \DEF{AND}(\VAR{start',data\_e,start\_f})\ \AND\
        \DEF{NOT}(\VAR{data\_e,not\_e})\ \AND \\
\phantom{\TURNST\ ~\exists~ }
        \DEF{AND}(\VAR{not\_e,start',start\_g})\ \AND\
           f (\VAR{start\_f},q,\VAR{done\_f},\VAR{out})\ \AND\\
\phantom{\TURNST\ ~\exists~ }
           g (\VAR{start\_g},q,\VAR{done\_g},\VAR{data\_g})\ \AND\
        \DEF{DEL}(\VAR{done\_g},\sVAR{c}{3})\ \AND\\
\phantom{\TURNST\ ~\exists~ }
        \DEF{AND}(\VAR{done\_g},\sVAR{c}{3},\sVAR{c}{4})\ \AND\
        \DEF{AND}(\VAR{done\_f},\VAR{done\_e},\sVAR{c}{2})\ \AND\
        \DEF{AND}(\sVAR{c}{2},\sVAR{c}{4},\VAR{done})
\end{array}
\]
The recursive constructor is similar to the conditional one
(see Figure~\ref{figRec}).
The main difference is the connection between the
``else'' branch and the circuit itself --- characterising a
recursive call. A multiplexer selects the input from either
the external environment or from the recursive call.
The circuit terminates if every subcomponent terminates
(see the variables \VAR{done\_e}, \VAR{done\_f} and \VAR{done\_g}
in Figure~\ref{figRec}). Furthermore, the component \VAR{g}
must have terminated at least one time unit before. This is
necessary to distinguish a recursive call from the
complete termination of the computation.

\begin{figure}[htb]
   \centerline{\input{rec.eepic}}
   \caption{\label{figRec}The recursive constructor: $\DEF{REC}\ e\ f\ g$.}
\end{figure}

\begin{example} {\em A simplified overview of the synthesis.\/}
Suppose the simple program below is to be synthesised.
\[ 
\begin{array}{l}
   \DEF{PlusOne}(n) = n{+}1 \\
   \DEF{MinusOne}(n) = n{-}1 \\
   \DEF{Main}(n) = \DEF{MinusOne}(\DEF{PlusOne}(n))
\end{array} 
\]
We assume that increment and decrement are
primitive operators of the language, i.e. 
there are combinational circuits in our
library which perform these operations.
The functions \DEF{PlusOne} and \DEF{MinusOne} 
are then simply compiled to the atomic circuits:
\[
\begin{array}{l}
\DEF{ATM}\ (\lambda x.\ x{+}1)\ (\VAR{load,inp,done,out}) \\
\DEF{ATM}\ (\lambda x.\ x{-}1)\ (\VAR{load,inp,done,out}) \\
\end{array}
\]
The function \DEF{Main} however is firstly
converted into a combinatory expression
built from the combinators \DEF{Seq}, 
\DEF{Par}, \DEF{Ite} and \DEF{Rec}.
(Actually the source code is always
converted into this intermediate form
before the synthesis is carried out.)
\[
\DEF{Main} = \DEF{Seq}\ \DEF{PlusOne}\ \DEF{MinusOne}
\]
The compiler now simply replaces \DEF{Seq},
\DEF{PlusOne} and \DEF{MinusOne} by the circuit
$\DEF{SEQ}\ (\DEF{ATM}\ (\lambda x.\ x{+}1))\ 
            (\DEF{ATM}\ (\lambda x.\ x{-}1))\ (\VAR{load,inp,done,out})$.

Notice that this is only a simplified description
of the synthesis. In the actual process
the compilation and the proof of correctness 
go hand in hand.
\end{example}


%--------------------------------------------------------------------------
\section{Compiling by Proof}
\label{secCompilingByProof}
%--------------------------------------------------------------------------


%--------------------------------------------------------------------------
\section{Case Study}
\label{secCaseStudy}
%--------------------------------------------------------------------------


%--------------------------------------------------------------------------
\section{Future Work}
\label{secFutureWork}
%--------------------------------------------------------------------------


%--------------------------------------------------------------------------
\bibliographystyle{plain}
\bibliography{tphols2005}
%--------------------------------------------------------------------------

\end{document}
% LocalWords:  langle


