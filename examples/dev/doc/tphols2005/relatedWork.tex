Previous approaches to combine theorem provers 
and formal synthesis established an analogy between
the goal directed proof technique and an interactive 
design process. In LAMBDA, the user starts from the behavioural
specification and builds the circuit incrementally
by adding primitive hardware components
which automatically simplify the goal \cite{Fou89}.
Hanna {\em et al.\/} \cite{HLD89} introduce
several {\em techniques\/} (functions) that
simplify the current goal into simpler subgoals.
Techniques are adaptations to hardware design
of {\em tactics\/} in LCF.

Alternative approaches synthesise circuits
by applying semantic-preserving transformations
to their specifications. For instance,
the Digital Design Derivation (DDD) transforms
finite-state machines specified in terms of
tail-recursive lambda abstractions into hierarchical
boolean systems~\cite{Johnson90}. Lava and Hydra
are both hardware description languages embedded
in Haskell whose programs
consist of definitions of gates and their 
connections (netlists)~\cite{BCSS99,OD02}. While Lava interfaces with
external theorem provers to verify its circuits,
Hydra designers can synthesise them
via formal equational reasoning
(using definitions and lemmas from functional programming).
The functional languages $\mu$FP and Ruby
adopt similar principles in hardware design~\cite{JS90,She84}.
The circuits are defined in terms of primitive
functions over booleans, numbers and lists, and
higher-order functions, the {\em combining forms\/},
which compose hardware blocks in different
structures. Their mathematical properties provide
a calculational style in design exploration.

These approaches deal with an interactive
synthesis at the gate or state-machine level
of abstraction only. Moreover, the synthesis
and the proof of correctness require a 
substantial user guidance. Gropius and SAFL 
are two related works that address these issues.

%------ Gropius: Blumenrohr
Gropius is a hardware description language
defined as a subset of HOL~\mbox{\cite{Blu01,Gropius1}}.
Its algorithmic level
provides control structures like if-then-else,
sequential composition and while loop.
The~atomic commands are DFGs (data flow
graphs) represented by lambda abstractions.
The compiler initially combines every while loop into
a single one at the outermost level of the
program:
\[
\DEF{PROGRAM}\ \VAR{out\_default}\ (\DEF{LOCVAR}\ \VAR{vars}\ 
(\DEF{WHILE}\ c\ (\DEF{PARTIALIZE}\ \VAR{b})))
\]
The body \VAR{b} of the \DEF{WHILE} loop is an acyclic~DFG.
The list \VAR{out\_default}
provides initial values for the output variables.
The term \DEF{LOCVAR} declares the local variables
\VAR{vars} and \DEF{PARTIALIZE} converts a
non-recursive (terminating) DFG into a potentially
non-terminating command.
The compiler then synthesises a handshaking
interface which encapsulates this program.
Each of these hardware blocks are now regarded
as primitive blocks or {\em processes\/} at the system level.
Processes are connected via communication
units ({\em k-processes\/}) which implement delay,
synchronisation, duplication,
splitting and joining of a process output data
(actually there  are 10 different k-processes \cite{Blu01}).
Although the synthesis produces the proof of
correctness of each process and k-process,
the correctness of the top-level system is not generated.
The reason for that is mainly because
the top-level interface of a network of processes and 
k-processes does not match the handshaking interface pattern.

%------ SAFL: Sharp
Our compilation method is partly inspired by SAFL 
(Statically Allocated Functional Language) \cite{MS01b},
especially the ideas in Richard Sharp's PhD \cite{Sha02}. 
SAFL~is a first-order functional language whose
programs consist of a sequence of tail-recursive function 
definitions. Its high-level of abstraction allows
the exploitation of powerful program analyses
and optimisations not available in traditional
synthesis systems. 
However, the synthesis is not based on
the correct-by-construction principles
and the compiler has not been verified.

% our approach
The novelty of our approach is the 
compilation of functional programs by
composing especially designed and
pre-verified circuit constructors.
%
As each of these circuit constructors
have the key property of implementing
a device that computes precisely their
corresponding combinators, 
the verification and the compilation of 
functional programs can be done
automatically.
