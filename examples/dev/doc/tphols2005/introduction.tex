
We describe a correct-by-construction flow from function definitions
in higher order logic to hardware implementations.  Each synthesised
implementation is created in the form of a theorem
$\vdash {\it{Imp}}\Rightarrow{\it{Spec}}$, where {\it{Imp}} is
a term describing a circuit that implements a four-phase handshake
computing a function, and the handshake is specified in higher order logic by
{\it{Spec}}. 

The synthesis process is implemented using proof
scripts and goes through several phases, each refining the
implementation to a more concrete form, until a representation that
can be output as Verilog is created. We intend that future synthesis
routes will provide the option of refining the intermediate
representations to other formats, for example to ARM assembler.

We have in mind two uses of the work described here: (i) generating
implementations and (ii) generating testbench monitors.

(i): Our current system can generate synthesisable Verilog, so can be
used to make correct-by-construction implementations. However, the
synthesis is quite naive and so the resulting hardware is not likely
to have high performance. This may not matter for some applications,
and we anticipate that having guaranteed-correct implementations will
interest some clients. For example, a major case study at Utah aims to
produce implementations of components useful for building
cryptographic hardware.  This will result in a reference library of ``golden''
implementations. Although the synthesis is naive, it is transparent
and programmable. Users can tune the generated hardware by
pre-optimising the higher order logic definitions that are used. Thus
part of the flow from mathematical specification to hardware can
consist in deductive optimisation of the source functions prior to
input to the synthesis tool.

(ii): The second use of our work is to automatically generate testbench
infrastructure. The idea here is that one synthesises a
guaranteed-correct representation of behaviour that can be run as a checker in
parallel, say in a Verilog simulator, with a bespoke hard-crafted
implementation. There is an analogy with
Assertion Based Verification (ABV) in the dynamic verification of
hardware. There, one uses a tool like FoCs [add refs to FoCs and Charme paper] 
o turn specifications into checkers.  With ABV specifications
are typically in temporal logic (e.g.{} PSL), but if the specification
were in HOL than our compiler could be used to make
testbench monitors to test (rather than to be) real implementations.

In the next section we give a quick overview of the currently
implemented system using a simple (but unrealistic) example chosen to
illustrate the synthesis flow.  Next we describe the models in higher
order logic that underlie the work. We then describe how synthesis is
implemented by proof scripts. Some unfinished case studies that are in
progress are then discussed. Next we survey related work by
others. Finally, our plans for the future are outlined.
