
We describe correct-by-construction compilation of
function definitions in higher order logic to hardware.  
Implementations are created by automated theorem proving in the form of theorems $\vdash
{\it{Imp}}\Rightarrow{\it{Spec}}$, where {\it{Imp}} is a term
describing a circuit that implements a four-phase handshake computing
a function, and the handshake is specified in higher order logic by
{\it{Spec}}.

The compiler is a specialised theorem prover
that goes through several phases, each refining the
implementation to a more concrete form, until a representation that
can be output as Verilog is deduced.

%We have in mind two uses of the work described here: generating
%implementations and generating testbench monitors.

Our goal is to generate synthesisable Verilog suitable for input to a
synthesis tool. The hardware designs we construct may not have high
performance, but we anticipate that having
guaranteed-correct implementations will interest some clients. For
example, a case study at Utah aims to produce implementations of
components useful for building cryptographic hardware.  This will
result in a reference library of ``golden'' implementations. 

The compilation to hardware is transparent and programmable. Users can
tune the generated hardware either by pre-optimising the higher order
logic specifications, or by adding optimisations to the theorem
proving script that performs compilation.

%The second use of our work is to automatically generate testbench
%infrastructure. The idea here is that one synthesises a
%guaranteed-correct representation of behaviour that can be run as a
%checker in parallel, say in a Verilog simulator, with a bespoke
%hand-crafted implementation. 
%There is an analogy with assertion based
%verification in the dynamic verification of hardware. There, one uses
%a tool like FoCs [add refs to FoCs and Charme paper] to turn
%specifications into checkers.  Traditional hardware specifications
%specifications are temporal logic properties, but if
%the specification were in HOL than our compiler could be used to make
%testbench monitors to test (rather than to be) real implementations.

In the next section we give a quick overview of the currently
implemented system using a simple (but unrealistic) example. We then
describe the specification of components in higher order logic that
underlies the work. Next we describe how function definitions in
higher order logic are translated to hardware via a sequence of steps,
ending with Verilog.  Some unfinished case studies that are in
progress are then discussed. Finally, we survey related work by
others, and outline our plans for the future. An appendix contains the
definitions of the circuit constructors that we use to build
implementations.
