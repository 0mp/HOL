loadPath := "../../" :: "../../dff/" :: !loadPath;

Globals.priming := SOME "";
app load ["word8CasesLib", "compile", "aesTheory"];
open word8Theory compile MultTheory RoundOpTheory aesTheory;

val MAKE_NETLIST = Count.apply MAKE_NETLIST;

(*---------------------------------------------------------------------------*)
(* xtime                                                                     *)
(*---------------------------------------------------------------------------*)

val xtime_dev = 
  PURE_REWRITE_RULE[GSYM DEV_IMP_def] 
           (CompileConvert (SPEC_ALL xtime_def));
val xtimeNetlist = MAKE_NETLIST (REFINE (DEPTHR ATM_REFINE) xtime_dev);


(*---------------------------------------------------------------------------*)
(* Iterative multiplication.                                                 *)
(*---------------------------------------------------------------------------*)

local
 val defth = SPEC_ALL IterConstMult_def
 val (lt,rt) = boolSyntax.dest_eq(concl defth)
 val (func,args) = dest_comb lt
 val (b,t1,t2) = dest_cond rt
 val fb = mk_pabs(args,b)
 val f1 = mk_pabs(args,t1)
 val f2 = mk_pabs(args,rand t2)
in
val total_thm = Q.prove
(`TOTAL(^fb,^f1,^f2)`,
 RW_TAC list_ss [composeTheory.TOTAL_def,pairTheory.FORALL_PROD] 
  THEN WF_REL_TAC `w2n o FST` THEN STRIP_TAC THEN
   word8CasesLib.word8Cases_on `p_1` THEN 
   RW_TAC std_ss [] THEN REPEAT (POP_ASSUM MP_TAC) THEN word8Lib.WORD_TAC)
val iter_mult_dev = 
  PURE_REWRITE_RULE[GSYM DEV_IMP_def] (RecCompileConvert defth total_thm);
val iter_mult_atm = REFINE (DEPTHR ATM_REFINE) iter_mult_dev;
val iter_mult_Netlist = MAKE_NETLIST iter_mult_atm;
end;

val iter_mult1_dev =
 REFINE (DEPTHR(LIB_REFINE[xtime_dev])) iter_mult_dev;

val iter_mult1_Netlist = 
  MAKE_NETLIST (REFINE (DEPTHR ATM_REFINE) iter_mult1_dev);

(*---------------------------------------------------------------------------*)
(* Round operations.                                                         *)
(*---------------------------------------------------------------------------*)

val to_state_dev = 
  PURE_REWRITE_RULE[GSYM DEV_IMP_def] 
           (CompileConvert (SPEC_ALL to_state_def));
val to_stateNetlist = MAKE_NETLIST (REFINE (DEPTHR ATM_REFINE) to_state_dev);

val from_state_dev = 
  PURE_REWRITE_RULE[GSYM DEV_IMP_def] 
           (CompileConvert (SPEC_ALL from_state_def));
val from_stateNetlist = MAKE_NETLIST (REFINE (DEPTHR ATM_REFINE) from_state_dev);

val SubBytes_def' = 
   SIMP_RULE std_ss [genSubBytes_def,FUN_EQ_THM,FORALL_BLOCK] SubBytes_def;
val SubBytes_dev = 
  PURE_REWRITE_RULE[GSYM DEV_IMP_def] 
           (CompileConvert (SPEC_ALL SubBytes_def'));
(* Slow *)
val SubBytesNetlist = 
  Count.apply MAKE_NETLIST (REFINE (DEPTHR ATM_REFINE) SubBytes_dev);

val InvSubBytes_def' = 
   SIMP_RULE std_ss [FUN_EQ_THM,FORALL_BLOCK,genSubBytes_def] InvSubBytes_def;
val InvSubBytes_dev = 
  PURE_REWRITE_RULE[GSYM DEV_IMP_def] 
           (CompileConvert (SPEC_ALL InvSubBytes_def'));
(* Slow *)
val InvSubBytesNetlist = MAKE_NETLIST (REFINE (DEPTHR ATM_REFINE) InvSubBytes_dev);

val ShiftRows_dev = 
  PURE_REWRITE_RULE[GSYM DEV_IMP_def] 
           (CompileConvert (SPEC_ALL ShiftRows_def));
val ShiftRowsNetlist = MAKE_NETLIST (REFINE (DEPTHR ATM_REFINE) ShiftRows_dev);

val InvShiftRows_dev = 
  PURE_REWRITE_RULE[GSYM DEV_IMP_def] 
           (CompileConvert (SPEC_ALL InvShiftRows_def));
val InvShiftRowsNetlist = MAKE_NETLIST (REFINE (DEPTHR ATM_REFINE) InvShiftRows_dev);

val MultCol_dev =
  PURE_REWRITE_RULE[GSYM DEV_IMP_def] 
           (CompileConvert (SPEC_ALL MultCol_def));
val MultColNetlist = MAKE_NETLIST (REFINE (DEPTHR ATM_REFINE) MultCol_dev);

val InvMultCol_dev =
  PURE_REWRITE_RULE[GSYM DEV_IMP_def] 
           (CompileConvert (SPEC_ALL InvMultCol_def));
val InvMultColNetlist = MAKE_NETLIST (REFINE (DEPTHR ATM_REFINE) InvMultCol_dev);

(* Need to eliminate lets *)
val MixColumns_def' = 
 GEN_BETA_RULE
  (SIMP_RULE std_ss [FUN_EQ_THM,FORALL_BLOCK,genMixColumns_def,LET_THM] MixColumns_def);

val MixColumns_dev =
  PURE_REWRITE_RULE[GSYM DEV_IMP_def] 
           (CompileConvert (SPEC_ALL MixColumns_def'));
val MixColumnsNetlist = 
  MAKE_NETLIST (REFINE (DEPTHR ATM_REFINE) MixColumns_dev);

val InvMixColumns_def' = 
 GEN_BETA_RULE
  (SIMP_RULE std_ss 
      [FUN_EQ_THM,FORALL_BLOCK,genMixColumns_def,LET_THM] InvMixColumns_def);

val InvMixColumns_dev =
  PURE_REWRITE_RULE[GSYM DEV_IMP_def] 
           (CompileConvert (SPEC_ALL InvMixColumns_def'));
val InvMixColumnsNetlist = 
  MAKE_NETLIST (REFINE (DEPTHR ATM_REFINE) InvMixColumns_dev);

val XOR_BLOCK_def = 
 Define 
   `XOR_BLOCK ((a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15):block,
               (b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15):block)
       =
      (a0 # b0,   a1 # b1,   a2 # b2,   a3 # b3,
       a4 # b4,   a5 # b5,   a6 # b6,   a7 # b7,
       a8 # b8,   a9 # b9,   a10 # b10, a11 # b11,
       a12 # b12, a13 # b13, a14 # b14, a15 # b15)`;

val XOR_BLOCK_dev =
  PURE_REWRITE_RULE[GSYM DEV_IMP_def] 
           (CompileConvert (SPEC_ALL XOR_BLOCK_def));
val XOR_BLOCKNetlist = 
  MAKE_NETLIST (REFINE (DEPTHR ATM_REFINE) XOR_BLOCK_dev);

* AddRoundKey_def

(*---------------------------------------------------------------------------*)
(* aesTheory                                                                 *)
(*---------------------------------------------------------------------------*)

* DUMMY_KEYS

val ROTKEYS_dev =
  PURE_REWRITE_RULE[GSYM DEV_IMP_def] 
           (CompileConvert (SPEC_ALL ROTKEYS_def));
val ROTKEYSNetlist = 
  MAKE_NETLIST (REFINE (DEPTHR ATM_REFINE) ROTKEYS_dev);

val REVKEYS_dev =
  PURE_REWRITE_RULE[GSYM DEV_IMP_def] 
           (CompileConvert (SPEC_ALL REVKEYS_def));
val REVKEYSNetlist = 
  MAKE_NETLIST (REFINE (DEPTHR ATM_REFINE) REVKEYS_dev);

Round_def
InvRound_def
AES_FWD
AES_BWD;

