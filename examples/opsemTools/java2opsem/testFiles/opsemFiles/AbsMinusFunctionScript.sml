(* This file has been generated by java2opSem from /home/helen/Recherche/hol/HOL/examples/opsemTools/java2opsem/testFiles/javaFiles/AbsMinusFunction.java*)


open HolKernel Parse boolLib
stringLib IndDefLib IndDefRules
finite_mapTheory relationTheory
newOpsemTheory
computeLib bossLib;

val _ = new_theory "AbsMinusFunction";

  (* Method func1*)
  val func1_def =
    Define `func1 i j k =
	    (* parameters are local variables in func1 *)
            (Local "func1_i" 
               (Local "func1_j" 
	          (Local "func1_k" 
		     (* parameter passing *)
		     (Seq 
                        (Assign "func1_i" i)
		        (Seq 
                           (Assign "func1_j" j)
		           (Seq  
                              (Assign "func1_k" k)
        (* method body *)
        (* result is a local variable in func1 *)
	(Local "func1_result" 
        (Seq
          (Assign "func1_result" (Const 0))
          (Seq
            (Cond 
              (And 
                (Equal 
                  (Var "func1_k")
                  (Const 1)
                )
                (Not (Equal 
                  (Var "func1_i")
                  (Var "func1_j")
                ))
              )
              (Assign "func1_result"
                (Sub 
                  (Var "func1_j")
                  (Var "func1_i")
                )
              )
              (Assign "func1_result"
                (Sub 
                  (Var "func1_i")
                  (Var "func1_j")
                )
              )
            )
            (Assign "func1_Result"
              (Var "func1_result")
            )
          )
        )
)
        ))))))        
      `

(* Method absMinus*)
val MAIN_def =
  Define `MAIN =
    RSPEC
    (\state.
      T)
      (Seq 
        (Assign "k"
          (Const 0)
        )
        (Seq 
          (Cond 
            (LessEq 
              (Var "i")
              (Var "j")
            )
            (Assign "k"
              (Plus 
                (Var "k")
                (Const 1)
              )
            )
            Skip
          )
	  (* function call *)
	(Seq
           (* function execution *)
           (func1 (Var "i") (Var "j") (Var "k"))
           (* get the result *)
           (Assign "Result" (Var "func1_Result"))
	)
      )
    )
    (\state1 state2.
      ((((ScalarOf (state1 ' "i")<ScalarOf (state1 ' "j")))) 
      ==> (((ScalarOf (state2 ' "Result")=ScalarOf (state1 ' "j")-ScalarOf (state1 ' "i")))))/\
      ((((ScalarOf (state1 ' "i")>=ScalarOf (state1 ' "j")))) ==> (((ScalarOf (state2 ' "Result")=ScalarOf (state1 ' "i")-ScalarOf (state1 ' "j"))))))
    `

    val intVar_def =
  	     Define `intVar =["i";"j";"k";"Result";"result";"func1_Result"]  `

    val arrVar_def =
  	     Define `arrVar =[]: string list  `


    val _ = export_theory();





