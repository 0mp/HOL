(* Functions to call an external SMT solver  *)

open HolKernel Parse boolLib term2yices;



(* exception raised when the output file generated with yices is empty
   because there was a compilation error *)
exception YICES_COMPILEError;


(* Path to Yices support directory *)
val yicesPath = Globals.HOLDIR ^ "/examples/opsemTools/verify/solvers/SMTSolver/yicesFiles/";


(* --------------------------------- *)
(* to print yices syntax into a file *)
(* --------------------------------- *)
fun printTerm_to_file(name,tm) =
 let val fileName = yicesPath ^ name ^ ".ys";
     val outstr = TextIO.openOut(fileName);
     fun out s = TextIO.output(outstr,s)
 in
  (print_opsemTerm(out,name,tm);
   TextIO.flushOut outstr;
   TextIO.closeOut outstr
   )
 end;



(* ============================================================ *)
(* Functions to read solutions generated by the external solver *)
(* ============================================================ *)


(* Read a file into a string *)
fun readFileToString name =
 let val file_name = yicesPath ^ "results/" ^ name ^ ".res"
     val instream = TextIO.openIn file_name
     val contents = TextIO.inputAll instream
     val _ = TextIO.closeIn instream
 in
  if contents=""
  then 
      (print("Compilation error in yices file: " ^ name);
      raise YICES_COMPILEError
      )
  else contents
 end;



(* 
Parse a solutions file -- very ad hoc and no error checking! 

 getSolutions : string -> (string * string) list list * real
 getSolutions file_name = ([[("x1","m1"),...,],...,[("y1","n1"),...]], time)

If the solver returns "No solution" then the first component of the
returned pair (a list of lists) is empty.

*)
local 

(* If p(xi)=false (for 1<=i<=n) and p(x)=true, then:
   splitUntil p [x1,...,xn,x,y1,...ym] = ([x1,...,xn],[y1,...,ym])  
*)
val splitUntil =
  let fun splitUntilAux acc p [] = (rev acc,[])
|  splitUntilAux acc p (x::l) = 
  if p(x) then (rev acc,l) 
  else splitUntilAux (x::acc) p l
  in
  splitUntilAux ([] : string list)
end;


(* dest_string_int_pair "(x,n)" --> ("x","n") *)
fun dest_string_int_pair str =
  let val [x,n] = 
    String.tokens (fn c => mem c [#"(",#")",#" ",#"="]) str
  in
  (x, n)
end


in

fun getSolutions name =
  let val lines = String.tokens (fn c => c = #"\n") (readFileToString name)
val solutions = 
  if hd lines = "unsat"
  then []
  else 
      map 
          dest_string_int_pair
	  (tl (fst (splitUntil (String.isPrefix "Statistics:") lines)))
val sol_time_str = String.extract(last lines, (String.size "cpu time:                         "),
				  NONE)
val SOME sol_time = Real.fromString(implode(butlast(explode sol_time_str)))
  in
  (solutions,sol_time)
end

end;


(* ------------------------------------------------------------ *)
(* Function to generate an error state from a given state value *)
(* ------------------------------------------------------------ *)

(* TODO: correctly compute error state for arrays
  BsearchKO:
          ERROR
              (FEMPTY |+ ("aLength",Scalar 10) |+ ("x",Scalar x) |+
               ("a",
                Array
                  (FEMPTY |+ (0,a_0) |+ (1,a_1) |+ (2,a_2) |+ (3,a_3) |+
                   (4,a_4) |+ (5,a_5) |+ (6,a_6) |+ (7,a_7) |+ (8,a_8) |+
                   (9,a_9))) |+ ("result",Scalar ~1) |+ ("left",Scalar 0) |+
               ("mid",Scalar 0) |+ ("right",Scalar ~1) |+
               ("Result",Scalar ~1) |+ ("a_8",Scalar ~32768) |+
               ("a_9",Scalar ~32767) |+ ("a_7",Scalar ~32768) |+
               ("a_6",Scalar ~32768) |+ ("a_5",Scalar ~32768) |+
               ("a_4",Scalar ~32768) |+ ("a_3",Scalar ~32768) |+
               ("a_2",Scalar ~32768) |+ ("a_1",Scalar ~32768) |+
               ("a_0",Scalar ~32768))))`` : term
Value of a_i must be set into the array a
*)
fun makeErrorState name st = 
   let val (sol,_) =  getSolutions name
   in 
     stateTools.finiteMapSol sol st
   end;




(* End of functions  to read a solution of a SMT solver *)
(* -----------------------------------------------------*)



(* ============================================================ 
   Functions to call the solver 
   ============================================================ *)

(* Path to Yices executable *)
exception YICES_EXECUndefinedError;

fun getYICES_EXEC() = 
 case Portable.getEnv "YICES_EXEC" of
    SOME path_name => path_name
  | NONE           => (print "Environment variable YICES_EXEC undefined.\n"; 
                       print "Add:\n setenv YICES_EXEC \"<path to YICES executable>\" \nto ~/.shrc\n";
                       raise YICES_EXECUndefinedError);



(* -----------------------------------------------------
   To launch yices executable

-st: prints statistics (solving time)
-e: print a model if the system is sat
*)


fun execPath name  =
 let val exec =  getYICES_EXEC() ^ " -st -e " ^ yicesPath 
                 ^ name ^ ".ys > " ^ yicesPath ^ "results/" ^ 
                 name ^ ".res";
  in
    (Portable.system(exec))
end;


(* same function as above but using a timeout.
   n is an integer and corresponds to the timeout given in
   seconds 
*)
fun limitedExecPath name n  =
  let val exec = getYICES_EXEC() ^ " -st -e --timeout=" ^ int_to_string(n) ^ yicesPath 
                 ^ name ^ ".ys > " ^ yicesPath ^ "results/" ^ name ^ ".res";
   in
     (Portable.system(exec)
     )
end;




(* ======================================================= *)
(* Function to call the external SMT solver and build theorems *)
(* ======================================================= *)


local 

(* Prove a term is satisfiable using a supplied solution  *)

(* 
   Obscure code to convert a string to a HOL integer, e.g.:
   string_to_int_term "37"  = ``37``
   string_to_int_term "~37" = ``~37``
   string_to_int_term "-37" = ``~37``
 *)
fun string_to_int_term s = intSyntax.term_of_int(Arbint.fromString s);


(* lookup a string in a solution and return a constant of the appropriate type *)
fun lookupSolution soln var =
 let val (s,ty) = dest_var var
    val v = assoc s soln
    in
    if ty=``:int`` then string_to_int_term v
    else (if v="0" then ``F`` else ``T``)
end;
                                                                             
            
(*
   proveSat tm soln existentially quantifies all variables in tm and then
   proves the result using soln (which is assumed to have been supplied
   by invoking a solver). 
 *)
fun proveSat tm soln =
  let val frees = free_vars tm
    val exists_tm = list_mk_exists(frees,tm)
  in
  prove
    (exists_tm,
     EVERY (map EXISTS_TAC (map (lookupSolution soln) frees))
       THEN CONV_TAC intLib.REDUCE_CONV)
end;

in


(* ================================================= *)
(* to call an external SMT solver *)
(*   If the solver doesn't find any solution, then return
   a theorem as an oracle
   If the solver finds solutions then uses the values that have
   been found and DECIDE_TAC to return a HOL theorem *)
(* no printing because printing are supposed to be done 
   in functions that call the external solver *)

(* return a pair (thm,time) where thm is the theorem
   and the time is the time taken by the solver *)

(* if timeout has been reached by the solver, then 
   raise exception ExtSolverTimeout                  *)

(* use default format for integers: 16 bits          *)
(* ================================================= *)

fun extSolvSMT name tm =
 let val (vars,bdy) = strip_exists tm
 in
 (print("Calling external SMT solver on:\n");
  print_term bdy; 
  print "\n";
  printTerm_to_file(name,bdy);
  execPath name ;
  let val (sol,time) = getSolutions name;
  in
      if (null sol)
      then  
	  (EQF_INTRO(mk_oracle_thm name ([], mk_neg tm)),time)
      else 
	  (EQT_INTRO(mk_oracle_thm name ([],tm)),time)
          (*(EQT_INTRO(proveSat bdy (hd sol)),time)*)
  end)
 end;



(* same function as above but use a timeout *)
(* TODO 
fun extSolvSMTTimeout name tm n f =
 let val (vars,bdy) = strip_exists tm
 in
 (print("Calling external SMT solver with timeout on:\n");
  print_term bdy; 
  print "\n";
  printXML_to_file(name,bdy);
  limitedExecPath name n ;
  let val (sol,time) =   getSolutions name;
     val tag = "yices:" ^name
  in
   if isSolverTimeout(sol,time)
   then raise ExtSolverTimeout
   else
      if (null sol)
      then  
	  (EQF_INTRO(mk_oracle_thm tag ([], mk_neg tm)),time)
      else 
	  (EQT_INTRO(mk_oracle_thm tag ([],tm)),time)
          (*(EQT_INTRO(proveSat bdy (hd sol)),time)*)
  end)
 end;

*)
end;

