(* Functions to call an external solver  *)

open HolKernel Parse boolLib term2xml;


(* Functions to read solutions generated by the external solver *)

(* Read a file into a string *)
fun readFileToString file_name =
 let val instream = TextIO.openIn file_name
     val contents = TextIO.inputAll instream
     val _ = TextIO.closeIn instream
 in
  contents
 end;

(* 
Parse a solutions file -- very ad hoc and no error checking! 

 getSolutions : string -> (string * string) list list * real
 getSolutions file_name = ([[("x1","m1"),...,],...,[("y1","n1"),...]], time)

If the solver returns "No solution" then the first component of the
returned pair (a list of lists) is empty.

*)
local 

(* If p(xi)=false (for 1<=i<=n) and p(x)=true, then:
   splitUntil p [x1,...,xn,x,y1,...ym] = ([x1,...,xn],[y1,...,ym])  
*)
val splitUntil =
  let fun splitUntilAux acc p [] = (rev acc,[])
|  splitUntilAux acc p (x::l) = 
  if p(x) then (rev acc,l) 
  else splitUntilAux (x::acc) p l
  in
  splitUntilAux ([] : string list)
end;


(* dest_string_int_pair "(x,n)" --> ("x","n") *)
fun dest_string_int_pair str =
  let val [x,n] = 
    String.tokens (fn c => mem c [#"(",#")",#","]) str
  in
  (x, n)
end

(* Group each solution into a list, returning a list of lists:
   sol_extract 
   [...,"Solution #2",...,"Solution #3",...,"Solution #4",...]
   -->
   [[...],[...],[...],[...]]
 *)
fun sol_extract [] = []
|  sol_extract l  = let val (l1,l2) = splitUntil (String.isPrefix "Solution: ") l
in 
  l1 :: sol_extract l2
end

in

fun getSolutions file_name =
  let val lines = String.tokens (fn c => c = #"\n") (readFileToString file_name)
val solutions = 
  if hd lines = "No solution"
  then []
  else 
     if hd lines = "Timeout"
     then [[("Timeout","Timeout")]]
     else map 
            (map dest_string_int_pair) 
            (sol_extract(tl(butlast lines)))
val sol_time_str = String.extract(last lines, (String.size "Resolution time: "),
				  NONE)
val SOME sol_time = Real.fromString(implode(butlast(explode sol_time_str)))
  in
  (solutions,sol_time)
end

end;


(* End of functions  to read a solution of a CSP solver *)
(* -----------------------------------------------------*)


(* function to transform the list of solutions
   as a finite map that can be used as outcome *)
fun addSol st nt vt = 
  ``^st |+ (^nt,Scalar ^vt)``;

fun finiteMapSol l st =
  if null l 
  then st
  else 
    let val (n,v) = (fst(hd(l)),snd(hd(l)));
      val (nt,vt) = (stringSyntax.fromMLstring(n),
                     intSyntax.term_of_int(Arbint.fromString(v)));
      val newSt = addSol st nt vt
      in 
        finiteMapSol (tl l) newSt
    end;

(* to know if the value returned by getSolutions is a 
   timeout *)
fun isSolverTimeout l =
  let val listSol = fst(l)
  in
   not(listSol = []) andalso fst(hd(hd(listSol))) = "Timeout"
end;





(* -----------------------------------------------------
   To launch the Java program that searches solutions of constraint
   system built from XML trees.
   The variable domains are [-2^(f-1)..(2^(f-1))-1] where f is 
   the format of integers.
   If the xml tree is a disjunction, successively consider each case
   of the disjunction.
   The search stops as soon as a first solution has been found.
   Used to test if a path is feasible.
*)
val sixteenBit = 16; 

fun execPathFormat name f =
 let val exec = ("java -cp " ^ getILOG_EXEC() ^ ":" ^ ilogPath ^ "java/classes"
                 ^ " validation.ValidationLauncher " ^ ilogPath 
                 ^ " " ^ name ^ " " ^ int_to_string(f));
  in
    (print exec;Portable.system(exec))
end;


(* same function as above but using a timeout.
   n is an integer and corresponds to the timeout given in
   milliseconds (e.g n=1000 is a timeout of 1s
*)
fun limitedExecPathFormat name n f =
  let val exec = "java -cp " ^ getILOG_EXEC() ^ ":" ^ ilogPath ^ "java/classes"
                  ^ " validation.ValidationLauncher "  ^ ilogPath 
                  ^ " "  ^ name ^ " " ^ int_to_string(f)
                  ^ " -timeout " ^ int_to_string(n);
   in
     (Portable.system(exec)
     )
end;

(* same function as above for default integer size *)
fun execPath name =
 execPathFormat name sixteenBit;


(* same function as above for default integer size *)
fun limitedExecPath name n =
    limitedExecPathFormat name n sixteenBit;





(* -----------------------------------------------------
   To compile the Java programs that symbolically executes
   the xml tree.
   Usefull only if Java sources have been modified
*)
fun compile() =
 let val compil = ("javac  -cp " ^ getILOG_EXEC() ^ ":" ^ ilogPath ^
                   "java/classes -d "  ^ ilogPath ^ "java/classes " ^ ilogPath ^ "java/src/*/*.java "
                   ^ ilogPath ^ "java/src/*/*/*.java ");
  in
     Portable.system(compil)
 end;


(* javac -cp /home/helen/Recherche/hol/lib/jsolver.jar:/home/helen/Recherche/hol/HOL/examples/opsemTools/verify/solvers/xmlterm2csp/java/classes -d /home/helen/Recherche/hol/HOL/examples/opsemTools/verify/solvers/xmlterm2csp/java/classes /home/helen/Recherche/hol/HOL/examples/opsemTools/verify/solvers/xmlterm2csp/java/src/*/*.java /home/helen/Recherche/hol/HOL/examples/opsemTools/verify/solvers/xmlterm2csp/java/src/*/*/*.java *)



(* ======================================================= *)
(* Function to call the externalm solver and build theorems *)
(* ======================================================= *)


(* Function to call an external solver as an oracle *)
fun extSolv name tm =
 let val (vars,bdy) = strip_exists tm
 in
 (print("Calling extSolv \"" ^ name ^ "\" on:\n");
  print_term bdy; print "\n";
  printXML_to_file(name,bdy);
  execPath name;
  let val (sol,time) = 
       getSolutions(ilogPath ^ "results/" ^ name ^ ".res");
      val th =
       if null sol
        then EQF_INTRO(mk_oracle_thm name ([], mk_neg tm))
        else EQT_INTRO(mk_oracle_thm name ([],tm))
  in
   if (null sol)
   then  
     (print "======================\n";
      print (term_to_string bdy ^ "\n");
      print "has no solutions:\n";
      print_thm th;
      print "\n======================\n";
      th
     )
   else 
     (print "======================\n";
      print(term_to_string tm ^ "\n");
      print("has " ^ Int.toString(length sol) ^ " solution" ^ 
            (if length sol > 1 then "s\n" else "\n"));
      print_thm th;
      print "\n======================\n";
      REFL tm
     )
  end)
 end;




(* ===================================================== *)
(* Functions to call an external solver using a time out.*)
(* ===================================================== *)

exception ExtSolverTimeout;

local 

(* Prove a term is satisfiable using a supplied solution  *)

(* 
   Obscure code to convert a string to a HOL integer, e.g.:
   string_to_int_term "37"  = ``37``
   string_to_int_term "~37" = ``~37``
   string_to_int_term "-37" = ``~37``
 *)
fun string_to_int_term s = intSyntax.term_of_int(Arbint.fromString s);


(* lookup a string in a solution and return a constant of the appropriate type *)
fun lookupSolution soln var =
 let val (s,ty) = dest_var var
    val v = assoc s soln
    in
    if ty=``:int`` then string_to_int_term v
    else (if v="0" then ``F`` else ``T``)
end;
                                                                             
            
(*
   proveSat tm soln existentially quantifies all variables in tm and then
   proves the result using soln (which is assumed to have been supplied
   by invoking a solver). 
 *)
fun proveSat tm soln =
  let val frees = free_vars tm
    val exists_tm = list_mk_exists(frees,tm)
  in
  prove
    (exists_tm,
     EVERY (map EXISTS_TAC (map (lookupSolution soln) frees))
       THEN CONV_TAC intLib.REDUCE_CONV)
end;

in


(* ================================================= *)
(* to call an external solver with a time out *)
(*   If the solver doesn't find any solution, then return
   a theorem as an oracle
   If the solver finds solutions then uses the values that have
   been found and DECIDE_TAC to return a HOL theorem *)
(* no printing because printing are supposed to be done 
   in functions that call the external solver *)

(* return a pair (thm,time) where thm is the theorem
   and the time is the time taken by the solver *)

(* if timeout has been reached by the solver, then 
   raise exception ExtSolverTimeout                  *)

(* use default format for integers: 16 bits          *)
(* ================================================= *)

fun extSolvTimeout name tm n =
 let val (vars,bdy) = strip_exists tm
 in
 (print("Calling external solver with timeout on:\n");
  print_term bdy; 
  print "\n";
  printXML_to_file(name,bdy);
  limitedExecPath name n;
  let val (sol,time) = 
       getSolutions(ilogPath ^ "results/" ^ name ^ ".res");
  in
   if isSolverTimeout(sol,time)
   then raise ExtSolverTimeout
   else
      if (null sol)
      then  
	  (EQF_INTRO(mk_oracle_thm name ([], mk_neg tm)),time)
      else 
	  (EQT_INTRO(mk_oracle_thm name ([],tm)),time)
          (*(EQT_INTRO(proveSat bdy (hd sol)),time)*)
  end)
 end;



(* same function as above but integer format can be defined *)
fun extSolvTimeoutFormat name tm n f =
 let val (vars,bdy) = strip_exists tm
 in
 (print("Calling external solver with timeout on:\n");
  print_term bdy; 
  print "\n";
  printXML_to_file(name,bdy);
  limitedExecPathFormat name n f;
  let val (sol,time) = 
       getSolutions(ilogPath ^ "results/" ^ name ^ ".res");
     val tag = "CSPSolver:" ^name ^ ":" ^int_to_string(f)
  in
   if isSolverTimeout(sol,time)
   then raise ExtSolverTimeout
   else
      if (null sol)
      then  
	  (EQF_INTRO(mk_oracle_thm tag ([], mk_neg tm)),time)
      else 
	  (EQT_INTRO(mk_oracle_thm tag ([],tm)),time)
          (*(EQT_INTRO(proveSat bdy (hd sol)),time)*)
  end)
 end;

end;
