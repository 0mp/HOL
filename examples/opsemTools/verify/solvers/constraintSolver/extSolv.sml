(* Functions to call an external solver  *)

open HolKernel Parse boolLib stateTools term2xml;


(* Path to ILOG support directory *)
val ilogPath = Globals.HOLDIR ^ "/examples/opsemTools/verify/solvers/constraintSolver/xmlterm2csp/";



(* ------------------------ *)
(* to print xml into a file *)
(* ------------------------ *)
fun printXML_to_file(name,tm) =
 let val fileName = ilogPath ^ "xml/" ^ name ^ ".xml";
     val outstr = TextIO.openOut(fileName);
     fun out s = TextIO.output(outstr,s)
 in
  (print_opsemTerm(out,name,tm);
   TextIO.flushOut outstr;
   TextIO.closeOut outstr
   )
 end;




(* ============================================================ *)
(* Functions to read solutions generated by the external solver *)
(* ============================================================ *)

(* Read a file into a string *)
fun readFileToString file_name =
 let val instream = TextIO.openIn file_name
     val contents = TextIO.inputAll instream
     val _ = TextIO.closeIn instream
 in
  contents
 end;

(*
Parse a solutions file -- very ad hoc and no error checking!

 getSolutions : string -> (string * string) list list * real
 getSolutions file_name = ([[("x1","m1"),...,],...,[("y1","n1"),...]], time)

If the solver returns "No solution" then the first component of the
returned pair (a list of lists) is empty.

*)
local

(* If p(xi)=false (for 1<=i<=n) and p(x)=true, then:
   splitUntil p [x1,...,xn,x,y1,...ym] = ([x1,...,xn],[y1,...,ym])
*)
val splitUntil =
  let fun splitUntilAux acc p [] = (rev acc,[])
|  splitUntilAux acc p (x::l) =
  if p(x) then (rev acc,l)
  else splitUntilAux (x::acc) p l
  in
  splitUntilAux ([] : string list)
end;


(* dest_string_int_pair "(x,n)" --> ("x","n") *)
fun dest_string_int_pair str =
  let val [x,n] =
    String.tokens (fn c => mem c [#"(",#")",#","]) str
  in
  (x, n)
end

(* Group each solution into a list, returning a list of lists:
   sol_extract
   [...,"Solution #2",...,"Solution #3",...,"Solution #4",...]
   -->
   [[...],[...],[...],[...]]
 *)
fun sol_extract [] = []
|  sol_extract l  = let val (l1,l2) = splitUntil (String.isPrefix "Solution: ") l
in
  l1 :: sol_extract l2
end

in

(* --------------------------- *)

(* function to read a solution *)
(* --------------------------- *)
fun getSolutions file_name =
  let val lines = String.tokens (fn c => c = #"\n")
                   (readFileToString file_name)
val solutions =
  if hd lines = "No solution"
  then []
  else
     if hd lines = "Timeout"
     then [[("Timeout","Timeout")]]
     else map
            (map dest_string_int_pair)
            (sol_extract(tl(butlast lines)))
val sol_time_str = String.extract(last lines, (String.size "Resolution time: "),
				  NONE)
val SOME sol_time = Real.fromString(implode(butlast(explode sol_time_str)))
  in
  (solutions,sol_time)
end

end;




(* ------------------------------------------------------------ *)
(* Function to generate an error state from a given state value *)
(* ------------------------------------------------------------ *)

(* TODO: correctly compute error state for arrays
  BsearchKO:
          ERROR
              (FEMPTY |+ ("aLength",Scalar 10) |+ ("x",Scalar x) |+
               ("a",
                Array
                  (FEMPTY |+ (0,a_0) |+ (1,a_1) |+ (2,a_2) |+ (3,a_3) |+
                   (4,a_4) |+ (5,a_5) |+ (6,a_6) |+ (7,a_7) |+ (8,a_8) |+
                   (9,a_9))) |+ ("result",Scalar ~1) |+ ("left",Scalar 0) |+
               ("mid",Scalar 0) |+ ("right",Scalar ~1) |+
               ("Result",Scalar ~1) |+ ("a_8",Scalar ~32768) |+
               ("a_9",Scalar ~32767) |+ ("a_7",Scalar ~32768) |+
               ("a_6",Scalar ~32768) |+ ("a_5",Scalar ~32768) |+
               ("a_4",Scalar ~32768) |+ ("a_3",Scalar ~32768) |+
               ("a_2",Scalar ~32768) |+ ("a_1",Scalar ~32768) |+
               ("a_0",Scalar ~32768))))`` : term
Value of a_i must be set into the array a
*)
fun makeErrorState name st =
   let val (sol,_) =  getSolutions (ilogPath ^ "results/" ^ name ^ ".res")
   in
     stateTools.finiteMapSol (hd sol) st
   end;




(* to know if the value returned by getSolutions is a
   timeout *)
fun isSolverTimeout l =
  let val listSol = fst(l)
  in
   not(listSol = []) andalso fst(hd(hd(listSol))) = "Timeout"
end;






(* ============================================================
   Functions to call the solver
   ============================================================ *)

(* Path to ILOG executable *)
exception ILOG_EXECUndefinedError;

fun getILOG_EXEC() =
 case Portable.getEnv "ILOG_EXEC" of
    SOME path_name => path_name
  | NONE           => (print "Environment variable ILOG_EXEC undefined.\n";
                       print "Add:\n setenv ILOG_EXEC \"<path to ILOG executable>\" \nto ~/.shrc\n";
                       raise ILOG_EXECUndefinedError);



(* -----------------------------------------------------
   To launch the Java program that searches solutions of constraint
   system built from XML trees.
   The variable domains are [-2^(f-1)..(2^(f-1))-1] where f is
   the format of integers.
   If the xml tree is a disjunction, successively consider each case
   of the disjunction.
   The search stops as soon as a first solution has been found.
   Used to test if a path is feasible.
*)
val sixteenBit = 16;

fun execPathFormat name f =
 let val exec = ("java -cp " ^ getILOG_EXEC() ^ ":" ^ ilogPath ^ "java/classes"
                 ^ " validation.ValidationLauncher " ^ ilogPath
                 ^ " " ^ name ^ " " ^ int_to_string(f));
  in
    (print exec;Portable.system(exec))
end;


(* same function as above but using a timeout.
   n is an integer and corresponds to the timeout given in
   milliseconds (e.g n=1000 is a timeout of 1s
*)
fun limitedExecPathFormat name n f =
  let val exec = "java -cp " ^ getILOG_EXEC() ^ ":" ^ ilogPath ^ "java/classes"
                  ^ " validation.ValidationLauncher "  ^ ilogPath
                  ^ " "  ^ name ^ " " ^ int_to_string(f)
                  ^ " -timeout " ^ int_to_string(n);
   in
     (Portable.system(exec)
     )
end;

(* same function as above for default integer size *)
fun execPath name =
 execPathFormat name sixteenBit;


(* same function as above for default integer size *)
fun limitedExecPath name n =
    limitedExecPathFormat name n sixteenBit;





(* -----------------------------------------------------
   To compile the Java programs that symbolically executes
   the xml tree.
   Usefull only if Java sources have been modified
*)
fun compile() =
 let val compil = ("javac  -cp " ^ getILOG_EXEC() ^ ":" ^ ilogPath ^
                   "java/classes -d "  ^ ilogPath ^ "java/classes " ^ ilogPath ^ "java/src/*/*.java "
                   ^ ilogPath ^ "java/src/*/*/*.java ");
  in
     Portable.system(compil)
 end;


(* javac -cp /home/helen/Recherche/hol/lib/jsolver.jar:/home/helen/Recherche/hol/HOL/examples/opsemTools/verify/solvers/xmlterm2csp/java/classes -d /home/helen/Recherche/hol/HOL/examples/opsemTools/verify/solvers/xmlterm2csp/java/classes /home/helen/Recherche/hol/HOL/examples/opsemTools/verify/solvers/xmlterm2csp/java/src/*/*.java /home/helen/Recherche/hol/HOL/examples/opsemTools/verify/solvers/xmlterm2csp/java/src/*/*/*.java *)



(* ======================================================= *)
(* Function to call the externalm solver and build theorems *)
(* ======================================================= *)


(* Function to call an external solver as an oracle *)
fun extSolv name tm =
 let val (vars,bdy) = strip_exists tm
 in
 (print("Calling extSolv \"" ^ name ^ "\" on:\n");
  print_term bdy; print "\n";
  printXML_to_file(name,bdy);
  execPath name;
  let val (sol,time) =
       getSolutions(ilogPath ^ "results/" ^ name ^ ".res");
      val th =
       if null sol
        then EQF_INTRO(mk_oracle_thm name ([], mk_neg tm))
        else EQT_INTRO(mk_oracle_thm name ([],tm))
  in
   if (null sol)
   then
     (print "======================\n";
      print (term_to_string bdy ^ "\n");
      print "has no solutions:\n";
      print_thm th;
      print "\n======================\n";
      th
     )
   else
     (print "======================\n";
      print(term_to_string tm ^ "\n");
      print("has " ^ Int.toString(length sol) ^ " solution" ^
            (if length sol > 1 then "s\n" else "\n"));
      print_thm th;
      print "\n======================\n";
      REFL tm
     )
  end)
 end;




(* ===================================================== *)
(* Functions to call an external solver using a time out.*)
(* ===================================================== *)

exception ExtSolverTimeout;

local

(* Prove a term is satisfiable using a supplied solution  *)

(*
   Obscure code to convert a string to a HOL integer, e.g.:
   string_to_int_term "37"  = ``37``
   string_to_int_term "~37" = ``~37``
   string_to_int_term "-37" = ``~37``
 *)
fun string_to_int_term s = intSyntax.term_of_int(Arbint.fromString s);


(* lookup a string in a solution and return a constant of the appropriate type *)
fun lookupSolution soln var =
 let val (s,ty) = dest_var var
    val v = assoc s soln
    in
    if ty=``:int`` then string_to_int_term v
    else (if v="0" then ``F`` else ``T``)
end;


(*
   proveSat tm soln existentially quantifies all variables in tm and then
   proves the result using soln (which is assumed to have been supplied
   by invoking a solver).
 *)
fun proveSat tm soln =
  let val frees = free_vars tm
    val exists_tm = list_mk_exists(frees,tm)
  in
  prove
    (exists_tm,
     EVERY (map EXISTS_TAC (map (lookupSolution soln) frees))
       THEN CONV_TAC intLib.REDUCE_CONV)
end;

in


(* ================================================= *)
(* to call an external solver with a time out *)
(*   If the solver doesn't find any solution, then return
   a theorem as an oracle
   If the solver finds solutions then uses the values that have
   been found and DECIDE_TAC to return a HOL theorem *)
(* no printing because printing are supposed to be done
   in functions that call the external solver *)

(* return a pair (thm,time) where thm is the theorem
   and the time is the time taken by the solver *)

(* if timeout has been reached by the solver, then
   raise exception ExtSolverTimeout                  *)

(* use default format for integers: 16 bits          *)
(* ================================================= *)

fun extSolvTimeout name tm n =
 let val (vars,bdy) = strip_exists tm
 in
 (print("Calling external solver with timeout on:\n");
  print_term bdy;
  print "\n";
  printXML_to_file(name,bdy);
  limitedExecPath name n;
  let val (sol,time) =
       getSolutions(ilogPath ^ "results/" ^ name ^ ".res");
  in
   if isSolverTimeout(sol,time)
   then raise ExtSolverTimeout
   else
      if (null sol)
      then
	  (EQF_INTRO(mk_oracle_thm name ([], mk_neg tm)),time)
      else
	  (EQT_INTRO(mk_oracle_thm name ([],tm)),time)
          (*(EQT_INTRO(proveSat bdy (hd sol)),time)*)
  end)
 end;



(* same function as above but integer format can be defined *)
fun extSolvTimeoutFormat name tm n f =
 let val (vars,bdy) = strip_exists tm
 in
 (print("Calling external solver with timeout on:\n");
  print_term bdy;
  print "\n";
  printXML_to_file(name,bdy);
  limitedExecPathFormat name n f;
  let val (sol,time) =
       getSolutions(ilogPath ^ "results/" ^ name ^ ".res");
     val tag = "CSPSolver:" ^name ^ ":" ^int_to_string(f)
  in
   if isSolverTimeout(sol,time)
   then raise ExtSolverTimeout
   else
      if (null sol)
      then
	  (EQF_INTRO(mk_oracle_thm tag ([], mk_neg tm)),time)
      else
	  (EQT_INTRO(mk_oracle_thm tag ([],tm)),time)
          (*(EQT_INTRO(proveSat bdy (hd sol)),time)*)
  end)
 end;

end;
