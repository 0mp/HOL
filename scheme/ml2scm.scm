(require (lib "plt-match.ss"))

(define Program
  (let ((p (open-input-file "/usr/local/hamlet/test.s")))
    (read p)
    (read p)
    (begin0 (read p)
            (close-input-port p))))

(define (capital-symbol? s)
  (and (symbol? s)
       (char-upper-case? (string-ref (symbol->string s) 0))))

(define function-map
  (let ((table
         (make-immutable-hash-table
          '((Math.sqrt . sqrt)
            (:: . cons)
            (@ . append)
            (ref . box)
            (:= . set-box!)
            (! . unbox)
            (read_integer . read)
            (toString . number->string)
            ))))
    (match-lambda*
      ((list (list 'quote (? capital-symbol? s)) arg)
       `(list (quote ,s) ,arg))
      ((list f arg)
       (if (symbol? f)
           (let ((scheme-f
                  (hash-table-get table f (lambda () #f))))
             (if scheme-f
                 (set! f scheme-f))))
       (match arg
         ((list 'list (list 'cons (list 'quote (? number? _)) act-arg) ...)
          (cons f act-arg))
         ((list 'RECORDAtExp _)
          (list f))
         (else
          (list f arg)))))))

(define translate
  (match-lambda
    ((list 'Program _ p)
     (translate p))
    ((list 'Program _ p1 p2)
     (append (translate p1)
             (translate p2)))
    ((list 'STRDECTopDec _ p)
     (list (translate p)))
    ((list 'STRDECTopDec _ p1 p2)
     (cons (translate p1)
           (translate p2)))
    ((list 'DECStrDec _ p)
     (translate p))
    ((list (or 'SEQStrDec 'SEQDec) _ p1 p2)
     (let ((def1 (translate p1))
           (def2 (translate p2)))
       `(match-define (cons ,(cadr def1) ,(cadr def2))
                      (cons ,(caddr def1) ,(caddr def2)))))
    ((list 'VALDec _ _ p)
     (translate p))
    ((list 'RECValBind _ p)
     (translate p))
    ((list 'PLAINValBind _ var val)
     `(match-define ,(translate var) ,(translate val)))
    ((list 'PLAINValBind _ var val another)
     (let ((moredefine (translate another)))
       `(match-define (cons ,(translate var)
                            ,(cadr moredefine))
                      (cons ,(translate val)
                            ,(caddr moredefine)))))
    ((list 'ATPat _ p)
     (translate p))
    ((list 'IDAtPat _ p)
     (translate p))
    ((list 'LongVId 'true)
     #t)
    ((list 'LongVId 'false)
     #f)
    ((list 'LongVId 'nil)
     '(list))
    ((list 'LongVId a)
     (if (char-upper-case? (string-ref (symbol->string a) 0))
         (list 'quote a)
         a))
    ((list 'ATExp _ p)
     (translate p))
    ((list 'PARAtExp _ p)
     (translate p))
    ((list 'PARAtPat _ p)
     (translate p))
    ((list 'APPExp _ f arg)
     (function-map (translate f)
                   (translate arg)))
    ((list 'RECORDAtPat _)
     '(list))
    ((list 'RECORDAtPat _ p)
     (translate p))
    ((list 'ExpRow _ (list 'Lab n) p)
     `(list (cons (quote ,n) ,(translate p))))
    ((list 'ExpRow _ (list 'Lab n) p1 p2)
     `(list (cons (quote ,n) ,(translate p1))
            ,@(cdr (translate p2))))
    ((list 'FIELDPatRow _ (list 'Lab n) p)
     `(list (cons (quote ,n) ,(translate p))))
    ((list 'FIELDPatRow _ (list 'Lab n) p1 p2)
     `(list (cons (quote ,n) ,(translate p1))
            ,@(cdr (translate p2))))
    ((list 'SCONAtPat _ p)
     (translate p))
    ((list 'INTSCon n)
     n)
    ((list 'REALSCon n)
     n)
    ((list 'SCONAtExp _ p)
     (translate p))
    ((list 'IDAtExp _ p)
     (translate p))
    ((list 'VId v)
     v)
    ((list 'EMPTYStrDec _)
     '(void))
    ((list 'STRINGSCon s)
     s)
    ((list 'FNExp _ p)
     `(match-lambda ,@(translate p)))
    ((list 'Match _ p)
     (list (translate p)))
    ((list 'Match _ p1 p2)
     (cons (translate p1)
           (translate p2)))
    ((list 'Mrule _ pat exp)
     (list (translate pat)
           (translate exp)))
    ((list 'LETAtExp _ def body)
     `(let ()
        ,(translate def)
        ,(translate body)))
    ((list 'COLONPat _ v _)
     (translate v))
    ((list 'COLONExp _ v _)
     (translate v))
    ((list 'RECORDAtExp _)
     '(void))
    ((list 'RECORDAtExp _ p)
     (translate p))
    ((list 'TYPEDec _ _)
     '(void))
    ((list 'WILDCARDAtPat _)
     '_)
    ((list 'DOTSPatRow _)
     `(list ,(gensym) ...))
    ((list 'LOCALStrDec _ locdef boddef)
     (let ((body (translate boddef)))
       (match body
         ((list 'match-define expr cause)
          `(match-define ,expr
                         (let ()
                           ,(translate locdef)
                           ,cause)))
         ;open
         (else
          `(let ()
             ,(translate locdef)
             ,body)))))
    ((list 'CONPat _ id pat)
     (function-map (translate id)
                   (translate pat)))
    ((list 'DATATYPEDec _ p)
     (translate p))
    ((list-rest 'DatBind _)
     '(void))
    ((list 'EXCEPTIONDec _ _)
     '(void))
    ((list 'RAISEExp _ p)
     `(raise ,(translate p)))
    ((list 'HANDLEExp _ body match)
     `(with-handlers (((lambda (err) #t)
                       ,(cons 'match-lambda
                              (translate match))))
        ,(translate body)))
    (else
     ;(error else)
     else
     )))

(define improve
  (match-lambda
    ((list (list 'match-lambda
                 (list '_ b)) a)
     (let ((imbroved_b (improve b)))
       (if (and (pair? imbroved_b)
                (eq? (car imbroved_b) 'begin))
           `(begin ,(improve a)
                   ,@(cdr imbroved_b))
           `(begin ,(improve a)
                   ,imbroved_b))))
    ((cons (list 'void) b)
     (improve b))
    ((list 'match-lambda
           (list (? symbol? literal)
                 (list lamb literal)))
     (improve lamb))
    ((list (list 'match-lambda
                 (list #t then)
                 (list #f else))
           cond)
     (list 'if
           (improve cond)
           (improve then)
           (improve else)))
    ((list 'match-lambda (list (? symbol? literal) body))
     `(lambda (,literal) ,(improve body)))
    ((list 'match-lambda
           (list (list 'list (list 'cons (list 'quote (? number? _)) arg) ...) body) ...)
     (if (and (= (length body) 1)
              (andmap symbol? (car arg)))
         (list* 'lambda (car arg) (improve body))
         (cons 'match-lambda*
               (map (lambda (arg body)
                      (list (cons 'list arg) (improve body)))
                    arg body))))
    ((list 'match-define (? symbol? var) val)
     `(define ,var ,(improve val)))
    ((list 'list (list 'cons lab val) ... (? symbol? sym) '...)
     `(list-no-order ,@(map (lambda (l v) `(cons ,l ,v))
                            lab val)
                     ,sym ...))
    ((cons p1 p2)
     (cons (improve p1)
           (improve p2)))
    (else
     else)))

(improve
 (translate
  Program))